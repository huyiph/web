<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="demon" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> O</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/icon.svg" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
      <script src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js"></script>
      
    <link rel="alternate" href="/atom.xml" title="O" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="page-"
  class="article article-type-page"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
       
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line">bhz_parameters = &#123;</span><br><span class="line">    <span class="string">&quot;topo&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;triv&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: -<span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;topo2&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.3</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;slowed&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.05</span>, <span class="string">&quot;B&quot;</span>: <span class="number">0.08</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.15</span>, <span class="string">&quot;M&quot;</span>: -<span class="number">0.3</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.5</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hoppings for bhz model</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (p.M - <span class="number">4</span> * p.B) * pauli.s0sz - <span class="number">4</span> * p.D * pauli.s0s0 + p.del_z * pauli.sysy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 + <span class="number">1j</span> * p.A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 - <span class="number">1j</span> * p.A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">w=<span class="number">20</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Make ribbon system with bhz model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    slowed parameters are used on the edge for finite size system.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_x</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    slowed_par = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;slowed&quot;</span>])</span><br><span class="line">    <span class="keyword">if</span> w <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[(lat(<span class="number">0</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w))] = onsite</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>, -<span class="number">1</span>)] = <span class="keyword">lambda</span> site, p: onsite(site, slowed_par)</span><br><span class="line">        syst[lat(<span class="number">1</span>, -<span class="number">1</span>), lat(<span class="number">0</span>, -<span class="number">1</span>)] = <span class="keyword">lambda</span> site1, site2, p: hopping_x(</span><br><span class="line">            site1, site2, slowed_par</span><br><span class="line">        )</span><br><span class="line">        syst[lat(<span class="number">0</span>, <span class="number">0</span>), lat(<span class="number">0</span>, -<span class="number">1</span>)] = hopy</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>, w)] = <span class="keyword">lambda</span> site, p: onsite(site, slowed_par)</span><br><span class="line">        syst[lat(<span class="number">1</span>, w), lat(<span class="number">0</span>, w)] = <span class="keyword">lambda</span> site1, site2, p: hopping_x(</span><br><span class="line">            site1, site2, slowed_par</span><br><span class="line">        )</span><br><span class="line">        syst[lat(<span class="number">0</span>, w), lat(<span class="number">0</span>, w - <span class="number">1</span>)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_cylinder</span>(<span class="params">w=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Make cylinder system with bhz model. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_x</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy_phase</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopy(site1, site2, p) * np.exp(<span class="number">1j</span> * p.ky)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, -w + <span class="number">1</span>), lat)] = hopy_phase</span><br><span class="line"></span><br><span class="line">    syst[lat(<span class="number">0</span>, <span class="number">0</span>)] = onsite</span><br><span class="line">    syst[lat(<span class="number">0</span>, w - <span class="number">1</span>)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lead</span>(<span class="params">t, trs=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym, time_reversal=<span class="number">1j</span> * pauli.sys0)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">1.8</span> * t * pauli.s0sz</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t * pauli.s0sz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_scatter_sys</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        x, y = pos</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="number">0</span>) * (<span class="number">0</span> &lt;= y &lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    lead_cylinder = bhz_cylinder()</span><br><span class="line">    lead = make_lead(<span class="number">1.0</span>)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    syst.attach_lead(lead_cylinder)</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scattering_det_pfaff</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pfaffian</span>(<span class="params">syst, p, ky</span>):</span></span><br><span class="line">        p.ky = ky</span><br><span class="line">        smat = kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).data</span><br><span class="line">        <span class="comment"># since we get relatively large numerical errors we project the matrix on</span></span><br><span class="line">        <span class="comment"># the space of antisymmetric matrices</span></span><br><span class="line">        smat = <span class="number">0.5</span> * (smat - smat.T)</span><br><span class="line">        <span class="keyword">return</span> pf.pfaffian(smat)</span><br><span class="line"></span><br><span class="line">    pfaff = [pfaffian(syst, p, <span class="number">0</span>), pfaffian(syst, p, np.pi)]</span><br><span class="line"></span><br><span class="line">    ks = np.linspace(<span class="number">0.0</span>, np.pi, <span class="number">50</span>)</span><br><span class="line">    det = [np.linalg.det(kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).data) <span class="keyword">for</span> p.ky <span class="keyword">in</span> ks]</span><br><span class="line">    det = np.array(det)</span><br><span class="line"></span><br><span class="line">    phase = np.angle(pfaff[<span class="number">0</span>]) + <span class="number">0.5</span> * np.cumsum(np.angle(det[<span class="number">1</span>:] / det[:-<span class="number">1</span>]))</span><br><span class="line">    kdims = [<span class="string">&quot;$k_y$&quot;</span>, <span class="string">&quot;phase&quot;</span>]</span><br><span class="line">    plot = holoviews.Path((ks[<span class="number">1</span>:], phase), kdims=kdims).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    plot *= holoviews.Points(([<span class="number">0</span>, np.pi], np.angle(pfaff)), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;g&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    xlims, ylims = <span class="built_in">slice</span>(-<span class="number">0.2</span>, np.pi + <span class="number">0.2</span>), <span class="built_in">slice</span>(-np.pi - <span class="number">0.2</span>, np.pi + <span class="number">0.2</span>)</span><br><span class="line">    pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">&quot;$\pi$&quot;</span>)], <span class="string">&quot;yticks&quot;</span>: pi_ticks&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.relabel(<span class="string">&quot;Winding&quot;</span>, depth=<span class="number">1</span>)[xlims, ylims].opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$A=&#123;:.2&#125;$, $B=&#123;:.2&#125;$, $D=&#123;:.2&#125;$, $M=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    <span class="keyword">return</span> title.<span class="built_in">format</span>(p.A, p.B, p.D, p.M)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Charles Kane from the University of Pennsylvania will introduce today’s lecture on two dimensional topological insulators with time-reversal symmetry.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;n5oUQvvsYd0&quot;</span>, src_location=<span class="string">&quot;5.1-intro&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Adding-symmetry-to-a-topological-insulator"><a href="#Adding-symmetry-to-a-topological-insulator" class="headerlink" title="Adding symmetry to a topological insulator"></a>Adding symmetry to a topological insulator</h1><p>In general, there are different approaches to discover new types of topological systems.</p>
<p>We have already used a very powerful method to make a Kitaev chain and the Chern insulator model. We started from guessing what kind of model to use for the edge, such that it is impossible to obtain without the bulk. Then we combined many such edges (dots for the Kitaev chain and wires for the Chern insulator) and tailored the coupling between them to leave exactly the type of model that we want on one edge.</p>
<p>A very skilled researcher in topology (or more specifically <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/K-theory">K-theory</a>) may also just calculate the expected topological classification of a system starting only from its dimensionality and symmetries. This is also a powerful method, but often it’s too hard and requires a very high skills in math.</p>
<p>Another approach that we can undertake is to start with one topological Hamiltonian and see what happens if we force the Hamiltonian to have some extra symmetry. This is the approach we will use in this chapter.</p>
<p>Let’s start from a simple example involving something which we already know, a quantum dot with the Hamiltonian $H_0$. We know that there is a topological invariant, the number of filled energy levels.</p>
<p>Now we can ask what happens if we force the dot to have a particle-hole symmetry. The Hamiltonian becomes</p>
<p>$$<br>H_\textrm{BdG} =<br>\begin{pmatrix}<br>H_0 &amp; 0\<br>0 &amp; -H_0^*<br>\end{pmatrix}.<br>$$</p>
<p>This model is clearly topologically trivial from the point of view of the old invariant, since the number of filled states is constant. However, there are still level crossings that appear. We may ask if these crossings stay protected if we also include a finite superconducting pairing $\Delta$ in the Hamiltonian, which couples the two blocks $H_0$ and $-H_0^*$.</p>
<p>Of course we know the answer: the crossings stay protected due to the change in the Pfaffian invariant. So what we did was to construct a topologically non-trivial superconducting dot by adding particle-hole symmetry to a topological Hamiltonian with a lower symmetry.</p>
<p>Let’s now apply the same logic to a new system. Specifically, let’s add time-reversal symmetry to a Chern insulator. The Chern insulator has chiral edge states whose direction of propagation is flipped by time-reversal symmetry $\mathcal{T}$. So let’s consider a Hamiltonian of the form</p>
<p>$$<br>H =<br>\begin{pmatrix}<br>H_0 &amp; 0\<br>0 &amp; \mathcal{T}H_0\mathcal{T}^{-1}<br>\end{pmatrix},.<br>$$</p>
<p>If $H_0$ is the Hamiltonian of a Chern insulator with $N$ edge states, then $H$ will have $N$ pairs of counterpropagating edge states that transform into each other by time-reversal symmetry. Moreover, the full $H$ obeys time-reversal symmetry, which merely exchanges the two blocks.</p>
<p>The following sketch describes the situation in the case $N=1$:</p>
<p><img src="/src/w5_qshe/fermion_parity_pump.htm/qsh_insulator.svg" alt></p>
<p>The next task which we now face is to understand if such edges stay topologically protected once we add coupling between the two blocks.</p>
<h1 id="A-perfectly-transmitted-channel-and-Kramers-degeneracy"><a href="#A-perfectly-transmitted-channel-and-Kramers-degeneracy" class="headerlink" title="A perfectly transmitted channel and Kramers degeneracy"></a>A perfectly transmitted channel and Kramers degeneracy</h1><p>We could try to see if all the edge states can be removed by adding some terms to the Hamiltonian, but instead we will use a closely related fact.</p>
<p>Let’s study transport through such edge states as a function of their total number and let’s only use the fact that time-reversal symmetry is present. Imagine, there is a total of $N$ states going in each direction along the edge, and that the edge is composed of a disordered region sandwiched between two clean regions. Again, let’s represent the situation for the case $N=1$.</p>
<p><img src="/src/w5_qshe/fermion_parity_pump.htm/qsh_scattering.svg" alt></p>
<h2 id="Scattering-states"><a href="#Scattering-states" class="headerlink" title="Scattering states"></a>Scattering states</h2><p>We label incoming states on the left and right with $\left|n,\textrm{L}\right\rangle$ and $\left|n,\textrm{R}\right\rangle$. The index $n$ goes from $1$ to $N$. The outgoing states are the time-reversed partners of the incoming states, so they are given by $\mathcal{T}\left|n,\textrm{L}\right\rangle$ and $\mathcal{T}\left|n,\textrm{R}\right\rangle$. Scattering states in the left and right regions are superpositions of incoming and outgoing states,</p>
<p>$$<br>\left|\Psi,\textrm{L}\right\rangle = \sum_{n=1}^N \alpha_{n,\textrm{L}},\left|n,\textrm{L}\right\rangle + \beta_{n,\textrm{L}},\mathcal{T}\left|n,\textrm{L}\right\rangle,,<br>$$<br>$$<br>\left|\Psi,\textrm{R}\right\rangle = \sum_{n=1}^N \alpha_{n,\textrm{R}},\left|n,\textrm{R}\right\rangle + \beta_{n,\textrm{R}},\mathcal{T}\left|n,\textrm{R}\right\rangle,.<br>$$</p>
<p>We can form vectors out of all the coefficients in the superposition, for instance $\alpha_\textrm{L} = (\alpha_{1,\textrm{L}},\dots,\alpha_{N,\textrm{L}})^T$ for the incoming states on the left side. Incoming and outgoing modes are then related by the scattering matrix $S$ of the disordered region,</p>
<p>$$<br>\begin{pmatrix} \beta_\textrm{L} \ \beta_\textrm{R} \end{pmatrix} = S \begin{pmatrix} \alpha_\textrm{L} \ \alpha_\textrm{R} \end{pmatrix}.<br>$$</p>
<p>There are a total of $2N$ incoming and $2N$ outgoing modes, so $S$ is a $2N\times 2N$ matrix. Since we are including all possible initial and final states, $S$ is also unitary, $S=S^\dagger$. It can be split into reflection and transmission blocks of dimension $N\times N$,</p>
<p>$$<br>S =<br>\begin{pmatrix}<br>r &amp; t\<br>t’ &amp; r’<br>\end{pmatrix},.<br>$$</p>
<p>If we can gap out the edges by adding some extra terms to the Hamiltonian, or backscatter them by adding disorder, then we should be able to achieve the situation where there is no transmission at all, $t = t’ = 0$. In this case, all modes must be reflected back, so the reflection blocks of the scattering matrix become unitary, $r^\dagger r = r’^\dagger r’ = 1$.</p>
<p>To see whether this is possible at all, we first have to understand the constraints that time-reversal symmetry imposes on $S$.</p>
<h2 id="Scattering-matrices-with-time-reversal-symmetry"><a href="#Scattering-matrices-with-time-reversal-symmetry" class="headerlink" title="Scattering matrices with time-reversal symmetry"></a>Scattering matrices with time-reversal symmetry</h2><p>Let’s recall some basic facts about time-reversal symmetry, which we already studied in the first week. Time-reversal symmetry has an antiunitary operator $\mathcal{T}$ which commutes with the Hamiltonian. Being antiunitary, $\mathcal{T}$ may come in two flavors - either $\mathcal{T}^2=1$ or $\mathcal{T}^2=-1$. The first case applies to systems with no or integer spin, such that $\mathcal{T}=\mathcal{K}$ in the simplest case, where $\mathcal{K}$ is the complex conjugation operator. The second case applies to systems with half-integer spin, and in the simplest case we have $\mathcal{T}=i\sigma_y\mathcal{K}$.</p>
<p>Let’s apply the time-reversal operator to our scattering states. We get</p>
<p>$$<br>\mathcal{T}\left|\Psi,\textrm{L}\right\rangle = \sum_{n=1}^N \alpha^<em>_{n,\textrm{L}},\mathcal{T}\left|n,\textrm{L}\right\rangle + \beta^</em><em>{n,\textrm{L}},\mathcal{T}^2\left|n,\textrm{L}\right\rangle,,<br>$$<br>$$<br>\mathcal{T}\left|\Psi,\textrm{R}\right\rangle = \sum</em>{n=1}^N \alpha^<em>_{n,\textrm{R}},\mathcal{T}\left|n,\textrm{R}\right\rangle + \beta^</em>_{n,\textrm{R}},\mathcal{T}^2\left|n,\textrm{R}\right\rangle,.<br>$$</p>
<p>Now, since time-reversal symmetry does not change the energy of a state, $\mathcal{T}\left|\Psi,\textrm{R}\right\rangle$ and $\mathcal{T}\left|\Psi,\textrm{L}\right\rangle$ are scattering states with the same energy as $\left|\Psi,\textrm{R}\right\rangle$ and $\left|\Psi,\textrm{L}\right\rangle$. Hence, the coefficients of incoming and outgoing modes are still related by the same scattering matrix $S$ as before. Note, however, that applying $\mathcal{T}$ exchanged the role of the $\alpha$’s and $\beta$’s, such that the $\alpha$’s now correspond to outgoing states and the $\beta$’s to incoming states. Hence, we have</p>
<p>$$<br> S\mathcal{T}^2 \begin{pmatrix}\beta^<em>_\textrm{L} \ \beta^</em>_\textrm{R} \end{pmatrix} = \begin{pmatrix} \alpha^<em>_\textrm{L} \ \alpha^</em>_\textrm{R} \end{pmatrix},.<br>$$</p>
<p>Multiplying both sides by $\mathcal{T}^2S^\dagger$ and taking the complex conjugate gives</p>
<p>$$<br>\begin{pmatrix} \beta_\textrm{L} \ \beta_\textrm{R} \end{pmatrix} = \mathcal{T}^2,S^T  \begin{pmatrix} \alpha_\textrm{L} \ \alpha_\textrm{R} \end{pmatrix}.<br>$$</p>
<p>By comparing this equation with the one a few lines above, we finally obtain</p>
<p>$$<br>S = \mathcal{T}^2 S^T.<br>$$</p>
<p>So if $\mathcal{T}^2=1$, the scattering matrix is symmetric ($S=S^T$), while if $\mathcal{T}^2=-1$, it is antisymmetric ($S=-S^T$).</p>
<p>What does this imply if we try to set $t=t’=0$?</p>
<p>If $S=S^T$, it turns out there is really nothing special we can tell. However, if $S=-S^T$ and $t=t’=0$, the $N\times N$ reflection matrix must be both unitary, $r^\dagger r=1$, and antisymmetric, $r=-r^T$.</p>
<p>If $N$ is odd, this isn’t possible at all, since any odd-dimensional antisymmetric matrix <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Skew-symmetric_matrix#Spectral_theory">must have</a> a single zero eigenvalue, while unitary matrices only have eigenvalues with unit norm!</p>
<p>We are forced to conclude that it is impossible to have $r$ unitary, and therefore it is impossible to have $t=0$ in this case. Furthermore, this zero eigenvalue of $r$ means that there is always a single mode that is transmitted with unit probability.</p>
<p>This is the discovery that Charles Kane described in the introductory video. We can quickly check it by randomly selecting an antisymmetric scattering matrix with odd $N$, like the following one with $N=3$,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span></span><br><span class="line">np.random.seed(<span class="number">12</span>)</span><br><span class="line">S = kwant.rmt.circular(N * <span class="number">2</span>, sym=<span class="string">&quot;AII&quot;</span>)</span><br><span class="line"></span><br><span class="line">pprint_matrix(S)</span><br></pre></td></tr></table></figure>

<p>and looking at the eigenvalues of $r^\dagger r$ and $t^\dagger t$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r = S[:N, :N]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reflection eigenvalues&quot;</span>)</span><br><span class="line">pprint_matrix(np.linalg.eigvalsh(r @ r.T.conj()))</span><br><span class="line"></span><br><span class="line">t = S[:N, N:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Transmission eigenvalues&quot;</span>)</span><br><span class="line">pprint_matrix(np.linalg.eigvalsh(t @ t.T.conj())[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>We conclude that if $\mathcal{T}^2=-1$ and the number of edge states going in one direction is odd, they cannot be gapped out, and the system is topological. On the other hand, if there is an even number of such edge states, they can be gapped out. Since these are the only two options, the integer invariant of a Chern insulator is reduced to a $\pm 1$ invariant in the presence of time reversal symmetry. These topologically protected, counterpropagating edge states are often referred to as <strong>helical edge states</strong>.</p>
</blockquote>
<h1 id="Helical-edge-states-are-Kramers-pairs"><a href="#Helical-edge-states-are-Kramers-pairs" class="headerlink" title="Helical edge states are Kramers pairs"></a>Helical edge states are Kramers pairs</h1><p>You might ask yourself what makes $\mathcal{T}^2=-1$ special, leading to the topological protection of the helical edge states.</p>
<p>As was mentioned in the first week, if $\mathcal{T}^2=-1$ then Kramers’ theorem applies. Kramers’ theorem tells us that given an eigenstate $|\Psi\rangle$ of the Hamiltonian with energy $E$, its time-reversed partner $|\Psi_\mathcal{T}\rangle\equiv\mathcal{T}|\Psi\rangle$ has the same energy, and the two states are orthogonal, $\langle \Psi | \Psi_\mathcal{T}\rangle=0$. These two states form a so-called <strong>Kramers pair</strong>. As we already know, this leads to the fact that Hamiltonians with spinful time-reversal symmetry have two-fold degenerate energy levels - <strong>Kramers degeneracy</strong>.</p>
<p>Now, the two counterpropagating helical modes are time-reversed partners of each other, so they form precisely such a Kramers pair. The condition $\langle \Psi | \Psi_\mathcal{T}\rangle=0$ implies that it is impossible to introduce any backscattering between the two states, unless we break time-reversal symmetry. This is the origin of the unit transmission and of the topological protection of helical edge states.</p>
<p>To gain a more intuitive understanding of this fact at a more microscopic level, we can assume that the projection of the electrons’ spin along a given axis is conserved, say the axis $z$ perpendicular to the plane. Then at the edge you have, say, a right-moving mode with spin up and a left-moving mode with spin down, and no other modes if $N=1$. Let’s draw again the picture of a helical edge state entering the disordered region:</p>
<p><img src="/src/w5_qshe/fermion_parity_pump.htm/spin_flip.svg" alt></p>
<p>Thus, an electron moving to the right must have spin up by assumption. In order to be reflected, its spin must also be flipped.  However, this spin-flip scattering process is forbidden, and again we conclude that the electron is transmitted with probability one.</p>
<p>In the case $\mathcal{T}^2=1$, there is no Kramers’ theorem. As a consequence, even though you can construct models which have counterpropagating edge states, you will find that they have no topological protection and can be gapped out without breaking the time-reversal symmetry.</p>
<h1 id="The-quantum-spin-Hall-effect"><a href="#The-quantum-spin-Hall-effect" class="headerlink" title="The quantum spin Hall effect"></a>The quantum spin Hall effect</h1><p>There is no really precise name for the 2D topological insulator with time-reversal symmetry. It is often called “$\mathbb{Z}_2$ topological insulator.” However, this simply indicates that there are only two values of the topological invariant, and so it isn’t a very specific name.</p>
<p>The most commonly used name for this system is “quantum spin Hall insulator.” To understand why, let’s analyse a Hall bar made of such a non-trivial insulator. We will only need a Hall bar with four terminals, as shown below:</p>
<p><img src="/src/w5_qshe/fermion_parity_pump.htm/qsh_hallbar.svg" alt></p>
<p>We have a finite voltage applied to terminal 1, so electrons are injected into the system from there. You can see that because of the helical edge states, there are as many modes connecting terminal 1 to terminal 3 as there are to terminal 4. A moment of thought, or otherwise a quick calculation, should convince you that in this case there is no net current flowing orthogonal to the applied voltage. The Hall conductance is zero, which is the expected result if time-reversal symmetry is preserved, as it is in our system.</p>
<p>However, counterpropagating edge states have to have exactly opposite spin due to Kramers degeneracy. This means that there may be a net spin current across the sample, orthogonal to the applied voltage.</p>
<p>In particular, let’s again make the simple assumption that the spin projection along some axis is conserved. Then, in the figure above, all modes colored in red have spin up, and all modes colored in blue have spin down. So terminal 1 distributes electrons coming out of it according to their spin: all electrons with spin up end up in terminal 4, and all those with spin down in terminal 3. The system has a quantized spin current between terminals 3 and 4, hence the name “quantum spin Hall effect”.</p>
<p>However, the quantized spin Hall current is not a general property of a quantum spin Hall insulator. Here, it arises because we have combined time reversal symmetry with a spin conservation law, and as we learned in the first week, conservation laws are boring from a topological point of view.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider the simple case where spin is conserved. &quot;</span></span><br><span class="line">    <span class="string">&quot;In the quantum spin Hall bar system above, what happens if, instead of applying a voltage between terminals 1 and 2, &quot;</span></span><br><span class="line">    <span class="string">&quot;you manage to apply a *spin-polarized* current between terminals 1 and 2?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The system will develop an opposite spin-polarized current to compensate the effect.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A spin-polarized current will develop between terminals 3 and 4.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A voltage difference will develop between terminals 3 and 4.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is impossible to apply such a current unless the bulk gap closes.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The spin-polarized current will create an electron population imbalance between terminals 3 and 4. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence, similar to the Hall effect, a voltage will develop orthogonal to the current.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="A-model-for-the-quantum-spin-Hall-insulator"><a href="#A-model-for-the-quantum-spin-Hall-insulator" class="headerlink" title="A model for the quantum spin Hall insulator"></a>A model for the quantum spin Hall insulator</h1><p>There is an important model which can be used to describe quantum spin Hall insulators, known as the <strong>Bernevig-Hughes-Zhang model</strong> or, in short, BHZ model. In essence, this model is equivalent to two copies of the Chern insulator Hamiltonian on the square lattice that we studied in the fourth week.</p>
<p>The BHZ Hamiltonian takes the form</p>
<p>$$<br>H_\textrm{BHZ}(\mathbf{k}) = \begin{pmatrix} h(\mathbf{k}) &amp; 0 \ 0 &amp; h^*(-\mathbf{k}) \end{pmatrix},,<br>$$</p>
<p>with</p>
<p>$$<br>h(\mathbf{k}) = \epsilon(\mathbf{k}) + \mathbf{d}(\mathbf{k})\cdot \pmb{\sigma},.<br>$$</p>
<p>Here $\pmb\sigma = (\sigma_x, \sigma_y, \sigma_z)$ is a vector of Pauli matrices acting on the electron/hole degree of freedom (the original two bands of the Chern insulator), $\epsilon(\mathbf{k}) = C - D(k_x^2+k_y^2)$, the vector $\mathbf{d} = [A k_x, -A k_y, M(\mathbf{k})]$, and<br>$M(\mathbf{k}) = M - B(k_x^2+k_y^2)$.</p>
<p>You can see that it is basically two copies of the massive Dirac Hamiltonian we used to study Chern insulators. In particular, there is a linear coupling in momentum between the holes and the electrons. The gap in the Hamiltonian is given by the term $M(\mathbf{k})$, a momentum-dependent effective mass.</p>
<p>By changing the sign of $M$ from negative to positive, you get a gap closing at $\mathbf{k}=\pmb{0}$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(Bz=<span class="number">0.0</span>, **bhz_parameters[<span class="string">&quot;topo2&quot;</span>])</span><br><span class="line">syst = bhz(w=<span class="literal">None</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;k_x&quot;</span>: k, <span class="string">&quot;k_y&quot;</span>: k, <span class="string">&quot;title&quot;</span>: title&#125;</span><br><span class="line">Ms = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.M: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>This gap closing turns your trivial insulator into a topologically non-trivial quantum spin Hall insulator.</p>
<p>In the rest of this lecture, we will use the BHZ model as a toy-model to illustrate the behavior of a quantum spin Hall insulator using numerical examples. The BHZ model, however, is more than a toy-model, and it can be used to capture the behavior of some real semiconducting materials. For this reason, the BHZ model will be a main protagonist in the next chapter, where we will discuss real materials and the experimental evidence for the quantum spin Hall effect.</p>
<h1 id="Alternative-point-of-view-fermion-parity-pump"><a href="#Alternative-point-of-view-fermion-parity-pump" class="headerlink" title="Alternative point of view: fermion parity pump"></a>Alternative point of view: fermion parity pump</h1><p>In the previous cases of the Kitaev chain and the quantum Hall effect, the bulk topological invariant that we eventually obtained was characterized by the response to some adiabatic experiment.</p>
<p>Since the time-reversal invariant topological insulator is two dimensional like a quantum Hall system, it is reasonable to put the system in a Corbino geometry and change the flux through the system, creating an azimuthal electric field:</p>
<p><img src="/src/w5_qshe/fermion_parity_pump.htm/qsh_corbino.svg" alt></p>
<p>However, because of time-reversal symmetry, the system is forbidden from having a Hall conductance and therefore there cannot be any charge transfer between the two edges of the disk. For instance, if we consider two copies of the Haldane model with opposite spin, there will be two quantum Hall pumps working in opposite directions (one transferring charge from the inner edge to the outer edge, the other one from the outer edge to the inner one). So the net charge transferred is zero.</p>
<p>Because the two pumps act on electrons with opposite spin, you might be tempted to define a spin current, which would flow in response to the electric field, orthogonal to it. However, as we just discussed, the spin along a given direction may not be conserved, so generally this is not a good way to define a robust pumping effect.</p>
<p>To understand what exactly happens in the pumping process, let’s look at the energy spectrum of the edge states for the BHZ model in the cylinder geometry. As we discussed in the quantum Hall lectures, the cylinder geometry is really equivalent to the Corbino disk, except that it is easier to study.</p>
<p>You also learned that in a cylinder of finite circumference $L$, the momenta of the allowed edge states are quantized at values determined by the flux.</p>
<p>To make things more simple, you may actually imagine that the circumference of the cylinder is just a single unit cell long. We then have only one allowed value of the momentum $k$ along the edge, which is exactly proportional to the flux threaded through the cylinder, $k = 2\pi \Phi/\Phi_0$.</p>
<p>So let’s look at the energy spectrum of a cylinder as a function of $k$ (or equivalently $\Phi$), and compare a cylinder in the quantum spin Hall phase with a cylinder in the trivial insulating phase.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">half_pi_ticks = [(<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi / <span class="number">2</span>, <span class="string">r&quot;$\pi/2$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">style = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(<span class="number">0</span>, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: half_pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>),</span><br><span class="line">    <span class="string">&quot;xlims&quot;</span>: [<span class="number">0</span>, np.pi],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syst = bhz(<span class="number">20</span>)</span><br><span class="line">p1 = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;topo&quot;</span>])</span><br><span class="line">p2 = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;triv&quot;</span>])</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p1, **style).relabel(<span class="string">&quot;Topological&quot;</span>) * holoviews.HLine(<span class="number">0</span>)</span><br><span class="line">    + spectrum(syst, p2, **style).relabel(<span class="string">&quot;Trivial&quot;</span>) * holoviews.HLine(<span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In both cases you see that at $k=0$ there are isolated pairs of states with degenerate energies, between the valence and conduction bands. The Fermi energy is set at $E=0$, in the middle of the gap between conduction and valence bands. These states are the Kramers pairs at the edges - one pair for the topological case, two for the trivial case.<br>You also see the splitting of Kramers pairs as soon as $k$ goes away from zero. This is because $k = 0$ is a time-reversal invariant point, a point in momentum space that is mapped to itself by time-reversal symmetry.</p>
<p>The plot ends at $k=\pi$ (that is, $\Phi=h/2e$), which is another time-reversal invariant point. Indeed, time-reversal symmetry sends $\Phi\to-\Phi$, but for $\Phi=h/2e$ this corresponds exactly to adding or subtracting a flux quantum. Hence, all the physical properties of the system remain unchanged under the action of time-reversal for this value of the flux. And indeed you can see that all levels meet again and form Kramers pairs.</p>
<blockquote>
<p>We now see an interesting difference though. In the topological case, the Kramers pairs at $k=\pi$ are not the same as those at $k=0$. In the trivial case however, the pairs are the same. As a consequence, in the topological case there is an odd number of levels crossing zero-energy, while in the trivial cases there is an even number of them. Therefore changing the flux by $h/2e$ in the topological case changes the fermion parity at the edge, while it does nothing in the trivial case. We have thus obtained a <strong>fermion parity pump</strong>.</p>
</blockquote>
<p>Strangely, this reminds us of the topological superconducting ring that we studied in the second week of the course. There we also had a fermion parity change in response to a flux. It turns out that this is not a coincidence, as we will see when we discuss how to realize topological superconductors using topological insulators.</p>
<p>You may appreciate that our argument did not rely on spin being a good quantum number, or on any other detail of the system, but only on Kramers theorem. And in fact it holds very generally. Deforming the dispersion of Kramers pairs does not break the fermion parity pump, as long as the way states combine to form Kramers pairs at $k=0$ and $k=\pi$ is unchanged.</p>
<h1 id="Pumping-expression-for-the-topological-invariant"><a href="#Pumping-expression-for-the-topological-invariant" class="headerlink" title="Pumping expression for the topological invariant"></a>Pumping expression for the topological invariant</h1><p>At this point, following the same path we followed for Chern insulator, we would like to find an expression for a topological bulk invariant which characterizes the quantum spin Hall effect.</p>
<p>However, we now encounter a problem: for complicated topological systems in higher dimensions, it is hard to evaluate the topological invariant. We know when the system is topological, and we know which values the topological invariant can take (for now just two: trivial and non-trivial), but it becomes hard to find and evaluate the correct expression for it.</p>
<p>We were able to calculate the Chern number using Berry curvature. The analogous computation for the topological invariant of the quantum spin Hall insulator is too involved, and so we will not present it in our course.</p>
<p>The scattering formulation of the topological invariant, however, is easy to implement and utilize. We can apply it by taking the cylinder threaded by a flux and connecting it to leads in the following geometry:</p>
<p><img src="/src/w5_qshe/fermion_parity_pump.htm/qsh_pumping.svg" alt></p>
<p>Let us now study what happens when we try to inject electrons into the edges of the cylinder. Since we have “rolled-up” our system along one direction, we have a one-dimensional scattering problem. Similar to a Thouless pump, we expect to be able to find a topological signature in the reflection matrix $r$ for an electron coming in from the left.</p>
<p>As we vary the flux, the reflection properties may change, leading to a $k$-dependent reflection matrix $r(k)$. We assume that the bulk is gapped, so transmission is suppressed, and therefore $r$ is unitary. Moreover, at $k=0$ and $k=\pi$, $r$ is also antisymmetric because of time-reversal symmetry.</p>
<p>It turns out that the topological invariant has a relatively simple form:</p>
<p>$$<br>Q = \frac{\textrm{Pf}[r(0)]}{\textrm{Pf}[r(\pi)]}\sqrt{\frac{\det[r(\pi)]}{\det[r(0)]}}<br>$$</p>
<p>This expression relies on the antisymmetry of $r$ at $k=0$ and $k=\pi$. At these values we can compute the Pfaffian. The eigenvalues of $r$ come in pairs of opposite sign $e^{i\alpha}$, $-e^{i\alpha}$, which correspond to the Kramers pairs formed by the helical edge states. This means we can calculate the Pfaffian at these momentum values, but its phase is arbitrary.</p>
<p>We can however compute $\sqrt{\det[r(k)]}$ for all the intermediate values of $k$. To get rid of the sign ambiguity of the square root, we require that $\sqrt{\det[r(k)]}$ is continuous for all $k$, and that $\sqrt{\det[r(0)]} = \textrm{Pf}[r(0)]$. This only gives a unique answer if $\det r \neq 0$ for all $k$.</p>
<p>This gives us a curve which starts at $\textrm{Pf}[r(0)]$ and ends at either $\textrm{Pf}[r(\pi)]$ or $-\textrm{Pf}[r(\pi)]$. These two cases distinguish the trivial and nontrivial systems.</p>
<p>In the plot below, we show how this trajectory changes for our cylinder geometry as the BHZ model is driven through the topological phase transition. In the right panel, the green dots give you the phase of $\textrm{Pf}[r(0)]$ and $\textrm{Pf}[r(\pi)]$, and the blue line the phase of $\det[r(k)]$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(a=<span class="number">1.0</span>, Bz=<span class="number">0.0</span>, ky=<span class="literal">None</span>, **bhz_parameters[<span class="string">&quot;topo2&quot;</span>])</span><br><span class="line">syst = bhz(w=<span class="literal">None</span>)</span><br><span class="line">scat_syst = make_scatter_sys()</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;k_x&quot;</span>: k, <span class="string">&quot;k_y&quot;</span>: k, <span class="string">&quot;title&quot;</span>: title&#125;</span><br><span class="line">Ms = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">(</span><br><span class="line">    holoviews.HoloMap(&#123;p.M: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>])</span><br><span class="line">    + holoviews.HoloMap(</span><br><span class="line">        &#123;p.M: scattering_det_pfaff(scat_syst, p) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>We now have a quantity equal to $\pm 1$, which cannot change continuously unless there’s a gap closing (when there’s a gap closing, $\det r$ becomes equal to $0$). It is relatively hard to prove that this invariant counts the pumping of fermion parity, but if you’re interested, check out this paper:</p>
<ul>
<li>arXiv:1107.2215</li>
</ul>
<p>From reading the paper, or just from the above discussion, you see that it takes a lot of effort to derive an explicit expression for a topological invariant. Even though it is a hard task, sometimes one can guess the right result (one of us was indeed able to guess the above expression for $Q$ before it was known). Other times, one can invoke some simplification and obtain some important insight. This is what we will do in the next unit.</p>
<h1 id="A-simplification-inversion-symmetry"><a href="#A-simplification-inversion-symmetry" class="headerlink" title="A simplification: inversion symmetry"></a>A simplification: inversion symmetry</h1><p>As just mentioned, topological invariants in higher dimensions are often difficult to write down and evaluate in the general case. Luckily, in the presence of <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Parity_%28physics%29#Effect_of_spatial_inversion_on_some_variables_of_classical_physics">inversion symmetry</a> - which reverses the lattice coordinates with respect to a symmetry center - the topological condition can be stated in rather simple terms.<br>This turns out to be quite useful to describe most topological materials, which happen to have crystal structure with inversion symmetry.</p>
<p>From our earlier discussion, we know that a system is a time-reversal invariant topological insulator if it has an odd number of helical edge states. We will now see how we can find an expression for the bulk topological invariant, using inversion symmetry and bulk-boundary correspondence.</p>
<p>So let’s consider a two-dimensional Bloch Hamiltonian $H(\mathbf{k})$ with both inversion and time-reversal symmetry. Inversion symmetry has a unitary operator $\mathcal{P}$ which maps $\mathbf{k}\rightarrow -\mathbf{k}$ and satisfies $\mathcal{P}^2=1$. If we have both inversion symmetry $\mathcal{P}$ and time-reversal $\mathcal{T}$, we get an anti-unitary symmetry $\mathcal{T}\otimes\mathcal{P}$, which preserves $\mathbf{k}$ and squares to $-1$.</p>
<blockquote>
<p>These are precisely the conditions needed for Kramers theorem to apply - only this time, every point $\mathbf{k}$ is mapped to itself because inversion symmetry is included as well. We conclude that every eigenstate at any $\mathbf{k}$ is two-fold degenerate.  We may label these two eigenstates with an index $\sigma=\pm$. If spin is a good quantum number, $\sigma$ labels two states with opposite spin. However, this may not be the case so we will just refer to it as a pseudospin associated with Kramers degeneracy.</p>
</blockquote>
<p>Note that the simplification obtained by adding inversion symmetry is that the spectrum is two-fold degenerate at all $\mathbf{k}$ in the Brillouin zone. Time-reversal symmetry alone cannot guarantee that, because it maps $\mathbf{k}$ to $-\mathbf{k}$.</p>
<p>Our next step is to calculate the effective description of helical edge states at a domain wall between a topological phase and a non-topological phase. This is something we already know how to do thanks to our experience with domain walls in the Kitaev chain and in Chern insulators. It will give us insight into the topological transition and the bulk topological invariant.</p>
<h2 id="Study-of-a-domain-wall"><a href="#Study-of-a-domain-wall" class="headerlink" title="Study of a domain wall"></a>Study of a domain wall</h2><p>Let’s imagine that the helical edge runs along the $y$ direction, and that the domain wall is described by a mass profile $M(x)$ along the $x$ direction, which is zero at the domain wall:</p>
<p><img src="/src/w5_qshe/fermion_parity_pump.htm/qsh_domain_wall.svg" alt></p>
<p>In this configuration, $k_y$ is still a good quantum number, and we can study the energy dispersion of states bound to the domain wall as a function of $k_y$. If the edge is gapless there must be a momentum, say $\bar{k}_y$, where counterpropagating modes cross at the Fermi level. Let’s fix $k_y=\bar{k}_y$, and write down an effective Hamiltonian for the motion transverse to the domain wall.</p>
<p>We have in total four states, distinguished by two quantum numbers: their direction of propagation, which we denote with $b=\pm$, and their pseudospin $\sigma$. Inversion symmetry $\mathcal{P}$ flips the direction of propagation $b$, while the pseudo-spin degeneracy $\sigma$ is related to the combination of inversion and time-reversal $\mathcal{T}\otimes\mathcal{P}.$ To lowest order in the momentum $k_x$ perpendicular to the domain wall, the states at the transition point disperse linearly with $k_x$, and are two-fold degenerate. In fact, as we noted from Kramers degeneracy, the Hamiltonian must be chosen such that none of the terms break the two-fold degeneracy associated with the pseudospin $\sigma$. This means that the domain wall cannot couple states with different values of $\sigma$, which leads us to an effective Hamiltonian</p>
<p>$$<br>H(\bar{k}<em>y)=\sum</em>{\sigma,b},k_x b,|b,\sigma\rangle\langle b,\sigma|+M(x)(|+,\sigma\rangle\langle -,\sigma|+h.c.)],.<br>$$</p>
<p>where the factor $b$ is odd under time-reversal symmetry so that $k_x b$ is even under time-reversal symmetry.</p>
<p>We are back to an old friend, the one dimensional Dirac Hamiltonian with a position-dependent mass $M(x)$. Adapting our arguments from the first week, we can immediately say that the domain-wall hosts a pair of zero modes only if $M(x)$ changes sign.</p>
<p>As interesting as this sounds, we must remember that this pair of zero modes is present for $k_y=\bar{k}_y$. Because of inversion symmetry, there is necessarily an identical pair at $-\bar{k}_y$. So we get a total of 4 degenerate domain wall states from this type of gap closing - an even number of pairs. As we know form before, such pairs of gap closings do not affect the value of the topological invariant on the two sides of the domain walls. To change the value of the topological invariant, we would need an odd number of pairs crossing zero energy.</p>
<p>However, there are points in momentum space which are mapped onto each other by time-reversal symmetry, up to a reciprocal lattice vector. For these values, the above counting does not hold. People refer to these momenta as “time-reversal invariant momenta” or TRIMs. In the simple case of a square Brillouin zone, they are the points $(k_x, k_y) = (0,0), (0,\pi), (\pi,0),(\pi,\pi)$.</p>
<p>Since TRIMs are their own time-reversed partners, it is still possible for a gap closing at $\bar{k}_y=0$ or $\bar{k}_y=\pi$ to change the topology of the system. In this case, our doubling problem in momentum space is solved, and we can produce just one pair of edge modes at the domain wall. If we move the momentum $k_y$ slightly away from $\bar{k}_y$, the degenerate pair of modes splits linearly to form a single helical mode that produces a non-trivial fermion parity pump.</p>
<p>To make the distinction clear between a gap closing at a finite $\bar{k}_y$ and at a time-reversal invariant point, let’s draw a sketch of the edge dispersion in the two cases.</p>
<p><img src="/src/w5_qshe/fermion_parity_pump.htm/qsh_edge_dispersions.svg" alt></p>
<p>Kramers pairs are colored in red and blue and have the same linestyle. On the left, you have two pairs of Kramers partners, which however never meet at zero energy. On the right, there is a single Kramers pair meeting at zero energy. This argument summarizes the simplification that inversion symmetry brings to time-reversal invariant topological insulators.</p>
<blockquote>
<p>We can determine the topological invariant for the inversion symmetric topological insulators entirely from the bulk Hamiltonian at time-reversal invariant momenta, since gap closings at any other point can only add domain wall states in multiples of four.</p>
</blockquote>
<p>Does this mean that any gap closing at a TRIM is a topological transition? The states $|b,\sigma\rangle$ are Bloch states with definite values of $k_y$. We are considering a time-reversal invariant value of $k_y$, and since $b$ is flipped by inversion symmetry, we can apply inversion symmetry to conclude that the states $|\pm,\sigma\rangle$<br>transform into each other under inversion i.e. $\mathcal{P}|\pm,\sigma\rangle= |\mp,\sigma\rangle$. By combining these states<br>into symmetric and anti-symmetric superpositions</p>
<p>$$|e,\sigma\rangle=\frac{1}{\sqrt{2}}\left[|+,\sigma\rangle, + ,|-,\sigma\rangle\right],,\quad |o,\sigma\rangle=\frac{i}{\sqrt{2}}\left[|+,\sigma\rangle, - ,|-,\sigma\rangle\right],$$</p>
<p>we obtain states that are even ($e$) and odd ($o$) under inversion—they are eigenstates of $\mathcal{P}$ with eigenvalue $+1$ or $-1$. They are also eigenstates of $M$ at $k_x=k_y=0$. The factor of $i$ in $|o,\sigma\rangle$ ensures a consistency under the time-reversal transformation, such that $\mathcal{T}|(e,o),\sigma\rangle=\sigma|(e,o),\sigma\rangle$.</p>
<p>Every gap closing at a TRIM is an even parity state crossing with an odd parity state. The effective Hamiltonian of such a gap closing must also add an extra Kramers pair of states at the domain wall, and therefore indeed every gap closing at a TRIM is a topological phase transition, while gap closings at all the other momenta are unimportant due to inversion symmetry.</p>
<p>This leads to a simplified way of computing a topological invariant of quantum spin Hall insulators with inversion symmetry:</p>
<blockquote>
<p>To compute a bulk topological invariant for a two-dimensional topological state with time reversal and inversion symmetry we need to keep track of the parity $P$ of all the occupied eigenstates of $H(\mathbf{k})$ at the different time-reversal invariant momenta in the Brillouin zone. We may write such a bulk topological invariant as a product</p>
</blockquote>
<blockquote>
<p>$$Q=\prod_{n,j}P_{n,j},,$$</p>
</blockquote>
<blockquote>
<p>where $P_{n,j}$ is the parity, $n$ runs over the occupied bands of $H(\mathbf{k})$ and $j$ over the time-reversal invariant momenta.</p>
</blockquote>
<p>You might now worry whether this definition of the invariant relied on having a smooth domain wall. From the fermion parity pump argument, bulk-edge correspondence implies that the bulk must be topologically non-trivial once you have edge states for any termination. Reversing this argument, we know that once we have a topologically non-trivial bulk, we must have helical edge states for any termination.</p>
<p>Thus, by looking at smooth domain walls we are able to establish a connection between the topological invariant in the presence of time-reversal and inversion symmetry, and the existence of helical edge states and fermion-parity pumping that characterizes the two dimensional topological insulator.</p>
<p>As a bonus, thanks to the previous arguments we can begin to understand how to look for two-dimensional topological insulators among real materials, or how to create them. The main idea is to generate a “band-inversion” between an even and an odd parity band at a TRIM.</p>
<p>Such a band inversion is not impossible to achieve in real materials, and can be captured using the BHZ model. But let’s leave this to the next lecture.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What is the value of the parity invariant $Q$ if you stack together two quantum spin Hall systems  &quot;</span></span><br><span class="line">    <span class="string">&quot;in the topological phase (i.e., both with $Q=-1$)?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The system has edge states and is therefore topologically non-trivial.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The total number of odd parity occupied orbitals must be even, so you get $Q=1$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It depends on whether the helical states in the two layers have same &quot;</span></span><br><span class="line">    <span class="string">&quot;or opposite spin for a given direction.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The invariant depends on the number of edge Dirac points at $k$ away from 0.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Both layers have $Q=-1$ and hence an odd number of odd parity orbitals. Therefore, by combining the layers  &quot;</span></span><br><span class="line">    <span class="string">&quot;we get an even number of odd parity orbitals. Hence $Q$, which is the parity of odd parity orbitals must be &quot;</span></span><br><span class="line">    <span class="string">&quot;$Q=1$.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;ft9ppqqLhH4&quot;</span>, src_location=<span class="string">&quot;5.1-summary&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;QSHE - theory&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://ihuyi.xyz/src/w5_qshe/fermion_parity_pump.html" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2021
        <i class="ri-heart-fill heart_icon"></i> huyi
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/icon.svg" alt="O"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/logs/">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://pan.ihuyi.xyz">网盘</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://aria.ihuyi.xyz">aria2</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>