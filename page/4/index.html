<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="demon" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     O
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">O</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-src/w2_majorana/Peierls" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w2_majorana/Peierls/"
    >src/w2_majorana/Peierls</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w2_majorana/Peierls/" class="article-date">
  <time datetime="2021-01-07T09:11:06.818Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This first cell will be removed by the converter.</span></span><br></pre></td></tr></table></figure>

<h1 id="Tight-binding-models-in-a-magnetic-field-Peierls-substitution"><a href="#Tight-binding-models-in-a-magnetic-field-Peierls-substitution" class="headerlink" title="Tight-binding models in a magnetic field: Peierls substitution"></a>Tight-binding models in a magnetic field: Peierls substitution</h1><p>To understand how the vector potential enters a tight-binding model by the so-called Peierls substitution, let us remind ourselves that the gauge-invariance of the Schrodinger equation requires us to transform the wave-function amplitude or equivalently the creation operator of an electron at a site as $$c_j^\dagger \rightarrow c_j^\dagger e^{-i\frac{e}{\hbar c}\Lambda(\bf r_j)},$$<br>where $\Lambda(\bf r)$ generates the gauge transformation of the vector potential $\bf A(\bf r)\rightarrow \bf A(\bf r)+\bf\nabla A(\bf r)$. If there is no magnetic field then the vector potential can locally be set to $\bf A=0$ by an appropriate gauge choice of $\bf \Lambda$. The hopping term in the absence of a vector potential is written as $H_t=t_{jl}c_j^\dagger c_l+h.c$, which must gauge transform to  $$H_t=t_{jl} e^{-i\frac{e}{\hbar c}(\Lambda(\bf r_j)-\Lambda(\bf r_l))}c_j^\dagger c_l+h.c=t_{jl} e^{-i\frac{e}{\hbar c}(\int_{\bf r_l}^{\bf r_j} d\bf r’\cdot\bf A(\bf r’)}c_j^\dagger c_l+h.c.$$ While this expression is derived for zero magnetic field, by choosing the integration path to be the shortest distance over nearest neighbor bond, this expression is used to include magnetic fields in lattice models. This is referred to as the Peierls substitution for lattices.</p>
<p>If we put our topological nanowire in a ring (as with the Aharonov-Bohm effect) with a junction (as in the figure) and concentrate the magnetic field in the center of the ring, the vector potential $\bf A$ is constrained  by the magnetic flux $\Phi$ as $$\oint d\bf {r’\cdot\bf A(\bf r’)}=\int d^2\bf {r’\bf \nabla\times \bf A(\bf r’)}=\Phi.$$<br>Choosing a gauge for the vector potential so that it vanishes everywhere except in the junction the hopping phase $\theta$ for the junction i.e. $H_t=t_{N,1}e^{i\theta}c_N^\dagger c_1+h.c.$ is written as $$\theta=\int_{\bf r_l}^{\bf r_j} d\bf r’\cdot\bf A(\bf r’)=\pi \Phi/\Phi_0,$$ where $\Phi_0=hc/2e$ is the superconducting flux quantum. </p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w1_topointro/w1_assignments" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w1_topointro/w1_assignments/"
    >src/w1_topointro/w1_assignments</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w1_topointro/w1_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.817Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-what-about-other-symmetries"><a href="#Simulations-what-about-other-symmetries" class="headerlink" title="Simulations: what about other symmetries"></a>Simulations: what about other symmetries</h1><p>So you’ve made it through the content of the first week. Congratulations!</p>
<p>Now let’s get our hands dirty.</p>
<p>Let’s begin by grabbing the notebooks of this week and the extra code we use to run these notebooks over <a href="http://tiny.cc/topocm_smc" target="_blank" rel="noopener">here</a>. (Click the [i] button to the left of the folder that you want to copy.)</p>
<p>You need to copy the <code>code</code> folder and the <code>w1_topointro</code> folder. Let’s look into what’s inside.</p>
<h4 id="First-task-combination-of-particle-hole-and-time-reversal-symmetries"><a href="#First-task-combination-of-particle-hole-and-time-reversal-symmetries" class="headerlink" title="First task: combination of particle-hole and time-reversal symmetries"></a>First task: combination of particle-hole and time-reversal symmetries</h4><p>Look at the notebook about topology of zero-dimensional systems, and see how we generate Hamiltonians with a spinful time-reversal symmetry</p>
<p>$$<br>H = \sigma_y H^* \sigma_y.<br>$$</p>
<p>Now try to add this time reversal symmetry to a Hamiltonian which also has particle-hole symmetry. It is easiest to do in the basis where particle-hole symmetry has the form $H = -H^*$.<br>What do you think will happen? What will the extra symmetry do to the topological invariant?<br>Test your guess by plotting the spectrum and calculating the Pfaffian invariant.</p>
<h4 id="Second-task-Su-Schrieffer-Heeger-SSH-model"><a href="#Second-task-Su-Schrieffer-Heeger-SSH-model" class="headerlink" title="Second task: Su-Schrieffer-Heeger (SSH) model"></a>Second task: Su-Schrieffer-Heeger (SSH) model</h4><p>Similar to the Kitaev chain, the SSH model is simple a one-dimensional model where you can see all the essential aspects of topological systems. Unlike the Kitaev chain it does correspond to a physical system: electrons in a polyacetylene chain.</p>
<p>Here’s such a chain:</p>
<p><img src="/2021/01/07/src/w1_topointro/w1_assignments/polyacetylene.png" alt></p>
<p>Due to the dimerization of the chain the unit cell has two atoms and the hoppings have alternating strengths $t_1$ and $t_2$, so that the Hamiltonian is<br>$$H = \sum_{n=1}^N t_1 \left|2n-1\right\rangle\left\langle 2n\right|+t_2 \left|2n\right\rangle \left\langle 2n+1\right| + \textrm{h.c}$$</p>
<p>We can choose to start a unit cell from an even-numbered site, so $t_1$ becomes intra-cell hopping and $t_2$ inter-cell hopping.</p>
<p>Now get the notebook with the Kitaev chain and transform a Kitaev chain into an SSH chain.</p>
<p>Now repeat the calculations we’ve done with Majoranas using SSH chain. Keep $t_1 = 1$ and vary $t_2$.<br>You should see something very similar to what you saw with the Kitaev chain.</p>
<p>As you can guess, this is because the chain is topological.<br>Think for a moment: what kind of symmetry protects the states at the edges of the chain.<br><em>(Hint: you did encounter this symmetry in our course.)</em></p>
<p>The particle-hole symmetry, is a consequence of a mathematical transformation, and cannot be broken.<br>The symmetry protecting the SSH chain, however, can be broken.<br>Test your guess about the protecting symmetry by adding to your chain a term which breaks this symmetry and checking what it does to the spectrum of a finite chain and to its dispersion (especially as chain goes through a phase transition).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Labs"</span>, <span class="string">"Toy models simulations"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><p>For the first week we have these papers:</p>
<h3 id="arXiv-1103-0780"><a href="#arXiv-1103-0780" class="headerlink" title="arXiv:1103.0780"></a>arXiv:1103.0780</h3><p><strong>Hint:</strong> Topological classification is not always applied to Hamiltonians.<br>Figure out what is the topological quantity in open systems.<br>See this idea also applied in arXiv:1405.6896.</p>
<h3 id="arXiv-1305-2924"><a href="#arXiv-1305-2924" class="headerlink" title="arXiv:1305.2924"></a>arXiv:1305.2924</h3><p><strong>Hint:</strong> This is a study of statistical properties of topological transitions.</p>
<h3 id="arXiv-1111-6600"><a href="#arXiv-1111-6600" class="headerlink" title="arXiv:1111.6600"></a>arXiv:1111.6600</h3><p><strong>Hint:</strong> A toy model may still be useful in practice.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Reviews"</span>, <span class="string">"Toy models"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w1_topointro/1D" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w1_topointro/1D/"
    >src/w1_topointro/1D</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w1_topointro/1D/" class="article-date">
  <time datetime="2021-01-07T09:11:06.811Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line">%output size=<span class="number">150</span></span><br><span class="line">dims = SimpleNamespace(</span><br><span class="line">    E_t=<span class="string">r"$E/t$"</span>,</span><br><span class="line">    mu_t=<span class="string">r"$\mu/t$"</span>,</span><br><span class="line">    lambda_=<span class="string">r"$\lambda$"</span>,</span><br><span class="line">    x=<span class="string">r"$x$"</span>,</span><br><span class="line">    k=<span class="string">r"$k$"</span>,</span><br><span class="line">    amplitude=<span class="string">r"$|u|^2 + |v|^2$"</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">holoviews.core.dimension.title = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kitaev_chain</span><span class="params">(L=None, periodic=False)</span>:</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">-1</span>,)))</span><br><span class="line">        L = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transformation to antisymmetric basis</span></span><br><span class="line">    U = np.array([[<span class="number">1.0</span>, <span class="number">1.0</span>], [<span class="number">1.0j</span>, <span class="number">-1.0j</span>]]) / np.sqrt(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(onsite, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.mu * U @ pauli.sz @ U.T.conj()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(L):</span><br><span class="line">        syst[lat(x)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> U @ (-p.t * pauli.sz - <span class="number">1j</span> * p.delta * pauli.sy) @ U.T.conj()</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">last_hop</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> hop(site1, site2, p) * (<span class="number">1</span> - <span class="number">2</span> * p.lambda_)</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>), lat(L - <span class="number">1</span>)] = last_hop</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bandstructure</span><span class="params">(mu, delta=<span class="number">1</span>, t=<span class="number">1</span>, Dirac_cone=<span class="string">"Hide"</span>, show_pf=False)</span>:</span></span><br><span class="line">    syst = kitaev_chain(<span class="literal">None</span>)</span><br><span class="line">    p = SimpleNamespace(t=t, delta=delta, mu=mu)</span><br><span class="line">    plot = holoviews.Overlay([spectrum(syst, p, ydim=<span class="string">"$E/T$"</span>, xdim=<span class="string">"$k$"</span>)][<span class="number">-4</span>:<span class="number">4</span>])</span><br><span class="line">    h_1 = h_k(syst, p, <span class="number">0</span>)</span><br><span class="line">    h_2 = h_k(syst, p, np.pi)</span><br><span class="line">    pfaffians = [find_pfaffian(h_1), find_pfaffian(h_2)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> show_pf:</span><br><span class="line">        signs = [(<span class="string">"&gt;"</span> <span class="keyword">if</span> pf &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">"&lt;"</span>) <span class="keyword">for</span> pf <span class="keyword">in</span> pfaffians]</span><br><span class="line">        title = (</span><br><span class="line">            <span class="string">"$\mu = &#123;mu&#125; t$, Pf$(iH_&#123;&#123;k=0&#125;&#125;) &#123;sign1&#125; 0$, Pf$(iH_&#123;&#123;k=\pi&#125;&#125;) &#123;sign2&#125; 0$"</span></span><br><span class="line">        )</span><br><span class="line">        title = title.format(mu=mu, sign1=signs[<span class="number">0</span>], sign2=signs[<span class="number">1</span>])</span><br><span class="line">        plot *= holoviews.VLine(<span class="number">0</span>) * holoviews.VLine(-np.pi)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> pfaffians[<span class="number">0</span>] * pfaffians[<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            title = <span class="string">"$\mu = &#123;mu&#125; t$, topological "</span>.format(mu=mu)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            title = <span class="string">"$\mu = &#123;mu&#125; t$, trivial "</span>.format(mu=mu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> Dirac_cone == <span class="string">"Show"</span>:</span><br><span class="line">        ks = np.linspace(-np.pi, np.pi)</span><br><span class="line">        ec = np.sqrt((mu + <span class="number">2</span> * t) ** <span class="number">2</span> + <span class="number">4.0</span> * (delta * ks) ** <span class="number">2</span>)</span><br><span class="line">        plot *= holoviews.Path((ks, ec), kdims=[dims.k, dims.E_t]).opts(</span><br><span class="line">            style=&#123;<span class="string">"linestyle"</span>: <span class="string">"--"</span>, <span class="string">"color"</span>: <span class="string">"r"</span>&#125;</span><br><span class="line">        )</span><br><span class="line">        plot *= holoviews.Path((ks, -ec), kdims=[dims.k, dims.E_t]).opts(</span><br><span class="line">            style=&#123;<span class="string">"linestyle"</span>: <span class="string">"--"</span>, <span class="string">"color"</span>: <span class="string">"r"</span>&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> plot.relabel(title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_pfaffian</span><span class="params">(H)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sign(np.real(pf.pfaffian(<span class="number">1j</span> * H)))</span><br></pre></td></tr></table></figure>

<h1 id="Kitaev-chain-and-bulk-edge-correspondence"><a href="#Kitaev-chain-and-bulk-edge-correspondence" class="headerlink" title="Kitaev chain and bulk-edge correspondence"></a>Kitaev chain and bulk-edge correspondence</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"U84MzZm9Gbo"</span>, src_location=<span class="string">"1.2-intro"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Unpaired-Majorana-modes-in-one-dimensional-systems"><a href="#Unpaired-Majorana-modes-in-one-dimensional-systems" class="headerlink" title="Unpaired Majorana modes in one-dimensional systems"></a>Unpaired Majorana modes in one-dimensional systems</h1><h2 id="Fermion-operators-and-Majorana-operators"><a href="#Fermion-operators-and-Majorana-operators" class="headerlink" title="Fermion operators and Majorana operators"></a>Fermion operators and Majorana operators</h2><p>Let’s start from the creation and annihilation operators $c^\dagger$ and $c$ of a fermionic mode. These operators satisfy the anticommutation relation $c^\dagger c + cc^\dagger = 1$ and, furthermore, square to zero, $c^2=0$ and $(c^\dagger)^2=0$. They connect two states $\left|0\right\rangle$ and $\left|1\right\rangle$ which correspond to the ‘vacuum’ state with no particle and the ‘excited’ state with one particle, according to the following rules $c \left|0\right\rangle = 0$, $c^\dagger\left|0\right\rangle=\left|1\right\rangle$ and $c^\dagger \left|1\right\rangle = 0$.</p>
<p>When you have a pair of $c$ and $c^\dagger$ operators, you can write them down in the following way</p>
<p>$$ c^\dagger = \tfrac{1}{2}(\gamma_1+i\gamma_2),;; c = \tfrac{1}{2}(\gamma_1-i\gamma_2).$$</p>
<p>The operators $\gamma_1$ and $\gamma_2$ are known as Majorana operators. By inverting the transformation above, you can see that $\gamma_1=\gamma_1^\dagger$ and $\gamma_2=\gamma_2^\dagger$. Because of this property, we cannot think of a single Majorana mode as being ‘empty’ or ‘filled’, as we can do for a normal fermionic mode. This makes Majorana modes special.</p>
<p>You can also check that to maintain all the properties of $c$ and $c^\dagger$, the operators $\gamma_1$ and $\gamma_2$ must satisfy the following relations:</p>
<p>$$\gamma_1\gamma_2 + \gamma_2\gamma_1 = 0;,;\gamma_1^2=1;,;\gamma_2^2=1;.$$</p>
<p>You can see that Majorana modes are similar to normal fermions in the sense that they have operators which all anticommute with each other. Using Majorana modes instead of normal fermionic modes is very similar to writing down two real numbers in place of a complex number. Indeed, every fermion operator can always be expressed in terms of a pair of Majorana operators. This also means that Majorana modes always come in even numbers.</p>
<p>The two Majorana operators $\gamma_1, \gamma_2$ still act on the same states $\left|0\right\rangle$ and $\left|1\right\rangle$.<br>If these two states have an energy difference $\epsilon$, this corresponds to a Hamiltonian $H=\epsilon c^\dagger c$.<br>We can also express this Hamiltonian in terms of Majoranas as $H=\tfrac{1}{2},\epsilon,(1 - i\gamma_1\gamma_2)$.</p>
<p>But is it possible to have a single isolated Majorana mode, one that is not close to its partner?<br>The naive answer is ‘no’: condensed matter systems are made out of electrons, and these always correspond to pairs of Majoranas.<br>However, it turns out that by engineering the Hamiltonian in a special way it actually is possible to separate two Majoranas.</p>
<h2 id="Unpaired-Majorana-modes-in-a-model-of-dominoes"><a href="#Unpaired-Majorana-modes-in-a-model-of-dominoes" class="headerlink" title="Unpaired Majorana modes in a model of dominoes"></a>Unpaired Majorana modes in a model of dominoes</h2><p>Let’s see how creating isolated Majoranas can be done. Let us consider a chain of $N$ sites, where each site can host a fermion with creation operator $c^\dagger_n$. Equivalently, each site hosts two Majorana modes $\gamma_{2n-1}$ and $\gamma_{2n}$. This situation is illustrated below for $N=4$, where each site is represented by a domino tile.</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/majorana_dominoes.svg" alt></p>
<p>What happens if we pair the Majoranas? This means that the energy cost for each fermion to be occupied is $\mu$, and the Hamiltonian becomes</p>
<p>$$H=(i/2),\mu, \sum_{n=1}^{N} \gamma_{2n-1}\gamma_{2n}.$$</p>
<p>This is how the pairing looks:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/trivial_dominoes.svg" alt></p>
<p>All the excitations in this system have an energy $\pm|\mu|/2$, and the chain has a gapped bulk and no zero energy edge states.</p>
<p>Of course this didn’t help us to achieve our aim, so let’s pair the Majoranas differently.<br>We want only one Majorana to remain at an edge, so let’s pair up the Majoranas from <em>adjacent</em> sites, leaving the first one and the last one without a neighboring partner:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/topological_dominoes.svg" alt></p>
<p>To every pair formed in this way, we assign an energy difference $2t$ between the empty and filled state, hence arriving at the Hamiltonian</p>
<p>$$H=it \sum_{n=1}^{N-1} \gamma_{2n}\gamma_{2n+1}.$$</p>
<p>You can see that the two end Majorana modes $\gamma_1$ and $\gamma_{2N}$ do not appear in $H$ at all.<br>Hence our chain has two zero-energy states, localized at its ends.<br>All the states which are not at the ends of the chain have an energy of $\pm |t|$, independently on the length of the chain. Hence, we have a one-dimensional system with a gapped bulk and zero energy states at the edges.</p>
<h2 id="The-Kitaev-chain-model"><a href="#The-Kitaev-chain-model" class="headerlink" title="The Kitaev chain model"></a>The Kitaev chain model</h2><p>Let us now try to write the Hamiltonian $H$, which we have so far written in terms of Majoranas, in terms of regular fermions by substituting $\gamma_{2n-1}=(c_n^\dagger+c_n)$ and $\gamma_{2n}=-i(c_n^\dagger-c_n)$. We find that both pairings sketched above are extreme limits of one tight-binding Hamiltonian for a one-dimensional superconducting wire:</p>
<p>$$H=-\mu\sum_n c_n^\dagger c_n-t\sum_n (c_{n+1}^\dagger c_n+\textrm{h.c.}) + \Delta\sum_n (c_n c_{n+1}+\textrm{h.c.}),.$$</p>
<p>It has three real parameters: the onsite energy $\mu$, the hopping $t$ between different sites, and the superconducting pairing $\Delta$. Note that the $\Delta$ terms create or annihilate pairs of particles at neighboring sites.</p>
<p>Starting from this Hamiltonian, the unpaired Majorana regime is the special point $\Delta=t$ and $\mu=0$, while the completely trivial regime of isolated fermions is $\Delta=t=0$ and $\mu\neq 0$.</p>
<p>As we learned just before, it is useful to write down the above superconducting Hamiltonian in the Bogoliubov-de Gennes formalism $H = \tfrac{1}{2} C^\dagger H_\textrm{BdG} C$, with $C$ a column vector containing all creation and annihilation operators, $C=(c_1, \dots, c_N, c_1^\dagger, \dots, c^\dagger_N)^T$. The $2N\times 2N$ matrix $H_\textrm{BdG}$ can be written in a compact way by using Pauli matrices $\tau$ in particle and hole space, and denoting with $\left|n\right\rangle$ a column basis vector $(0,\dots,1,0,\dots)^T$ corresponding to the $n$-th site of the chain. In this way, we have for instance that $C^\dagger,\tau_z,\left|n\right\rangle\left\langle n\right|,C = 2c_n^\dagger c_n-1$. The Bogoliubov-de Gennes Hamiltonian is then given by</p>
<p>$$H_{BdG}=-\sum_n \mu \tau_z\left|n\right\rangle\left\langle n\right|-\sum_n \left[(t\tau_z+i\Delta\tau_y),\left|n\right\rangle\left\langle n+1 \right| + \textrm{h.c.}\right].$$</p>
<p>The BdG Hamiltonian acts on a set of basis states $\left|n\right\rangle\left|\tau\right\rangle$, with $\tau=\pm 1$ corresponding to electron and hole states respectively. It has particle-hole symmetry, $\mathcal{P}H_\textrm{BdG}\mathcal{P}^{-1}=-H_\textrm{BdG}$ with $\mathcal{P}=\tau_x\mathcal{K}$.</p>
<h2 id="Topological-protection-of-edge-Majorana-modes"><a href="#Topological-protection-of-edge-Majorana-modes" class="headerlink" title="Topological protection of edge Majorana modes"></a>Topological protection of edge Majorana modes</h2><p>The fact that the Kitaev model can have unpaired Majorana zero modes is certainly interesting. At this point you might however object:</p>
<p>“Unpaired Majoranas appear because you chose one particular, and perhaps even unreachable, set of parameters! Clearly by setting $\mu=0$ you have cut the first and last Majorana mode from the rest of the chain. I bet that if you change the value of $\mu$ only slightly from zero, the zero modes will be coupled to the rest of the chain and quickly disappear. So these Majorana modes may just be an artefact appearing in this highly tuned model!”</p>
<p>Well, let’s test if this objection is true. Let’s start from the situation with unpaired Majorana modes ($\Delta=t, \mu=0$) and then increase $\mu$. Then let’s plot the energy spectrum of a chain with $N=25$ sites as a function of $\mu$, and also keep track how do the two lowest energy states of our system look like, when we change $\mu$ <strong>(move the slider)</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_wf</span><span class="params">(syst, wf1, wf2, lstyle=<span class="string">"-"</span>, lcolor=<span class="string">"b"</span>)</span>:</span></span><br><span class="line">    xs = np.array([i.pos[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> syst.sites])</span><br><span class="line">    indx = np.argsort(xs)</span><br><span class="line">    wf_sq = (</span><br><span class="line">        np.linalg.norm(wf1.reshape(<span class="number">-1</span>, <span class="number">2</span>), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line">        + np.linalg.norm(wf2.reshape(<span class="number">-1</span>, <span class="number">2</span>), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    plot = holoviews.Path((xs[indx], wf_sq[indx]), kdims=[dims.x, dims.amplitude])</span><br><span class="line">    <span class="keyword">return</span> plot.opts(</span><br><span class="line">        style=&#123;<span class="string">"linestyle"</span>: lstyle, <span class="string">"color"</span>: lcolor&#125;,</span><br><span class="line">        plot=&#123;<span class="string">"yticks"</span>: <span class="number">0</span>, <span class="string">"xticks"</span>: list(range(<span class="number">0</span>, len(xs), <span class="number">10</span>))&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pwave</span><span class="params">(L, t, delta, mu)</span>:</span></span><br><span class="line">    <span class="comment"># At mu=0 the first exited state is not well defined due to the massive degeneracy.</span></span><br><span class="line">    <span class="comment"># That is why we add a small offset to mu.</span></span><br><span class="line">    syst = kitaev_chain(L).finalized()</span><br><span class="line">    p = SimpleNamespace(t=t, delta=delta, mu=mu + <span class="number">1e-4</span>)</span><br><span class="line">    ham = syst.hamiltonian_submatrix(params=dict(p=p))</span><br><span class="line">    ev, evec = np.linalg.eigh(ham)</span><br><span class="line">    <span class="keyword">return</span> plot_wf(syst, evec[:, L], evec[:, L - <span class="number">1</span>]) * plot_wf(</span><br><span class="line">        syst, evec[:, L + <span class="number">1</span>], evec[:, L - <span class="number">2</span>], lstyle=<span class="string">"--"</span>, lcolor=<span class="string">"r"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syst = kitaev_chain(L=<span class="number">25</span>)</span><br><span class="line">mus = np.arange(<span class="number">0</span>, <span class="number">4</span>, <span class="number">0.2</span>)</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, delta=<span class="number">1</span>, mu=mus)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(</span><br><span class="line">        syst,</span><br><span class="line">        p,</span><br><span class="line">        xticks=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        yticks=range(<span class="number">-3</span>, <span class="number">4</span>),</span><br><span class="line">        xdim=dims.mu_t,</span><br><span class="line">        ydim=dims.E_t,</span><br><span class="line">        ylims=(<span class="number">-3</span>, <span class="number">3</span>),</span><br><span class="line">    )</span><br><span class="line">    * holoviews.HoloMap(&#123;mu: holoviews.VLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[dims.mu_t])</span><br><span class="line">    + holoviews.HoloMap(</span><br><span class="line">        &#123;mu: plot_pwave(<span class="number">25</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[dims.mu_t]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The left panel shows the spectrum, where we see two states at zero energy that split. On the right panel the blue line is the wave function of the state corresponding to the pair of Majorana modes, while the red dashed line is the wave function of the first excited state.</p>
<p>As you can see, the zero energy eigenvalues corresponding to the two unpaired Majorana zero modes persist for a long time, and they only split in energy when $\mu \simeq 2t$. Another thing that we observe is that the wave function of the Majoranas stays zero in the middle of our wire.</p>
<p>As we increase $\mu$ (try it), the wave function of the Majoranas becomes less localized near the edges of the wire, but the coupling between two ends only appears later.</p>
<p>You would observe a similar behavior if you varied $\mu$ in the negative direction starting from $\mu=0$. The Majoranas persist until $\mu\simeq-2t$, where the bulk gap closes.</p>
<p>In fact, the Majoranas only split when the higher-energy states in the bulk, originally separated by an energy gap of $2 t$, come very close to zero energy. So our investigation shows that the Majorana modes are protected <strong>as long as the bulk energy gap is finite</strong>.</p>
<p>How can we understand this? Recall that we are dealing with a particle-hole symmetric Hamiltonian. Hence, the spectrum has to be symmetric around zero energy. When $\mu=0$, we have two zero energy levels, corresponding to the Majorana modes which are localized far away from each other and separated by a gapped medium. Trying to move these levels from zero energy individually is impossible, as it would violate particle-hole symmetry:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/level_deformation_fig.svg" alt></p>
<p>The only possibility to move the energy levels from zero is to couple the two unpaired Majorana modes to each other. However, because of the spatial separation between Majoranas and of the presence of an energy gap, this coupling is impossible. The only way to split the Majorana modes in energy is to first close the bulk energy gap, and that is exactly what happens at large values of $\mu$ (to be precise, it happens at $\mu=2t$).</p>
<p>So we have just learned the following:</p>
<blockquote>
<p>Isolated zero end-modes at each end in the Kitaev chain are protected by <strong>symmetry</strong> between positive and negative energy, and by the <strong>absence of zero-energy excitations in the bulk of the wire</strong>, but not by fine-tuning of the chain parameters.</p>
</blockquote>
<p>As you see, our conclusion sounds a lot like what we learned about topology just before. We have come to these conclusions by studying a Kitaev chain on an open geometry with boundaries, and by focusing on the presence or absence of edge states localized at the boundaries of the chain. In the rest of the unit we will see that the presence or absence of edge states can be deduced by studying the bulk alone. In order to do this, we will now study an infinite Kitaev chain without boundaries.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"But wait! What happens if we remove the last Majorana site of a Kitaev chain"</span></span><br><span class="line">    <span class="string">" in the topological phase?"</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"We get a chain with a single Majorana mode."</span>,</span><br><span class="line">    <span class="string">"We cannot remove a single Majorana site because electrons (pairs of Majoranas) "</span></span><br><span class="line">    <span class="string">"are the only physical degrees of freedom."</span>,</span><br><span class="line">    <span class="string">"The Hamiltonian becomes topologically trivial."</span>,</span><br><span class="line">    <span class="string">"Removing a single Majorana is not allowed by particle-hole symmetry"</span>,</span><br><span class="line">]</span><br><span class="line">explanation = <span class="string">"Indeed, as we explained, removing a single Majorana is like removing a single pole of a magnet. So not possible."</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Topological-phases-from-the-bulk-spectrum"><a href="#Topological-phases-from-the-bulk-spectrum" class="headerlink" title="Topological phases from the bulk spectrum"></a>Topological phases from the bulk spectrum</h1><h2 id="Going-to-momentum-space"><a href="#Going-to-momentum-space" class="headerlink" title="Going to momentum space"></a>Going to momentum space</h2><p>The Majoranas are edge excitations that arise from the bulk-edge correspondence. You might wonder if there is a way to deduce the existence of Majorana modes by looking at the bulk? To answer this, eliminate the boundaries from the study of the Kitaev chain. You can imagine that the last site of the chain is reconnected to the first, so that the chain is closed in a ring (a “Kitaev ring”). In the absence of boundaries, the Bogoliubov-de Gennes Hamiltonian has a translational symmetry $\left|n\right\rangle,\to,\left|n+1\right\rangle$, since all parameters $t, \Delta$ and $\mu$ do not depend on the chain site $n$. In the presence of translational symmetries, it is always convenient to use <a href="http://en.wikipedia.org/wiki/Bloch_wave#Preliminaries:_Crystal_symmetries.2C_lattice.2C_and_reciprocal_lattice" target="_blank" rel="noopener">Bloch’s theorem</a> and write down the Hamiltonian in momentum space rather than in real space. In our case, a state with momentum $k$ is given by</p>
<p>$$ \left|k\right\rangle =(N)^{-1/2} \sum_{n=1}^{N} e^{-ikn} \left|n\right\rangle.$$</p>
<p>We apply periodic boundary conditions, that is $\left\langle k | n=0 \right\rangle=\left\langle k | n=N \right\rangle$. The momentum $k$ is then a conserved quantum number with allowed values $2\pi p /N$ where $p=0, 1, 2, \dots, N-1$. Values of $k$ which differ by $2\pi$ are equivalent. One can also imagine that for very large $N$, $k$ is a continuous periodic variable with values in the interval $[-\pi,\pi]$, the <strong>Brillouin zone</strong>. Because $k$ is a good quantum number, the Bogoliubov-de Gennes Hamiltonian in momentum space can be reduced to a $2\times 2$ matrix:</p>
<p>$$ H(k) \equiv \left\langle k\right| H_\textrm{BdG} \left| k \right\rangle = (-2t\cos{k}-\mu),\tau_z + 2\Delta \sin{k},,\tau_y.$$</p>
<p>The full Bogoliubov-de Gennes Hamiltonian is obtained by summing all these $2\times 2$ blocks:</p>
<p>$$ H_\textrm{BdG} = \sum_k H(k) \left| k \right\rangle\left\langle k \right|.$$</p>
<p>In the limit of an infinite chain the sum becomes an integral over the Brillouin zone.</p>
<h2 id="Particle-hole-symmetry-in-momentum-space"><a href="#Particle-hole-symmetry-in-momentum-space" class="headerlink" title="Particle-hole symmetry in momentum space"></a>Particle-hole symmetry in momentum space</h2><p>Going to momentum space does not affect the particle-hole symmetry of the Bogoliubov-de Gennes Hamiltonian. However, one must always be careful in dealing with anti-unitary operators when making a basis transformation. The reason is that the action of the complex conjugation operator might depend on the basis. In our case, we have</p>
<p>$$\mathcal{P}\left|k\right\rangle!\left|\tau\right\rangle =  \left(\sum_n,e^{-ikn}\right)^<em>,\left|n\right\rangle,\tau_x\left|\tau\right\rangle^</em>=\left|-k\right\rangle,\tau_x\left|\tau\right\rangle^*.$$</p>
<p>Note that the particle-hole symmetry operator changes $k$ to $-k$. Therefore, the action of $\mathcal{P}$ on the Bogoliubov-de Gennes Hamiltonian written in momentum space is the following:</p>
<p>$$\mathcal{P}H_\textrm{BdG}\mathcal{P}^{-1} = \sum_k \tau_xH^<em>(k)\tau_x \left| -k \right\rangle\left\langle -k \right|=\sum_k \tau_xH^</em>(-k)\tau_x \left| k \right\rangle\left\langle k \right|,.$$</p>
<p>In the last equality, we have used the fact that the allowed values of $k$ always come in $(-k, k)$ pairs, plus the two symmetric points $k=0$ and $k=\pi$. Therefore, particle-hole symmetry $\mathcal{P}H_\textrm{BdG}\mathcal{P}^{-1}= -H_\textrm{BdG}$ implies that</p>
<p>$$H(k)=-\tau_xH^*(-k)\tau_x.$$</p>
<p>You can verify that it is indeed the case:</p>
<p>$$\tau_x H^*(-k) \tau_x = (2t\cos{k}+\mu),\tau_z - 2\Delta \sin{k},,\tau_y.$$</p>
<p>Given a solution with energy $E$ and momentum $k$, particle-hole symmetry dictates in general the presence of a solution with energy $-E$ and momentum $-k$.</p>
<h2 id="Band-structure"><a href="#Band-structure" class="headerlink" title="Band structure"></a>Band structure</h2><p>At this point, we only need to diagonalize this $2\times 2$ matrix to obtain the <em>band structure</em> of the Kitaev chain model, that is the energy levels $E(k)$. This can be done very easily, and results in two energy bands, one with positive energy and one with negative energy:</p>
<p>$$ E(k) = \pm\sqrt{(2t\cos{k}+\mu)^2 + 4\Delta^2\sin^2{k}}. $$</p>
<p>Let’s see what this band structure looks like (<strong>once again move the slider</strong> to change $\mu$):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mus = np.arange(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">plots = &#123;</span><br><span class="line">    (mu, Dirac_cone): bandstructure(mu, Dirac_cone=Dirac_cone)</span><br><span class="line">    <span class="keyword">for</span> mu <span class="keyword">in</span> mus</span><br><span class="line">    <span class="keyword">for</span> Dirac_cone <span class="keyword">in</span> [<span class="string">"Show"</span>, <span class="string">"Hide"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(plots, kdims=[dims.mu_t, <span class="string">"Dirac cone"</span>])</span><br></pre></td></tr></table></figure>

<p>You can see that the energy spectrum is gapped at all $k$ for $\mu=0$. This is natural: Since our chain does not have boundaries anymore, the energy spectrum does not contain the zero energy Majorana modes which we found in the previous subsection at $\mu=0$. However, you can see very clearly the bulk gap closing which occurs at the points $\mu=2t$ and $\mu=-2t$. Indeed, for these values of $\mu$ the two bands at negative and positive energy touch at $E=0$, for $k=\pi$ and $k=0$ respectively.</p>
<p>At first sight, the band structure looks quite similar on both sides of the bulk gap closings. Just from the above plot, it is not clear that the bulk gap closings separate two distinct phases of the model. Nevertheless, we will see that it is possible to rigorously come to this conclusion by studying the properties of $H(k)$ in more detail. But in the meantime, we will start by understanding better what happens close to the transition, by writing down a simple effective model from which we will be able to deduce a lot of information.</p>
<h2 id="Study-of-the-bulk-transition-with-an-effective-Dirac-model"><a href="#Study-of-the-bulk-transition-with-an-effective-Dirac-model" class="headerlink" title="Study of the bulk transition with an effective Dirac model"></a>Study of the bulk transition with an effective Dirac model</h2><p>Let’s look at the gapless points more in detail. We focus on the gap closing at $\mu=-2t$, which happens at $k=0$. Close to this point where the two bands touch, we can make a linear expansion of the Hamiltonian $H(k)$,</p>
<p>$$H(k) \simeq m \tau_z + 2\Delta,k,\tau_y,,$$</p>
<p>with $m=-\mu-2t$. We can see that $H(k)$ becomes a <strong>Dirac Hamiltonian</strong> - note that condensed matter physicists use this term quite loosely to refer to any Hamiltonian which is linear in the momentum operator. You can easily check that this Hamiltonian gives an energy spectrum $E(k) = \pm\sqrt{m^2 + 4\Delta^2k^2}$, and by returning to the plot above you can indeed verify that this is a very good approximation of the exact band structure around $\mu=-2t$.</p>
<p>The ‘’mass’’ $m$ appearing in this Dirac Hamiltonian is a very important parameter to describe what is happening. Its magnitude is equal to the energy gap $\left|\mu+2t\right|$ in the band structure close to the gap closing. Its sign reminds us of the two original phases which we encountered in the previous part of the lecture:</p>
<ul>
<li>$m&lt;0$ for $\mu&gt;-2t$, which corresponds to the <strong>topological</strong> phase, the one with Majorana modes in the open chain.</li>
<li>$m&gt;0$ for $\mu&lt;-2t$, which corresponds to the <strong>trivial</strong> phase, the one without Majorana modes in the open chain.</li>
</ul>
<p>Previously, we had identified the point $\mu=-2t$ as a phase transition between two phases with or without zero energy edge modes. By looking at the bulk Hamiltonian, the same point $\mu=-2t$ appears as a point where the bulk gap closes and <em>changes sign</em>.</p>
<p>When $m=0$, the Hamiltonian has two eigenstates with energy $E=\pm 2\Delta k$. These states are the eigenstates of $\tau_y$, hence they are equal weight superpositions of electron and holes. They are in fact Majorana modes, that are left-moving on the branch $E = -2\Delta k$ and right-moving on $E = 2\Delta k$. Now they are free to propagate in the chain since there is no bulk gap anymore. In our simple model, the speed of these modes is given by $v=2\Delta$.</p>
<h2 id="Majorana-modes-appearing-at-a-domain-wall-between-different-phases"><a href="#Majorana-modes-appearing-at-a-domain-wall-between-different-phases" class="headerlink" title="Majorana modes appearing at a domain wall between different phases"></a>Majorana modes appearing at a domain wall between different phases</h2><p>Let us consider the following question: What happens if the mass parameter $m(x)$ varies continuously <em>in space</em>, and changes sign at a certain point?</p>
<p>To answer the question, let’s write down the Dirac Hamiltonian above in real space. Then we have</p>
<p>$$H = -v,\tau_y,i\partial_x + m(x), \tau_z.$$</p>
<p>As anticipated, the mass is now a function of position, $m(x)$, with the property that $m(x)\to \pm m$ for $x\to\pm\infty$ and $m(x=0)=0$. The point $x=0$ is a <em>domain wall</em>, the border between two regions of space with opposite sign of the mass.</p>
<p>We already know that when $m=0$, the Hamiltonian above has a zero energy Majorana mode as a solution. Let us look at it in more detail. We need to solve the equation $H\Psi=0$, which can be rewritten as</p>
<p>$$\partial_x\Psi(x) = (1/v),m(x),\tau_x,\Psi(x).$$</p>
<p>Only a single Pauli matrix $\tau_x$ appears in this equation, which is therefore quite easy to solve. The solutions have the form</p>
<p>$$\Psi(x) = \exp,\left(\tau_x\int_0^x \frac{m(x’)}{v}, dx’\right) \Psi(0).$$</p>
<p>Two linearly independent solutions are given by the eigenstates of $\tau_x$:</p>
<p>$$\Psi(x) = \exp,\left(\pm\int_0^x \frac{m(x’)}{v}, dx’\right) \begin{pmatrix} 1 \ \pm 1 \end{pmatrix},.$$</p>
<p>Only one of the two is normalizable, thanks to the fact that $m(x)$ changes sign at $x=0$. In this way we obtain a wave function localized at $x=0$, with two exponential tails on the sides. This solution is our Majorana mode which, in this case, is a bound state localized at the domain wall. Note that no zero-energy solution would exist if $m(x)$ did not change sign. In this case $\Psi(x)$ would not be normalizable at either side of the domain wall.</p>
<p>Physically, we are considering a situation where our system is in the topological phase for $x&lt;0$ and in the trivial phase for $x&gt;0$. Therefore we have just demonstrated that at the interface between these two regions <em>there must be</em> a zero energy mode.</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/domain_wall_zero_mode.svg" alt></p>
<p>To clarify the situation, we can represent the same domain wall with our domino tiles. When you join together two chains of dominoes paired up in a different way, one single unpaired Majorana <em>must be</em> left in the middle:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/domain_wall_with_dominoes.svg" alt></p>
<h1 id="Bulk-topological-invariant-and-the-bulk-edge-correspondence"><a href="#Bulk-topological-invariant-and-the-bulk-edge-correspondence" class="headerlink" title="Bulk topological invariant and the bulk-edge correspondence"></a>Bulk topological invariant and the bulk-edge correspondence</h1><h2 id="Bulk-topological-invariant"><a href="#Bulk-topological-invariant" class="headerlink" title="Bulk topological invariant"></a>Bulk topological invariant</h2><p>Now that we understand the topological transition in more detail, let’s go back to the bulk Hamiltonian $H(k)$ of the Kitaev ring and try to generalize our Dirac-equation based criterion for Majorana modes. In our effective Dirac model it was easy to identify a quantity, the mass parameter $m$, whose sign determined whether the system could support unpaired Majorana modes at its ends. Let’s now try to turn this effective description into a <strong>bulk topological invariant</strong> which can be computed directly from $H(k)$. We will not attempt to give a rigorous derivation of the bulk invariant - a task which is often difficult even for advanced researchers in the field - but rather to arrive at it in a heuristic manner.</p>
<p>We can start with some important clues. On the one hand, we are studying a Bogoliubov-de Gennes Hamiltonian, and we have already learned that quantum dots with particle-hole symmetry are characterized by a topological invariant, the sign of the Pfaffian, which changes sign at every gap closing. On the other hand, we have just seen that the gap closing in the Kitaev chain model is accompanied by a change of sign of $m$. This suggests to try to link the quantity $m$ to a Pfaffian. How to do so?</p>
<p>In fact, you can think of the full $H_\textrm{BdG}$ as a very large matrix with particle-hole symmetry. It can be put in antisymmetric form and we can compute its Pfaffian. This Pfaffian may change only when an eigenvalue of $H(k)$ passes through zero. Because of particle-hole symmetry, for every eigenvalue $E(k)$ we have one at $-E(-k)$. So if $E(k)$ passes through zero, also its partner does. Furthermore, the spectrum has to be periodic in the Brillouin zone, which means that gap closings at finite momentum always come in pairs, and cannot change the Pfaffian. There are only two points which make exception: $k=0$ and $k=\pi$, which are mapped onto themselves by particle-hole symmetry. In fact, for these points we have:</p>
<p>$$ \tau_x H^<em>(0)\tau_x=-H(0),$$<br>$$ \tau_x H^</em>(\pi)\tau_x=-H(\pi).$$</p>
<p>So $H(0)$ and $H(\pi)$ can always be put individually in antisymmetric form, and we can always compute their Pfaffian. Also, note that these are precisely the points in momentum space where the gap closes: at $k=0$ for $\mu=-2t$ and at $k=\pi$ for $\mu=2t$. All things considered, we have a strong reason to focus exclusively on $H(0)$ and $H(\pi)$. Following the procedure that we learned in the last chapter, we can therefore put $H(0)$ and $H(\pi)$ in antisymmetric form,</p>
<p>$$\tilde{H}(0) = \frac{1}{2}<br>\begin{pmatrix} 1 &amp; 1 \ i &amp; -i \end{pmatrix}<br>\begin{pmatrix} -2t-\mu &amp; 0 \ 0 &amp; 2t+\mu \end{pmatrix}<br>\begin{pmatrix} 1 &amp; -i \ 1 &amp; i \end{pmatrix} = -i<br>\begin{pmatrix} 0 &amp; -2t-\mu \ 2t+\mu &amp; 0\end{pmatrix},$$<br>$$\tilde{H}(\pi) = \frac{1}{2}<br>\begin{pmatrix} 1 &amp; 1 \ i &amp; -i \end{pmatrix}<br>\begin{pmatrix} 2t-\mu &amp; 0 \ 0 &amp; -2t+\mu \end{pmatrix}<br>\begin{pmatrix} 1 &amp; -i \ 1 &amp; i \end{pmatrix} = -i<br>\begin{pmatrix} 0 &amp; 2t-\mu \ -2t+\mu &amp; 0\end{pmatrix}.$$</p>
<p>We now easily obtain that</p>
<p>$$\textrm{Pf}[iH(0)]=-2t-\mu,$$<br>$$\textrm{Pf}[iH(\pi)]=2t-\mu.$$</p>
<p>You see that the Pfaffian of $H(0)$ changes sign at $\mu=-2t$, and the Pfaffian of $H(\pi)$ does so at $\mu=2t$, in perfect agreement with the position of the gap closing in the band structure:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mus = np.arange(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">0.25</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;mu: bandstructure(mu, show_pf=<span class="literal">True</span>) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[dims.mu_t]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Individually, the two Pfaffians account for one of the two bulk gap closings which can occur in the model. To obtain a single bulk invariant $Q$ we can simply multiply the two! Hence we arrive at the following expression:</p>
<p>$$Q = \textrm{sign}\left(, \textrm{Pf}[iH(0)],\textrm{Pf}[iH(\pi)],\right).$$</p>
<p>A value $Q=-1$ means that the bulk is in a topological phase, such that if the wire was cut at a point, two unpaired Majorana modes would appear at the ends of it. On the other hand, a value $Q=+1$ means that the bulk is in the trivial phase. Again, you might think that this expression for $Q$, that we have just cooked up, is only valid for the particular model that we are considering. However, you would be wrong:</p>
<blockquote>
<p>The topological invariant $Q$ cannot change under continuous deformations of the Hamiltonian unless the gap closes.</p>
</blockquote>
<h2 id="Connecting-the-bulk-invariant-and-the-edge-modes"><a href="#Connecting-the-bulk-invariant-and-the-edge-modes" class="headerlink" title="Connecting the bulk invariant and the edge modes"></a>Connecting the bulk invariant and the edge modes</h2><p>At the moment, the bulk topological invariant $Q$ defined above might look just like an abstract mathematical object. We know that $Q=-1$ corresponds to the topological phase, but can we give a more concrete physical meaning to this value? This is the goal of this last part of the lecture.</p>
<p>We have already connected the Pfaffian of a Bogoliubov-de Gennes Hamiltonian to a physical quantity: The ground state fermion parity of the system. Our one-dimensional invariant involves the product of two Pfaffians, $\textrm{Pf}[iH(0)]$ and $\textrm{Pf}[iH(\pi)]$. By taking their product we are somehow <em>comparing</em> the fermion parity of the two states of the chain with $k=0$ and $k=\pi$, and we have that $Q=-1$ if and only if the two parities are different.</p>
<p>This means that if we <em>continuously deform</em> $H(0)$ into $H(\pi)$ in some way without breaking the particle-hole symmetry, we must encounter a zero-energy level crossing in the energy spectrum, what we called a <em>fermion parity switch</em> in the last chapter.</p>
<p>In practice, this can be done in the following way. Let’s imagine that we change the boundary conditions of a Kitaev ring with $N$ sites from <em>periodic</em> to <em>antiperiodic</em> boundary conditions, that is from $\left\langle k | n=0 \right\rangle=\left\langle k | n=N \right\rangle$ to $\left\langle k | n=0 \right\rangle=-\left\langle k | n=N \right\rangle$. This means that the allowed values of momentum shift from $k=2\pi p/N$ to $k = 2\pi p/N + \pi /N$.</p>
<p>Let’s now ask what is the difference in ground state fermion parity of the two chains. The value $k=0$ is always present in the chain with periodic boundary conditions, while $k=\pi$ is in the first set if $N$ is even and in the second set if $N$ is odd. This means that in either case, the difference in the ground state fermion parities between the chains with periodic and antiperiodic boundary conditions is equal to $Q$!</p>
<p>To verify this statement, we will now <em>physically change the boundary condition in real space</em>. For simplicity, we will do so for a Kitaev ring with $\Delta=t$. You will remember that, in the Majorana basis, this corresponds to the limit where neighboring Majoranas from different sites are coupled by hopping of strength $t$.</p>
<p>To go from periodic to antiperiodic boundary condition, we can change the hopping on the last bond of the ring (the one connecting sites $n=N-1$ and $n=0$) from $t$ to $-t$. This can easily be done continuously and without breaking particle-hole symmetry, for instance by setting the last hopping to be equal to $t,(1-2\lambda)$ and varying $\lambda$ in the interval $[0,1]$, as shown in this picture:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/majorana_ring.svg" alt></p>
<p>You can check that the Bogoliubov-de Gennes Hamiltonian of this closed ring satisfies particle-hole symmetry at every value of $\lambda$. Let’s now look at the energy spectrum $E(\lambda)$ of the system as we vary $\mu$ from $0$ to $4t$, passing once again through the gap closing at $\mu=2t$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syst = kitaev_chain(L=<span class="number">25</span>, periodic=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, delta=<span class="number">1</span>, lambda_=np.linspace(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">101</span>), mu=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">"xticks"</span>: np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="string">"yticks"</span>: np.linspace(<span class="number">-4</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="string">"xdim"</span>: dims.lambda_,</span><br><span class="line">    <span class="string">"ydim"</span>: dims.E_t,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mus = np.arange(<span class="number">0</span>, <span class="number">4</span>, <span class="number">0.1</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[dims.mu_t]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>You can see that for $\mu&lt;2t$, the energy spectrum shows a zero-energy level crossing at $\lambda=1/2$. The fermion parity of the system is therefore different at $\lambda=0$ and $\lambda=1$. When $\lambda=1/2$ the hopping on the last bond is equal to zero. We have introduced a “cut” to the system, such that our closed Kitaev ring is effectively transformed to an open Kitaev chain. Because we are in the topological phase, this open Kitaev chain has two zero-energy unpaired Majorana modes!</p>
<p>On the other hand, when $\mu&gt;2 t$ no zero-energy level crossing is present. The ground state fermion parity is the same at $\lambda=0$ and $\lambda=1$. In this case, when we cut the system at $\lambda=1/2$, we find no unpaired Majorana modes, consistent with our knowledge of the behavior of the open chain in the trivial phase.</p>
<p>We have therefore learned the essence of the bulk-boundary correspondence: A non-trivial value $Q=-1$ of the bulk invariant for the closed chain implies the existence of unpaired Majorana modes for the open chain. Also, we have been able to connect the value of the bulk invariant to a measurable quantity, in this case the ground state fermion parity of the closed chain.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"What will happen if we take a 100 site Kitaev chain in the topological phase "</span></span><br><span class="line">    <span class="string">"and change the potential mu to a very large negative value for the last 50 sites?"</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The topological gap at the last 50 sites closes and reopens as $\mu$ changes from $0$ to $-\infty$."</span>,</span><br><span class="line">    <span class="string">"The Majoranas get destroyed by the drastic change of chemical potential $\mu_j$."</span>,</span><br><span class="line">    <span class="string">"One of the Majoranas moves from being the end of the system to the middle."</span>,</span><br><span class="line">]</span><br><span class="line">MoocCheckboxesAssessment(question, answers, correct_answers=[<span class="number">0</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<h1 id="Three-approaches-to-analysing-topological-systems"><a href="#Three-approaches-to-analysing-topological-systems" class="headerlink" title="Three approaches to analysing topological systems"></a>Three approaches to analysing topological systems</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"wiHPQlEha6g"</span>, src_location=<span class="string">"1.2-summary"</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"Bulk-edge correspondence in the Kitaev chain"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w12_manybody/w12_assignments" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w12_manybody/w12_assignments/"
    >src/w12_manybody/w12_assignments</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w12_manybody/w12_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.810Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-0910-2763"><a href="#arXiv-0910-2763" class="headerlink" title="arXiv:0910.2763"></a>arXiv:0910.2763</h3><p><strong>Hint:</strong> Fractional quantum Hall effect in graphene</p>
<h3 id="arXiv-1204-5479"><a href="#arXiv-1204-5479" class="headerlink" title="arXiv:1204.5479"></a>arXiv:1204.5479</h3><p><strong>Hint:</strong> Fractional Majoranas in fractional quantum Hall edges</p>
<h3 id="arXiv-0803-0272"><a href="#arXiv-0803-0272" class="headerlink" title="arXiv:0803.0272"></a>arXiv:0803.0272</h3><p><strong>Hint:</strong> A scheme for quantum computation using the toric code</p>
<h3 id="arXiv-1502-01665"><a href="#arXiv-1502-01665" class="headerlink" title="arXiv:1502.01665"></a>arXiv:1502.01665</h3><p><strong>Hint:</strong> Making a fractional quantum Hall effect by coupling wires</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Reviews"</span>, <span class="string">"Many-body topology"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w12_manybody/fqhe" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w12_manybody/fqhe/"
    >src/w12_manybody/fqhe</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w12_manybody/fqhe/" class="article-date">
  <time datetime="2021-01-07T09:11:06.809Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This topic is introduced by Sankar Das Sarma from the university of Maryland.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"4gSJSo3olfg"</span>, src_location=<span class="string">"12.1-intro"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Interacting-systems"><a href="#Interacting-systems" class="headerlink" title="Interacting systems"></a>Interacting systems</h1><p>One obvious thing that we completely ignored throughout the course is the effects of interactions on topology. It is of course possible to generalize all the symmetry classes that we have studied to many-body Hamiltonians, but what happens to the classification of the topological phases?</p>
<p>The first statement we should make here is that our work so far wasn’t wasted: most of the usual topological insulators turn out to tolerate interactions as long as the interactions do not spontaneously break the symmetry, or close the bulk gap.<br>There are interesting cases where the classification collapses. For example, the 1D BDI chain with Majorana fermions on one of the two sublattice degrees of freedom allows a $\mathbb{Z}_8$ classification with interactions instead of $\mathbb{Z}$. The reason for this is that the 8-Majorana interaction term doesn’t break the symmetries anymore.</p>
<p>However this is relatively minor compared to the real can of worms that the interactions open: the amount of possibilities for the interacting phases is much larger. To begin with, we’ll discuss the oldest known example of a strongly interacting topological phase, the fractional quantum Hall effect. Note that it only covers a single dimension ($D=2$), and a single symmetry class (no symmetry at all). Yet, classifying all such states turns out to be a very hard task.</p>
<h1 id="Fractional-charge-and-statistics-in-the-fractional-quantized-Hall-effect"><a href="#Fractional-charge-and-statistics-in-the-fractional-quantized-Hall-effect" class="headerlink" title="Fractional charge and statistics in the fractional quantized Hall effect"></a>Fractional charge and statistics in the fractional quantized Hall effect</h1><p>If you followed what we learned about the integer quantum Hall effect, you’ll remember that we used the pumping argument to establish that the Hall conductance in an incompressible liquid is quantized in integers. You might now wonder if the experimental evidence for the fractional quantum Hall effect completely invalidates this argument in some way. The key step in the argument was to realize that the pumped charge that results from the insertion of one flux quantum $\Phi_0$ into a Corbino geometry is </p>
<p>$$<br>Q_{pump}=\sigma_{xy}\Phi_0\equiv \nu e,<br>$$</p>
<p>where $\nu=\sigma_{xy}/G_0$ is the Hall conductance in dimensionless units. For the non-interacting system that we studied in the quantum Hall effect, we assumed that only an integer number of electrons could be transferred between the edges - so $\nu$ had to be an integer. </p>
<p>The real reason that the charge transferred had to be an integer multiple of the electron charge was that the Hamiltonian for the electrons was identical between flux $\Phi=0$ and flux $\Phi=\Phi_0$. Since the system is incompressible, it is reasonable to assume that all excitations in the system are local. Usually we expect different excited states to differ by rearranging electrons. Within this framework, such excitations can differ by integer multiples of electronic charge.</p>
<p>The existence of fractional values of $\nu$ implies that the edge can have local excitations that differ by a fractional electron charge. In principle, the inner edge of the Corbino geometry can be shrunk to a point, and if we do this, we’re forced to conclude that the system can now host excitations that have fractional charge.</p>
<p>The fractional charged excitations are local particles just like the electrons themselves. So we can ask about the statistics under exchange of two such particles. On performing such an exchange, the total many-body wave function of the system returns to itself, but<br>the wave function can pick up a Berry phase. For fermions this phase is $\pi$ and for Bosons it is zero. Instead of computing the phase directly, let us consider doing a double exchange, which is topologically equivalent to taking a particle around another one and computing the phase for that. </p>
<p><img src="/2021/01/07/src/w12_manybody/fqhe/exchange.svg" alt></p>
<p>Let us first assume that one of the particles was created by a flux quantum. Since the flux quantum created this particle adiabatically by a pumping process, locality dictates that the particle going around the flux quantum + particle cannot know about the existence of the other particle. Thus the phase from going around a particle together with its flux quantum must vanish. On the other hand, the particle picks up a phase of $2\pi \nu$ from just going around the flux quantum. Thus double exchange of a pair of particles leads to a Berry phase of $-2\pi\nu$. This is another strange property of excitations in the FQH state! They must obey different statistics than both fermions and bosons, and are thus referred to as anyons. Therefore the exchange phase of anyons in the simple FQH states is given by </p>
<p>$$<br>\phi_{exch}=\pi\nu.<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"The Laughlin argument was used to prove that the Hall effect must be quantized in integers. What is the key assumption"</span></span><br><span class="line">    <span class="string">"that must be dropped in order to understand the fractional quantum Hall effect?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"Allow electrons to have fractional statistics."</span>,</span><br><span class="line">    <span class="string">"Allow quasiparticles with fractional charge."</span>,</span><br><span class="line">    <span class="string">"Require that the system forms an incompressible fluid."</span>,</span><br><span class="line">    <span class="string">"Allow electrons to have fractional charge."</span>,</span><br><span class="line">    <span class="string">"Allow quasiparticles to have fractional statistics."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"The key assumption in the Laughlin argument for the integer case was that the charge that was added by pumping could"</span></span><br><span class="line">    <span class="string">"only be an integer multiple of an electronic charge."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Topological-degeneracy"><a href="#Topological-degeneracy" class="headerlink" title="Topological degeneracy"></a>Topological degeneracy</h1><p>Knowing that the system supports particles with nontrivial braiding statistics, we can derive its next important property, the topological degeneracy of the ground state.</p>
<p>To do this, we turn around the argument for computing the statistics of particles and consider the statistics of fluxes. A particle going around a flux acquires a phase of $2\pi\nu$. As noted in the last unit, the combination of a particle and flux does not have any non-trivial exchange statistics. So replacing the particle by another flux will lead to a phase of $-2\pi \nu$. Therefore the exchange phase of fluxes gives a phase of $\pi\nu$, just like the exchange of particles.</p>
<p>Let us now put the FQH system on a torus. A natural operation on the torus is to create a flux anti-flux pair, move them around a cycle of the torus and annihilate them at the end. This operation inserts a flux into one of the two nontrivial cycles of the torus. Let’s label this operation $T_{1,2}$ for each of the cycles of the torus:</p>
<p><img src="/2021/01/07/src/w12_manybody/fqhe/torus.svg" alt></p>
<p>The last physical step to deriving the degeneracy is to ask what is the commutator $T_1^{-1}T_2^{-1}T_1 T_2$. This operator describes first moving a vortex around the red contour, then moving the vortex around the blue contour, moving the vortex back around the red contour, and finally undoing the motion of the vortex along the blue contour.<br>No matter which path we choose for this operation, we will need to take one vortex all the way around the other one. According to the braiding rule we get:</p>
<p>$$<br>T_1^{-1}T_2^{-1}T_1 T_2 =e^{i2\pi \nu}.<br>$$</p>
<p>Now all we need to do is an exercise in elementary quantum mechanics. First of all, both $T_{1,2}$ commute with the Hamiltonian. Let’s take $|\Psi\rangle$ as a simultaneous ground state of the Hamiltonian and eigenstate of $T_1$. If in addition $e^{i\alpha}|\Psi\rangle=T_2|\Psi\rangle$, then $T_1$ and $T_2$ would commute. Since we know this isn’t the case, $T_2|\Psi\rangle$ must be a ground state of the Hamiltonian which is not the same as $|\Psi\rangle$.</p>
<blockquote>
<p>We conclude that fractional quantum Hall phases have ground state degeneracy on the torus.</p>
</blockquote>
<p>We have seen an example of ground state degeneracy in Majorana wires, where the degeneracy of the zero modes could not be lifted by any local perturbation. The difference between the Majorana case and fractional quantum Hall is that in the latter we don’t rely on the presence of defects, and the degeneracy is a property of the surface on which we put the fractional quantum Hall state.</p>
<h1 id="Creating-an-FQH-state"><a href="#Creating-an-FQH-state" class="headerlink" title="Creating an FQH state"></a>Creating an FQH state</h1><p>How can we describe a fractional quantum Hall state? Laughlin used a representation of the many-electron wave function in complex coordinates to guess a wave function of an incompressible state. We will instead follow the more intuitive “Composite Fermion” approach due to Jain to understand this state. </p>
<p>The starting point for the FQH state is of course the same as for the integer quantum Hall states, i.e. electrons in a magnetic field that occupy Landau levels. As we noticed in week 3, every state in a single Landau level is at exactly the same energy. The simplest family of FQH states are ones where the lowest Landau level states are only partially filled. Since there is no kinetic energy, the state is determined entirely by optimizing the Coulomb repulsion such that the electrons are as far away from each other as possible.</p>
<p>The composite fermion theory postulates that electrons manage to space themselves out by associating themselves with “vortex”-like excitations. As you hopefully recall, a vortex in a superconductor is a defect where the superconducting phase $\varphi$ winds by $2\pi$ when going around the vortex. An electron going around the vortex picks up a $\pi$-phase shift. On the other hand, an electron can go around a double vortex and pick up effectively no (i.e. $2\pi$) phase shift. However, the electron feels a phase gradient or a vector potential ${\bf A}={\bf\nabla}\varphi$ as it goes around the vortex. Such a vector potential is like a magnetic field and repels the electron. </p>
<p>Of course we have no superconductivity at hand, but we can mimic the vortex properties using a mathematical trick involving complex numbers. First let us introduce complex coordinates for the electrons $z=x+iy$. Then we notice that we can insert a double vortex at $z_0$ in a gas of electrons with wave function $\Psi(z_1,\dots)$ by the transformation</p>
<p>$$<br>\Psi(z_1,\dots)\rightarrow \prod(z_i-z_0)^2\Psi(z_1,\dots).<br>$$</p>
<blockquote>
<p>The basic trick of composite fermions in trying to keep electrons far apart is to say that each electron binds  an even number $(2m)$ vortices to form a composite fermion.</p>
</blockquote>
<p>This amounts to the transformation of the many-body wave function $\Psi_{CF}(z_1,z_2,\dots)=\prod_{i &lt; j}(z_i-z_j)^2\Psi(z_1,z_2,\dots)$, where $z_j$ are the electron wave-functions.</p>
<p>Pictorially the composite fermion transformation is represented as:</p>
<p><img src="/2021/01/07/src/w12_manybody/fqhe/composite.svg" width="800"></p>
<p>The next step in the composite fermion approach to the FQH state is to say that all the correlation effects of the Coulomb interaction are taken care of by the flux attachment. Beyond this, the composite fermions are weakly interacting particles. If we believe in this picture, then the only non-interacting incompressible states that we can get are integer quantum Hall states. This means that the FQH states are integer quantum Hall states of the composite fermions.</p>
<p>How does this explain a fractionally filled state? Well, the original electron is $2m$ flux quanta together with a composite fermion. If we smear out the flux created by the electron density $\nu$, we get a magnetic field of $2m\nu$ flux quanta per unit area. This is in addition to the one flux quantum per unit area of the external magnetic field. Therefore the composite fermions, which are at a density of $\nu$ per unit area, see a magnetic field of $2m\nu+1$ per unit area. We can make the composite fermions form an incompressible state with $p$-Landau levels filled if<br>$\nu=p(2m\nu+1),$ so that we describe a state of filling </p>
<p>$$<br>\nu=\frac{p}{2 m p-1}.<br>$$</p>
<p>Thus the composite fermion theory provides an explanation for how electrons can form incompressible states at a fractional sequence of filling fractions that is known as the “Jain sequence”. These states were all seen in experiments.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"Composite fermions allow one to explain incompressible states at fractional filling of the Landau levels by "</span></span><br><span class="line">    <span class="string">"postulating that:"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The quantum Hall system forms an incompressible liquid."</span>,</span><br><span class="line">    <span class="string">"The fractionally charged quasiparticles bind to fluxes to reduce the filling."</span>,</span><br><span class="line">    <span class="string">"The electrons become fractionally charged."</span>,</span><br><span class="line">    <span class="string">"The electrons bind to fluxes and reduce the effective magnetic field."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"Composite fermions are electrons bound to fluxes. Electrons are the fundamental particles and they cannot change "</span></span><br><span class="line">    <span class="string">"their charge. The fractional charged quasiparticles are invoked by composite fermions not explained by the theory. "</span></span><br><span class="line">    <span class="string">" The incompressible liquid is true for either integer or fractional quantum Hall."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Classification-and-fractional-topological-insulators"><a href="#Classification-and-fractional-topological-insulators" class="headerlink" title="Classification and fractional topological insulators"></a>Classification and fractional topological insulators</h1><p>Before we approach the classification of topological insulators in the presence of symmetries, let us discuss the fractional quantum Hall effect. In fact, there is a whole bunch of fractional quantum Hall states, so there is clearly room for classification. However, at first glance it looks more challenging because we cannot really solve general two dimensional interacting Hamiltonians. The tool that is used to understand what phases might exist is braiding. Based on all the examples of two-dimensional topological states with no symmetry that we have so far, it is believed that distinct topological states are characterized by distinct particle-like anyonic excitations with distinct topological properties. It is certainly obvious that if two states have topologically distinct excitations in the bulk they cannot be adiabatically deformed into one another, since the braiding rules cannot change continuously.</p>
<p>So the basic rule of the game is to ask what are all possible braiding rules for excitations in two dimensions. One would think that it would simply be arbitrary. Turns out that the situation is not quite as bad - locality and unitarity put rather strong constraints on the possible braidings of particles. The answer is obtained through a branch of mathematics called modular tensor category theory, and the theory tells us that valid sets of fractional excitations must obey the so-called pentagon and hexagon equations. All this being said, not all solutions of these equations are known - so basically the set of possible phases is not quite known. And this is all very abstract - and not even all the abstractly known phases that have acceptable braiding rules are known to be realized in nature. In fact, so far most of the known phases seem to be composite fermion ones that are well understood.</p>
<h2 id="Symmetries"><a href="#Symmetries" class="headerlink" title="Symmetries"></a>Symmetries</h2><p>To approach the classification of interacting topological insulators with symmetries, we can start by playing the same game as Kane and Mele, and combine two fractional quantum Hall states (instead of integer ones) to make a fractional topological insulator. If we choose a pair of FQH states which are related by time-reversal and stack them together for spin-up and spin-down electrons, that technically leads to a time-reversal invariant state. The key question that needs to be asked is whether one can gap out the edge states by adding time-reversal invariant perturbations. If one can do that, then unlike the Kane-Mele quantum spin Hall state, the state is not a phase that is protected by just time-reversal symmetry. This question is not too mathematically involved, though still beyond this course and can be answered by the bosonization technique as was done by <a href="http://arxiv.org/abs/0906.2769" target="_blank" rel="noopener">Stern and Levin</a>.</p>
<p>We can however explain the result. If one stacks the two FQH states one obtains a spin-Hall conductance $\sigma_{sh}$, which is equal to the Hall conductance of each layer. Let the smallest charge of an excitation of our phase be $e^<em>$, some fraction of electron charge. It turns out that the edge states are protected from gapping by time-reversal invariant perturbations if and only if $\sigma_{sh}/e^</em>$ is an odd integer. This gives some idea as to what kind of interacting analogues of quantum spin Hall states one may get. But again, as with the non-symmetric case, the general classification is still up in the air. More importantly, we don’t really have realistic candidates for such states yet.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"zrL-qxjKfGw"</span>, src_location=<span class="string">"12.1-summary"</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"FQHE"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w12_manybody/topoorder" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w12_manybody/topoorder/"
    >src/w12_manybody/topoorder</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w12_manybody/topoorder/" class="article-date">
  <time datetime="2021-01-07T09:11:06.809Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The topological order is introduced by Barbara Terhal from RWTH Aachen.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"rLdHCKxMumY"</span>, src_location=<span class="string">"12.2-intro"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Simplest-model-for-topological-degeneracy-Toric-code"><a href="#Simplest-model-for-topological-degeneracy-Toric-code" class="headerlink" title="Simplest model for topological degeneracy: Toric code"></a>Simplest model for topological degeneracy: Toric code</h1><p>We have worked hard to create topological models so far. The FQH system, which is the most topological in some sense, was also more obscure in terms of microscopics. Here, we follow Alexei Kitaev and write down a simple Hamiltonian that is obviously topological, but also relatively easy to analyse.</p>
<p>Let’s consider a system of localized spin$-1/2$ electrons that live on the bonds of a square lattice. The particular Hamiltonian that Kitaev wrote down is:</p>
<p>$$H=-A_v\sum_{+}\prod_+ \sigma_z-B_p\sum_{\Box}\prod_{\Box} \sigma_x.$$</p>
<p>As you can see in the figure below, $\Box$ refers to the spins on the bonds that surround a plaquette and $+$ refers to the bonds that surround a vertex. The beauty of this Hamiltonian is that all the terms commute between themselves. The only terms that you might suspect not to commute are a plaquette term and a vertex term that share some bonds. But you can convince yourself easily (by  looking at the figure) that such terms always share an even number of spins. This means that the commutation picks up an even number of minus signs and so these terms commute as well.</p>
<p><img src="/2021/01/07/src/w12_manybody/topoorder/toric_layout.svg" alt></p>
<p>Since $H$ is a sum of commuting terms, we can calculate the ground state as the simultaneous ground state for all the terms.<br>Let us first look at the vertex terms proportional to $A$. If we draw a red line through bond connecting neighboring spins with $\sigma_z=-1$ on our lattice (as shown below), then we find that each vertex in the ground state configuration has an even number of red lines coming in. Thus, we can think of the red  lines forming loops that can never be open ended. This allows us to view the ground state of the toric code as a loop gas. </p>
<p><img src="/2021/01/07/src/w12_manybody/topoorder/loops.svg" alt></p>
<p>What if we focus on the large plaquette term limit i.e. $A_v\ll B_p$ instead? The toric code is fairly symmetric between the vertex and plaquette terms. Clearly, focusing on the $\sigma_z$ diagonal basis was a choice. If we draw loops (blue lines) through the dual lattice (whose vertices are in the middle of the original lattice) whenever $\sigma_x=-1$ on some link. This results in a loop gas picture (blue lines) on the dual lattice, which focusses on the $\sigma_x$ terms. </p>
<p>Returning to the $\sigma_z$ representation, it looks like every loop configuration is a ground state wave-function and so is a massively degenerate loop space $L$. But this conclusion doesn’t include the plaquette terms (i.e. the $B_p$ coefficient) yet. Since the plaquette terms commute with the vertex terms in the Hamiltonian, the plaquette terms take us between different loop configurations. Considering the plaquette Hamiltonian in the low energy space of closed loops we can show that the ground state wave-function must be the sum of all possible (i.e. ones that can be reached by applying the plaquette terms) loop configurations with equal weight. </p>
<p>The ground state looks pretty non-degenerate at this point but if we consider the system with periodic boundary conditions - namely on a torus, we immediately see that there are 4 topologically distinct loop configurations that are degenerate. Basically, the plaquette terms can only deform the loops smoothly and therefore cannot change the parity of the winding numbers of the loops. </p>
<p>It is however possible to continuously deform a closed loop into a pair of loops along some cycle of the torus. So only the parity of the loop winding across a cut cannot be changed. Thus, the toric code on a torus has 4 degenerate ground state wave-functions (all with the same energy), which are topologically distinct. The difference between these wave functions is the parity of the number of loops crossing a vertical or a horizontal cycle on the torus.</p>
<p>Does this have anything to do with the way we have defined topology in this course, using the bulk-edge correspondence? Unfortunately and confusingly, not. These interacting systems are topological in the sense of having a topological degeneracy between topologically distinct states that cannot be continuously deformed into one another. In a sense, this is a more amazing feature than the bulk edge correspondence itself - the degeneracy between these states cannot be lifted by any reasonable (local) perturbation. This is sort of similar to Majorana fermions, but even more robust. In fact, the toric code does not even have edge states, so there is really no bulk-edge correspondence to speak of.</p>
<p>The topological robustness makes the topologically degenerate states particularly attractive to store quantum information. The main challenge of quantum information is the quantum decoherence problem, where local fluctuations in the Hamiltonian destroy the phase coherence of the quantum system used to store information. The solution proposed by topological quantum computation is to use the topologically degenerate space of a toric code to store the information. In fact, this is in essence what is being attempted by experimentalists who work on superconducting qubits, under the framework of the surface code. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"How would the topological degeneracy of the ground state that comes from the loop configurations "</span></span><br><span class="line">    <span class="string">"change if we put it on a torus (donut) with two holes?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"Since there is still an infinite number of loop configurations, the degeneracy would be infinite."</span>,</span><br><span class="line">    <span class="string">"Since there is one additional hole there are two more distinct cycles. "</span></span><br><span class="line">    <span class="string">"So  the number of ground states increases by a factor of 4."</span>,</span><br><span class="line">    <span class="string">"It still remains 4 since the loops is topologically forbidden from going around the extra loops."</span>,</span><br><span class="line">    <span class="string">"Since there is one additional hole the loops can go around this hole an even or an odd number of time, "</span></span><br><span class="line">    <span class="string">"so the degeneracy increases from 4 to 8."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"The additional hole introduces the possibility of 2 values of parity on each extra cycle. This adds a "</span></span><br><span class="line">    <span class="string">"factor of $2 \\times 2=4$."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Particle-like-excitations"><a href="#Particle-like-excitations" class="headerlink" title="Particle-like excitations"></a>Particle-like excitations</h1><p>As we saw in the FQH systems, excitations with fractional charge and statistics was really the hall-mark of topologically degenerate states. Since the basic degree of freedom in the toric code are spin, we expect all excitations to be neutral. But there is a possibility that we get fractionalized statistics. The neat thing about the toric code Hamiltonian is that it allows us to not only compute the ground state for the toric code but also all the excited states. Again, this is not too surprising since all the terms in the Hamiltonian commute, so all eigenstates are simultaneous eigenstates of the vertex and plaquette terms. If we focus on the vertex terms first (let’s say by assuming that $B_p\ll A_v$), we can get excitations of the vertex Hamiltonian by breaking loops. We can think of the end points of the loops as excitations, since the plaquette terms proportional to $B_p$ make the plaquette terms fluctuate. These particles (that you see in the figure below) because of analogy with $Z_2$ gauge theory, are called the electric defects, which we label ‘e’. As shown below, analogous defects in $\sigma_x=-1$-loops on the dual lattice are referred to as magnetic defects, which we will label ‘m’. </p>
<p><img src="/2021/01/07/src/w12_manybody/topoorder/toric_exchanges.svg" alt></p>
<p>While the intuitive picture for the excitations as ends of broken loops is nice, to describe these exctiation in the more general case, where $A_v$ and $B_p$ are comparable, it is convenient to define the so-called Wilson path operators </p>
<p>$$W_e=\prod_{\mathcal{l}<em>e} \sigma_z,\quad, W_m=\prod</em>{\mathcal{l}_m}  \sigma_x.$$</p>
<p>By viewing the system in the $\sigma_z$-basis in the limit $B_p\rightarrow 0$, we see that the operator $W_e$ counts the parity of $\sigma_z=-1$ spins that lie on the loop $\mathcal{l}_e$. Therefore, in this limit $W_e$ measures the parity of ‘e’ excitations inside the loop $\mathcal{l}_e$. The  operator $W_e$ is a product of the vertex terms inside the loop $\mathcal{l}_e$ and hence commutes with $H$ for any strength  of the plaquette terms proportional to $B_p$. </p>
<blockquote>
<p>Therefore $W_e$ and $W_m$ are conserved ‘flux’ operators that measure the parity of the number of electric and magnetic defects inside the loops $\mathcal{l}_{e,m}$ respectively.</p>
</blockquote>
<p>Thus, the values $W_{e,m}=-1$ can also be used to define what it means to have a localized ‘e’ or ‘m’ excitation respectively. These defects describe the localized excitations of the toric code. In fact in this model, this excitation on the ground states are localized to exactly one lattice site and may be viewed as point-like particles in a vacuum.  </p>
<p>Just like in the quantum Hall effect, we can use the Wilson loops $W_{e,m}$ to characterize the degenerate ground states of the toric code on a torus. The value of the Wilson loop $W_e$ counts the parity of intersections of $\sigma_z=-1$ loops (red lines) crossing the Wilson loop. Therefore, the value of the Wilson loop $W_e$ along one of the cycles of the torus counts the parity of the $\sigma_z=-1$ loops crossing it. Since we can draw a pair of commuting Wilson loop $W_e$, one through each cycle of the torus, the degeneracy of the torus from $W_e=\pm 1$ is 4. This is exactly what we got from the loop picture. </p>
<h1 id="Semionic-statistics-of-excitations"><a href="#Semionic-statistics-of-excitations" class="headerlink" title="Semionic statistics of excitations"></a>Semionic statistics of excitations</h1><p>The loop gas picture makes the ‘e’ and ‘m’ excitations, which are ends of loops look quite topological. But are they topological in a sense similar to the charges in the FQH system? To see this, let us try to interchange an ‘e’ particle and an ‘m’ particle. For starters let us see how to move each of these particles. To do this we use the ‘path’ operators </p>
<p>$$\Gamma^{(e)}(a,b)=\prod_{a\rightarrow b}\sigma_x,\quad,\Gamma^{(m)}(a,b)=\prod_{a\rightarrow b}\sigma_z,$$</p>
<p>to move an excitation from point $a$ to $b$. This is because this operator will flip $W_{e,m}(a):-1\rightarrow +1$ at end $a$ and hence destroy the excitation and also flip $W_{e,m}(b):+1\rightarrow -1$ to create an excitation. </p>
<p>Now, if we try to take an ‘e’ particle around an ‘m’ particle, the path forms a loop $W_e$ around ‘m’. This adds a factor of  $W_e=-1$ to the wave-function, for the double exchange process between ‘e’ and ‘m’, which is topologically equivalent to taking one particle around the other. This strange exchange statistics, which is not quite the same as the exchange of identical particles that we are used to is referred to as “semionic” statistics.</p>
<p>Next, we try to exchange a pair of ‘e’ particles. We can do this by applying a pair of path operators $\Gamma^{(e)}$ to the particles<br>that form a loop. This pair of operators form loop operator $W_e$, which must be $W_e=+1$ unless there is an ‘m’ particle inside. Therefore the ‘e’ particles are bosons and so are the ‘m’ particles by a similar argument.</p>
<p>Finally, if we exchange an ‘e’-‘m’ pair with another ‘e’-‘m’ pair, we see, that the result is equivalent to a double exchange between an ‘e’ particle and an ‘m’ particle in addition some ‘e’ and ‘m’ exchanges. The double exchange produces a $-$ sign as we saw. However, unlike the case of exchanging ‘e’ and ‘m’ particles, the ‘e’-‘m’ pairs (also called dyons) are identical particles and therefore we can treat them analogous to exchanging quantum particles in nature. In this context, the $-$ sign should suggest to you that the dyon ‘e’-‘m’ are really fermions. This is rather strange because the microscopic constituents of our theory were spins whose exchange phases are always $1$ (i.e. bosons) and we end up with fermions, which are in some sense half of bosons.<br>Thus, the toric code, in a sense, gives us a microscopic model of “fractional statistics”.</p>
<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"Topological order"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w11_extensions2/floquet" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w11_extensions2/floquet/"
    >src/w11_extensions2/floquet</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w11_extensions2/floquet/" class="article-date">
  <time datetime="2021-01-07T09:11:06.804Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg <span class="keyword">as</span> la</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">pi_ticks = [</span><br><span class="line">    (-np.pi, <span class="string">r"$-\pi$"</span>),</span><br><span class="line">    (-np.pi / <span class="number">2</span>, <span class="string">r"$-\pi/2$"</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="string">r"$0$"</span>),</span><br><span class="line">    (np.pi / <span class="number">2</span>, <span class="string">r"$\pi/2$"</span>),</span><br><span class="line">    (np.pi, <span class="string">r"$\pi$"</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkerboard</span><span class="params">(W=None)</span>:</span></span><br><span class="line">    lat = kwant.lattice.general([[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]], [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)])</span><br><span class="line">    a, b = lat.sublattices</span><br><span class="line">    <span class="keyword">if</span> W:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">            (x, y) = pos</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; W <span class="keyword">and</span> <span class="number">0</span> &lt;= x &lt; W</span><br><span class="line"></span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">        syst[a.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">0</span></span><br><span class="line">        syst[b.shape(lead_shape, (<span class="number">1</span>, <span class="number">0</span>))] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">0</span></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>), b, a)] = <span class="keyword">lambda</span> s1, s2, p: -p.t1</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">-1</span>, <span class="number">1</span>), b, a)] = <span class="keyword">lambda</span> s1, s2, p: -p.t2</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), a, b)] = <span class="keyword">lambda</span> s1, s2, p: -p.t3</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), a, b)] = <span class="keyword">lambda</span> s1, s2, p: -p.t4</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evolution_operator</span><span class="params">(hamiltonians, T)</span>:</span></span><br><span class="line">    n = len(hamiltonians)</span><br><span class="line">    exps = [la.expm(<span class="number">-1j</span> * h * T / n) <span class="keyword">for</span> h <span class="keyword">in</span> hamiltonians]</span><br><span class="line">    <span class="keyword">return</span> reduce(np.dot, exps)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_h_k</span><span class="params">(lead, p)</span>:</span></span><br><span class="line">    bands = kwant.physics.Bands(lead, params=dict(p=p))</span><br><span class="line">    h, t = bands.ham, bands.hop</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> k: h + t * np.exp(<span class="number">-1j</span> * k) + t.T.conj() * np.exp(<span class="number">1j</span> * k)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Today’s topic, Floquet topological insulators, is introduced by Mark Rudner from the Niels Bohr Institute at Copenhagen.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"1peVp_IZ7Ts"</span>, src_location=<span class="string">"11.1-intro"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Periodically-driven-systems"><a href="#Periodically-driven-systems" class="headerlink" title="Periodically driven systems"></a>Periodically driven systems</h1><p>We will now learn about a new generalization of topology, namely how it applies to the quantum evolution of systems with a time-dependent Hamiltonian. As you may recall, we’ve already encountered time dependence, back when we considered quantum pumps. However, back then we assumed that the time evolution was very slow, such that the system stayed in the ground state at all times, i.e. it was adiabatic. Can we relax the adiabaticity constraint? Can we find an analog of topology in systems that are driven so fast that energy isn’t conserved?</p>
<p>For the same reasons as before, we’ll consider periodic driving</p>
<p>$$<br>H(t + T) = H(t).<br>$$</p>
<p>Once again, this is necessary because otherwise, any system can be continuously deformed into any other, and there is no way to define a gap.</p>
<p>Before we get to topology, let’s refresh our knowledge of time-dependent systems.</p>
<p>The Schrödinger equation is:</p>
<p>$$<br>i\frac{d \psi}{dt} = H(t) \psi.<br>$$</p>
<p>It is a linear equation, so we can write its solution as</p>
<p>$$<br>\psi(t_2) = U(t_2, t_1) \psi(t_1),<br>$$</p>
<p>where $U$ is a unitary <em>time evolution operator</em>. It solves the same Schrödinger equation as the wave function, and is equal to the identity matrix at the initial time. It is commonly written as</p>
<p>$$<br>U(t_2, t_1) = \mathcal{T} \exp,\left[-i\int_{t_1}^{t_2} H(t) dt\right],<br>$$</p>
<p>where $\mathcal{T}$ represents time-ordering (not time-reversal symmetry). The time-ordering is just a short-hand notation for the need to solve the full differential equation, and it is necessary if the Hamiltonians evaluated at different times in the integral do not commute.</p>
<p>The time evolution operator satisfies a very simple multiplication rule:</p>
<p>$$<br>U(t_3, t_1) = U(t_3, t_2) U(t_2, t_1),<br>$$</p>
<p>which just says that time evolution from $t_1$ to $t_3$ is a product of time evolutions from $t_1$ to $t_2$ and then from $t_2$ to $t_3$. Of course an immediate consequence of this is the equality $U(t_2, t_1)^\dagger = U(t_2, t_1)^{-1} = U(t_1, t_2)$.</p>
<h2 id="Floquet-theory"><a href="#Floquet-theory" class="headerlink" title="Floquet theory"></a>Floquet theory</h2><p>The central object for the study of driven systems is the evolution operator over one period of the driving,</p>
<p>$$<br>U(t + T, t) \equiv U,<br>$$</p>
<p>which is called the Floquet time evolution operator. It is important because it allows us to identify the wave functions that are the same if an integer number of drive periods passes. These are the stationary states of a driven system, and they are given by the eigenvalues of the Floquet operator:</p>
<p>$$<br>U \psi = e^{i \alpha} \psi.<br>$$</p>
<p>The stationary states are very similar to the eigenstates of a stationary Hamiltonian, except that they are only stationary if we look at fixed times $t + nT$. That’s why the Floquet time evolution operator is also called a stroboscopic time evolution operator.</p>
<p>We can very easily construct a Hermitian matrix from $U$, the <strong>Floquet Hamiltonian</strong>:</p>
<p>$$<br>H_\textrm{eff} = i T^{-1} ,\ln U.<br>$$</p>
<p>Its eigenvalues $\varepsilon = \alpha / T$ are called quasi-energies, and they always belong to the interval $-\pi &lt; \alpha \leq \pi$.</p>
<p>If the system is translationally invariant, we can study the effective band structure of $H_\textrm{eff}(\mathbf{k})$, find an energy in which the bulk Hamiltonian has no states, and study the topological properties of such a Hamiltonian: most of the things we already know still apply.</p>
<p>Of course, selecting a single quasi-energy as the Fermi level is arbitrary, since the equilibrium state of driven systems doesn’t correspond to a Fermi distribution of filling factors, but at least it seems close enough for us to try to apply topological ideas.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"But wait, we arbitrarily chose the starting point $t$ in time for calculating the "</span></span><br><span class="line">    <span class="string">"Floquet operator. What if we chose a different one?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The starting time is just an extra parameter of our system, and topology depends on it."</span>,</span><br><span class="line">    <span class="string">"It doesn't matter, the wave function evolution within one period "</span></span><br><span class="line">    <span class="string">"can be neglected, since we are interested in many periods."</span>,</span><br><span class="line">    <span class="string">"There's only one correct starting point in time."</span>,</span><br><span class="line">    <span class="string">"It doesn't matter since the quasienergies are independent of the starting point."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"Choosing a different starting point applies a unitary transformation "</span></span><br><span class="line">    <span class="string">"to the Floquet evolution operator, and so it keeps the quasienergies the same."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Driven-Majorana-wire"><a href="#Driven-Majorana-wire" class="headerlink" title="Driven Majorana wire"></a>Driven Majorana wire</h1><p>Let us start by considering something we know very well, namely the superconducting Majorana nanowire model from week 2. This model has three important parameters which determine whether the wire is in the topological Majorana phase or not: the chemical potential $\mu$, the superconducting gap $\Delta$, and the magnetic field $B$. The topological phase with unpaired Majorana modes at zero energy is realized for $B &gt; \sqrt{\mu^2 + \Delta^2}$.</p>
<p>Now, imagine that we can periodically drive some of these parameters. For instance, consider the simple example when</p>
<p>$$<br>\mu = \left{<br>\begin{matrix}<br>\mu_1 \quad \text{for } 0 &lt; t &lt; T/2 \<br>\mu_2 \quad \text{for } T/2 &lt; t &lt; T<br>\end{matrix}\right.<br>$$</p>
<p>Then, the integral to find the time evolution operator is easy to evaluate, and we simply have</p>
<p>$$<br>U = \exp(i T H_2 / 2) \exp(i T H_1 / 2)<br>$$</p>
<p>with $H_1$ and $H_2$ the nanowire Hamiltonians with chemical potential $\mu_1$ and $\mu_2$. A peculiar property of driven systems is that as the period becomes large, the band structure ‘folds’: if the driving is very weak, and the original Hamiltonian has energy $E$, the Floquet Hamiltonian has a much smaller quasienergy $(E\bmod 2\pi /T)$. This means that even when $H_1$ and $H_2$ correspond to trivial systems, we can still obtain nontrivial topology if we make the period large enough, as you can see for yourself:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">%%opts Path &#123;+axiswise&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_chain</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu) * pauli.szs0 + p.B * pauli.s0sz + p.delta * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 + <span class="number">0.5</span> * <span class="number">1j</span> * p.alpha * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> L:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">-1</span>,)))</span><br><span class="line">        L = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    syst[(lat(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(L))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_finite_spectrum</span><span class="params">(periods, hamiltonians)</span>:</span></span><br><span class="line">    energies = []</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> periods:</span><br><span class="line">        U = evolution_operator(hamiltonians, T)</span><br><span class="line">        phases = np.angle(la.eigvals(U))</span><br><span class="line">        phases = np.sort(np.abs(phases))</span><br><span class="line">        ev = np.sort([(<span class="number">-1</span>) ** n * val <span class="keyword">for</span> n, val <span class="keyword">in</span> enumerate(phases)])</span><br><span class="line">        energies.append(ev)</span><br><span class="line">    <span class="keyword">return</span> np.array(energies).real</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_bands</span><span class="params">(momenta, hamiltonians_k, T)</span>:</span></span><br><span class="line">    energies = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> momenta:</span><br><span class="line">        hamiltonians = [h_k(k) <span class="keyword">for</span> h_k <span class="keyword">in</span> hamiltonians_k]</span><br><span class="line">        U = evolution_operator(hamiltonians, T)</span><br><span class="line">        phases = np.angle(la.eigvals(U))</span><br><span class="line">        phases = np.sort(np.abs(phases))</span><br><span class="line">        ev = np.sort([(<span class="number">-1</span>) ** n * val <span class="keyword">for</span> n, val <span class="keyword">in</span> enumerate(phases)])</span><br><span class="line">        energies.append(ev)</span><br><span class="line">    <span class="keyword">return</span> np.array(energies).real</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">J = <span class="number">2.0</span></span><br><span class="line">p1 = SimpleNamespace(t=J / <span class="number">2</span>, mu=<span class="number">-1</span> * J, B=J, delta=<span class="number">2</span> * J, alpha=J)</span><br><span class="line">p2 = SimpleNamespace(t=J / <span class="number">2</span>, mu=<span class="number">-3</span> * J, B=J, delta=<span class="number">2</span> * J, alpha=J)</span><br><span class="line"></span><br><span class="line">syst = nanowire_chain(L=<span class="number">20</span>).finalized()</span><br><span class="line">H1 = syst.hamiltonian_submatrix(params=dict(p=p1))</span><br><span class="line">H2 = syst.hamiltonian_submatrix(params=dict(p=p2))</span><br><span class="line"></span><br><span class="line">lead = kwant.wraparound.wraparound(nanowire_chain(L=<span class="literal">None</span>)).finalized()</span><br><span class="line">h1_k = <span class="keyword">lambda</span> kx: lead.hamiltonian_submatrix(params=dict(p=p1, k_x=kx))</span><br><span class="line">h2_k = <span class="keyword">lambda</span> kx: lead.hamiltonian_submatrix(params=dict(p=p2, k_x=kx))</span><br><span class="line"></span><br><span class="line">periods = np.linspace(<span class="number">0.2</span> / J, <span class="number">1.6</span> / J, <span class="number">100</span>)</span><br><span class="line">momenta = np.linspace(-np.pi, np.pi)</span><br><span class="line"></span><br><span class="line">energies = calculate_finite_spectrum(periods, [H1, H2])</span><br><span class="line">spectrum = np.array([calculate_bands(momenta, [h1_k, h2_k], T) <span class="keyword">for</span> T <span class="keyword">in</span> periods])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot</span><span class="params">(n)</span>:</span></span><br><span class="line">    T = J * periods[n]</span><br><span class="line"></span><br><span class="line">    plot_1 = holoviews.Path(</span><br><span class="line">        (J * periods, energies),</span><br><span class="line">        kdims=[<span class="string">r"Driving period $(JT)$"</span>, <span class="string">r"Quasi-energy $(ET)$"</span>],</span><br><span class="line">        label=<span class="string">"Finite system"</span>,</span><br><span class="line">    ).opts(plot=&#123;<span class="string">"xticks"</span>: <span class="number">5</span>, <span class="string">"yticks"</span>: pi_ticks&#125;)</span><br><span class="line"></span><br><span class="line">    VLine = holoviews.VLine(T).opts(style=&#123;<span class="string">"color"</span>: <span class="string">"b"</span>, <span class="string">"linestyle"</span>: <span class="string">"--"</span>&#125;)</span><br><span class="line"></span><br><span class="line">    plot_2 = holoviews.Path(</span><br><span class="line">        (momenta, spectrum[n]), kdims=[<span class="string">"$k$"</span>, <span class="string">"$E_kT$"</span>], label=<span class="string">"Floquet bands"</span></span><br><span class="line">    ).opts(plot=&#123;<span class="string">"xticks"</span>: pi_ticks, <span class="string">"yticks"</span>: pi_ticks, <span class="string">"aspect"</span>: <span class="string">"equal"</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> plot_1 * VLine + plot_2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(&#123;n: plot(n) <span class="keyword">for</span> n <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)&#125;, kdims=[<span class="string">"n"</span>]).collate()</span><br></pre></td></tr></table></figure>

<p>On the left you see the Floquet spectrum of a finite system as a function of the driving period measured in units of the hopping strength, and on the right you see the Floquet dispersion in momentum space.</p>
<p>We now witness a cool phenomenon: just like in the undriven case, the particle-hole symmetry maps $E \rightarrow -E$, but now this means that not only $E = 0$ is special, but also $E = \pi$!</p>
<p>In other words, this means that there are two relevant gaps in the effective Floquet BdG Hamiltonian $H_\textrm{eff}$. Now, by using the same argument as we used for the regular Majoranas, we learn that if we have an isolated Floquet state with a quasienergy $\epsilon=0$ or $\epsilon=\pi$, it cannot be removed unless the gap surrounding it closes.</p>
<p>In other words:</p>
<blockquote>
<p>A Floquet superconductor has two types of Majorana bound states: the usual ones with quasienergy $\epsilon=0$, and the $\pi$-Majoranas that are as far from zero energy as possible.</p>
</blockquote>
<p>So the calculation above reveals two interesting features of driven systems: the first is that the periodic driving can turn a trivial system into a non-trivial system with topologically protected Floquet states. The second is that topology is richer than in the non-driven system: for instance, here the richness comes from the fact that the topologically protected states may occur at two different points in the spectrum.</p>
<p>Now try to answer the following question: what’s the topological invariant of this system? How do we tell whether normal Majoranas are present, and whether $\pi$-Majoranas are present? (We’ll return to this question in the end of the lecture.)</p>
<h1 id="A-Floquet-Chern-insulator"><a href="#A-Floquet-Chern-insulator" class="headerlink" title="A Floquet Chern insulator"></a>A Floquet Chern insulator</h1><p>As a second example of a driven system that shows something that the undriven system doesn’t, let’s consider the following toy model.</p>
<p>We take a square lattice with time-dependent nearest neighbor hopping $t$. Next, let’s engineer a time-evolution of the hopping between sites such that during a period $T$ hoppings are turned on in an alternate fashion, as in the following figure:</p>
<p><img src="/2021/01/07/src/w11_extensions2/floquet/time_steps.svg" alt></p>
<p>Each step lasts one quarter of a period.</p>
<p>Now let’s tune the period such that the probability for an electron to hop along a hopping is one at the end of each quarter period [$t = (\pi / 2) / (T / 4)$]. Over the complete period the trajectories of electrons will look like this:</p>
<p><img src="/2021/01/07/src/w11_extensions2/floquet/floquet_bulk.svg" alt></p>
<p>Every electron makes a closed loop and ends up back at its origin. After every single period the system is back to its initial state. In other words, the Floquet operator is $U=1$, and $H_\textrm{eff}=0$.</p>
<p>Let’s have a look at the dispersion, and also see what happens as we tune the driving period:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">%%output size=<span class="number">200</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_dispersion_2D</span><span class="params">(T)</span>:</span></span><br><span class="line">    syst = checkerboard()</span><br><span class="line">    B = np.array(syst.symmetry.periods).T</span><br><span class="line">    A = B @ np.linalg.inv(B.T @ B)</span><br><span class="line">    syst = kwant.wraparound.wraparound(syst).finalized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hamiltonian_k</span><span class="params">(par)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(k_x, k_y)</span>:</span></span><br><span class="line">            k_x, k_y = np.linalg.lstsq(A, [k_x, k_y], rcond=<span class="literal">None</span>)[<span class="number">0</span>]</span><br><span class="line">            ham = syst.hamiltonian_submatrix(params=dict(p=par, k_x=k_x, k_y=k_y))</span><br><span class="line">            <span class="keyword">return</span> ham</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    hamiltonians_k = [</span><br><span class="line">        hamiltonian_k(SimpleNamespace(t1=<span class="number">1</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>)),</span><br><span class="line">        hamiltonian_k(SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">1</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>)),</span><br><span class="line">        hamiltonian_k(SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">1</span>, t4=<span class="number">0</span>)),</span><br><span class="line">        hamiltonian_k(SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">1</span>)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_energies</span><span class="params">(k_x, k_y)</span>:</span></span><br><span class="line">        hamiltonians = [h_k(k_x, k_y) <span class="keyword">for</span> h_k <span class="keyword">in</span> hamiltonians_k]</span><br><span class="line">        U = evolution_operator(hamiltonians, T)</span><br><span class="line">        ev = np.sort(np.angle(la.eigvals(U)))</span><br><span class="line">        <span class="keyword">return</span> ev</span><br><span class="line"></span><br><span class="line">    K = np.linspace(-np.pi, np.pi, <span class="number">50</span>)</span><br><span class="line">    energies = np.array([[get_energies(k_x, k_y) <span class="keyword">for</span> k_x <span class="keyword">in</span> K] <span class="keyword">for</span> k_y <span class="keyword">in</span> K])</span><br><span class="line"></span><br><span class="line">    ticks = &#123;<span class="string">"xticks"</span>: pi_ticks[::<span class="number">2</span>], <span class="string">"yticks"</span>: pi_ticks[::<span class="number">2</span>], <span class="string">"zticks"</span>: <span class="number">3</span>&#125;</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">"extents"</span>: (-np.pi, -np.pi, <span class="number">-4</span>, np.pi, np.pi, <span class="number">4</span>),</span><br><span class="line">        <span class="string">"kdims"</span>: [<span class="string">"$k_x$"</span>, <span class="string">"$k_y$"</span>],</span><br><span class="line">        <span class="string">"vdims"</span>: [<span class="string">"$E$"</span>],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    title = <span class="string">r"$T = &#123;:.2&#125; \pi$"</span>.format(T / np.pi)</span><br><span class="line"></span><br><span class="line">    xs = np.linspace(-np.pi, np.pi, energies.shape[<span class="number">1</span>])</span><br><span class="line">    ys = np.linspace(-np.pi, np.pi, energies.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        holoviews.Surface((xs, ys, energies[:, :, <span class="number">0</span>]), **kwargs).opts(plot=ticks)</span><br><span class="line">        * holoviews.Surface((xs, ys, energies[:, :, <span class="number">1</span>]), **kwargs).opts(plot=ticks)</span><br><span class="line">    ).relabel(title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ts = np.linspace(<span class="number">1</span>, <span class="number">3</span>, <span class="number">11</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line">holoviews.HoloMap(&#123;T: plot_dispersion_2D(np.pi * T) <span class="keyword">for</span> T <span class="keyword">in</span> Ts&#125;, kdims=[<span class="string">"$T$"</span>])</span><br></pre></td></tr></table></figure>

<p>Now, there isn’t a Hamiltonian which is more topologically trivial than the zero Hamiltonian. We may be tempted to conclude that our system is trivial and, by bulk-boundary correspondence, has no edge states.</p>
<p>That’s something we can also very easily verify by computing the dispersion of a finite size ribbon:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">%%output size=<span class="number">200</span></span><br><span class="line">%%opts Path &#123;+axiswise&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_bands</span><span class="params">(momenta, hamiltonians_k, T)</span>:</span></span><br><span class="line">    energies = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> momenta:</span><br><span class="line">        hamiltonians = [h_k(k) <span class="keyword">for</span> h_k <span class="keyword">in</span> hamiltonians_k]</span><br><span class="line">        U = evolution_operator(hamiltonians, T)</span><br><span class="line">        energies.append(np.sort(np.angle(la.eigvals(U))))</span><br><span class="line">    <span class="keyword">return</span> np.array(energies).real</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ribbon_lead = checkerboard(<span class="number">10</span>).finalized()</span><br><span class="line"></span><br><span class="line">hamiltonians_k = [</span><br><span class="line">    get_h_k(ribbon_lead, SimpleNamespace(t1=<span class="number">1</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>)),</span><br><span class="line">    get_h_k(ribbon_lead, SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">1</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>)),</span><br><span class="line">    get_h_k(ribbon_lead, SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">1</span>, t4=<span class="number">0</span>)),</span><br><span class="line">    get_h_k(ribbon_lead, SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">1</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">periods = np.linspace(<span class="number">0</span>, <span class="number">4</span> * np.pi, <span class="number">11</span>)</span><br><span class="line">momenta = np.linspace(-np.pi, np.pi)</span><br><span class="line">spectrum = np.array([calculate_bands(momenta, hamiltonians_k, T) <span class="keyword">for</span> T <span class="keyword">in</span> periods])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot</span><span class="params">(n)</span>:</span></span><br><span class="line">    T = periods[n]</span><br><span class="line">    title = <span class="string">r"spectrum: $T=&#123;:.2&#125; \pi$"</span>.format(T / np.pi)</span><br><span class="line">    <span class="keyword">return</span> holoviews.Path(</span><br><span class="line">        (momenta, spectrum[n]), label=title, kdims=[<span class="string">"$k$"</span>, <span class="string">"$E_kT$"</span>]</span><br><span class="line">    ).opts(plot=&#123;<span class="string">"xticks"</span>: pi_ticks, <span class="string">"yticks"</span>: pi_ticks, <span class="string">"aspect"</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(&#123;n: plot(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">11</span>)&#125;, kdims=[<span class="string">"n"</span>])</span><br></pre></td></tr></table></figure>

<p>We see something very different from our expectations. All the bulk states are indeed at $E=0$, but there are two branches of dispersion that are clearly propagating. These can only belong to the edges, and since the two edges look identical, these two modes have to belong to the opposite edges. We seem to conclude that even though the bulk Hamiltonian is trivial, the edges carry chiral edge states, as if there was a finite Chern number.</p>
<p>When the driving period is tuned to ensure the absence of bulk dispersion, we can also understand why the edge states appear. If we select a state that starts on the edge, and follow it for one period, we find that there are modes that never leave the edge, since one of the hoppings in the vertical direction is absent.</p>
<p><img src="/2021/01/07/src/w11_extensions2/floquet/trajectories.svg" alt></p>
<p>So what is happening with bulk-edge correspondence?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">"How can you change the chirality of the edge states in the figure above?"</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"By changing the driving period."</span>,</span><br><span class="line">    <span class="string">"By reversing the driving protocol sequence."</span>,</span><br><span class="line">    <span class="string">"By changing the sign of the nearest neighbor hopping."</span>,</span><br><span class="line">    <span class="string">"By making the electrons start from the black sublattice."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"Reversing the driving protocol is the same as applying time-reversal symmetry, "</span></span><br><span class="line">    <span class="string">"so it will reverse the direction of the chiral edge modes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Bulk-edge-correspondence-in-driven-systems"><a href="#Bulk-edge-correspondence-in-driven-systems" class="headerlink" title="Bulk-edge correspondence in driven systems"></a>Bulk-edge correspondence in driven systems</h1><p>The two examples we’ve studied reveal an imporant feature of topological Floquet insulators. It seems that knowing the bulk Floquet Hamiltonian is sufficient to calculate the topological invariant, by just applying the known expression to the Floquet Hamiltonian. However, that’s not enough.</p>
<p>In rough terms, the reason for this insufficiency is due to Floquet topological insulators missing a topologically trivial state which can be taken as a reference. With any regular 2D Hamiltonian, we know that if we take $E \rightarrow -\infty$, we will get a trivial system with the Chern number zero. In a Floquet system, the only thing that lowering the energy tells us is that the Chern number is periodic in quasienergy, like any other observable property.</p>
<p>What do we need to know to derive the full topological invariant from the bulk properties? The answer is that we need the complete evolution operator for all moments in time, or in other words the full dependence $H(t)$. The actual calculation of the topological invariant is technically involved, and falls beyond what we can cover in this course. Moreover, to the best of our knowledge, the full classification of Floquet topological insulators is not yet accomplished.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"DbyqIczcR9c"</span>, src_location=<span class="string">"11.1-summary"</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"Floquet"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w11_extensions2/w11_assignments" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w11_extensions2/w11_assignments/"
    >src/w11_extensions2/w11_assignments</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w11_extensions2/w11_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.804Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulation-powers-combined"><a href="#Simulation-powers-combined" class="headerlink" title="Simulation: powers combined"></a>Simulation: powers combined</h1><p>As usual, start by grabbing the notebooks of this week (<code>w11_extensions2</code>). They are once again over <a href="http://tiny.cc/topocm_smc" target="_blank" rel="noopener">here</a>.</p>
<p>Are you tired yet of all the different kinds of topology? If no, this assignment is for you :-)</p>
<p>By now you should have a feel for how to make new topological phases. Your task now is to combine the two systems you’ve learned about and to create a Floquet crystalline topological insulator. If you want even more challenge, create also a gapless Floquet topological material.</p>
<p>Take care however: if you take a topologically nontrivial system and just apply rapid driving, you’ll still get a topological one. This cheating way is prohibited: at any moment during the driving cycle the Hamiltonian of your system should remain gapped.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Labs"</span>, <span class="string">"Floquet and crystalline"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1010-6126"><a href="#arXiv-1010-6126" class="headerlink" title="arXiv:1010.6126"></a>arXiv:1010.6126</h3><p><strong>Hint:</strong> Computes topological edge states from Floquet Hamiltonian.</p>
<h3 id="arXiv-1212-3324"><a href="#arXiv-1212-3324" class="headerlink" title="arXiv:1212.3324"></a>arXiv:1212.3324</h3><p><strong>Hint:</strong> Points out and explains why the floquet Hamiltonian in momentum space does not capture the presence of Floquet edge states.</p>
<h3 id="arXiv-1202-1003"><a href="#arXiv-1202-1003" class="headerlink" title="arXiv:1202.1003"></a>arXiv:1202.1003</h3><p><strong>Hint:</strong> Theoretical prediction of topological crystalline insulator.</p>
<h3 id="arXiv-1212-6191"><a href="#arXiv-1212-6191" class="headerlink" title="arXiv:1212.6191"></a>arXiv:1212.6191</h3><p><strong>Hint:</strong> Are topological crystalline surface states stable against disorder?</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Reviews"</span>, <span class="string">"Floquet and crystalline"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w11_extensions2/cti" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w11_extensions2/cti/"
    >src/w11_extensions2/cti</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w11_extensions2/cti/" class="article-date">
  <time datetime="2021-01-07T09:11:06.800Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size=<span class="number">150</span></span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Crystalline topological insulators are introduced by Liang Fu from MIT.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"N9-tUYjXC1s"</span>, src_location=<span class="string">"11.2-intro"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="The-role-of-crystalline-symmetries"><a href="#The-role-of-crystalline-symmetries" class="headerlink" title="The role of crystalline symmetries"></a>The role of crystalline symmetries</h1><p>In the very beginning of the course, we told you that conservation laws - unitary symmetries of the Hamiltonian - do not lead to striking consequences on topology. They allow to reduce the problem by making the Hamiltonian block-diagonal, but not much else (see also Shinsei Ryu’s introductory video to week eight).</p>
<p>At first sight, it may seem that crystalline symmetries: mirror or reflection symmetries, rotation symmetries, and so on - are no exception to the above consideration. They are unitary symmetries whose operators commute with the Hamiltonian. </p>
<p>Nevertheless, the role of crystalline symmetries can be quite subtle and it can have important consequences. The reason is that crystalline symmetries are non-local. They relate one point in a crystal to another point, possibly a very distant point. This means that in terms of the Bloch Hamiltonian of the crystal, these symmetries mix different values of momentum.</p>
<p>Consider for instance a 2D crystal with a reflection symmetry $\mathcal{R}: (x, y) \to (-x, y)$ around the $x=0$ axis. In momentum space, this symmetry will read $RH(k_x, k_y)R^\dagger = H(-k_x, k_y)$, with a certain unitary operator $R$.</p>
<p>Due to this type of constraint on the Brillouin zone, crystalline symmetries can have important consequences on the topological properties of Bloch Hamiltonians.</p>
<p>Note however, that sometimes the mere presence of a surface can break a crystalline symmetry of the bulk, so that one should be careful when applying the bulk-boundary correspondence to properties based on crystalline symmetries.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">r"In which case can inversion symmetry protect gapless surface states?"</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"Never."</span>,</span><br><span class="line">    <span class="string">"In the case of 2D TIs with inversion symmetry."</span>,</span><br><span class="line">    <span class="string">"Only in three dimensions."</span>,</span><br><span class="line">    <span class="string">"Only in combination with particle-hole or time-reversal symmetry. "</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">"Any surface would break inversion symmetry of a crystal."</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">0</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Reflection-symmetry"><a href="#Reflection-symmetry" class="headerlink" title="Reflection symmetry"></a>Reflection symmetry</h1><p>The second-simplest crystalline symmetry (after translation symmetry of course) occurring in many materials is reflection (or mirror) symmetry around one spatial coordinate. For instance, in a 3D crystal, reflection symmetry around the $z$ axis transforms the wave-wector as</p>
<p>$$<br>(k_x, k_y, k_z)\rightarrow (k_x, k_y, -k_z).<br>$$</p>
<p>Reflection symmetry also applies a 180 degree rotation about the $z$-axis to the electron spin, so $\psi_{\uparrow}\rightarrow -i \psi_{\uparrow}$ and $\psi_{\downarrow}\rightarrow i \psi_{\downarrow}$, so that the operator squares to $-1$ when acting on a spin.</p>
<p>Next, if we consider the application of reflection symmetry to either a two-dimensional material or a plane in a three dimensional material, then we can choose $k_z=0$ and the reflection symmetry just becomes a regular unitary symmetry i.e., the $C_2$ rotation.</p>
<p>In this case, the topological classification follows rather simply from our earlier discussion. $C_2$ is a unitary symmetry with eigenvalues $\pm i$. We can split our Hamiltonian into the corresponding two sector $H_{\pm}$ acting on the $C_2=\pm i$ sectors respectively. Each of the Hamiltonians $H_{\pm}$ are 2 dimensional Hamiltonians in class A (i.e. with no symmetry) and therefore we can associate a Chern number $N_{\pm}$ with each of them. </p>
<blockquote>
<p>If the Hamiltonian overall is trivial then the total Chern number $N_++N_-=0$ so we can classify the 2 dimensional mirror symmetric Hamiltonians by a <strong>mirror Chern number</strong> $N_M=N_+-N_-$.</p>
</blockquote>
<p>The mirror Chern number is a topological invariant in the sense that it cannot change without a closure of the bulk gap provided the reflection symmetry remains intact. Moreover, the reflection symmetry together with non-trivial values of the invariant will guarantee edge states.</p>
<p>Naturally, the same recipe allows to construct a reflection symmetric topological insulator starting from any other topological invariant, not just a Chern number. We will now try to do this.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"How would you attempt to make a model of a topological"</span></span><br><span class="line">    <span class="string">" insulator with surface states protected by reflection symmetry?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"By using the interface of a material with reflection symmetry, and that of one without it."</span>,</span><br><span class="line">    <span class="string">"By stacking many layers of a lower dimensional topological insulator, "</span></span><br><span class="line">    <span class="string">"and coupling them in a reflection-symmetric fashion."</span>,</span><br><span class="line">    <span class="string">"Reflection symmetry alone cannot protect any gapless surface state."</span>,</span><br><span class="line">    <span class="string">"By making a narrow ribbon of the material where only the momentum orthogonal to the reflection axis can be non-zero."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"Such a stack would have a reflection symmetry around any of the layers, "</span></span><br><span class="line">    <span class="string">"which is not broken by the presence of a surface parallel to the stacking direction."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>Let’s think, what could be the simplest topological system protected by reflection symmetry.</p>
<p>We need $d=2$, since the only possible reflection symmetry is broken by the boundary in $d=1$, and we can once again consider coupled Majorana nanowires.</p>
<p>We can put two nanowires in a unit cell of the lattice and make their parameters different. In this way, the weak topological invariant is trivial (there is an even number of Majoranas per unit cell).</p>
<p>On the other hand, if the hopping between the nanowires is reflection invariant, there will be a reflection symmetry axis passing through each nanowire, like this:</p>
<p><img src="/2021/01/07/src/w11_extensions2/cti/reflection.svg" alt></p>
<p>If we do everything right (this does require some trial and error in searching for the hopping that actually can couple the two Majoranas from the edge), we get a painfully familiar dispersion:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_chains</span><span class="params">(length=<span class="number">40</span>, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (<span class="number">2</span> * p.t - p.mu) * pauli.szs0</span><br><span class="line">            + p.delta * pauli.sxs0</span><br><span class="line">            + (y % <span class="number">2</span> == <span class="number">0</span>) * p.B * pauli.s0sz</span><br><span class="line">            + (y % <span class="number">2</span> == <span class="number">1</span>) * p.B * pauli.s0sy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 + <span class="number">0.5</span> * <span class="number">1j</span> * p.alpha * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        (x1, y1) = site1.pos</span><br><span class="line">        (x2, y2) = site2.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1j</span> * (<span class="number">-1</span>) ** ((x1 + x2 - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) * p.tx * pauli.sysx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; n) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; length)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym = kwant.TranslationalSymmetry((n, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syst = nanowire_chains()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, tx=<span class="number">0.2</span>, mu=<span class="number">0.0</span>, B=<span class="number">0.4</span>, delta=<span class="number">0.15</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">spectrum(</span><br><span class="line">    syst,</span><br><span class="line">    p,</span><br><span class="line">    k_x=np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">101</span>),</span><br><span class="line">    ylims=(<span class="number">-0.2</span>, <span class="number">0.2</span>),</span><br><span class="line">    xticks=<span class="number">3</span>,</span><br><span class="line">    yticks=<span class="number">3</span>,</span><br><span class="line">    title=<span class="string">"Stacked Majorana wires"</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In a similar way, we can also construct a tight-binding model with a mirror Chern number. The only difference with the Majorana wires that we need to worry about is that Chern number is a $\mathbb{Z}$ invariant instead of $\mathbb{Z}_2$.</p>
<p>This means that the Chern number of the alternating layers has to have opposite signs, or otherwise the surface would just have surface states going in a single direction.</p>
<p>Once again, coupling the layers we get a familiar Dirac cone on the surface:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stacked_qwz</span><span class="params">(w=<span class="number">50</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= z &lt; w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-0.5j</span> * p.delta * pauli.sx - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> p.gamma * pauli.sy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        (x, y, z) = site1.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-0.5j</span> * p.delta * pauli.sy * (<span class="number">-1</span>) ** (y) - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> pauli.sz * (<span class="number">4</span> * p.t + p.mu)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.eye(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xticks = [(-np.pi, <span class="string">r"$-\pi$"</span>), (<span class="number">0</span>, <span class="string">r"$0$"</span>), (np.pi, <span class="string">r"$\pi$"</span>)]</span><br><span class="line">yticks = [(<span class="number">0</span>, <span class="string">r"$0$"</span>), (np.pi / <span class="number">2</span>, <span class="string">r"$\pi/2$"</span>), (np.pi, <span class="string">r"$\pi$"</span>)]</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1</span>, gamma=<span class="number">0.5</span>, mu=<span class="number">-0.5</span>)</span><br><span class="line">syst = stacked_qwz(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">spectrum(</span><br><span class="line">    syst,</span><br><span class="line">    p,</span><br><span class="line">    num_bands=<span class="number">2</span>,</span><br><span class="line">    k_x=np.linspace(-np.pi, np.pi, <span class="number">51</span>),</span><br><span class="line">    k_y=np.linspace(<span class="number">0</span>, np.pi, <span class="number">51</span>),</span><br><span class="line">    xticks=xticks,</span><br><span class="line">    yticks=yticks,</span><br><span class="line">    title=<span class="string">"Stacked Chern insulator"</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Again, the dispersion of the edge states looks exactly like what we saw already because the edge state dispersion in any topological insulator is just given by the Dirac equation.</p>
<h1 id="Experimental-realization-of-a-3D-crystalline-topological-insulator"><a href="#Experimental-realization-of-a-3D-crystalline-topological-insulator" class="headerlink" title="Experimental realization of a 3D crystalline topological insulator"></a>Experimental realization of a 3D crystalline topological insulator</h1><p>As mentioned by Liang Fu, three dimensional crystalline topological insulators have been both predicted and also found in nature. The magical material, which is topological turns out to be SnTe, which is actually a “rock-salt” structure. We won’t bore you with the details of the rock-salt structure, which you can find for yourself on <a href="https://en.wikipedia.org/wiki/Cubic_crystal_system#Rock-salt_structure" target="_blank" rel="noopener">Wikipedia</a>. </p>
<p>We will just start with the key ingredients for the crystalline topological insulator, namely the symmetries of the crystal. These include, spatial inversion $P$, time-reversal symmetry $\Theta$ and most importantly the three mirror planes in the cubic Brillouin zone. The three mirror planes $\Gamma L_1 L_2$, $\Gamma L_3 L_4$ and $\Gamma L_3 L_1$ in the Brillouin zone are reflection-symmetric directions that are created out of four time-reversal invariant momenta $\Gamma, L_1, L_2, L_3, L_4$. </p>
<p>While the reflection symmetry acts non-trivially on general wave-vectors $\bf k$, the symmetry preserves the mirror planes in the Brillouin zone. Following the idea of dimensional reduction that we used for three dimensional topological insulators (week 6) and also in subsequent weeks, we can define the topological invariant for the crystalline topological insulator in terms of the three mirror Chern numbers for the three mirror planes. For SnTe, all these mirror Chern numbers turn out to be $N_{M}(\Gamma L_i L_j)=-2$. This topological invariant leads to surface Dirac cones on certain surfaces as shown below.</p>
<p><img src="/2021/01/07/src/w11_extensions2/cti/SnTefig.png" alt></p>
<p>Figure copyright of the Zahid Hasan lab, Princeton, 2015, available under CC-BY-NC-SA 4.0 International license.</p>
<p>This surface spectrum is very easy to interpret.</p>
<p>The crystal surface you see here is perpendicular to two mirror planes projected on $\bar{\Gamma}\bar{X}$ axes. Since the mirror Chern number with respect to each of these planes is $-2$, there is a pair of Dirac cones near each $X$-point protected by a respective mirror symmetry.</p>
<p>The reflection symmetry pins the pairs of Dirac cones to the mirror planes, while time reversal symmetry requires their momenta to be opposite. The 90 degree rotation symmetry interchanges the pairs of cones.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In short, crystalline topological insulators combine the variety of topological phases with the variety of the crystalline symmetry groups, leading to a multitude of new opportunities.</p>
<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"Crystalline TI"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w10_extensions/w10_assignments" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w10_extensions/w10_assignments/"
    >src/w10_extensions/w10_assignments</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w10_extensions/w10_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.799Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h1><p>As usual, start by grabbing the notebooks of this week (<code>w10_extensions</code>). They are once again over <a href="http://tiny.cc/topocm_smc" target="_blank" rel="noopener">here</a>.</p>
<h2 id="Weyl-semimetal-with-time-reversal-symmetry"><a href="#Weyl-semimetal-with-time-reversal-symmetry" class="headerlink" title="Weyl semimetal with time-reversal symmetry."></a>Weyl semimetal with time-reversal symmetry.</h2><p>Time-reversal symmetry has a very similar effect on Weyl semimetals as it has on gapless superconductors: it keeps the value of the Chern number around the Weyl point the same, and leads to appearance of quadruplets of Weyl points.</p>
<p>Your task is to construct a Weyl semimetal with time reversal symmetry. As we discussed, 4 Weyl points are needed.</p>
<p>If you don’t know where to start, here’s a hint: you’re not the first one who wants to construct a Weyl semimetal with time reversal, search on arxiv.</p>
<h2 id="Graphene-edge-states"><a href="#Graphene-edge-states" class="headerlink" title="Graphene edge states."></a>Graphene edge states.</h2><p>Graphene, just like $d$-wave superconductors has edge states. They only exist when the Dirac points are not located at coinciding momenta parallel to the boundary.</p>
<p>Define a graphene ribbon supporting edge states. For that you’ll need to figure out which orientation to choose.</p>
<p>Then try to add a term to the boundary that breaks the sublattice symmetry and moves the edge states from zero energy. What happens?</p>
<p>What if you add the next-nearest neighbor hopping in the bulk. What do you see now?</p>
<p>Try to remove the edge states completely by tweaking the sublattice symmetry breaking term at the edge. Did you succeed? How?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Labs"</span>, <span class="string">"Extensions"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1504-01350"><a href="#arXiv-1504-01350" class="headerlink" title="arXiv:1504.01350"></a>arXiv:1504.01350</h3><h3 id="arXiv-1503-06808"><a href="#arXiv-1503-06808" class="headerlink" title="arXiv:1503.06808"></a>arXiv:1503.06808</h3><p><strong>Hint:</strong> Different mechanical TI</p>
<h3 id="arXiv-1309-5846"><a href="#arXiv-1309-5846" class="headerlink" title="arXiv:1309.5846"></a>arXiv:1309.5846</h3><p><strong>Hint:</strong> Weyl + disorder</p>
<h3 id="arXiv-1410-1320"><a href="#arXiv-1410-1320" class="headerlink" title="arXiv:1410.1320"></a>arXiv:1410.1320</h3><p><strong>Hint:</strong> The best of both worlds</p>
<h3 id="arXiv-0909-5680"><a href="#arXiv-0909-5680" class="headerlink" title="arXiv:0909.5680"></a>arXiv:0909.5680</h3><p><strong>Hint:</strong> A general approach to gapless superconductors.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Reviews"</span>, <span class="string">"Extensions"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020-2021
        huyi
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>

      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="O"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/logs/">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://pan.huyiph.xyz" target="_blank" rel="noopener">网盘</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://aria.huyiph.xyz" target="_blank" rel="noopener">aria2</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['----------------------', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>




  <script src='https://unpkg.com/mermaid@v8.4.8/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


    
  </div>
</body>

</html>