<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="demon" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     O
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">O</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-src/w7_defects/ti_majoranas" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w7_defects/ti_majoranas/"
    >src/w7_defects/ti_majoranas</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w7_defects/ti_majoranas/" class="article-date">
  <time datetime="2021-01-07T09:11:06.878Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> sl</span><br><span class="line"></span><br><span class="line">my = <span class="number">0.5</span> * (pauli.sys0 + pauli.sysz)</span><br><span class="line">s0s0sz = np.kron(pauli.s0s0, pauli.sz)</span><br><span class="line">s0szsz = np.kron(pauli.s0sz, pauli.sz)</span><br><span class="line">mys0 = np.kron(my, pauli.s0)</span><br><span class="line">s0s0sx = np.kron(pauli.s0s0, pauli.sx)</span><br><span class="line">s0s0sy = np.kron(pauli.s0s0, pauli.sy)</span><br><span class="line">szsxsz = np.kron(pauli.szsx, pauli.sz)</span><br><span class="line">s0sysz = np.kron(pauli.s0sy, pauli.sz)</span><br><span class="line">sxsxsz = np.kron(pauli.sxsx, pauli.sz)</span><br><span class="line">sysxsz = np.kron(pauli.sysx, pauli.sz)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qshe_sc</span><span class="params">(l=<span class="number">40</span>, w=<span class="number">10</span>, lead=False)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.M - <span class="number">4</span> * p.B) * s0szsz</span><br><span class="line">            - <span class="number">4</span> * p.D * s0s0sz</span><br><span class="line">            + p.gaps(x, y)[<span class="number">1</span>] * mys0</span><br><span class="line">            + p.gaps(x, y)[<span class="number">0</span>] * s0s0sx</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz + <span class="number">0.5j</span> * p.A * szsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz - <span class="number">0.5j</span> * p.A * s0sysz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lead:</span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        lead = kwant.Builder(sym)</span><br><span class="line">        lead[lat(<span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1.5</span> * p.B * s0szsz</span><br><span class="line">        lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -p.B * s0szsz</span><br><span class="line">        syst.attach_lead(lead)</span><br><span class="line">        syst.attach_lead(lead.reversed())</span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qshe_sc_ribbon</span><span class="params">(w=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= x &lt; w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.M - <span class="number">4</span> * p.B) * s0szsz</span><br><span class="line">            - <span class="number">4</span> * p.D * s0s0sz</span><br><span class="line">            + p.gaps(x, y)[<span class="number">1</span>] * mys0</span><br><span class="line">            + p.gaps(x, y)[<span class="number">0</span>] * s0s0sx</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz + <span class="number">0.5j</span> * p.A * szsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz - <span class="number">0.5j</span> * p.A * s0sysz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_2d_pwave</span><span class="params">(w, l)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        (x1, y1) = site1.pos</span><br><span class="line">        (x2, y2) = site2.pos</span><br><span class="line">        phi = p.phase(<span class="number">0.5</span> * (x1 + x2), <span class="number">0.5</span> * (y1 + y2))</span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz + <span class="number">1j</span> * p.delta * (</span><br><span class="line">            np.cos(phi) * pauli.sx + np.sin(phi) * pauli.sy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        (x1, y1) = site1.pos</span><br><span class="line">        (x2, y2) = site2.pos</span><br><span class="line">        phi = p.phase(<span class="number">0.5</span> * (x1 + x2), <span class="number">0.5</span> * (y1 + y2))</span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz - <span class="number">1j</span> * p.delta * (</span><br><span class="line">            np.cos(np.pi / <span class="number">2</span> + phi) * pauli.sx + np.sin(np.pi / <span class="number">2</span> + phi) * pauli.sy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site1, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">4</span> * p.t - p.mu) * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (w / <span class="number">2</span> - <span class="number">1</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_slab</span><span class="params">(l, w, h)</span>:</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; h) <span class="keyword">and</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        (x, y, z) = site.pos</span><br><span class="line">        phi = p.phase(x, y)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * s0s0sz</span><br><span class="line">            + (p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2) * s0szsz</span><br><span class="line">            + p.delta * (np.cos(phi) * s0s0sx + np.sin(phi) * s0s0sy)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * s0s0sz - p.B2 * s0szsz + p.A2 * <span class="number">0.5j</span> * sxsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * s0s0sz - p.B2 * s0szsz + p.A2 * <span class="number">0.5j</span> * sysxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * s0s0sz - p.B1 * s0szsz + p.A1 * <span class="number">0.5j</span> * szsxsz</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_energies</span><span class="params">(syst, p, num_orbitals, num_states)</span>:</span></span><br><span class="line">    ham = syst.hamiltonian_submatrix(params=dict(p=p), sparse=<span class="literal">True</span>).tocsc()</span><br><span class="line">    energies, states = sl.eigsh(ham, sigma=<span class="number">0</span>, k=num_states)</span><br><span class="line">    densities = (</span><br><span class="line">        np.linalg.norm(states.reshape(<span class="number">-1</span>, num_orbitals, num_states), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> energies, states, densities</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>We have a returning lecturer for the first chapter of this week’s lectures: Carlo Beenakker from Leiden University, who will tell us more about different ways to create Majoranas in superconducting vortices.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"YVGlfejNH90"</span>, src_location=<span class="string">"7.1-intro"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Different-types-of-bulk-edge-correspondence"><a href="#Different-types-of-bulk-edge-correspondence" class="headerlink" title="Different types of bulk-edge correspondence"></a>Different types of bulk-edge correspondence</h1><p>By now, we have seen examples of how the topological properties of the bulk of a material can give birth to new physical properties at its edges, and how these edge properties cannot exist without a bulk. This is the essence of bulk-edge correspondence. For example, the unpaired Majorana bound states at the edges of a Kitaev chain exist because they are separated by the bulk of the chain.</p>
<p>Observe that the systems we have studied so far all had something in common: the topologically protected edge states were separated by a bulk that is one dimension higher than the dimension of the edge states. For example, the 0D Majorana bound states are separated by the 1D bulk of a Kitaev chain, and 1D chiral edge modes are separated by a 2D Chern insulator.</p>
<p>In this week, we will see that this does not need to be the case.</p>
<blockquote>
<p>The dimension of the bulk does not need to be one higher than the dimension of the topologically protected edge. Any dimension higher than the dimension of the edge works equally well.</p>
</blockquote>
<p>We will see how this simple insight opens new avenues in the hunt for topological protection.</p>
<h1 id="Turning-the-helical-edge-into-a-topological-superconductor"><a href="#Turning-the-helical-edge-into-a-topological-superconductor" class="headerlink" title="Turning the helical edge into a topological superconductor"></a>Turning the helical edge into a topological superconductor</h1><p>In the past weeks, we have studied two systems that appear very different, but where topology showed up in a very similar way.</p>
<p>First, let’s consider the quantum spin-Hall insulator. As we saw two weeks ago, it is characterized by a fermion parity pump: if you take a Corbino disk made out of a quantum spin-Hall insulator and change the flux by half a normal flux quantum, that is by $h/2e$, one unit of fermion parity is transferred from one edge of the sample to the other.</p>
<p>Secondly, let us consider a one-dimensional topological superconductor, like we studied in weeks two and three. If such a system is closed into a Josephson ring, and the flux through the ring is advanced by one superconducting flux quantum $h/2e$, the fermion parity at the Josephson junction connecting the two ends changes from even to odd, or viceversa. This is the $4π$ Josephson effect, one of the main signatures of topological superconductivity.</p>
<p>Note that the change in flux is equal to $h/2e$ in both cases, since a superconducting flux quantum $h/2e$ is half of the normal flux quantum $h/e$.</p>
<p>This suggest that once you have a quantum-spin Hall insulator, you are only one small step away from topological superconductivity and Majoranas. The only ingredient that is missing is to introduce superconducting pairing on the quantum spin-Hall edge.</p>
<p>But this is easy to add, for instance by putting a superconductor on top of the outer edge of our quantum spin-Hall Corbino disk:</p>
<p><img src="/2021/01/07/src/w7_defects/ti_majoranas/qsh_josephson_ring.svg" alt></p>
<p>The superconductor covers the entire quantum spin-Hall edge except for a small segment, which acts as a Josephson junction with a phase difference given by $\phi = 2e\Phi/\hbar$, where $\Phi$ is the magnetic flux through the center of the disk. We imagine that the superconductor gaps out the helical edge by proximity, which means that Cooper pairs can tunnel in and out from the superconductor into the edge. In order for this to happen, a conventional $s$-wave superconductor is enough.</p>
<p>We will not repeat our pumping experiment, that is increasing the flux $\Phi$ by $h/2e$. We know that one unit of fermion parity must be transferred from the inner edge of the disk to the outer edge. However, the only place where we can now find a zero-energy state is the Josephson junction, because the rest of the edge is gapped.</p>
<p>From the point of view of the superconducting junction, this means that advancing the phase difference $\phi$ by $2\pi$, the ground state fermion parity of the junction changes. Recalling what we learned in the second and third weeks, we can say that the Josephson effect is $4\pi$-periodic.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">"What happens to the Josephson current in the setup shown above if you remove the inner edge of the Corbino disk?"</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The pumping argument fails and the Josephson effect becomes $2\pi$ periodic."</span>,</span><br><span class="line">    <span class="string">"Then you can no longer apply a flux through the disk."</span>,</span><br><span class="line">    <span class="string">"The Josephson effect remains $4\pi$ periodic, but the fermion parity becomes fixed."</span>,</span><br><span class="line">    <span class="string">"Nothing changes if the inner edge of the Corbino disk is removed."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"Josephson current is a local effect, so it cannot be affected by a removal of the inner edge. "</span></span><br><span class="line">    <span class="string">"When you insert a superconducting flux quantum into the ring, the fermion parity of the edge becomes odd. "</span></span><br><span class="line">    <span class="string">"The extra fermion comes from the gapped bulk of QSHE, which now acquires one broken "</span></span><br><span class="line">    <span class="string">"Kramers pair. That is allowed since there is half a normal flux quantum penetrating the bulk, "</span></span><br><span class="line">    <span class="string">"and Kramers theorem doesn't apply anymore."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Majoranas-on-the-quantum-spin-Hall-edge"><a href="#Majoranas-on-the-quantum-spin-Hall-edge" class="headerlink" title="Majoranas on the quantum spin-Hall edge"></a>Majoranas on the quantum spin-Hall edge</h2><p>We know that the $4\pi$-periodicity of the Josephson effect can always be associated with the presence of Majorana zero modes at the two superconducting interfaces of the Josephson junction.</p>
<p>However, if you compare the system above with the Josephson ring studied in week three, you will notice an important difference. In that case, the Josephson junction was formed by an insulating barrier. Now on the other hand, the two superconducting interfaces are connected by the quantum spin-Hall edge.</p>
<p>This means that our Majoranas are connected by a gapless system, and therefore always strongly coupled. In order to see unpaired Majoranas, or at least weakly coupled ones, we need to gap out the segment of the edge forming the Josephson junction.</p>
<p>To gap it out, we can try to place another superconductor in the gap. Unfortunately, this doesn’t really help us, because it results in the formation of two Josephson junctions connected in series, and we only want one.</p>
<p>However, we know that the edge modes of the quantum spin-Hall insulator are protected from backscattering by time-reversal symmetry. To gap them out, we need to break time-reversal symmetry. Since a magnetic field breaks time-reversal symmetry, we can gap out the edge modes by placing a magnet on the segment of the edge between the two superconductors:</p>
<p><img src="/2021/01/07/src/w7_defects/ti_majoranas/qsh_majoranas.svg" alt></p>
<p>In the sketch above, you see two Majoranas drawn, one at each interface between the magnet and the superconductor. Their wavefunctions decay as we move away from the interfaces. As Carlo Beenakker mentioned in the introductory video, these Majoranas are quite similar to those we found at the ends of quantum wires.</p>
<p>To understand them in more detail, note that the magnet and the superconductor both introduce a gap in the helical edge, but through a completely different physical mechanism. The magnet flips the spin of an incoming electron, or hole, while the superconductor turns an incoming electron with spin up into an outgoing hole with spin down. These two different types of reflection processes combine together to form a Majorana bound state.</p>
<p>We can capture this behavior with the following Bogoliubov-de Gennes Hamiltonian for the edge:</p>
<p>$$H_\textrm{BdG}=(-iv\sigma_x \partial_x-\mu)\tau_z+m(x),\sigma_z+\Delta(x),\tau_x.$$</p>
<p>The first term is the edge Hamiltonian of the quantum spin-Hall effect, describing spin up and down electrons moving in opposite direction, together with a chemical potential $\mu$. The matrix $\tau_z$ acts on the particle-hole degrees of freedom, doubling the normal state Hamiltonian as usual. The second term is the Zeeman term due to the presence of the magnet. Finally, the last term is the superconducting pairing.</p>
<p>The strength of the Zeeman field $m(x)$ and the pairing $\Delta(x)$ both depend on position. At a domain wall between the superconductor and the magnet, when the relevant gap for the edge changes between $m$ and $\Delta$, the Hamiltonian above yields a Majorana mode.</p>
<p>This is shown below in a numerical simulation of a quantum spin-Hall disk. The left panel shows the edge state of the disk without any superconductor or magnet. In the right panel we cover one half of the disk by a superconductor and the other by a magnet, and obtain two well-separated Majoranas:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="number">60</span></span><br><span class="line">w = <span class="number">60</span></span><br><span class="line">sys2 = make_qshe_sc(l, w)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(A=<span class="number">0.5</span>, B=<span class="number">1.00</span>, D=<span class="number">0.1</span>, M=<span class="number">0.5</span>)</span><br><span class="line">p.gaps = <span class="keyword">lambda</span> x, y: [(y &lt; <span class="number">0</span>) * <span class="number">0.0</span>, (y &gt;= <span class="number">0</span>) * <span class="number">0.0</span>]</span><br><span class="line">energies0, states0, densities0 = calc_energies(sys2, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line">p.gaps = <span class="keyword">lambda</span> x, y: [(y &lt; <span class="number">0</span>) * <span class="number">0.2</span>, (y &gt;= <span class="number">0</span>) * <span class="number">0.3</span>]</span><br><span class="line">energies, states, densities = calc_energies(sys2, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">phi = np.linspace(-np.pi, np.pi, <span class="number">51</span>)</span><br><span class="line">x = (w + <span class="number">0.5</span>) / <span class="number">2</span> * np.cos(phi)</span><br><span class="line">y = (l + <span class="number">0.5</span>) / <span class="number">2</span> * np.sin(phi)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">9</span>, <span class="number">3.5</span>))</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">122</span>)</span><br><span class="line">gap_B = ax1.fill_between(x[:<span class="number">26</span>], <span class="number">0</span>, y[:<span class="number">26</span>], facecolor=<span class="string">"gold"</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">gap_Sc = ax1.fill_between(x[<span class="number">26</span>:], <span class="number">0</span>, y[<span class="number">26</span>:], facecolor=<span class="string">"blue"</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">kwant.plotter.map(sys2, densities[:, <span class="number">0</span>], colorbar=<span class="literal">False</span>, ax=ax1, cmap=<span class="string">"gist_heat_r"</span>)</span><br><span class="line">plt.plot(x, y, <span class="string">"k-"</span>, lw=<span class="number">2</span>)</span><br><span class="line">text_style = dict(fontsize=<span class="number">16</span>, arrowprops=dict(arrowstyle=<span class="string">"-"</span>, facecolor=<span class="string">"black"</span>, lw=<span class="number">0</span>))</span><br><span class="line">plt.annotate(<span class="string">"$E_Z$"</span>, xytext=(-w / <span class="number">20</span>, l / <span class="number">5</span>), xy=(<span class="number">0</span>, l / <span class="number">3</span>), **text_style)</span><br><span class="line">plt.annotate(<span class="string">"$\Delta$"</span>, xytext=(-w / <span class="number">20</span>, -l / <span class="number">4</span>), xy=(<span class="number">0</span>, -l / <span class="number">3</span>), **text_style)</span><br><span class="line">ax1.set_yticks([])</span><br><span class="line">ax1.set_xticks([])</span><br><span class="line">ax1.set_ylim(-l / <span class="number">2</span> - <span class="number">3</span>, l / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax1.set_xlim(-w / <span class="number">2</span> - <span class="number">3</span>, w / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">pot = np.log(abs(energies0[<span class="number">0</span>])) // np.log(<span class="number">10.0</span>) - <span class="number">1</span></span><br><span class="line">fac = abs(energies0[<span class="number">0</span>]) * <span class="number">10</span> ** (-pot)</span><br><span class="line">ax1.set_title(<span class="string">"Majoranas, $E = $"</span> + scientific_number(abs(energies[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line">ax0 = fig.add_subplot(<span class="number">121</span>)</span><br><span class="line">kwant.plotter.map(sys2, densities0[:, <span class="number">0</span>], colorbar=<span class="literal">False</span>, ax=ax0, cmap=<span class="string">"gist_heat_r"</span>)</span><br><span class="line">ax0.set_yticks([])</span><br><span class="line">ax0.set_xticks([])</span><br><span class="line">ax0.set_ylim(-l / <span class="number">2</span> - <span class="number">3</span>, l / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax0.set_xlim(-w / <span class="number">2</span> - <span class="number">3</span>, w / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax0.set_title(<span class="string">"Edge state, $E = $"</span> + scientific_number(abs(energies0[<span class="number">0</span>])))</span><br><span class="line">plt.plot(x, y, <span class="string">"k-"</span>, lw=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>The density of states plot of the lowest energy state reveals one Majorana mode at each of the two interfaces between the magnet and the superconductor.</p>
<p>This clearly shows how is it possible to obtain 0D topologically protected states (the Majorana modes) from a $2D$ bulk topological phase (the quantum spin Hall insulator). All we had to do was to add the appropriate ingredients (the superconductor and the magnet).</p>
<h1 id="Two-dimensional-p-wave-superconductors"><a href="#Two-dimensional-p-wave-superconductors" class="headerlink" title="Two-dimensional $p$-wave superconductors"></a>Two-dimensional $p$-wave superconductors</h1><p>Let us now move on to Majoranas in vortices, as discussed by Carlo Beenakker in the introductory video. We will need a model for a 2D topological superconductor. How do we obtain it?</p>
<p>It turns out that the method we used to construct 2D Chern insulators in week 4, namely stacking 1D Kitaev chains and coupling them, can also be used to construct 2D topological superconductors.</p>
<p>That isn’t very surprising though, is it? Remember that back then, we told you to forget that the Kitaev model was really a superconductor. Bearing that in mind, it comes as no surprise that stacking 1D superconductors gives us a 2D superconductor.</p>
<p>So let’s look back at the Hamiltonian we obtained for a Chern insulator by coupling a stack of Kitaev chains: </p>
<p>$$H_\textrm{2D}(\mathbf{k})=-(2t\cos{k_x}+\mu),\tau_z+\Delta\sin{k_x}\tau_y-2\gamma,(\cos{k_y}\tau_z+\sin{k_y},\tau_x).$$ </p>
<p>Those of us who are careful would want to check that the above Hamiltonian is indeed a superconductor, in particular that the terms coupling different chains do not spoil particle-hole symmetry.</p>
<p>And indeed if we consider the operator $\mathcal{P}=\tau_x \mathcal{K}$ with $\mathcal{K}$ the complex conjugation operator, we find that the Bloch Hamiltonian obeys $H_\textrm{2D}(\mathbf{k}) = -\tau_x H^*_\textrm{2D}(-\mathbf{k}) \tau_x$, precisely the symmetry obeyed by the Kitaev chain, extended to two dimensions (if you do not remember how to apply an anti-unitary symmetry in momentum space, you can go back to week 1 and look at the original derivation).</p>
<p>The Hamiltonian above is quite anisotropic - it looks different in the $x$ and $y$ directions, a consequence of the way we derived it in week four. For our purposes, however, it is convenient to make it look isotropic. Thus, we tweak the coefficients in $H$ to make it look similar in the $x$ and $y$ directions. This is fine as long as we do not close the gap, because the topological properties of $H$ remain unchanged.</p>
<p>In this way we arrive at the canonical Hamiltonian of a so-called $p$-wave superconductor:</p>
<p>$$H(k_x,k_y)=-[2t,(\cos{k_x}+\cos{k_y})+\mu],\tau_z+\Delta,(\sin{k_x}\tau_y-\sin{k_y}\tau_x).$$</p>
<p>Apart from looking more symmetric between the $x$ and $y$ directions, the Hamiltonian clearly separates normal hopping, which is proportional to $t$, and superconducting pairing, which is proportional to $\Delta$. This superconductor is $p$-wave because the pairing is linear in momentum, just like in the Kitaev chain. This can be seen explicitly by expanding $H$ around $\mathbf{k}=\mathbf{0}$, which gives</p>
<p>$$H(k_x,k_y)\approx [t,(k_x^2+k_y^2)-\mu+4 t]\tau_z+[i \Delta(k_x+i k_y)\tau_++\textrm{h.c.}],$$</p>
<p>where $\tau_+=(\tau_x+i\tau_y)/2$. Note that the pairing is proportional to $k_x+ik_y$, and it breaks both time-reversal and inversion symmetries.</p>
<p>Even though we have reinterpreted the Hamiltonian $H$ as a superconductor, it is still originally a Chern insulator. This means that the system is still characterized by a bulk Chern number, which determines the presence of chiral edge states.<br>A chiral edge state can be described by a simple effective Hamiltonian, equivalent to that of a quantum Hall edge:</p>
<p>$$H_\textrm{edge}=\hbar v k$$</p>
<p>with $v$ the velocity and $k$ the momentum along the edge. Note that the edge Hamiltonian maintains the particle-hole symmetry of the bulk: for every state with energy $E$ and momentum $k$ there is a state with energy $-E$ and momentum $-k$.</p>
<p>We are now ready to see how unpaired Majoranas can appear in a 2D $p$-wave superconductor.</p>
<h1 id="Vortices-in-2D-p-wave-superconductors"><a href="#Vortices-in-2D-p-wave-superconductors" class="headerlink" title="Vortices in 2D p-wave superconductors"></a>Vortices in 2D p-wave superconductors</h1><p>So far we have considered a uniform superconducting pairing $\Delta$, with constant amplitude and phase. This is an idealized situation, which corresponds to a perfect superconductor with no defects.</p>
<p>If you apply a small magnetic field to a superconducting film, or if there are defects in the material, a <a href="http://en.wikipedia.org/wiki/Abrikosov_vortex" target="_blank" rel="noopener"><strong>vortex</strong></a> of supercurrent can form to lower the free energy of the system.<br>In a vortex, there is a supercurrent circulating in a small area around the defect or the magnetic field lines penetrating the superconductor. The magnetic flux enclosed by the vortex supercurrent is equal to a superconducting flux quantum $h/2e$.</p>
<p>The amplitude $\Delta$ of the superconducting pairing is suppressed in the core of the vortex, going to zero in its center, and the superconducting phase winds by $2\pi$ around a closed path surrounding it. The situation is sketched below:</p>
<p><img src="/2021/01/07/src/w7_defects/ti_majoranas/vortex.svg" alt></p>
<p>Because the pairing $\Delta$ goes to zero in the middle of the vortex, there can be states with an energy smaller than $\Delta$ which are localized at the vortex core. We now want to see whether it is possible to have a non-degenerate zero energy solution in the vortex - because of particle-hole symmetry, this would be an unpaired Majorana mode!</p>
<p>To compute the spectrum of the vortex we could introduce a position dependent-phase for $\Delta$ in the Hamiltonian of the superconductor, and solve it for the energy spectrum by going through quite some algebra. But as usual in this course, we will take a shortcut.</p>
<p>Our shortcut comes from answering the following question: how is the spectrum of the chiral edge states affected by introducing a vortex in the middle of the superconductor?</p>
<p>From week one, we know that changing the flux through a superconducting ring by a flux quantum changes the boundary condition from periodic to antiperiodic, or viceversa.</p>
<p>A vortex has precisely the same effect on the chiral edge states. Therefore, in the presence of a vortex, the allowed values $k_n$ of momentum in a disk shift by $\pi/L$, with $L$ the length of the edge. The energy levels depend linearly on momentum and are shifted accordingly,</p>
<p>$$<br>E_n,\to, E_n + \hbar v \pi / L.<br>$$</p>
<p>Now, with or without the vortex, the spectrum must be symmetric around $E=0$ because of particle-hole symmetry. The energy levels $E_n$ correspond to standing waves and are equally spaced, with spacing given by $2\hbar v \pi / L$. There are only two such spectra consistent with particle-hole symmetry, $E_n = 2\pi,n, \hbar v / L$ and $E_n = 2\pi,(n+1/2), \hbar v / L$.</p>
<p>Which one of the two spectra correspond to the presence of a vortex?</p>
<p>To answer this question, observe that the energy spectrum $E_n = 2 \pi,n,\hbar v / L$ includes a zero-energy solution, which is an unpaired Majorana mode at the edge! This is impossible unless there is somewhere a place to have a second zero-energy solution. And the only other possible place where we could have a zero-energy solution is the core of the vortex.</p>
<blockquote>
<p>Just by looking at the edge state momentum quantization, we have thus demonstrated that a vortex in a $p$-wave superconductor must come with a Majorana.</p>
</blockquote>
<p>Below, we plot the wave function of the lowest energy state in a $p$-wave disk with a vortex in the middle. The lowest energy wavefunction is an equal superposition of the two Majorana modes. Here you can see that half of it is localized close to the vortex core and half of it close to the edge.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.cm</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"></span><br><span class="line">colors = matplotlib.cm.gist_heat_r(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>) ** <span class="number">0.25</span>)</span><br><span class="line">gist_heat_r_rescaled = mcolors.LinearSegmentedColormap.from_list(</span><br><span class="line">    <span class="string">"gist_heat_r_rescaled"</span>, colors</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.4</span>, delta=<span class="number">0.5</span>, phase=<span class="keyword">lambda</span> x, y: np.angle(x + <span class="number">1j</span> * y))</span><br><span class="line">l = <span class="number">60</span></span><br><span class="line">w = <span class="number">60</span></span><br><span class="line">syst = make_2d_pwave(w, l)</span><br><span class="line">energies, states, densities = calc_energies(syst, p, num_orbitals=<span class="number">2</span>, num_states=<span class="number">10</span>)</span><br><span class="line">kwant.plotter.map(</span><br><span class="line">    syst, densities[:, <span class="number">0</span>], cmap=gist_heat_r_rescaled, show=<span class="literal">False</span>, colorbar=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>The wave function is not zero in the bulk between the edge and the vortex because of the relatively small size of the system. The separation between edge and vortex, or between different vortices, plays the same role as the finite length of a Kitaev chain, i.e. it splits the Majorana modes away from zero energy by an exponentially small amount.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"What happens if you add a second vortex to the superconductor? "</span></span><br><span class="line">    <span class="string">"Imagine that the vortices and edge are all very far away from each other"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The second vortex has no Majorana."</span>,</span><br><span class="line">    <span class="string">"Both vortices have a Majorana, and the edge has two Majoranas."</span>,</span><br><span class="line">    <span class="string">"The Majorana mode at the edge goes away, and each vortex has its own Majorana."</span>,</span><br><span class="line">    <span class="string">"Vortices can only be added in pairs because Majoranas only come in pairs."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"The energy spectrum of the edge is shifted by $\hbar v \pi/L$ by the addition of a second vortex, "</span></span><br><span class="line">    <span class="string">"so the edge has no Majoranas now. The first vortex is not affected, and we know that it has a Majorana. "</span></span><br><span class="line">    <span class="string">"And so, of course, the second vortex must have a Majorana as well."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Vortices-in-3D-topological-insulator"><a href="#Vortices-in-3D-topological-insulator" class="headerlink" title="Vortices in 3D topological insulator"></a>Vortices in 3D topological insulator</h1><p>Unfortunately, superconductors with $p$-wave pairing are very rare, with mainly <a href="http://en.wikipedia.org/wiki/Strontium_ruthenate" target="_blank" rel="noopener">one material</a> being a good candidate. But instead waiting for nature to help us, we can try to be ingenious.</p>
<p>As Carlo mentioned, Fu and Kane <a href="http://arxiv.org/abs/0707.1692" target="_blank" rel="noopener">realized</a> that one could obtain an effective $p$-wave superconductor and Majoranas on the surface of a 3D TI.</p>
<p>We already know how to make Majoranas with a 2D topological insulator. Let us now consider an interface between a magnet and a superconductor on the surface of a 3D topological insulator. Since the surface of the 3D TI is two dimensional, such an interface will be a one dimensional structure and not a point defect as in the quantum spin-Hall case.</p>
<p>The Hamiltonian of the surface is a very simple extension of the edge Hamiltonian,  $\sigma_x k_x + \sigma_y k_y$ instead of just $\sigma_x k_x$. We can imagine that $k_y$ is the momentum along the interface between the magnet and the superconductor, and it is conserved. The effective Bogoliubov-de Gennes Hamiltonian is</p>
<p>$$H_\textrm{BdG}=(-i\sigma_x \partial_x+ \sigma_y k_y-\mu)\tau_z+m(x),\sigma_z+\Delta(x) \tau_x.$$</p>
<p>What is the dispersion $E(k_y)$ of states along the interface resulting from this Hamiltonian? Well, for $k_y=0$ we have exactly the Hamiltonian of the magnet/superconductor interface in the quantum spin-Hall case, which had a zero mode. So we know that the interface is gapless. The magnet breaks time-reversal symmetry, so we will have a chiral edge state, with energy $E$ proportional to $k_y$. Just like in the $p$-wave superconductor case!</p>
<p>At this point, analyzing the case of a vortex is very simple. We just have to reproduce the geometry we analyzed before. That is, we imagine an $s$-wave superconductor disk with a vortex in the middle, surrounded by a magnetic insulator, all on the surface of a 3D topological insulator:</p>
<p><img src="/2021/01/07/src/w7_defects/ti_majoranas/3d_ti_vortex.svg" alt></p>
<p>The introduction of a vortex changes the boundary conditions for the momentum at the edge, like in the $p$-wave case, and thus affects the spectrum of the chiral edge states going around the disk.</p>
<blockquote>
<p>Following the same argument as in the $p$-wave case, particle-hole symmetry dictates that there is a Majorana mode in the vortex core on a 3D TI. Interestingly, the vortex core is spatially separated from the magnet - so the vortex should contain a Majorana mode irrespective of the magnet that was used to create the chiral edge mode.</p>
</blockquote>
<p>In fact, the magnet was only a crutch that we used to make our argument. We can now throw it away and consider a vortex in a superconductor which covers the entire surface of the topological insulator.</p>
<p>To confirm this conclusion, below we show the result of a simulation of a 3D BHZ model in a cube geometry, with a vortex line passing through the middle of the cube. To make things simple, we have added superconductivity everywhere in the cube, and not just on the surface (nothing prevents us from doing this, even though in real life materials like Bi$_2$Te$_3$ are not naturally superconducting).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.cm</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"></span><br><span class="line">colors = matplotlib.cm.gist_heat_r(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>))</span><br><span class="line">colors[:, <span class="number">3</span>] = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>)</span><br><span class="line">gist_heat_r_transparent = mcolors.LinearSegmentedColormap.from_list(</span><br><span class="line">    <span class="string">"gist_heat_r_transparent"</span>, colors</span><br><span class="line">)</span><br><span class="line">l, w, h = <span class="number">10</span>, <span class="number">10</span>, <span class="number">25</span></span><br><span class="line">syst = bhz_slab(l, w, h)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(</span><br><span class="line">    A1=<span class="number">0.5</span>,</span><br><span class="line">    A2=<span class="number">0.5</span>,</span><br><span class="line">    B1=<span class="number">0.5</span>,</span><br><span class="line">    B2=<span class="number">0.5</span>,</span><br><span class="line">    C=<span class="number">-0.2</span>,</span><br><span class="line">    D1=<span class="number">0.1</span>,</span><br><span class="line">    D2=<span class="number">0.0</span>,</span><br><span class="line">    M=<span class="number">-0.2</span>,</span><br><span class="line">    delta=<span class="number">0.15</span>,</span><br><span class="line">    phase=<span class="keyword">lambda</span> x, y: np.angle(x + <span class="number">1j</span> * y),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">energies, states, densities = calc_energies(syst, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">9</span>, <span class="number">3.5</span>))</span><br><span class="line"></span><br><span class="line">ax0 = fig.add_subplot(<span class="number">121</span>, projection=<span class="string">"3d"</span>)</span><br><span class="line">kwant.plot(syst, ax=ax0, site_size=<span class="number">0.3</span>)</span><br><span class="line">ax0.set_xlim(-w / <span class="number">2</span> - <span class="number">2</span>, w / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax0.set_ylim(-l / <span class="number">2</span> - <span class="number">2</span>, l / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax0.set_yticks([])</span><br><span class="line">ax0.set_xticks([])</span><br><span class="line">ax0.set_zlim3d([<span class="number">0</span>, h])</span><br><span class="line">ax0.set_zticks([<span class="number">0</span>, h])</span><br><span class="line">ax0.set_zticklabels([<span class="string">"$0$"</span>, <span class="string">"$%d$"</span> % h])</span><br><span class="line">densities /= np.max(densities, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">122</span>, projection=<span class="string">"3d"</span>)</span><br><span class="line">kwant.plotter.plot(</span><br><span class="line">    syst,</span><br><span class="line">    site_color=densities[:, <span class="number">0</span>],</span><br><span class="line">    ax=ax1,</span><br><span class="line">    cmap=gist_heat_r_transparent,</span><br><span class="line">    colorbar=<span class="literal">False</span>,</span><br><span class="line">    site_lw=<span class="number">0</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ax1.set_xlim(-w / <span class="number">2</span> - <span class="number">2</span>, w / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax1.set_ylim(-l / <span class="number">2</span> - <span class="number">2</span>, l / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax1.set_yticks([])</span><br><span class="line">ax1.set_xticks([])</span><br><span class="line">ax1.set_zlim3d([<span class="number">0</span>, h])</span><br><span class="line">ax1.set_zticks([<span class="number">0</span>, h])</span><br><span class="line">ax1.set_zticklabels([<span class="string">"$0$"</span>, <span class="string">"$%d$"</span> % h])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>In the right panel, you can see a plot of the wavefunction of the lowest energy state. You see that it is very well localized at the end points of the vortex line passing through the cube. These are precisely the two Majorana modes that Carlo Beenakker explained at the end of his introductory video.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"B7lMz-NrKec"</span>, src_location=<span class="string">"7.1-summary"</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"Majoranas in topological insulators"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w7_defects/crystalline_defects" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w7_defects/crystalline_defects/"
    >src/w7_defects/crystalline_defects</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w7_defects/crystalline_defects/" class="article-date">
  <time datetime="2021-01-07T09:11:06.871Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">"ignore"</span>, UserWarning)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hoppings terms for BHZ and QAH model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_BHZ</span><span class="params">(site, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (p.M - <span class="number">4</span> * p.B) * pauli.s0sz</span><br><span class="line">        - <span class="number">4</span> * p.D * pauli.s0s0</span><br><span class="line">        + p.field * site.pos[<span class="number">1</span>] * pauli.s0s0</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_BHZ</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 + <span class="number">0.5j</span> * p.A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_BHZ</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 - <span class="number">0.5j</span> * p.A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weak_hopping_BHZ</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.t_inter * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_QAH</span><span class="params">(site, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (p.mu - <span class="number">4</span> * p.B) * pauli.sz + p.field * site.pos[<span class="number">1</span>] * pauli.s0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_QAH</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.sz + <span class="number">0.5j</span> * p.A * pauli.sx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_QAH</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.sz + <span class="number">0.5j</span> * p.A * pauli.sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weak_hopping_QAH</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.t_inter * np.eye(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Systems</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_screw_system</span><span class="params">(L, W, H, xs=None, ys=None, ye=None, pbc=True, model=<span class="string">"BHZ"</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Create system with screw dislocation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Function creates system with a screw dislocation. </span></span><br><span class="line"><span class="string">    L, W, H are dimension of scattering region.</span></span><br><span class="line"><span class="string">    L, W are dimension of cross section. </span></span><br><span class="line"><span class="string">    Leads are attached from top and bottom (0,0,1) direction.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xs, ys, ye describes where disloaction is placed.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"BHZ"</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_BHZ,</span><br><span class="line">            hopx_BHZ,</span><br><span class="line">            hopy_BHZ,</span><br><span class="line">            weak_hopping_BHZ,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">"QAH"</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_QAH,</span><br><span class="line">            hopx_QAH,</span><br><span class="line">            hopy_QAH,</span><br><span class="line">            weak_hopping_QAH,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; H)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calling kwant</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># scattering system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lead system</span></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># defining dislocation</span></span><br><span class="line">    <span class="keyword">if</span> xs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(ys, ye):</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> range(H):</span><br><span class="line">                <span class="keyword">del</span> syst[lat(xs + <span class="number">1</span>, y, z), lat(xs, y, z)]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">del</span> lead[lat(xs + <span class="number">1</span>, y, <span class="number">0</span>), lat(xs, y, <span class="number">0</span>)]</span><br><span class="line">            lead[lat(xs + <span class="number">1</span>, y, z + <span class="number">1</span>), lat(xs, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y, z <span class="keyword">in</span> itertools.product(range(ys, ye), range(H - <span class="number">1</span>)):</span><br><span class="line">            syst[lat(xs + <span class="number">1</span>, y, z + <span class="number">1</span>), lat(xs, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding periodic boundary conditions</span></span><br><span class="line">    <span class="keyword">if</span> pbc:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(L):</span><br><span class="line">            lead[lat(x, <span class="number">0</span>, <span class="number">0</span>), lat(x, W - <span class="number">1</span>, <span class="number">0</span>)] = hopy</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> range(H):</span><br><span class="line">                syst[lat(x, <span class="number">0</span>, z), lat(x, W - <span class="number">1</span>, z)] = hopy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(W):</span><br><span class="line">            lead[lat(<span class="number">0</span>, y, <span class="number">0</span>), lat(L - <span class="number">1</span>, y, <span class="number">0</span>)] = hopx</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> range(H):</span><br><span class="line">                syst[lat(<span class="number">0</span>, y, z), lat(L - <span class="number">1</span>, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.reversed())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized(), lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_edge_dislocation_system</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    L, W, H, xs=None, ys=None, ye=None, pbc=True, model=<span class="string">"BHZ"</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span>:</span></span><br><span class="line">    <span class="string">""" Create system with edge dislocation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Function creates system with an edge dislocation. </span></span><br><span class="line"><span class="string">    L, W, H are dimension of scattering region.</span></span><br><span class="line"><span class="string">    L, W are dimension of cross section. </span></span><br><span class="line"><span class="string">    Leads are attached from top and bottom (0,0,1) direction.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xs, ys, ye describes where disloaction is placed.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"BHZ"</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_BHZ,</span><br><span class="line">            hopx_BHZ,</span><br><span class="line">            hopy_BHZ,</span><br><span class="line">            weak_hopping_BHZ,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">"QAH"</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_QAH,</span><br><span class="line">            hopx_QAH,</span><br><span class="line">            hopy_QAH,</span><br><span class="line">            weak_hopping_QAH,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; H)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calling kwant</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># scattering system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = weak_hopping</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lead system</span></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = weak_hopping</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># defining disclocation</span></span><br><span class="line">    <span class="keyword">if</span> xs != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(ys, ye):</span><br><span class="line">            <span class="keyword">del</span> lead[lat(xs, y, <span class="number">0</span>)]</span><br><span class="line">            lead[lat(xs + <span class="number">1</span>, y, <span class="number">0</span>), lat(xs - <span class="number">1</span>, y, <span class="number">0</span>)] = weak_hopping</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> range(H):</span><br><span class="line">                <span class="keyword">del</span> syst[lat(xs, y, z)]</span><br><span class="line">                syst[lat(xs + <span class="number">1</span>, y, z), lat(xs - <span class="number">1</span>, y, z)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># periodic boundary conditions</span></span><br><span class="line">    <span class="keyword">if</span> pbc:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(L):</span><br><span class="line">            lead[lat(x, <span class="number">0</span>, <span class="number">0</span>), lat(x, W - <span class="number">1</span>, <span class="number">0</span>)] = hopy</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> range(H):</span><br><span class="line">                syst[lat(x, <span class="number">0</span>, z), lat(x, W - <span class="number">1</span>, z)] = hopy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(W):</span><br><span class="line">            lead[lat(<span class="number">0</span>, y, <span class="number">0</span>), lat(L - <span class="number">1</span>, y, <span class="number">0</span>)] = weak_hopping</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> range(H):</span><br><span class="line">                syst[lat(<span class="number">0</span>, y, z), lat(L - <span class="number">1</span>, y, z)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># attaching leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.reversed())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized(), lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_densities</span><span class="params">(lead, momentum, p, model, sorting_mid=<span class="number">0.0</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Calculate density of states in the lead at a given momentum. """</span></span><br><span class="line">    coord = np.array([i.pos <span class="keyword">for</span> i <span class="keyword">in</span> lead.sites])</span><br><span class="line">    xy = coord[coord[:, <span class="number">2</span>] == <span class="number">0</span>][:, :<span class="number">-1</span>]</span><br><span class="line">    indxs_xy = np.lexsort(xy.T)</span><br><span class="line">    xy = xy[indxs_xy, :]</span><br><span class="line"></span><br><span class="line">    h, t = lead.cell_hamiltonian(params=dict(p=p)), lead.inter_cell_hopping(params=dict(p=p))</span><br><span class="line">    h_k = <span class="keyword">lambda</span> k: h + t * np.exp(<span class="number">-1j</span> * k) + t.T.conj() * np.exp(<span class="number">1j</span> * k)</span><br><span class="line"></span><br><span class="line">    vals, vecs = np.linalg.eigh(h_k(momentum))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"BHZ"</span>:</span><br><span class="line">        num_orbital = <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"QAH"</span>:</span><br><span class="line">        num_orbital = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    densities = np.linalg.norm(vecs.reshape(<span class="number">-1</span>, num_orbital, len(vecs)), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    indxs = np.argsort(abs(vals - sorting_mid))</span><br><span class="line">    vals = vals[indxs]</span><br><span class="line">    densities = densities[:, indxs]</span><br><span class="line">    densities = densities[indxs_xy, :]</span><br><span class="line"></span><br><span class="line">    L, W = int(np.max(xy[:, <span class="number">0</span>]) + <span class="number">1</span>), int(np.max(xy[:, <span class="number">1</span>]) + <span class="number">1</span>)</span><br><span class="line">    twod_densities = np.zeros((W, L, densities.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> coord, val <span class="keyword">in</span> zip(xy, densities):</span><br><span class="line">        i, j = np.array(coord, dtype=int)</span><br><span class="line">        twod_densities[j, i, :] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> twod_densities, vals</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_spectrum_and_densities</span><span class="params">(sys_func, p, model, momentum, kwargs)</span>:</span></span><br><span class="line">    syst, lead = sys_func(L=<span class="number">11</span>, W=<span class="number">21</span>, H=<span class="number">5</span>, xs=<span class="number">4</span>, ys=<span class="number">5</span>, ye=<span class="number">16</span>, model=model)</span><br><span class="line">    spect = spectrum(lead, p, **kwargs)</span><br><span class="line">    densities = get_densities(syst.leads[<span class="number">0</span>], momentum, p, model)</span><br><span class="line">    <span class="keyword">return</span> spect, densities</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_hm</span><span class="params">(sys_func, momentum, kwargs)</span>:</span></span><br><span class="line">    parameters = &#123;</span><br><span class="line">        <span class="string">"BHZ"</span>: &#123;<span class="string">"A"</span>: <span class="number">1.0</span>, <span class="string">"B"</span>: <span class="number">1.0</span>, <span class="string">"D"</span>: <span class="number">0.0</span>, <span class="string">"M"</span>: <span class="number">0.8</span>&#125;,</span><br><span class="line">        <span class="string">"QAH"</span>: &#123;<span class="string">"A"</span>: <span class="number">1.0</span>, <span class="string">"B"</span>: <span class="number">1.0</span>, <span class="string">"D"</span>: <span class="number">0.0</span>, <span class="string">"mu"</span>: <span class="number">0.8</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p_BHZ = SimpleNamespace(field=<span class="number">0.005</span>, t_inter=<span class="number">-0.1</span>, **parameters[<span class="string">"BHZ"</span>])</span><br><span class="line">    p_QAH = SimpleNamespace(field=<span class="number">0.01</span>, t_inter=<span class="number">-0.1</span>, **parameters[<span class="string">"QAH"</span>])</span><br><span class="line"></span><br><span class="line">    spectrum_QAH, densities_QAH = get_spectrum_and_densities(</span><br><span class="line">        sys_func, p_QAH, <span class="string">"QAH"</span>, momentum, kwargs</span><br><span class="line">    )</span><br><span class="line">    spectrum_BHZ, densities_BHZ = get_spectrum_and_densities(</span><br><span class="line">        sys_func, p_BHZ, <span class="string">"BHZ"</span>, momentum, kwargs</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    hm_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> model, density, spect <span class="keyword">in</span> zip(</span><br><span class="line">            [<span class="string">"BHZ"</span>, <span class="string">"QAH"</span>], [densities_BHZ, densities_QAH], [spectrum_BHZ, spectrum_QAH]</span><br><span class="line">        ):</span><br><span class="line">            hm_dict[n, model] = (</span><br><span class="line">                spect</span><br><span class="line">                * holoviews.Points((momentum, density[<span class="number">1</span>][n]))</span><br><span class="line">                * holoviews.VLine(momentum)</span><br><span class="line">            ).relabel(<span class="string">"Bandstructure"</span>) + holoviews.Raster(</span><br><span class="line">                density[<span class="number">0</span>][:, :, n], label=<span class="string">r"$\left|\psi\right|^2$"</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> holoviews.HoloMap(hm_dict, kdims=[<span class="string">"n"</span>, <span class="string">"model"</span>])</span><br></pre></td></tr></table></figure>

<h1 id="Introduction-weak-topological-phases"><a href="#Introduction-weak-topological-phases" class="headerlink" title="Introduction: weak topological phases"></a>Introduction: weak topological phases</h1><p>Taylor Hughes from the University of Illinois at Urbana-Champaign will describe the interplay between defects in crystals and weak topological insulators.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"k3ZKCg7jtTs"</span>, src_location=<span class="string">"7.2-intro"</span>)</span><br></pre></td></tr></table></figure>

<p>As you can see, there is a simple and universal connection between weak topological phases and the ability of defects to carry topologically protected states. The topological invariant $\mathcal{Q}$ of a dislocation is the number of protected states that it carries. It can be determined from the vector of weak topological invariants, $\mathbf{\mathcal{Q}}_\textrm{weak}$, and the Burgers vector of the dislocation $\mathbf{B}$:</p>
<p>$$\mathcal{Q} = \mathbf{\mathcal{Q}}_\textrm{weak}\cdot\mathbf{B}$$</p>
<p>Let us now go through the main points that lead to this conclusion, and argue for why it has to be that way.</p>
<h1 id="Crystallographic-defects-and-topology"><a href="#Crystallographic-defects-and-topology" class="headerlink" title="Crystallographic defects and topology"></a>Crystallographic defects and topology</h1><p>There are many different types of <a href="http://en.wikipedia.org/wiki/Crystallographic_defect" target="_blank" rel="noopener">defects in crystals</a>: vacancies, substitutions, grain boundaries, dislocations, and many more.</p>
<p>What kinds of defects are important for topology? Consider a vacancy for example:<br><img src="/2021/01/07/src/w7_defects/crystalline_defects/Formation_Point_Defect.png" alt><br>(By Safe cracker (Own work) [CC BY 3.0 (<a href="http://creativecommons.org/licenses/by/3.0)]" target="_blank" rel="noopener">http://creativecommons.org/licenses/by/3.0)]</a>, via Wikimedia Commons)</p>
<p>To create a vacancy, we need to remove a single atom (or all the atoms following one line). Can this type of defect carry a topologically protected state?</p>
<p>We already know that topological protection requires a Hamiltonian that cannot be created locally. For example, in order to create a single Majorana bound state at a phase boundary, another Majorana must appear elsewhere. Removing an atom or a line of atoms only changes the system locally, so the <em>other</em> topologically protected state cannot appear anywhere.</p>
<p>A simple vacancy is therefore not interesting from a topological point of view. What kinds of topological defects would work then? Crystallographic defects leave nothing different since they leave the bulk Hamiltonian unchanged far away from the defect core. This means we need to do something nontrivial to the crystal so that it cannot be removed locally.</p>
<p>Examples of such defects are dislocations:</p>
<p><img src="/2021/01/07/src/w7_defects/crystalline_defects/burgers_vectors.png" alt><br>(By David Gabriel García Andrade (Own work) [Public domain], via Wikimedia Commons)</p>
<p>In order to create a dislocation we need to cut a crystal along one plane and displace all the atoms along that plane by the <em>Burgers vector</em>. This has to be done all the way to the crystal boundary (or infinity in an infinite crystal), so the dislocation affects the entire system. This means that a dislocation cannot be removed locally.</p>
<p>As Taylor Hughes explained, a dislocation can be detected infinitely far from its core by going around it and verifying that we don’t return to the point of origin. We cannot simply remove a dislocation by locally replacing some atoms. Therefore, it may carry a topologically protected mode.</p>
<p>Unsurprisingly, crystallographic defects that cannot be removed locally are called “topological”, which brings us to the first important conclusion:</p>
<blockquote>
<p><em>Topological</em> crystallographic defects are the ones that may carry topologically protected modes.</p>
</blockquote>
<p>This is a non-trivial observation, even though it sounds tautological. There are two different types of topology involved: the topology of the electronic modes and the topology of the crystal.</p>
<h1 id="The-role-of-defect-dimensionality"><a href="#The-role-of-defect-dimensionality" class="headerlink" title="The role of defect dimensionality"></a>The role of defect dimensionality</h1><p>When do topological defects carry protected edge states?</p>
<p>Far away from the defect, the bulk is homogeneous. Hence, the appearance of an edge state must be encoded both in the properties of the defect and in the bulk Hamiltonian. Of course, the appearance of this state must also be controlled by a topological invariant, since the protected state cannot disappear without the closing of the bulk gap.</p>
<p>What kind of topological invariant can this be? Can a strong topological invariant create a protected edge state at a defect?</p>
<p>In a sense we already know that it does. We can think of the crystal surface as a defect that breaks translational symmetry, and so it is a crystallographic defect. The strong topological invariant is the quantity that tells us whether or not the bulk can be continuously deformed into vacuum, or equivalently, whether or not the surface can be smoothly removed without closing the bulk gap.</p>
<p>In a $d$-dimensional bulk, the strong invariant is responsible for the appearance of a $d-1$-dimensional topologically protected state. This state can only be bound to a surface, which is the only $d-1$-dimensional topological defect. Defects of lower dimensionality can not be impacted by the strong invariant. An example of such a defect of lower dimensionality is precisely a dislocation, as in the previous figure. It is a one-dimensional defect in a three-dimensional crystal.</p>
<p>This is where the weak invariants come into play.</p>
<p>First of all, we know that the dimensionality $d_\textrm{egde}$ of a protected state at a defect must match the dimensionality of the defect. Secondly, we know the dimensionality of the topological invariant that controls this protected state: it is the topological invariant in the dimension $d_\textrm{edge}+1$.</p>
<p>The topological invariants with dimensionality $d_{edge}+1$ form a vector or a tensor of the weak indices. The last thing we need to figure out is how to extract information about what happens at the defect from the weak indices.</p>
<h1 id="The-defect-topological-invariant"><a href="#The-defect-topological-invariant" class="headerlink" title="The defect topological invariant"></a>The defect topological invariant</h1><p>We have almost arrived at the criterion for the appearance of protected states in dislocations.</p>
<p>To see how the weak topological invariant relates to the number of states in the dislocation, we start by deforming a weak topological insulator into a set of disconnected planes, each carrying protected states. If there is a single state approaching the dislocation, as is shown in the figure below, it cannot backscatter and must therefore continue through the dislocation core.</p>
<p><img src="/2021/01/07/src/w7_defects/crystalline_defects/dislocation_helical.svg" alt></p>
<p>(adapted from Cdang (Own work), via Wikimedia Commons, <a href="http://creativecommons.org/licenses/by-sa/3.0" target="_blank" rel="noopener">CC BY-SA 3.0</a>.)</p>
<p>Counting the number and the orientation of the crystal planes approaching the core of the dislocation is just the Burgers vector. Hence, the number of edge states entering the dislocation core is the Burgers vector times the number of states per crystal plane. This brings us to the conclusion:</p>
<p>$$\mathcal{Q} = \mathbf{\mathcal{Q}}_\textrm{weak}\cdot\mathbf{B}.$$</p>
<p>Let’s now test this idea and see if we can observe the protected dislocation states.</p>
<h1 id="Electronic-states-in-dislocations"><a href="#Electronic-states-in-dislocations" class="headerlink" title="Electronic states in dislocations"></a>Electronic states in dislocations</h1><p>Now that we know the main concepts, let’s apply them to concrete examples. Let’s take two models for topological insulators that we already know and apply them to lattice systems with dislocations.</p>
<p>We will create a 3D weak topological insulators by stacking many layers of 2D topological insulators along the $z$ direction. For the individual layers, we will use the BHZ model (by the way, note that the lecture today was given by the H of BHZ!) for a time-reversal invariant topological insulator, and the square lattice model for the quantum Hall effect that we used in week 4. In this way, we can study dislocations both with and without time reversal symmetry. In both cases, we take the hoppings between different layers to be relatively weak compared to those within the same layer.</p>
<p>Let’s start with a screw dislocation connecting two layers. The system looks like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># System parameters</span></span><br><span class="line">L = <span class="number">6</span></span><br><span class="line">W = <span class="number">7</span></span><br><span class="line">ws = <span class="number">3</span></span><br><span class="line">xs = <span class="number">2</span></span><br><span class="line">syst, lead = create_screw_system(</span><br><span class="line">    L, W, <span class="number">2</span>, xs=xs, ys=<span class="number">0</span>, ye=W - ws, pbc=<span class="literal">False</span>, model=<span class="string">"BHZ"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, projection=<span class="string">"3d"</span>)</span><br><span class="line">kwant.plot(syst, site_size=<span class="number">0.0</span>, site_lw=<span class="number">0.01</span>, hop_lw=<span class="number">0.025</span>, ax=ax, num_lead_cells=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">ax.set_zticks(())</span><br><span class="line">ax.view_init(<span class="number">50</span>, <span class="number">-110</span>)</span><br></pre></td></tr></table></figure>

<p>The Burgers’ vector is parallel to $z$ and has unit length - the dislocation connects neighboring layers.</p>
<p>The figure above only shows two layers, but we imagine that the system is repeated identically along the $z$ direction. Along the $x$ and $y$ directions it has periodic boundary conditions. Above we only show half of the dislocation.</p>
<p>Let’s look at the band structure along the $z$ direction, and the wave functions of the corresponding states.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%opts Raster(cmap=<span class="string">'gist_heat_r'</span> interpolation=<span class="literal">None</span>) &#123;+framewise&#125;</span><br><span class="line">%opts Points(s=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">"k_x"</span>: np.linspace(np.pi - np.pi / <span class="number">4</span>, np.pi + np.pi / <span class="number">4</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">"ylims"</span>: [<span class="number">-0.6</span>, <span class="number">0.95</span>],</span><br><span class="line">    <span class="string">"yticks"</span>: [<span class="number">-0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>],</span><br><span class="line">    <span class="string">"xticks"</span>: [</span><br><span class="line">        (np.pi - np.pi / <span class="number">4</span>, <span class="string">r"$\pi-\pi/4$"</span>),</span><br><span class="line">        (np.pi, <span class="string">r"$\pi$"</span>),</span><br><span class="line">        (np.pi + np.pi / <span class="number">4</span>, <span class="string">r"$\pi+\pi/4$"</span>),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create_hm(create_screw_system, momentum=np.pi + <span class="number">0.1</span>, kwargs=kwargs).collate()</span><br></pre></td></tr></table></figure>

<p>You see that the band structure is gapless: because of the presence of the dislocation, there are states dispersing below the bulk gap along the $z$ direction.</p>
<p>A look at their wave functions in the right panel shows that in the $x$-$y$ plane, these low-energy states are localized around the end points of the dislocation (we show the wave function corresponding to the blue dot in the band structure plot). On the other hand, when you look at the wave function of states above the gap, you see that they are spread out the whole $x$-$y$ plane.</p>
<p>Here, the fundamental difference between the BHZ model and the quantum anomalous Hall case is that in the former, the gapless states at the dislocation are helical, while in the latter they are chiral.</p>
<p>We can also look at an edge dislocation:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># System parameters</span></span><br><span class="line">L = <span class="number">7</span></span><br><span class="line">W = <span class="number">7</span></span><br><span class="line">ws = <span class="number">3</span></span><br><span class="line">xs = <span class="number">3</span></span><br><span class="line">syst, lead = create_edge_dislocation_system(</span><br><span class="line">    L, W, <span class="number">2</span>, xs=xs, ys=<span class="number">0</span>, ye=W - ws, pbc=<span class="literal">False</span>, model=<span class="string">"BHZ"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, projection=<span class="string">"3d"</span>)</span><br><span class="line"></span><br><span class="line">kwant.plot(syst, site_size=<span class="number">0.0</span>, site_lw=<span class="number">0.01</span>, hop_lw=<span class="number">0.025</span>, ax=ax, num_lead_cells=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">ax.set_zticks(())</span><br><span class="line">ax.view_init(<span class="number">50</span>, <span class="number">-110</span>)</span><br></pre></td></tr></table></figure>

<p>The Burgers vector is now along the $y$ direction, and it still has unit length. The band structure and the wave function plots show similar behavior.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%opts Raster(cmap=<span class="string">'gist_heat_r'</span> interpolation=<span class="literal">None</span>) &#123;+framewise&#125;</span><br><span class="line">%opts Points(s=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">"k_x"</span>: np.linspace(-np.pi / <span class="number">4</span>, np.pi / <span class="number">4</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">"ylims"</span>: [<span class="number">-0.6</span>, <span class="number">0.95</span>],</span><br><span class="line">    <span class="string">"yticks"</span>: [<span class="number">-0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>],</span><br><span class="line">    <span class="string">"xticks"</span>: [(-np.pi / <span class="number">4</span>, <span class="string">r"$-\pi/4$"</span>), (<span class="number">0</span>, <span class="string">r"$0$"</span>), (np.pi / <span class="number">4</span>, <span class="string">r"$\pi/4$"</span>)],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create_hm(create_edge_dislocation_system, momentum=<span class="number">0.1</span>, kwargs=kwargs).collate()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"What would happen in both simulations above if we changed the dislocation, "</span></span><br><span class="line">    <span class="string">"making the Burgers vector twice as long?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The wave function would just spread out a bit more because the dislocation is larger."</span>,</span><br><span class="line">    <span class="string">"The number of gapless states would double for both models."</span>,</span><br><span class="line">    <span class="string">"The gapless states would be gapped out for both models."</span>,</span><br><span class="line">    <span class="string">"The dislocation would only have gapless states in the quantum anomalous Hall case, not for the BHZ model."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"Doubling the Burgers vector doubles the topological invariant in the $\mathbb&#123;Z&#125;$ case, "</span></span><br><span class="line">    <span class="string">"and changes it from non-trivial to trivial in the $\mathbb&#123;Z&#125;_2$ case."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"MvcvJiZYSSk"</span>, src_location=<span class="string">"7.2-summary"</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"Crystalline defects"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w6_3dti/w6_assignments" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w6_3dti/w6_assignments/"
    >src/w6_3dti/w6_assignments</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w6_3dti/w6_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.870Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-more-Chern-insulators"><a href="#Simulations-more-Chern-insulators" class="headerlink" title="Simulations: more Chern insulators"></a>Simulations: more Chern insulators</h1><p>As usual, start by grabbing the notebooks of this week (<code>w6_3dti</code>). They are once again over <a href="http://tiny.cc/topocm_smc" target="_blank" rel="noopener">here</a>.</p>
<p>Simulations of the three-dimensional systems are hard, mostly because they take a lot of computational power. That’s why we’ll do something relatively simple this time.</p>
<h3 id="Breaking-time-reversal"><a href="#Breaking-time-reversal" class="headerlink" title="Breaking time-reversal"></a>Breaking time-reversal</h3><p>One mechanism of opening the gap on the surface of a topological insulator is to bring it into contact with a ferromagnet, which creates an effective Zeeman field.</p>
<ul>
<li>By calculating dispersion of a slab of 3D TI, observe the effect of Zeeman field pointing in different directions on the surface state dispersion. Find out which direction of the Zeeman field opens the gap in the surface state.</li>
<li>Make a domain wall between different orientations of Zeeman field. Are there any modes in this domain wall?</li>
</ul>
<h3 id="Many-invariants"><a href="#Many-invariants" class="headerlink" title="Many invariants"></a>Many invariants</h3><p>The BHZ model is rather rich and allows to produce every possible topological invariant. Can you find the parameter values that produce all the desired values of the invariants? (Hint: you need to make the model anisotropic).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Labs"</span>, <span class="string">"3DTI"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1410-0655"><a href="#arXiv-1410-0655" class="headerlink" title="arXiv:1410.0655"></a>arXiv:1410.0655</h3><p><strong>Hint:</strong> What enters the measurement of a Dirac point conductance.</p>
<h3 id="arXiv-0811-1303"><a href="#arXiv-0811-1303" class="headerlink" title="arXiv:0811.1303"></a>arXiv:0811.1303</h3><p><strong>Hint:</strong> Consequences of magneto-electric effect.</p>
<h3 id="arXiv-1401-7461"><a href="#arXiv-1401-7461" class="headerlink" title="arXiv:1401.7461"></a>arXiv:1401.7461</h3><p><strong>Hint:</strong> Weak and strong topological insulators with disorder.</p>
<h3 id="arXiv-1311-1758"><a href="#arXiv-1311-1758" class="headerlink" title="arXiv:1311.1758"></a>arXiv:1311.1758</h3><p><strong>Hint:</strong> Topological, but not insulator.</p>
<h3 id="arXiv-1005-3762"><a href="#arXiv-1005-3762" class="headerlink" title="arXiv:1005.3762"></a>arXiv:1005.3762</h3><p><strong>Hint:</strong> Threading flux through a topological insulator.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Reviews"</span>, <span class="string">"3DTI"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w6_3dti/bhz" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w6_3dti/bhz/"
    >src/w6_3dti/bhz</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w6_3dti/bhz/" class="article-date">
  <time datetime="2021-01-07T09:11:06.856Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span><span class="params">(X=None, Y=None, Z=None, system_type=<span class="string">"infinite"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""A cuboid region of BZZ material with two leads attached.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    parameters for leads and scattering region can be defined separately</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Onsite and hoppings matrices used for building BZZ model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * pauli.s0s0 + (</span><br><span class="line">            p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2</span><br><span class="line">        ) * pauli.s0sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sxsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sysx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * pauli.s0s0 - p.B1 * pauli.s0sz + p.A1 * <span class="number">0.5j</span> * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx_phase</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1, z1 = site1.pos</span><br><span class="line">        x2, y2, z2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(<span class="number">-0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_slab</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= z &lt; Z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_lead</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= y &lt; Y) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; Z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_cube</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; X) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; Y) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; Z)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>), norbs=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">"slab"</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]))</span><br><span class="line">        syst[lat.shape(shape_slab, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">"lead"</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[lat.shape(shape_lead, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">"cuboid"</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line">        syst[lat.shape(shape_cube, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">"infinite"</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx_phase</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">r"$M=&#123;:.3&#125;$"</span>.format(p.M)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lead</span><span class="params">()</span>:</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>), norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder(</span><br><span class="line">        kwant.TranslationalSymmetry((<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>)), time_reversal=<span class="number">1j</span> * pauli.sys0</span><br><span class="line">    )</span><br><span class="line">    syst[lat(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1.5</span> * pauli.s0sz</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = <span class="number">-1</span> * pauli.s0sz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_scatter_sys</span><span class="params">()</span>:</span></span><br><span class="line">    syst = kwant.wraparound.wraparound(bhz(Z=<span class="number">1</span>, system_type=<span class="string">"slab"</span>))</span><br><span class="line">    syst.attach_lead(make_lead())</span><br><span class="line">    syst.attach_lead(kwant.wraparound.wraparound(bhz(), keep=<span class="number">0</span>))</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scattering_det_pfaff</span><span class="params">(syst, p)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pfaffian</span><span class="params">(syst, p, k_x, k_y)</span>:</span></span><br><span class="line">        smat = kwant.smatrix(</span><br><span class="line">            syst, energy=<span class="number">0.0</span>, params=dict(p=p, k_x=k_x, k_y=k_y, k_z=<span class="number">0</span>)</span><br><span class="line">        ).data</span><br><span class="line">        <span class="comment"># since we get relatively large numerical errors we project the matrix on</span></span><br><span class="line">        <span class="comment"># the space of antisymmetric matrices</span></span><br><span class="line">        smat = <span class="number">0.5</span> * (smat - smat.T)</span><br><span class="line">        <span class="keyword">return</span> pf.pfaffian(smat)</span><br><span class="line"></span><br><span class="line">    xdim, ydim = <span class="string">"$k_y$"</span>, <span class="string">"phase"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plot_k_x</span><span class="params">(syst, p, k_x, label, col)</span>:</span></span><br><span class="line">        pfaff = [pfaffian(syst, p, k_x, <span class="number">0</span>), pfaffian(syst, p, k_x, np.pi)]</span><br><span class="line">        ks = np.linspace(<span class="number">0.0</span>, np.pi, <span class="number">50</span>)</span><br><span class="line">        det = [</span><br><span class="line">            np.linalg.det(</span><br><span class="line">                kwant.smatrix(</span><br><span class="line">                    syst, energy=<span class="number">0.0</span>, params=dict(p=p, k_x=k_x, k_y=k_y, k_z=<span class="number">0</span>)</span><br><span class="line">                ).data</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">for</span> k_y <span class="keyword">in</span> ks</span><br><span class="line">        ]</span><br><span class="line">        det = np.array(det)</span><br><span class="line">        phase = np.angle(pfaff[<span class="number">0</span>]) + <span class="number">0.5</span> * np.cumsum(np.angle(det[<span class="number">1</span>:] / det[:<span class="number">-1</span>]))</span><br><span class="line">        kdims = [xdim, ydim]</span><br><span class="line">        plot = holoviews.Path((ks[<span class="number">1</span>:], phase), kdims=kdims, label=label).opts(</span><br><span class="line">            style=&#123;<span class="string">"color"</span>: col&#125;</span><br><span class="line">        )</span><br><span class="line">        plot *= holoviews.Points(([<span class="number">0</span>, np.pi], np.angle(pfaff)), kdims=kdims).opts(</span><br><span class="line">            style=&#123;<span class="string">"color"</span>: col&#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> plot</span><br><span class="line"></span><br><span class="line">    plot = plot_k_x(syst, p, <span class="number">0</span>, <span class="string">r"$k_x=0$"</span>, <span class="string">"g"</span>) * plot_k_x(</span><br><span class="line">        syst, p, np.pi, <span class="string">r"$k_x=\pi$"</span>, <span class="string">"b"</span></span><br><span class="line">    )</span><br><span class="line">    xlims, ylims = (<span class="number">-0.2</span>, np.pi + <span class="number">0.2</span>), (-np.pi - <span class="number">0.2</span>, np.pi + <span class="number">0.2</span>)</span><br><span class="line">    pi_ticks = [(-np.pi, <span class="string">r"$-\pi$"</span>), (<span class="number">0</span>, <span class="string">"$0$"</span>), (np.pi, <span class="string">r"$\pi$"</span>)]</span><br><span class="line">    style_overlay = &#123;</span><br><span class="line">        <span class="string">"xticks"</span>: [(<span class="number">0</span>, <span class="string">"0"</span>), (np.pi, <span class="string">"$\pi$"</span>)],</span><br><span class="line">        <span class="string">"yticks"</span>: pi_ticks,</span><br><span class="line">        <span class="string">"show_legend"</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">"legend_position"</span>: <span class="string">"top"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    style_path = &#123;<span class="string">"show_legend"</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.range(**&#123;xdim: xlims, ydim: ylims&#125;).opts(</span><br><span class="line">        plot=&#123;<span class="string">"Overlay"</span>: style_overlay, <span class="string">"Path"</span>: style_path&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Joel Moore from the University of California, Berkeley will introduce this week’s topic, by telling us how the idea of a two-dimensional topological insulator was generalized to three dimensions.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"NIhMjm7cyug"</span>, src_location=<span class="string">"6.1-intro"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Making-3D-topological-invariants-out-of-2D-ones"><a href="#Making-3D-topological-invariants-out-of-2D-ones" class="headerlink" title="Making  3D topological invariants out of 2D ones"></a>Making  3D topological invariants out of 2D ones</h1><p>Let us follow the direction explained by Joel Moore and construct a three-dimensional topological state from the two-dimensional topological state. This time, we’ll do this by studying the system in momentum space rather than in real space as we did before. As with two dimensional systems, time-reversal invariant momenta (TRIMs) play an important role in three dimensions. </p>
<p>For illustrative purposes, consider the three dimensional irreducible Brillouin Zone (i.e. $k_j\in [0,\pi]$) of a cubic system shown below. Fixing one of the three momenta $k_{x,y,z}$ to a TRIM, say $k_x=0$ without loss of generality, we can think of the Hamiltonian in the $(k_y,k_z)$ plane as a two dimensional Hamiltonian, which may either be topologically trivial ($\mathbb{Z}_2$-index $=0$) or non-trivial ($\mathbb{Z}_2$-index $=1$).</p>
<p><img src="/2021/01/07/src/w6_3dti/bhz/3dbz.svg" alt></p>
<p>So for every side of the cube shown above we can compute a QSHE topological invariant, which gives us 6 numbers. However not all of them are independent. Specifically, there is a constraint $Q(k_x=0),Q(k_x=\pi) \equiv Q(k_y=0),Q(k_y=\pi) \equiv Q(k_z=0),Q(k_z=\pi)$.</p>
<p>This product is called <em>the strong topological invariant</em>. Accordingly, the topological insulators where this invariant is non-trivial are called strong topological insulators. For the remaining three invariants, we can choose  $Q(k_x=\pi),,Q(k_y=\pi),,Q(k_z=\pi)$.</p>
<p>Very frequently the topological invariants of a compound are written as $(1;010)$, where the first number corresponds to the strong invariant, and the remaining three to the weak invariants along each axis. For example, the first predicted topological insulator, the alloy Bi$<em>x$Sb$</em>{1-x}$ is $(1;111)$, and the second generation topological insulators Bi$_2$Te$_3$ and Bi$_2$Se$_3$ are $(1;000)$.</p>
<p>Just by using the bulk-edge correspondence for $Q$ we know that the strong topological invariant means that there is an odd number of helical states going in each direction on each facet of the topological insulator. We will see later why this is special, but before that let’s construct a model for a 3D TI.</p>
<h1 id="BHZ-model-of-a-3D-topological-insulator"><a href="#BHZ-model-of-a-3D-topological-insulator" class="headerlink" title="BHZ model of a 3D topological insulator"></a>BHZ model of a 3D topological insulator</h1><p>Our goal in this unit is to derive an effective three-dimensional Hamiltonian $H(\mathbf{k})$ for a strong topological insulator.</p>
<p>We follow the same logic that led us to defining the three-dimensional topological invariant in the previous unit, building up on our knowledge of 2D topological insulators. Our first step is therefore to set $k_z=0$ and start from a two-dimensional Bloch Hamiltonian which describes a non-trivial 2D topological insulator. Of course, we choose a model we already know for this 2D Hamiltonian, the Bernevig-Hughes-Zhang (BHZ) model.</p>
<p>Let’s recapitulate what we said about the BHZ model last week. It is a four band model, which has two electron bands (spin up and spin down) and two hole bands (spin up and down). It has inversion symmetry, with electron and hole bands having opposite parity. We will not need more bands for our 3D topological insulator model.</p>
<p>Copying the BHZ Hamiltonian of last week, at $k_z=0$ we have </p>
<p>$$<br>H(k_z=0) = \epsilon(\mathbf{k})\cdot\mathbb{1} +<br>\begin{pmatrix}<br>M_0(\mathbf{k}) &amp; A k_+ &amp; 0 &amp; 0 \<br>A k_- &amp; -M_0(\mathbf{k}) &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; M_0(\mathbf{k}) &amp; -Ak_- \<br>0 &amp; 0 &amp; -Ak_+ &amp; -M_0(\mathbf{k})<br>\end{pmatrix},,<br>$$</p>
<p>where $k_\pm = k_x \pm i k_y$. This Hamiltonian is written in a basis given by the states $\left|E\uparrow\right\rangle$, $\left|H\uparrow\right\rangle$, $\left|E\downarrow\right\rangle$, $\left|H\downarrow\right\rangle$, in that order. The block structure of the Hamiltonian reminds you that it is a doubled version of a Chern insulator, with two diagonal blocks for up and down spins. The particular form of $\epsilon(\mathbf{k})$ can be important to describe the band structure of a given material, but will not play a role in what follows. The effective mass is given by $M_0(\mathbf{k}) = M - B(k_x^2+k_y^2)$, and the transition between the topological and trivial insulating phases in this 2D model happens when $M$ changes sign.</p>
<p>To get a strong topological insulator, we would like the two-dimensional $\mathbb{Z}_2$ invariant applied to the $(k_x, k_y)$ plane to take different values at $k_z=0$ and $k_z=\pi$. It is easy to achieve this by adding a $k_z$-dependent term to the effective mass, for instance in the following way</p>
<p>$$<br>M_0(\mathbf{k}),\to,M(\mathbf{k}) = M - B(k_x^2+k_y^2+k_z^2),.<br>$$</p>
<p>Compared to the 2D model above, we can make the sign of the ‘new’ mass $M-Bk_z^2$ effectively change at fixed $k_x$ and $k_y$ by choosing $k_z$ large enough.</p>
<p>There is now a problem, however. Looking at the Hamiltonian at different values of $k_z$, we see that if we fix $k_z$ it still has time-reversal symmetry. Since it is topologically nontrivial at $k_z=0$ and becomes trivial at $k_z = \pi$, it should have a topological phase transition somewhere in between.</p>
<p>In other words, if we just add the $B k_z^2$ term, the Hamiltonian becomes gapless! Of course, we would like to have a gapped Hamiltonian in the whole 3D Brillouin zone instead.</p>
<p>How can we avoid the gap closing? We definitely need to couple the two spin blocks in $H(\mathbf{k})$, since otherwise each block is undergoing a Chern insulator transition. Recall that spin is odd under time-reversal, so to couple the spins we need a coupling which is odd in momentum, in order to maintain time-reversal invariance in the system. The simplest thing is to pick a coupling that is linear in $k_z$.</p>
<p>We then arrive at the following 3D Hamiltonian,</p>
<p>$$<br>H(\mathbf{k}) = \epsilon(\mathbf{k})\cdot\mathbb{1} +<br>\begin{pmatrix}<br>M(\mathbf{k}) &amp; A k_+ &amp; 0 &amp; \tilde{A}k_z \<br>A k_- &amp; -M(\mathbf{k}) &amp; \tilde{A}k_z &amp; 0 \<br>0 &amp; \tilde{A}k_z &amp; M(\mathbf{k}) &amp; -Ak_- \<br>\tilde{A}k_z &amp; 0 &amp; -Ak_+ &amp; -M(\mathbf{k})<br>\end{pmatrix},.<br>$$</p>
<p>This Hamiltonian is known as the <strong>3D BHZ model</strong>. It is gapped at finite $M$, and a transition between the trivial and strong topological insulator phases is achieved by changing the sign of $M$. Just like its two-dimensional counterpart, the 3D BHZ model can be used as a prototype for a strong topological insulator, as well as a starting point to model real materials. </p>
<p>The above derivation makes one important point evident: a necessary ingredient to have a strong topological insulator is to break spin conservation. Above, we achieved this by adding coupling between the spins, to avoid the undesirable gap closing at finite $k_z$</p>
<h1 id="Dirac-surface-states"><a href="#Dirac-surface-states" class="headerlink" title="Dirac surface states"></a>Dirac surface states</h1><p>What is the dispersion of the surface state of the $3D$ topological insulator?</p>
<p>We know that if we fix one momentum (say $k_x$) to zero, the Hamiltonian of the remaining system is that of a quantum spin Hall insulator. For this system we know that the Hamiltonian of the edge states is just that of a pair of counter-propagating modes, so</p>
<p>$$H = v \sigma_y k_y.$$</p>
<p>Here, the matrix $\sigma_y$ acts on the degrees of freedom of these two surface modes, and doesn’t correspond to particle spin.</p>
<p>Since time-reversal symmetry changes the sign of $k_y$, it must also change the sign of $\sigma_y$, so the time-reversal operator must be $\mathcal{T} = i \sigma_y K$.</p>
<p>What if we consider a nonzero $k_x$? Generically, the two modes are then coupled by an extra term in the Hamiltonian. This term should be proportional to $k_x$, and since it couples the modes it must also include a Pauli matrix, which we can just choose to be $\sigma_x$.</p>
<p>So if the surface of the topological insulator is isotropic, its Hamiltonian is merely</p>
<p>$$H=v \mathbf{\sigma} \cdot \mathbf{k}.$$</p>
<p>Let’s have a quick look at it to get a more concrete understanding:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">'png'</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1.5</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=<span class="literal">None</span>, Bz=<span class="number">0</span>)</span><br><span class="line">syst = bhz(Z=<span class="number">5</span>, system_type=<span class="string">"slab"</span>)</span><br><span class="line">k = np.linspace(-np.pi, np.pi)</span><br><span class="line">Ms = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;</span><br><span class="line">        p.M: spectrum(syst, p, k_x=k, k_y=k, k_z=<span class="number">0</span>, title=title, num_bands=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms</span><br><span class="line">    &#125;,</span><br><span class="line">    kdims=[<span class="string">r"$M$"</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>What you see here is the dispersion of the two lowest energy bands of a thin slice of a 3D BHZ model.</p>
<p>The system is topological when $M&lt;0$. As expected, the lowest energy state then has a Dirac dispersion, and surface states are formed.</p>
<p>The distinguishing feature of the strong topological insulator is that it has an odd number of Dirac cones in total.<br>In fact, the reason why it is called “strong” is also the reason why an odd number of Dirac cones is special.</p>
<p>To see what is unique, let us add an infinitesimal magnetic field and compute the Chern number of the surface state. We know that the number of Dirac cones is odd. From our study of Chern insulators, we know that the <em>change</em> in the Chern number between $B = -\varepsilon$ and $B = +\varepsilon$ is just the number of the Dirac cones. This is because we open a gap at each of them.</p>
<p>Since the Chern number is odd under time reversal, we come to a paradoxical conclusion: if we break time reversal, we end up with a half-integer Hall conductance $\sigma_{xy} = e^2/h (n + 1/2)$ on a surface of a topological insulator.</p>
<p>This is of course not possible in any purely 2D system, since the Hall conductance must be an integer, and therefore the surface state of a strong topological insulator cannot be created without the topological bulk.</p>
<blockquote>
<p>The statement that it is impossible to have a tight-binding Hamiltonian with time-reversal symmetry and a single Dirac cone is known as the “fermion doubling theorem”. There are several tricks that one can perform to work around this limitation in a numerical simulation, but we won’t cover them in the course.</p>
</blockquote>
<h1 id="Weak-invariants"><a href="#Weak-invariants" class="headerlink" title="Weak invariants"></a>Weak invariants</h1><p>Now that we understand what is special about the strong invariant, let’s deal with the weak invariants.</p>
<p>From their definition, we know that the weak invariants don’t change the parity of the number of Dirac cones on any surface.<br>Furthermore, there is a very good reason why the weak invariants are called ‘weak’. Imagine we keep the Hamiltonian the same, but instead we double the unit cell in each direction. This folds the Brillouin zone onto itself such that $k=\pi$ is mapped to $k=0$. This doesn’t impact the strong invariant, but all the weak invariants become 0.</p>
<p>As a final illustration of the relation between weak and strong invariants, let’s see how the invariants change as a function of $M$ as we vary $M$ on a scale comparable with the band width.</p>
<p>We determine the topological invariant in the same way as for QSHE: we see if the phase of the reflection matrix connects the Pfaffians of $r(k_y=0)$ and $r(k_y=\pi)$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">'png'</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">0.2</span>, C=<span class="number">0</span>, D1=<span class="number">0.1</span>, D2=<span class="number">0</span>, M=<span class="literal">None</span>, Bz=<span class="number">0</span>)</span><br><span class="line">syst = bhz(Z=<span class="number">15</span>, system_type=<span class="string">"slab"</span>)</span><br><span class="line">fsyst = make_scatter_sys()</span><br><span class="line">k = np.linspace(-np.pi, np.pi)</span><br><span class="line">Ms = np.linspace(<span class="number">-2.75</span>, <span class="number">0.75</span>, <span class="number">11</span>)</span><br><span class="line">hm1 = holoviews.HoloMap(</span><br><span class="line">    &#123;</span><br><span class="line">        p.M: spectrum(syst, p, k_x=k, k_y=k, k_z=<span class="number">0</span>, title=title, num_bands=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms</span><br><span class="line">    &#125;,</span><br><span class="line">    kdims=[<span class="string">r"$M$"</span>],</span><br><span class="line">)</span><br><span class="line">hm2 = holoviews.HoloMap(</span><br><span class="line">    &#123;p.M: scattering_det_pfaff(fsyst, p) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r"$M$"</span>]</span><br><span class="line">)</span><br><span class="line">hm1 + hm2</span><br></pre></td></tr></table></figure>

<p>We see the values of the invariants change several times:</p>
<ul>
<li>Initially, when $M&gt;0$, the system is trivial.</li>
<li>Then, as $M$ is lowered, the topological invariants become $\mathcal{Q}(k_x=0) = 1$ and $\mathcal{Q}(k_x=\pi) = 0$, and there’s a Dirac cone at $k=0$.</li>
<li>When $M$ is lowered further, two new Dirac cones appear at $k = (0,\pi)$ and $k = (\pi, 0)$. This changes the invariants to $\mathcal{Q}(k_x=0) = 0$ and $\mathcal{Q}(k_x=\pi) = 1$.</li>
<li>Finally one more Dirac cone appears at $k = (\pi, \pi)$, accompanied by both invariants becoming trivial.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">"Suppose you have a $(0;100)$ weak topological insulator. Which one of the following statements is correct?"</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"There is an even number of Dirac cones for both $k_x=0$ and $k_x=\pi$."</span>,</span><br><span class="line">    <span class="string">"There is an even number of Dirac cones for $k_x=0$ and an odd one for $k_x=\pi$."</span>,</span><br><span class="line">    <span class="string">"There is an odd number of Dirac cones for $k_x=0$ and an even one for $k_x=\pi$."</span>,</span><br><span class="line">    <span class="string">"There is an odd number of Dirac cones for both $k_x=0$ and $k_x=\pi$."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"We know that the strong invariant $Q(k_x=0)Q(k_x=\pi)=0$, so there must be an even number of Dirac cones in total. "</span></span><br><span class="line">    <span class="string">"The number at $k_x=\pi$ is odd because $Q(k_x=\pi)=1$, so the number at $k_x=0$ must also be odd."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Quantum-Hall-conductance-and-the-magneto-electric-effect"><a href="#Quantum-Hall-conductance-and-the-magneto-electric-effect" class="headerlink" title="Quantum Hall conductance and the magneto-electric effect"></a>Quantum Hall conductance and the magneto-electric effect</h1><p>So, what happens if we measure the Hall conductance of a 3D topological insulator? Will we actually obtain a half-integer? If you followed the course closely, you will know that the answer is negative, and that the Hall conductance is always quantized to an integer. So what is going on when we measure the Hall conductance?</p>
<p>To answer this question we need to remember that we cannot just consider one surface on its own. Each surface is connected to the sides and other surfaces. Let’s consider a part of a 3D TI in magnetic field:</p>
<p><img src="/2021/01/07/src/w6_3dti/bhz/3d_ti_slab.svg" alt></p>
<p>The top surface has the quantum Hall conductance $(n + 1/2)e^2/h$, but it is not the only part of the material. The bottom surface is also subject to a magnetic field and hence contributes a half-integer Hall conductance as well.</p>
<p>In total we thus get $\sigma_{xy} = (2n + 1) e^2/h$: an integer, which resolves the apparent paradox. While this statement sounds relatively simple, there are entire papers dedicated to the question whether it’s possible to measure a half-integer Hall conductance (the answer is ‘not really’).</p>
<p>Finally, let’s look at the dispersion of the Landau levels and edge states:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%output size=<span class="number">150</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=<span class="number">-1</span>, Bz=<span class="number">0.125</span>)</span><br><span class="line">lead = bhz(Y=<span class="number">20</span>, Z=<span class="number">10</span>, system_type=<span class="string">"lead"</span>)</span><br><span class="line">k = np.linspace(<span class="number">-3.5</span>, <span class="number">1.5</span>)</span><br><span class="line">kwargs = &#123;<span class="string">"ylims"</span>: [<span class="number">-0.8</span>, <span class="number">0.8</span>], <span class="string">"yticks"</span>: <span class="number">5</span>&#125;</span><br><span class="line">spectrum(lead, p, k_x=k, **kwargs)</span><br></pre></td></tr></table></figure>

<p>We see that the Landau levels come in pairs. In each such pair, one level comes from the top surface, and one from the bottom surface. The magnetic field is parallel to the side surfaces, so there is no gap there. The edge states propagate freely along the side surfaces and are reflected by the magnetic field as they try to enter either the top or the bottom surfaces.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"Suppose that you take the 3D TI slab above, and connect the left and right surfaces, making it into "</span></span><br><span class="line">    <span class="string">"a very thick Corbino disk. "</span></span><br><span class="line">    <span class="string">"You then apply to it a strong perpendicular field in the same direction as in the figure, perpendicular to the top "</span></span><br><span class="line">    <span class="string">"and bottom surfaces. "</span></span><br><span class="line">    <span class="string">"What happens if you throw an additional flux quantum through the inner hole of the disk?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"A half-integer number of electron charges is transferred from the inner to the outer surface of the disk."</span>,</span><br><span class="line">    <span class="string">"An integer number of electron charges is transferred from the inner to the outer surface of the disk."</span>,</span><br><span class="line">    <span class="string">"An integer number of charges is transferred from the top to the bottom surface of the disk."</span>,</span><br><span class="line">    <span class="string">"The bulk gap closes."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"The top and bottom surfaces combined form an integer quantum Hall state. "</span></span><br><span class="line">    <span class="string">"Hence the whole system acts like a Laughlin pump, exactly like in the purely 2D case."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusion-integers-half-integers-and-two-types-of-electromagnetic-response"><a href="#Conclusion-integers-half-integers-and-two-types-of-electromagnetic-response" class="headerlink" title="Conclusion: integers, half-integers, and two types of electromagnetic response"></a>Conclusion: integers, half-integers, and two types of electromagnetic response</h1><p>Before we move on to the next lecture, Joel Moore will tell us more about the origins of the peculiar electromagnetic response of topological insulators, and a fascinating connection to high energy physics.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"s7H6oLighOM"</span>, src_location=<span class="string">"6.1-summary"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"3DTI invariants"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w6_3dti/3dti_signatures" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w6_3dti/3dti_signatures/"
    >src/w6_3dti/3dti_signatures</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w6_3dti/3dti_signatures/" class="article-date">
  <time datetime="2021-01-07T09:11:06.855Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> sla</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">"ignore"</span>, UserWarning)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span><span class="params">(L, W, H, system_type)</span>:</span></span><br><span class="line">    <span class="string">"""A cuboid region of BHZ material with two leads attached.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    parameters for leads and scattering region can be defined separately</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Onsite and hoppings matrices used for building BHZ model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * pauli.s0s0 + (</span><br><span class="line">            p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2</span><br><span class="line">        ) * pauli.s0sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sxsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sysx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * pauli.s0s0 - p.B1 * pauli.s0sz + p.A1 * <span class="number">0.5j</span> * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_lead</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; H) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_syst</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; H) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= x &lt; L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx_phase</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1, z1 = site1.pos</span><br><span class="line">        x2, y2, z2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(<span class="number">-0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">"sys"</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line">        syst[lat.shape(shape_syst, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_scat * np.eye(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">"lead"</span>:</span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        syst = kwant.Builder(sym)</span><br><span class="line">        syst[lat.shape(shape_lead, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">"infinite"</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx_phase</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_scatter</span><span class="params">(L, W, H)</span>:</span></span><br><span class="line">    syst = bhz(L, W, H, <span class="string">"sys"</span>)</span><br><span class="line">    lead = bhz(L, W, H, <span class="string">"lead"</span>)</span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.reversed())</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cond_mu</span><span class="params">(p, L, W, H)</span>:</span></span><br><span class="line">    p.mu_lead = <span class="number">0.7</span></span><br><span class="line">    syst = bhz_scatter(L, W, H)</span><br><span class="line">    sys_leads_fixed = syst.finalized().precalculate(energy=<span class="number">0</span>, params=dict(p=p))</span><br><span class="line">    mus = np.linspace(<span class="number">-0.4</span>, <span class="number">0.4</span>, <span class="number">40</span>)</span><br><span class="line">    cond = [</span><br><span class="line">        kwant.smatrix(</span><br><span class="line">            sys_leads_fixed, energy=<span class="number">0</span>, params=dict(p=p.update(mu_scat=mu))</span><br><span class="line">        ).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> mu <span class="keyword">in</span> mus</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> np.array(cond), mus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_cond_mu</span><span class="params">(cond, mus)</span>:</span></span><br><span class="line">    xdim, ydim = [<span class="string">r"$\mu$"</span>, <span class="string">r"$G\,[e^2/h]$"</span>]</span><br><span class="line">    kwargs = &#123;<span class="string">"kdims"</span>: [xdim, ydim]&#125;</span><br><span class="line">    plot = holoviews.Path((mus, cond), **kwargs).opts(</span><br><span class="line">        plot=&#123;<span class="string">"xticks"</span>: <span class="number">3</span>, <span class="string">"yticks"</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;, style=&#123;<span class="string">"color"</span>: <span class="string">"r"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> plot.redim.range(**&#123;xdim: (<span class="number">-0.4</span>, <span class="number">0.4</span>), ydim: (<span class="number">0</span>, <span class="number">8</span>)&#125;).relabel(<span class="string">"Conductance"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_bands</span><span class="params">(p, L, W, H)</span>:</span></span><br><span class="line">    lead = bhz(L, W, H, <span class="string">"lead"</span>)</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">"k_x"</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">101</span>),</span><br><span class="line">        <span class="string">"ylims"</span>: [<span class="number">-1</span>, <span class="number">1</span>],</span><br><span class="line">        <span class="string">"yticks"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">"xticks"</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r"$-\pi/3$"</span>), (<span class="number">0</span>, <span class="string">r"$0$"</span>), (np.pi / <span class="number">3</span>, <span class="string">r"$\pi/3$"</span>)],</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu_lead = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> spectrum(lead, p, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_cond_spect</span><span class="params">(mu, cond_plot, bands_plot)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cond_plot * holoviews.VLine(mu).opts(</span><br><span class="line">        style=&#123;<span class="string">"color"</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">    ) + bands_plot.relabel(<span class="string">"Spectrum"</span>) * holoviews.HLine(mu).opts(style=&#123;<span class="string">"color"</span>: <span class="string">"b"</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_warping</span><span class="params">(A=<span class="number">1.2</span>, B=<span class="number">1.8</span>, C=<span class="number">1.5</span>, Kmax=<span class="number">1.0</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate_on_grid</span><span class="params">(X, Y, func)</span>:</span></span><br><span class="line">        <span class="string">""" X, Y should be in np.meshgrid form. It's enough for func to work on floats. """</span></span><br><span class="line">        data = []</span><br><span class="line">        <span class="keyword">for</span> xx, yy <span class="keyword">in</span> zip(X, Y):</span><br><span class="line">            data.append([func(i, j) <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(xx, yy)])</span><br><span class="line">        data = np.array(data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_energy_function</span><span class="params">(A, B, C)</span>:</span></span><br><span class="line">        <span class="string">""" Used for plotting of hexagonal warping. """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(kx, ky)</span>:</span></span><br><span class="line">            matrix = (</span><br><span class="line">                A * (kx ** <span class="number">2</span> + ky ** <span class="number">2</span>) * pauli.s0</span><br><span class="line">                + B * (kx * pauli.sy - ky * pauli.sx)</span><br><span class="line">                + C * <span class="number">0.5</span> * ((kx + <span class="number">1j</span> * ky) ** <span class="number">3</span> + (kx - <span class="number">1j</span> * ky) ** <span class="number">3</span>) * pauli.sz</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> sla.eigh(matrix)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">    zmin, zmax = <span class="number">-1.0</span>, <span class="number">3.5</span></span><br><span class="line">    xylims = (<span class="number">-1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    zlims = (<span class="number">-1.0</span>, <span class="number">3.5</span>)</span><br><span class="line">    kdims = [<span class="string">r"$k_x$"</span>, <span class="string">r"$k_y$"</span>]</span><br><span class="line">    vdims = [<span class="string">r"E"</span>]</span><br><span class="line">    <span class="comment"># Generate a circular mesh</span></span><br><span class="line">    N = <span class="number">100</span></span><br><span class="line">    r = np.linspace(<span class="number">0</span>, Kmax, N)</span><br><span class="line">    p = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, N)</span><br><span class="line">    r, p = np.meshgrid(r, p)</span><br><span class="line">    x, y = r * np.cos(p), r * np.sin(p)</span><br><span class="line">    energies = evaluate_on_grid(x, y, func=get_energy_function(A, B, C))</span><br><span class="line"></span><br><span class="line">    xy_ticks = [<span class="number">-1.2</span>, <span class="number">0</span>, <span class="number">1.2</span>]</span><br><span class="line">    zticks = [<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">    style = &#123;<span class="string">"xticks"</span>: xy_ticks, <span class="string">"yticks"</span>: xy_ticks, <span class="string">"zticks"</span>: zticks&#125;</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">"extents"</span>: (xylims[<span class="number">0</span>], xylims[<span class="number">0</span>], zlims[<span class="number">0</span>], xylims[<span class="number">1</span>], xylims[<span class="number">1</span>], zlims[<span class="number">1</span>]),</span><br><span class="line">        <span class="string">"kdims"</span>: kdims,</span><br><span class="line">        <span class="string">"vdims"</span>: vdims,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hex_cmap colormap is defined below.</span></span><br><span class="line">    plot = holoviews.Overlay(</span><br><span class="line">        [</span><br><span class="line">            holoviews.TriSurface(</span><br><span class="line">                (x.flat, y.flat, energies[:, :, i].flat), **kwargs</span><br><span class="line">            ).opts(style=dict(cmap=hex_cmap, linewidth=<span class="number">0</span>), plot=style)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(energies.shape[<span class="number">-1</span>])</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=&#123;<span class="string">"Overlay"</span>: &#123;<span class="string">"fig_size"</span>: <span class="number">350</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom colormap for the hexagonal warping plot</span></span><br><span class="line">cmap_list = [</span><br><span class="line">    ((value + <span class="number">1</span>) / <span class="number">4.0</span>, colour)</span><br><span class="line">    <span class="keyword">for</span> value, colour <span class="keyword">in</span> zip([<span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">3.0</span>], [<span class="string">"Blue"</span>, <span class="string">"White"</span>, <span class="string">"Red"</span>])</span><br><span class="line">]</span><br><span class="line">hex_cmap = matplotlib.colors.LinearSegmentedColormap.from_list(<span class="string">"custom"</span>, cmap_list)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction-searching-the-periodic-table-for-topological-materials"><a href="#Introduction-searching-the-periodic-table-for-topological-materials" class="headerlink" title="Introduction: searching the periodic table for topological materials"></a>Introduction: searching the periodic table for topological materials</h1><p>How do we find a topological insulator? In the first video of today, David Vanderbilt from Rutgers University will tell us more about the material science aspects of topological insulators research.</p>
<p>This is an expertise that no one from the course team has, so pay close attention to it: this material stands apart from the rest.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"62ZObitJ4DM"</span>, src_location=<span class="string">"6.2-intro"</span>)</span><br></pre></td></tr></table></figure>

<p>In the rest of the lecture, we will instead discuss the experimental signatures of 3D topological insulators, similarly to what we did in the previous week for their 2D counterparts.</p>
<p>All the figures showing the experimental data are copyright of the Zahid Hasan lab, Princeton, 2015. They are available under CC-BY-NC-SA 4.0 International license.</p>
<h1 id="Conductance-of-a-3D-topological-insulator"><a href="#Conductance-of-a-3D-topological-insulator" class="headerlink" title="Conductance of a 3D topological insulator"></a>Conductance of a 3D topological insulator</h1><p>Both the quantum Hall and quantum spin Hall states have striking conductance quantization properties, thanks to the presence of perfectly transmitting one-dimensional transport channels.</p>
<p>The 3D topological insulators do not posses similar striking conductance properties. In a slab geometry, the surface states contribute with a finite density of propagating states. This density has a minimum at the Dirac point. The conductance increases roughly with a hyperbolic shape if the chemical potential is tuned away from the Dirac point as shown in the plot below:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=<span class="number">-1</span>, Bz=<span class="number">0</span>, mu_scat=<span class="number">0</span>)</span><br><span class="line">L, W, H = <span class="number">10</span>, <span class="number">30</span>, <span class="number">6</span></span><br><span class="line">cond, mus = cond_mu(p, L, W, H)</span><br><span class="line">cond_plot = plot_cond_mu(cond, mus)</span><br><span class="line">bands_plot = plot_bands(p, L, W, H)</span><br><span class="line">mus = np.linspace(<span class="number">-0.4</span>, <span class="number">0.4</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;mu: plot_cond_spect(mu, cond_plot, bands_plot) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r"$\mu$"</span>]</span><br><span class="line">).collate()</span><br></pre></td></tr></table></figure>

<p>It is also the behavior that is observed experimentally. In the figure below, you see that the resistance of a 3D TI slab reaches a maximum and then decreases as the chemical potential difference between its top and bottom surfaces is varied.</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/zero_field_Rxx.png" alt></p>
<p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>Note that in such a measurement, you cannot separate contributions of states coming from the different surfaces, or potentially also from the sides or the sample, or even from the bulk - we’ll discuss this issue soon in more detail.</p>
<p>Nevertheless, the observed maximum in resistance corresponds to the minimum in conductance computed just above, and it demonstrates the presence of a Dirac point between the conduction and valence bands.</p>
<p>This behavior discussed above is not very striking. For instance, the same behavior is observed in graphene. The conductance is not sensitive to degeneracies in the electron spectrum in a qualitative way, so just from it, we cannot demonstrate that the surface of a 3D TI has a single Dirac cone, unlike graphene which has four. Hence, while the measurement above is a signature of a surface state, it is not a particularly striking one.</p>
<p>Perhaps we will be more lucky with topological signatures of 3D topological insulators, if we look at the Hall conductance?</p>
<h1 id="Landau-levels"><a href="#Landau-levels" class="headerlink" title="Landau levels"></a>Landau levels</h1><p>In last chapter, we saw that one single surface of a 3D topological insulator is characterized by a Hall conductance of $ (n+1/2), e^2/h$. We also pointed out that there are always two surfaces, say the top and bottom one of a slab, which gives a total Hall conductance of $(2n+1),e^2/h$ and makes it hard to observe the half-integer Hall conductance.</p>
<p>You may say - OK, we can live with this and be happy with our $(2n+1)$ sequence. After all, it looks almost as unique as the $(n+1/2)$ sequence. Sure, it does not allow us to see directly the half-integer value, but it gives a step between plateaus which is twice the usual one, and no plateau with $n=0$. After all, measuring <em>twice</em> that sequence was a good enough probe for graphene.</p>
<p>So let’s look at a Hall conductance measurements performed on a slab of a 3D TI, focusing for instance on the blue trace.</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/LL_spectroscopy.png" alt></p>
<p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>You see a sequence of plateaus with integer steps of a normal height $e^2/h$. Nothing special. Why did our prediction of a $(2n+1)$ sequence fail?</p>
<p>The reason is that there is no symmetry at all between top and bottom surfaces, they are really independent. For instance, they might have different doping, and hence be characterized by different values $n_\textrm{top}$ and $n_\textrm{bottom}$ of the Chern integer.</p>
<p>Therefore, rather than observing a sequence $e^2/h,(2n+1)$, we observe a more conventional sequence given by $e^2/h,(n_\textrm{top}+n_\textrm{bottom}+1)$, with the usual $e^2/h$ steps between different plateaus.</p>
<p>So, even by studying the Landau levels experimentally, we do not get a topological signature. But do not despair, luckily there is a much better thing that we can do rather than just measuring conductance: looking at the energy spectrum of the surface states directly.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">"Which control parameter can remove the 0th plateau in the QHE measurement? "</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"Increasing the magnetic field."</span>,</span><br><span class="line">    <span class="string">"Gate voltage difference (which controls difference in electron density) between the surfaces."</span>,</span><br><span class="line">    <span class="string">"Increasing topological mass."</span>,</span><br><span class="line">    <span class="string">"Adding an in-plane magnetic field."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"Gate voltage difference changes the filling of the individual states without shifting the total density of electrons. "</span></span><br><span class="line">    <span class="string">"This can therefore shift the plateaus of each surface. Magnetic field and topological mass are part of generating the "</span></span><br><span class="line">    <span class="string">" $0^&#123;th&#125;$ plateau to begin with so cannot eliminate it. "</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Spectroscopy-of-the-surface-of-a-3D-topological-insulator"><a href="#Spectroscopy-of-the-surface-of-a-3D-topological-insulator" class="headerlink" title="Spectroscopy of the surface of a 3D topological insulator"></a>Spectroscopy of the surface of a 3D topological insulator</h1><p>Amazingly, the surface states of a 3D topological insulator can be directly imaged experimentally using the technique of Angle Resolved Photo Emission Spectroscopy - or, in short, <a href="http://en.wikipedia.org/wiki/Angle-resolved_photoemission_spectroscopy" target="_blank" rel="noopener">ARPES</a>.</p>
<p>In ARPES, X-ray photons are shot vertically into a metal surface in order to eject electrons out of it. Due to energy and momentum conservation, the emitted electrons have the same momentum (parallel to the surface) that they had in the crystal, and an energy which is related to their band energy in the crystal. Hence, ARPES is the ideal tool to measure the energy dispersion of the surface states of a solid, i.e. $E(k_x, k_y)$ as a function of momenta $\hbar k_x$ and $\hbar k_y$.</p>
<p>Below, we see an example of ARPES spectra for the surface states of a strong topological insulator Bi$_2$ Se$_3$:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/arpes_fig1.png" alt></p>
<p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>ARPES can only eject electrons - so only occupied states below the Fermi level are visible in the experiment, but of course one can still map out the Fermi surface at different energies by changing the chemical potential in the crystal. In the ARPES results above we see the results for different dopings of the crystal.</p>
<p>In the top panel of the figure above, we see that by changing the chemical potential, the Fermi surface shrinks from a circle to a point, exactly what you would expect for electrons with a Dirac-like dispersion.</p>
<p>While the top panels shows where the occupied states lie in the $(k_x, k_y)$ plane, in the second and third rows we see a cross-section of the energy as a function of momentum, where the Dirac cone is clearly visible, emerging from a bulk valence band filled with electrons.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">"Why do you think ARPES observes surface states even if there is conductance through the bulk?"</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"ARPES can only observe occupied states and therefore bulk conductance is not an issue. "</span>,</span><br><span class="line">    <span class="string">"Since ARPES measures the spectrum in a momentum resolved way, it can separate out surface and bulk states."</span>,</span><br><span class="line">    <span class="string">"ARPES does not measure conductance and therefore bulk electronic states are not an issue."</span>,</span><br><span class="line">    <span class="string">"Since ARPES measures the spectrum in an energy resolved way, it can selectively choose the surface states in the bulk gap."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"The surface states live within the energy gap of the bulk. Since ARPES directly measure $E(k)$, it separates out "</span></span><br><span class="line">    <span class="string">"surface states from bulk states, which are in different energy ranges. "</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Quasiparticle-interference-QPI"><a href="#Quasiparticle-interference-QPI" class="headerlink" title="Quasiparticle interference (QPI)"></a>Quasiparticle interference (QPI)</h1><p>Scanning tunneling microscopy (STM) is another tool to image surface states in a topological insulator. In the process of STM we tunnel electrons into the surface from a metallic tip. In contrast to ARPES, the electrons are not going into free space, so we don’t have momentum resolution. On the other hand, we do trade momentum resolution for nearly atomic spatial resolution. We know where exactly on the surface the electron came from.</p>
<p>Tunneling into a uniform surface can tell us a little bit about which orbital on an atom, the electrons at a certain energy come from. Otherwise, we’d see a uniform surface, which wouldn’t have much information.  We can make things more interesting and, strangely enough, get more information by sprinkling some impurities on the surface. The impurities scatter the surface electrons and produce a standing wave pattern on the surface, which depends on the Fermi surface momenta of the electrons at the particular tunneling energy (Note: in this unit we refer to the equal energy surface in momentum space at the tunneling energy as Fermi surface for convenience). The resulting pattern is referred to QPI. Specifically, Fourier transforming the QPI pattern directly maps out the momentum transfer across the Fermi-surface of the surface state.</p>
<p>Clearly, we can expect to map out some properties of the momentum space scattering on the surface of the topological insulator.</p>
<p>In the simulation below. we see that the Fourier transform shows an interesting pattern:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/QPI_pic_adapted.png" alt><br>(adapted, copyright Hasan lab, Princeton, see license in the beginning of the chapter)  </p>
<p>By comparing the QPI patterns showing spin-dependent and spin-independent scattering (respectively on the left and right column on the right side of the arrow), we see that the intensity at momenta connecting opposite points on the Fermi surface is suppressed in the case of spin-independent scattering.</p>
<p>In fact, by comparing the fourier transform of the QPI on the right with the Fermi surface on the left, we begin to see that the absence of back-scattering, which is one of the key properties of the topological insulator surface state plays a key role. As you might remember from the quantum spin hall systems - elastic backscattering of electrons is forbidden between states at $\bf k$ and $-\bf k$ because of Kramers’ theorem. Looking at the QPI pattern from spin-independent impurities and comparing it with the Fermi surface confirms this.</p>
<h1 id="The-issue-of-bulk-conductivity"><a href="#The-issue-of-bulk-conductivity" class="headerlink" title="The issue of bulk conductivity"></a>The issue of bulk conductivity</h1><p>One of the central issues that has plagued the experimental progress with topological insulators is the presence of bulk doping or conductance in most naturally grown crystals. You can see this simply by looking at the ARPES plots below:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/bulk_conductance_TI.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>What you see is that the Fermi-energy, which is the highest energy till which you can eject electrons in ARPES intersects the conduction band. This means that in the native state the conduction band of the electrons is occupied and the fermi level is not in the gap. In the figure above, the situation is worst for pure Antimony in the extreme left panel, which is really a semimetal with overlapping electron and hole bands. In this case, independent of fermi level position, the system would remain metallic. Moving from pure Sb to $Bi_2 Se_3$ improves this somewhat, but still does not make this an insulator. Theoretically, we do expect pure $Bi_2 Se_3$ to be an insulator - but in reality, the system typically have Se vacancies, which make it metallic.</p>
<p>Being metallic really ruins a lot of interesting properties of the topological insulators. So a lot of effort is going in to fixing it up. Below, we see some of the results from these attempts:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/insulating_TI.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>where various combinations of $Bi$, $Se$ and $Te$ have been combined to drive the system insulating. By looking at the ARPES spectra, it should look convincing that by varying different conditions, the fermi level is indeed shifting in to the interior of the gap. The experimental tricks used to get this working range between changing the pressure of various elements in the growth condition to counter doping the surface etc.  But the resistance results seem to be improving quite a bit.</p>
<h1 id="Hexagonal-warping"><a href="#Hexagonal-warping" class="headerlink" title="Hexagonal warping"></a>Hexagonal warping</h1><p>ARPES measurements on the surface of topological materials in the bismuth family also demonstrated an interesting (even though non-topological) feature of the surface states.</p>
<p>The effective Dirac Hamiltonian is linear in momentum and has a full rotational symmetry in the $(x,y)$ plane of the surface, making the Fermi surface circular. However, moving away in energy from the Dirac point, experimentalists observed a different shape of the Fermi surface, similar to a snowflake:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/warping.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>It’s clear that this shape cannot be explained by the Dirac Hamiltonian with its rotational invariance. In order to take into account this deformation of the Fermi surface, we have to think about the crystal symmetries of the surface. In BiSe and BiTe compounds, there is no full rotational symmetry, but only a lower three-fold rotation symmetry. We can take into account this effect by adding a correction to the effective Dirac Hamiltonian.</p>
<p>This is exactly what was done in this article:</p>
<ul>
<li>arXiv:0908.1418</li>
</ul>
<p>There Liang Fu made a relatively simple theoretical exercise. He listed all the terms in the Hamiltonian allowed by time-reversal and crystalline symmetries, that are proportional to $k^3.$ This is the result:</p>
<p>$$<br>H(\mathbf{k}) = E_0(k) + v, (1+\alpha \mathbf{k}^2),(k_x\sigma_y - k_y\sigma_x) + \frac{\lambda}{2},(k^3_++k^3_-),\sigma_z.<br>$$</p>
<p>You see a correction to the Dirac velocity proportional to $\alpha \mathbf{k}^2$, which doesn’t break the rotational symmetry, as well as the term with $\lambda$, which is responsible for the warping.</p>
<p>Let’s plot the spectrum of this extended effective Hamiltonian:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">'png'</span></span><br><span class="line"></span><br><span class="line">plot_warping()</span><br></pre></td></tr></table></figure>

<p>This Hamiltonian reproduces correctly the <em>hexagonal warping</em> of the Fermi surface. In particular, independently of the parameters $\lambda$ and $\alpha$, the vertices of the hexagon are always aligned with the $x$ crystal axis, as is observed experimentally.</p>
<p>In addition to modifying the shape of the Fermi surface, we see that the extra term is proportional to $\sigma_z$, and rotates the spin of the surface state out of plane. This strongly affects the scattering properties of the surface state.</p>
<h1 id="Outlook-from-basic-science-to-potential-applications"><a href="#Outlook-from-basic-science-to-potential-applications" class="headerlink" title="Outlook: from basic science to potential applications"></a>Outlook: from basic science to potential applications</h1><p>David Vanderbilt will conclude this week’s lectures by offering a perspective on the future of the field.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"WZmNeEwM1N4"</span>, src_location=<span class="string">"6.2-summary"</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"3DTI materials and signatures"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w5_qshe/qshe_experiments" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w5_qshe/qshe_experiments/"
    >src/w5_qshe/qshe_experiments</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w5_qshe/qshe_experiments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.853Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">"ignore"</span>, UserWarning)</span><br><span class="line"></span><br><span class="line">bhz_parameters = &#123;</span><br><span class="line">    <span class="string">"topo"</span>: &#123;<span class="string">"A"</span>: <span class="number">0.5</span>, <span class="string">"B"</span>: <span class="number">1.00</span>, <span class="string">"D"</span>: <span class="number">0.0</span>, <span class="string">"M"</span>: <span class="number">0.2</span>&#125;,</span><br><span class="line">    <span class="string">"topo2"</span>: &#123;<span class="string">"A"</span>: <span class="number">0.5</span>, <span class="string">"B"</span>: <span class="number">1.00</span>, <span class="string">"D"</span>: <span class="number">0.0</span>, <span class="string">"M"</span>: <span class="number">1.0</span>&#125;,</span><br><span class="line">    <span class="string">"triv"</span>: &#123;<span class="string">"A"</span>: <span class="number">0.5</span>, <span class="string">"B"</span>: <span class="number">1.00</span>, <span class="string">"D"</span>: <span class="number">0.0</span>, <span class="string">"M"</span>: <span class="number">-0.2</span>&#125;,</span><br><span class="line">    <span class="string">"lead"</span>: &#123;<span class="string">"A_lead"</span>: <span class="number">1.5</span>, <span class="string">"B_lead"</span>: <span class="number">1.00</span>, <span class="string">"D_lead"</span>: <span class="number">0.0</span>, <span class="string">"M_lead"</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hopping functions for the BHZ model.</span></span><br><span class="line"><span class="comment"># Sometimes, we use different BHZ parameters in the</span></span><br><span class="line"><span class="comment"># scattering region and leads, so we treat them</span></span><br><span class="line"><span class="comment"># separately.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_onsite</span><span class="params">(site, p, is_lead=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        B, D, M = p.B_lead, p.D_lead, p.M_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        B, D, M = p.B, p.D, p.M</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (M - <span class="number">4</span> * B) * pauli.s0sz</span><br><span class="line">        - <span class="number">4</span> * D * pauli.s0s0</span><br><span class="line">        + p.ez_y * np.kron(pauli.sy, (pauli.s0 + pauli.sz) / <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _onsite(site, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_lead</span><span class="params">(site, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _onsite(site, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_hopx</span><span class="params">(site1, site2, p, is_lead=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        A, B, D = p.A_lead, p.B_lead, p.D_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A, B, D = p.A, p.B, p.D</span><br><span class="line">    <span class="keyword">return</span> B * pauli.s0sz + D * pauli.s0s0 + <span class="number">1j</span> * A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _hopx(site1, site2, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_lead</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _hopx(site1, site2, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_hopy</span><span class="params">(site1, site2, p, is_lead=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        A, B, D = p.A_lead, p.B_lead, p.D_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A, B, D = p.A, p.B, p.D</span><br><span class="line">    <span class="keyword">return</span> B * pauli.s0sz + D * pauli.s0s0 - <span class="number">1j</span> * A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _hopy(site1, site2, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_lead</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _hopy(site1, site2, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_terminal</span><span class="params">(L, w)</span>:</span></span><br><span class="line">    <span class="string">""" Make a two terminal system with the BHZ model. """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w <span class="keyword">and</span> <span class="number">0</span> &lt;= x &lt; L</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_two_term</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> onsite(site, p) - p.mu * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_two_term_lead</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> onsite_lead(site, p) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Scattering region</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite_two_term</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Leads</span></span><br><span class="line">    lead = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">-1</span>, <span class="number">0</span>)))</span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite_two_term_lead</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx_lead</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy_lead</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attach leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.reversed())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span><span class="params">(w=None)</span>:</span></span><br><span class="line">    <span class="string">"""Translationally invariant BHZ system with a infinite or fixed width w."""</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    <span class="keyword">if</span> w <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">            (x, y) = pos</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        syst = kwant.Builder(sym)</span><br><span class="line">        syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G_mu_plot</span><span class="params">(p, mus, color)</span>:</span></span><br><span class="line">    syst = two_terminal(<span class="number">40</span>, <span class="number">40</span>).finalized()</span><br><span class="line">    G = [</span><br><span class="line">        kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=dict(p=p)).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus</span><br><span class="line">    ]</span><br><span class="line">    ydim = <span class="string">r"G $[e^2/h]$"</span></span><br><span class="line">    kdims = [<span class="string">r"$\mu$"</span>, ydim]</span><br><span class="line">    plot = holoviews.Path((mus, np.array(G)), kdims=kdims, label=<span class="string">"Conductance"</span>)</span><br><span class="line">    ticks = &#123;<span class="string">"xticks"</span>: [<span class="number">-0.8</span>, <span class="number">-0.4</span>, <span class="number">0</span>, <span class="number">0.4</span>, <span class="number">0.8</span>], <span class="string">"yticks"</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.range(**&#123;ydim: (<span class="number">0</span>, <span class="number">10</span>)&#125;).opts(plot=ticks, style=&#123;<span class="string">"color"</span>: color&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G_Ez_plot</span><span class="params">(p, E_zs)</span>:</span></span><br><span class="line">    syst = two_terminal(<span class="number">40</span>, <span class="number">20</span>).finalized()</span><br><span class="line">    G = [</span><br><span class="line">        kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=dict(p=p)).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> p.ez_y <span class="keyword">in</span> E_zs</span><br><span class="line">    ]</span><br><span class="line">    ydim = <span class="string">r"G $[e^2/h]$"</span></span><br><span class="line">    kdims = [<span class="string">r"$E_z$"</span>, ydim]</span><br><span class="line">    plot = holoviews.Path((E_zs, np.array(G)), kdims=kdims, label=<span class="string">"Conductance"</span>)</span><br><span class="line">    ticks = &#123;<span class="string">"xticks"</span>: [<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">0.10</span>, <span class="number">0.15</span>], <span class="string">"yticks"</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>]&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.range(**&#123;ydim: (<span class="number">0</span>, <span class="number">2</span>)&#125;).opts(plot=ticks)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"-HRBuCgOUvs"</span>, src_location=<span class="string">"5.2-intro"</span>)</span><br></pre></td></tr></table></figure>

<p>This topic is special, since in order to meaningfully discuss experimental progress we need to do something we didn’t do before in the course: we will show you the measurements and compare them with the <em>simple</em> theoretical expectations. Like this we will see what agrees and what doesn’t.</p>
<p>All the figures showing the experiments are copyright Physical Society of Japan (2008), published in <a href="http://journals.jps.jp/doi/abs/10.1143/JPSJ.77.031007" target="_blank" rel="noopener"><br>J. Phys. Soc. Jpn. 77, 031007 (2008)</a> by  Markus König, Hartmut Buhmann, Laurens W. Molenkamp, Taylor Hughes, Chao-Xing Liu, Xiao-Liang Qi, and Shou-Cheng Zhang. They are available under CC-BY-NC-SA 4.0 International license.</p>
<h1 id="Two-limits-Mexican-hat-and-weak-pairing"><a href="#Two-limits-Mexican-hat-and-weak-pairing" class="headerlink" title="Two limits: Mexican hat and weak pairing"></a>Two limits: Mexican hat and weak pairing</h1><p>We just learned that topological insulators with inversion symmetry were simpler to think about. We will now use the  topological invariant to find a simple recipe for finding topological insulators. All we need to do is somehow vary the parity of the occupied states. One fact of nature that comes to our aid in this is that electrons in semiconductors typically occupy even parity $s$-orbitals and odd parity $p$-orbitals.</p>
<p>If we look up the bandstructure of a typical “non-topological” semiconductor, the highest valence-band is of odd parity and the lowest conduction band is even parity. As one moves down the periodic table to heavier elements with larger spin-orbit coupling the odd parity orbital switches spots with the even parity orbital. This <em>band inversion</em> is the domain where we can hope to find topological insulators.</p>
<p>Now you might think that all we have to do is go down the periodic table to heavier elements and just pick some material like HgTe (actually used in the creation of QSHE), but that’s not all yet. We still need to make a quantum well out of this semiconductor to make the system two-dimensional. This leads to two dimensional bands derived from the three dimensional band structure.</p>
<p>By carefully choosing the widths, it is possible to invert the odd and even parity bands. We saw from the last unit, that such a band-inversion leads to a topologically non-trivial value of the parity invariant. Right around the topological transition, the even and odd parity bands are degenerate. Thus, we can follow the discussion in the last unit to derive domain wall states at the edges.</p>
<p>We can write down the simplest Hamiltonian for an even and an odd parity band in a basis $|e,\sigma\rangle$ and $|o,\sigma\rangle$ in a block form </p>
<p>$$H({\bf k})=\left(\begin{array}{cc}\epsilon_e({\bf k})&amp;\Delta({\bf k})\\Delta^\dagger({\bf k})&amp;\epsilon_o({\bf k})\end{array}\right),$$</p>
<p>where $\Delta({\bf k})$ is the $2\times 2$ hybridization matrix. Inversion and time-reversal symmetries imply that $\Delta({\bf k})=-\Delta(-{\bf k})$ is odd under inversion and even under time-reversal.  Here we will focus on one such model, $\Delta({\bf k})=\alpha\sigma_z(k_x+i k_y)$, which we call the Bernevig-Hughes-Zhang model. </p>
<p>Since the even band is electron-like, we approximate the even-band dispersion $\epsilon_e({\bf k})$<br>as $\epsilon_e({\bf k}) = \delta_e + m_e k^2$, while we take the odd parity dispersion to be $\epsilon_o({\bf k})= \delta_o - m_o k^2$ for simplicity. The band inversion happens when $\delta_e &lt; \delta_o$.</p>
<p>The spectrum of this Hamiltonian is very similar to that of a Chern insulator (after all we essentially just doubled the degrees of freedom). Just like in most topological systems, the shape of the band structure depends on the relative strength of band inversion and inter-band coupling.</p>
<p>So below we see a qualitative band structure of one of the QSHE insulators, HgTe/CdTe quantum well, compared with the band structure of InAs/GaSb quantum well.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p_triv = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">0.0</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=<span class="number">-0.1</span>, M=<span class="number">-0.2</span>)</span><br><span class="line">p_topo = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">0.0</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=<span class="number">-0.1</span>, M=<span class="number">1.5</span>)</span><br><span class="line">syst = bhz()</span><br><span class="line">kwargs = &#123;<span class="string">"zticks"</span>: [<span class="number">-8</span>, <span class="number">-4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>]&#125;</span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p_triv, **kwargs).relabel(<span class="string">"Trivial"</span>)</span><br><span class="line">    + spectrum(syst, p_topo, **kwargs).relabel(<span class="string">"Topological"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In the last unit, we understood the nature of the edge modes near the topological phase transition, where a doubled Dirac model was appropriate. Deep in the strongly band-inverted topological regime, the bulk band structure has a mexican hat structure with the gap proportional to $\alpha$. </p>
<p>The edge modes in this regime are quite different in structure from those near the topological transition. To see this, let us first set $k_y=0$ in the Hamiltonian. If we set $\alpha=0$ then there are two fermi points where the dispersion is roughly linear - let us label these points by $\tau_z=\pm 1$. We can describe the edge of the system, by assigning boundary conditions to the $k_x=\pm k_F$ modes in terms of time-reversal invariant phase-shifts. </p>
<p>The bulk solutions near $k_x\sim\pm k_F$ can be written as $\psi_\pm(x)=e^{-x/\xi}\psi_\pm(0)$. Matching boundary conditions, we find that a zero energy pair of edge solutions exists in the case of inverted bands. These solutions differ from the ones in the Dirac limit by the presence of the oscillating part of the wave function.</p>
<h1 id="Quantized-conductance-and-length-dependence"><a href="#Quantized-conductance-and-length-dependence" class="headerlink" title="Quantized conductance and length dependence"></a>Quantized conductance and length dependence</h1><p>Unlike in the case of Majoranas, not much thinking is required to figure out the relevant signature of the quantum spin Hall effect. There is a pair of modes on each edge of the sample that is protected from backscattering. All the other modes are gapped or backscattered, so the edge states are the only ones to carry current. This current will not suffer from backscattering.</p>
<p>If we consider the simplest case, a sample with only two terminals, then Landauer’s formula together with the absence of backscattering gives the conductance $G_0=2 e^2/h$.</p>
<p>When we move the Fermi level outside of the bulk gap, the bulk becomes conducting, and so the conductance increases.</p>
<p>We end up with this situation:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">p_topo = SimpleNamespace(</span><br><span class="line">    mu=<span class="literal">None</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">1.5</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=<span class="number">0.0</span>, M=<span class="number">0.2</span>, **bhz_parameters[<span class="string">"lead"</span>]</span><br><span class="line">)</span><br><span class="line">p_triv = SimpleNamespace(</span><br><span class="line">    mu=<span class="literal">None</span>,</span><br><span class="line">    ez_y=<span class="number">0.0</span>,</span><br><span class="line">    mu_lead=<span class="number">1.5</span>,</span><br><span class="line">    A=<span class="number">0.5</span>,</span><br><span class="line">    B=<span class="number">1.0</span>,</span><br><span class="line">    D=<span class="number">0.0</span>,</span><br><span class="line">    M=<span class="number">-0.2</span>,</span><br><span class="line">    **bhz_parameters[<span class="string">"lead"</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">"k_x"</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">"xticks"</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r"$-\pi/3$"</span>), (<span class="number">0</span>, <span class="string">"0"</span>), (np.pi / <span class="number">3</span>, <span class="string">r"$\pi/3$"</span>)],</span><br><span class="line">    <span class="string">"yticks"</span>: [<span class="number">-1.5</span>, <span class="number">-1.0</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>],</span><br><span class="line">    <span class="string">"ylims"</span>: (<span class="number">-1.5</span>, <span class="number">1.5</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syst = bhz(w=<span class="number">20</span>)</span><br><span class="line">spec_topo = spectrum(syst, p_topo, **kwargs).relabel(<span class="string">"spectrum (topo)"</span>)</span><br><span class="line">spec_triv = spectrum(syst, p_triv, **kwargs).relabel(<span class="string">"spectrum (triv)"</span>)</span><br><span class="line">mus = np.linspace(<span class="number">-0.8</span>, <span class="number">0.8</span>, <span class="number">50</span>)</span><br><span class="line">HLines = holoviews.HoloMap(&#123;mu: holoviews.HLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r"$\mu$"</span>])</span><br><span class="line">VLines = holoviews.HoloMap(&#123;mu: holoviews.VLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r"$\mu$"</span>])</span><br><span class="line">G_triv = G_mu_plot(p_triv, mus, <span class="string">"b"</span>)</span><br><span class="line">G_topo = G_mu_plot(p_topo, mus, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line">(G_triv * (G_topo * VLines) + spec_topo * HLines + spec_triv * HLines)</span><br></pre></td></tr></table></figure>

<p>Here on the left we see a comparison between the conductances of a trivial (blue curve) and a topological (red curve) insulator as a function of chemical potential. The other two panels show the spectra of a quantum spin Hall insulator in the topological and trivial phases. As we expected, conductance is quantized when the chemical potential is inside the band gap of a topological system.</p>
<p>Let’s now see what can be measured experimentally.</p>
<p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig13.png" alt></p>
<p>(copyright JPS, see license in the beginning of the chapter)</p>
<p>What you notice is that the maximum resistance for the 4.5 nm thick quantum well is much higher than for the 8 nm thick well. Given that theory predicts that the HgTe quantum wells described by Michael Wimmer in his video are topological when their thickness is between 6.3 nm and 12 nm, this measurement suggests that the lower resistance of the 8 nm thick well might be due to edge conductance. But even though it is the lower of the two, you might complain that the resistance of the 8 nm well is closer to $100$ $k\Omega$ than the predicted $12$ $k\Omega$ from the quantum of conductance.</p>
<p>The black curve here is the resistance of a trivial insulator, and the red one should be that of a topological one. The resistance of a trivial insulator becomes very high as expected, and there is a plateau-like feature in the topological regime.</p>
<p>Fortunately, it was revealed in further experiments by the Wurzburg group, that by reducing the length of the sample from length $L=20$ $\mu m$ to $L=1$ $\mu m$, the conductance maximum rises to about $12.9$ $k\Omega$:</p>
<p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig14.png" alt></p>
<p>(copyright JPS, see license in the beginning of the chapter)</p>
<p>We see something different from what we expected: the average resistance value at the plateau is correct, but only within 10% precision, very different from the $10^{-8}$ accuracy of the quantum Hall effect.</p>
<p>This difference most likely originates from backscattering. In the quantum Hall effect, backscattering is prohibited by the absence of modes going in the other direction. In the quantum spin Hall effect however, the protection is much weaker and is merely due to Kramers theorem.</p>
<p>The exact origin of the backscattering is hard to understand. It could be inelastic scattering that does not preserve energy, or it could also be some residual magnetic impurities, which break time reversal symmetry. In both cases, Kramers theorem does not hold. One of the papers that we suggest for review proposes an interesting theory for the origin of the backscattering, while another reports measurements of InAs/GaSb quantum well, where conductance seems much better quantized.</p>
<p>Regardless of the exact origin of backscattering, at any finite temperature, there is an inelastic scattering length $l_\phi$ beyond which we do not expect any protection from scattering. When the edge length $L$ is larger than $l_\phi$, we expect the edge to turn into an incoherent conductor with resistance of $(e^2/h) l_\phi/L$. </p>
<p>In principle, this allows us to measure $l_\phi$ for the quantum spin hall edges by looking at the length dependence of the conductance. Indeed, experiments find that small samples have conductance close to $G_0$, while in large samples the conductance is suppressed.</p>
<h1 id="Landau-levels"><a href="#Landau-levels" class="headerlink" title="Landau levels"></a>Landau levels</h1><p>We learned that the key ingredient to obtain an inversion symmetric topological insulator is band inversion - an electron-like band with a positive effective mass and a hole-like band with a negative effective mass are inverted.</p>
<p>The standard way to distinguish electrons from holes is to measure the sign of the Hall resistance, which is positive for electrons and negative for holes. Hence, we expect to measure a change in the sign of the Hall conductance as we change the position of the Fermi level from being above to being below the band gap.</p>
<p>In the first plot below, you see traces of the Hall resistance of a quantum spin Hall sample as a function of the applied magnetic field, for several values of the gate voltage, given by different colors. You see that for $V_g=-1$ V the Hall resistance is positive, while for $V_g = -2 V$ the resistance is negative. These are the two black traces. They both exhibit a very well formed $\nu=1$ quantum Hall plateau for high enough fields, and a vanishing Hall resistance for zero magnetic field. This is the standard, expected behavior.</p>
<p>For some traces between these two values, the resistance shoots up to very high values. This is because the Fermi level is in the middle of the band gap. As expected, we thus observe insulating behavior.</p>
<p>However, you may notice something interesting. Let’s focus for instance on the green and red traces taken for two very close values of $V_g$. Because these correspond to Fermi levels in the middle of the band gap, they show a very high resistance, except for a range of magnetic field values, where they also exhibit a quantum Hall plateau!</p>
<p>This proves what we hoped to find: there is a Landau level of electrons that crosses with a Landau level of holes.</p>
<p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig11.png" alt></p>
<p>(copyright JPS, see license in the beginning of the chapter)</p>
<p>As shown in the lower panel, this particular feature is due to the unique structure of Landau levels which you obtain in the presence of a band inversion.</p>
<p>The Landau levels of an electron-like band have a positive slope as a function of magnetic field, while those of a hole-like band have a negative slope. In a trivial bandstructure, all negative energy levels would bend down as a function of magnetic field, while all positive energy levels would bend up. As a consequence, if you place the Fermi level in the middle of the band gap and increase the magnetic field, no Landau level will ever cross the Fermi level.</p>
<p>However, in the presence of a band inversion, you obtain what is shown in the figure: the lowest Landau levels coming from the inverted bands go in the “wrong” direction. At some value of the magnetic field, they must cross. Furthemore, they will both cross the Fermi level if it is in the middle of the zero-field band gap.</p>
<p>Due to this fact, one observes a Hall effect in a certain range of fields, even when the Fermi level is placed in the middle of the zero-field band gap. And indeed, by comparing the experimental results with the expected behavior of the Landau levels, you see that the positions of the Fermi-level crossings coincide with the re-entrant Hall plateaus of the experimental traces - as marked by the green and red arrows.</p>
<p>As a further confirmation that this effect is due to band inversion, this behavior was only observed in samples with a thickness above the expected threshold value to obtain a quantum spin Hall phase, and never in samples with a smaller thickness.</p>
<h1 id="Localization-of-the-edge-states-by-magnetic-field"><a href="#Localization-of-the-edge-states-by-magnetic-field" class="headerlink" title="Localization of the edge states by magnetic field"></a>Localization of the edge states by magnetic field</h1><p>Theoretically, the hallmark of the topological insulator is the quantized conductance of the edge states that are protected from elastic backscattering. In the last unit, we learned that the key to this protection is time-reversal symmetry. Therefore, breaking time reversal symmetry by for example applying a magnetic field, should suppress the quantized conductance.</p>
<p>We can think about this more explicitly by considering a simple model for the helical edge states with a magnetic field $\bf B$:</p>
<p>$$H=v_F k_x\sigma_z+{\bf B}\cdot {\bf \sigma},$$</p>
<p>where $\bf \sigma$ are Pauli matrices representing the spin degree of freedom at the edge. This is what we get from the BHZ model, which conserves spin. For more general models we would interpret $\bf \sigma$ as a pseudo-spin degree of freedom, which is odd under time-reversal.</p>
<p>If we consider the simple case of a magnetic field ${\bf B}=B {\bf x}$ along the x-direction, we find that the edge spectrum $E=\pm\sqrt{v_F^2 k_x^2+B^2}$ becomes gapped. Clearly, the edge becomes insulating if we set the chemical potential at $E=0$.</p>
<p>We can very easily calculate that this is the case if we plot the conductance of the QSHE model as a function of magnetic field:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">1.5</span>, **bhz_parameters[<span class="string">"topo2"</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> bhz_parameters[<span class="string">"topo2"</span>].items():</span><br><span class="line">    <span class="comment"># setting the parameters for the lead the same as the scattering system</span></span><br><span class="line">    p.__dict__[key + <span class="string">"_lead"</span>] = value</span><br><span class="line"></span><br><span class="line">syst = bhz(w=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">"k_x"</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">"ylims"</span>: (<span class="number">-1.5</span>, <span class="number">1.5</span>),</span><br><span class="line">    <span class="string">"xticks"</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r"$-\pi/3$"</span>), (<span class="number">0</span>, <span class="string">r"$0$"</span>), (np.pi / <span class="number">3</span>, <span class="string">r"$\pi/3$"</span>)],</span><br><span class="line">    <span class="string">"yticks"</span>: [<span class="number">-1.5</span>, <span class="number">-1.0</span>, <span class="number">-0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>],</span><br><span class="line">    <span class="string">"title"</span>: <span class="keyword">lambda</span> p: <span class="string">"Band structure"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E_zs = np.linspace(<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">50</span>)</span><br><span class="line">VLines = holoviews.HoloMap(</span><br><span class="line">    &#123;ez_y: holoviews.VLine(ez_y) <span class="keyword">for</span> ez_y <span class="keyword">in</span> E_zs&#125;, kdims=[<span class="string">r"$E_z$"</span>]</span><br><span class="line">)</span><br><span class="line">spectra = holoviews.HoloMap(</span><br><span class="line">    &#123;p.ez_y: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.ez_y <span class="keyword">in</span> E_zs&#125;, kdims=[<span class="string">r"$E_z$"</span>]</span><br><span class="line">)</span><br><span class="line">G_Ez_plot(p, E_zs) * VLines + spectra * holoviews.HLine(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>However, even if we consider energies $E&gt;B$ above the gap, the eigenstates at $\pm k_x$ are no longer Kramers’ pairs, i.e. related by time-reversal symmetry. Therefore, any mechanism which changes momentum by $2 k_x$ can backscatter electrons from left movers to right movers. </p>
<p>Edges of semiconductors are typically quite disordered - so we expect the random potential at the edge to provide “elastic backscattering” that can change the momentum without changing the energy. Such backscattering, in addition to any other “inelastic backscattering” by phonons etc, would decrease the conductance of the edge from the ideal quantized value. If we set $B=0$, elastic back-scattering that can occur at finite $B$ is forbidden, so we generally expect the application of a magnetic field to reduce conductance of the edge.</p>
<p>We see below that indeed the conductance of the $L=20,\mu m$ device is strongly reduced by the application of a magnetic field: </p>
<p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig15.png" alt></p>
<p>(copyright JPS, see license in the beginning of the chapter)</p>
<p>However, we notice that this effect seems to work only when the magnetic field is perpendicular to the sample. In-plane magnetic fields do not seem to do a whole lot (there is an effect, but much larger fields are required). According to our model Hamiltonian, an in-plane field should have opened a gap, while a perpendicular field which adds a term proportional to $\sigma_z$ should have not done anything.</p>
<p>So, while the experiment sees something similar to what we hoped to find using a simple theory, the effect of the magnetic field seems reversed. There may be several explanations for this phenomenon, such as a presence of extra terms in the Hamiltonian that rotate the spins of the edge states without breaking time-reversal symmetry.</p>
<p>You might be worried that the suppression of conductance is only shown for the long device, which does not show quantized conductance. If you are, then you are absolutely right in worrying about this :-)</p>
<p>Localization of QSHE edge states by magnetic field is relatively poorly understood, and we are not aware of a final experiment that would prove its existence or tell us in details what it is that happens at the QSHE edge in a magnetic field. As you will learn in two weeks, opening the gap by magnetic field opens new pathways for the creation of Majoranas, and so it is still a very important direction of research.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"Why did we not see a similar suppression of conductance with magnetic field in the case of  "</span></span><br><span class="line">    <span class="string">"the quantum Hall effect in week 3?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The quantum Hall effect appeared in much higher quality samples."</span>,</span><br><span class="line">    <span class="string">"There was no spin in the quantum Hall effect, so the magnetic field could not couple to anything."</span>,</span><br><span class="line">    <span class="string">"The topological protection of quantum Hall edges does not rely on time-reversal, unlike quantum spin "</span></span><br><span class="line">    <span class="string">"Hall edges."</span>,</span><br><span class="line">    <span class="string">"The suppression here arises from inelastic scattering, which could not arise in the quantum Hall case."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"The magnetic field dependence here arises from the fact that B breaks time-reversal symmetry, which is  "</span></span><br><span class="line">    <span class="string">"required for the protection of edge states in the quantum spin Hall effect. "</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"Kop4zXWQ1Zc"</span>, src_location=<span class="string">"5.2-summary"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"QSHE - experiments"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w5_qshe/w5_assignments" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w5_qshe/w5_assignments/"
    >src/w5_qshe/w5_assignments</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w5_qshe/w5_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.853Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h1><p>As usual, start by grabbing the notebooks of this week (<code>w5_qshe</code>). They are once again over <a href="http://tiny.cc/topocm_smc" target="_blank" rel="noopener">here</a>.</p>
<h3 id="Kane-Mele-model"><a href="#Kane-Mele-model" class="headerlink" title="Kane-Mele model"></a>Kane-Mele model</h3><p>The first known implementation of quantum spin Hall effect is the Kane-Mele model, introduced in <a href="http://arxiv.org/abs/cond-mat/0411737" target="_blank" rel="noopener">this paper</a>. It is a doubled copy of the Haldane model (get that one from the previous week’s notebooks), with spin up and spin down having next-nearest neighbor hoppings complex conjugate of each other due to spin-orbit coupling.</p>
<p>Implement the Kane-Mele model and add a staggered onsite potential to also be able to create a trivial gap. Calculate the scattering matrix topological invariant of that model.</p>
<p>How would you add disorder and calculate the topological invariant? (Hint: you need to add disorder to the scattering region, and make leads on both sides conducting)</p>
<h3 id="Quantum-Hall-regime"><a href="#Quantum-Hall-regime" class="headerlink" title="Quantum Hall regime"></a>Quantum Hall regime</h3><p>The helical edge states of quantum spin Hall effect survive for some time when a magnetic field is added. Make a Hall bar out of the BHZ model. Can you reproduce the experimental results? What do you see? Are the inversion symmetry breaking terms important?</p>
<p>What about conductance in a two terminal geometry: can you see the crossover from quantum spin Hall regime to quantum Hall regime?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Labs"</span>, <span class="string">"Quantum spin Hall effect"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1306-1925"><a href="#arXiv-1306-1925" class="headerlink" title="arXiv:1306.1925"></a>arXiv:1306.1925</h3><p><strong>Hint:</strong> A better material?</p>
<h3 id="arXiv-0808-1723"><a href="#arXiv-0808-1723" class="headerlink" title="arXiv:0808.1723"></a>arXiv:0808.1723</h3><p><strong>Hint:</strong> What happens when edge states meet.</p>
<h3 id="arXiv-1104-3282"><a href="#arXiv-1104-3282" class="headerlink" title="arXiv:1104.3282"></a>arXiv:1104.3282</h3><p><strong>Hint:</strong> A completely different approach.</p>
<h3 id="arXiv-1312-2559"><a href="#arXiv-1312-2559" class="headerlink" title="arXiv:1312.2559"></a>arXiv:1312.2559</h3><p><strong>Hint:</strong> Adding superconductors.</p>
<h3 id="arXiv-1303-1766"><a href="#arXiv-1303-1766" class="headerlink" title="arXiv:1303.1766"></a>arXiv:1303.1766</h3><p><strong>Hint:</strong> Sources of back-scattering in QSHE edge.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Reviews"</span>, <span class="string">"Quantum spin Hall effect"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w5_qshe/fermion_parity_pump" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w5_qshe/fermion_parity_pump/"
    >src/w5_qshe/fermion_parity_pump</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w5_qshe/fermion_parity_pump/" class="article-date">
  <time datetime="2021-01-07T09:11:06.844Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line">bhz_parameters = &#123;</span><br><span class="line">    <span class="string">"topo"</span>: &#123;<span class="string">"A"</span>: <span class="number">0.5</span>, <span class="string">"B"</span>: <span class="number">1.00</span>, <span class="string">"D"</span>: <span class="number">0.0</span>, <span class="string">"M"</span>: <span class="number">1.0</span>, <span class="string">"del_z"</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">"triv"</span>: &#123;<span class="string">"A"</span>: <span class="number">0.5</span>, <span class="string">"B"</span>: <span class="number">1.00</span>, <span class="string">"D"</span>: <span class="number">0.0</span>, <span class="string">"M"</span>: <span class="number">-1.0</span>, <span class="string">"del_z"</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">"topo2"</span>: &#123;<span class="string">"A"</span>: <span class="number">0.5</span>, <span class="string">"B"</span>: <span class="number">1.00</span>, <span class="string">"D"</span>: <span class="number">0.3</span>, <span class="string">"M"</span>: <span class="number">1.0</span>, <span class="string">"del_z"</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">"slowed"</span>: &#123;<span class="string">"A"</span>: <span class="number">0.05</span>, <span class="string">"B"</span>: <span class="number">0.08</span>, <span class="string">"D"</span>: <span class="number">0.15</span>, <span class="string">"M"</span>: <span class="number">-0.3</span>, <span class="string">"del_z"</span>: <span class="number">0.5</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hoppings for bhz model</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (p.M - <span class="number">4</span> * p.B) * pauli.s0sz - <span class="number">4</span> * p.D * pauli.s0s0 + p.del_z * pauli.sysy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 + <span class="number">1j</span> * p.A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 - <span class="number">1j</span> * p.A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span><span class="params">(w=<span class="number">20</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Make ribbon system with bhz model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    slowed parameters are used on the edge for finite size system.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_x</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(<span class="number">-0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    slowed_par = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">"slowed"</span>])</span><br><span class="line">    <span class="keyword">if</span> w <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[(lat(<span class="number">0</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(w))] = onsite</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>, <span class="number">-1</span>)] = <span class="keyword">lambda</span> site, p: onsite(site, slowed_par)</span><br><span class="line">        syst[lat(<span class="number">1</span>, <span class="number">-1</span>), lat(<span class="number">0</span>, <span class="number">-1</span>)] = <span class="keyword">lambda</span> site1, site2, p: hopping_x(</span><br><span class="line">            site1, site2, slowed_par</span><br><span class="line">        )</span><br><span class="line">        syst[lat(<span class="number">0</span>, <span class="number">0</span>), lat(<span class="number">0</span>, <span class="number">-1</span>)] = hopy</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>, w)] = <span class="keyword">lambda</span> site, p: onsite(site, slowed_par)</span><br><span class="line">        syst[lat(<span class="number">1</span>, w), lat(<span class="number">0</span>, w)] = <span class="keyword">lambda</span> site1, site2, p: hopping_x(</span><br><span class="line">            site1, site2, slowed_par</span><br><span class="line">        )</span><br><span class="line">        syst[lat(<span class="number">0</span>, w), lat(<span class="number">0</span>, w - <span class="number">1</span>)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_cylinder</span><span class="params">(w=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Make cylinder system with bhz model. """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_x</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(<span class="number">-0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy_phase</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopy(site1, site2, p) * np.exp(<span class="number">1j</span> * p.ky)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, -w + <span class="number">1</span>), lat)] = hopy_phase</span><br><span class="line"></span><br><span class="line">    syst[lat(<span class="number">0</span>, <span class="number">0</span>)] = onsite</span><br><span class="line">    syst[lat(<span class="number">0</span>, w - <span class="number">1</span>)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lead</span><span class="params">(t, trs=None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym, time_reversal=<span class="number">1j</span> * pauli.sys0)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">1.8</span> * t * pauli.s0sz</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t * pauli.s0sz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_scatter_sys</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        x, y = pos</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="number">0</span>) * (<span class="number">0</span> &lt;= y &lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    lead_cylinder = bhz_cylinder()</span><br><span class="line">    lead = make_lead(<span class="number">1.0</span>)</span><br><span class="line">    syst.attach_lead(lead.reversed())</span><br><span class="line">    syst.attach_lead(lead_cylinder)</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scattering_det_pfaff</span><span class="params">(syst, p)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pfaffian</span><span class="params">(syst, p, ky)</span>:</span></span><br><span class="line">        p.ky = ky</span><br><span class="line">        smat = kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=dict(p=p)).data</span><br><span class="line">        <span class="comment"># since we get relatively large numerical errors we project the matrix on</span></span><br><span class="line">        <span class="comment"># the space of antisymmetric matrices</span></span><br><span class="line">        smat = <span class="number">0.5</span> * (smat - smat.T)</span><br><span class="line">        <span class="keyword">return</span> pf.pfaffian(smat)</span><br><span class="line"></span><br><span class="line">    pfaff = [pfaffian(syst, p, <span class="number">0</span>), pfaffian(syst, p, np.pi)]</span><br><span class="line"></span><br><span class="line">    ks = np.linspace(<span class="number">0.0</span>, np.pi, <span class="number">50</span>)</span><br><span class="line">    det = [np.linalg.det(kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=dict(p=p)).data) <span class="keyword">for</span> p.ky <span class="keyword">in</span> ks]</span><br><span class="line">    det = np.array(det)</span><br><span class="line"></span><br><span class="line">    phase = np.angle(pfaff[<span class="number">0</span>]) + <span class="number">0.5</span> * np.cumsum(np.angle(det[<span class="number">1</span>:] / det[:<span class="number">-1</span>]))</span><br><span class="line">    kdims = [<span class="string">"$k_y$"</span>, <span class="string">"phase"</span>]</span><br><span class="line">    plot = holoviews.Path((ks[<span class="number">1</span>:], phase), kdims=kdims).opts(style=&#123;<span class="string">"color"</span>: <span class="string">"b"</span>&#125;)</span><br><span class="line">    plot *= holoviews.Points(([<span class="number">0</span>, np.pi], np.angle(pfaff)), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">"color"</span>: <span class="string">"g"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    xlims, ylims = slice(<span class="number">-0.2</span>, np.pi + <span class="number">0.2</span>), slice(-np.pi - <span class="number">0.2</span>, np.pi + <span class="number">0.2</span>)</span><br><span class="line">    pi_ticks = [(-np.pi, <span class="string">r"$-\pi$"</span>), (<span class="number">0</span>, <span class="string">"$0$"</span>), (np.pi, <span class="string">r"$\pi$"</span>)]</span><br><span class="line">    ticks = &#123;<span class="string">"xticks"</span>: [(<span class="number">0</span>, <span class="string">"0"</span>), (np.pi, <span class="string">"$\pi$"</span>)], <span class="string">"yticks"</span>: pi_ticks&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.relabel(<span class="string">"Winding"</span>, depth=<span class="number">1</span>)[xlims, ylims].opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span><span class="params">(p)</span>:</span></span><br><span class="line">    title = <span class="string">r"$A=&#123;:.2&#125;$, $B=&#123;:.2&#125;$, $D=&#123;:.2&#125;$, $M=&#123;:.2&#125;$"</span></span><br><span class="line">    <span class="keyword">return</span> title.format(p.A, p.B, p.D, p.M)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Charles Kane from the University of Pennsylvania will introduce today’s lecture on two dimensional topological insulators with time-reversal symmetry.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"n5oUQvvsYd0"</span>, src_location=<span class="string">"5.1-intro"</span>, res=<span class="string">"360"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Adding-symmetry-to-a-topological-insulator"><a href="#Adding-symmetry-to-a-topological-insulator" class="headerlink" title="Adding symmetry to a topological insulator"></a>Adding symmetry to a topological insulator</h1><p>In general, there are different approaches to discover new types of topological systems.</p>
<p>We have already used a very powerful method to make a Kitaev chain and the Chern insulator model. We started from guessing what kind of model to use for the edge, such that it is impossible to obtain without the bulk. Then we combined many such edges (dots for the Kitaev chain and wires for the Chern insulator) and tailored the coupling between them to leave exactly the type of model that we want on one edge.</p>
<p>A very skilled researcher in topology (or more specifically <a href="https://en.wikipedia.org/wiki/K-theory" target="_blank" rel="noopener">K-theory</a>) may also just calculate the expected topological classification of a system starting only from its dimensionality and symmetries. This is also a powerful method, but often it’s too hard and requires a very high skills in math.</p>
<p>Another approach that we can undertake is to start with one topological Hamiltonian and see what happens if we force the Hamiltonian to have some extra symmetry. This is the approach we will use in this chapter.</p>
<p>Let’s start from a simple example involving something which we already know, a quantum dot with the Hamiltonian $H_0$. We know that there is a topological invariant, the number of filled energy levels.</p>
<p>Now we can ask what happens if we force the dot to have a particle-hole symmetry. The Hamiltonian becomes</p>
<p>$$<br>H_\textrm{BdG} =<br>\begin{pmatrix}<br>H_0 &amp; 0\<br>0 &amp; -H_0^*<br>\end{pmatrix}.<br>$$</p>
<p>This model is clearly topologically trivial from the point of view of the old invariant, since the number of filled states is constant. However, there are still level crossings that appear. We may ask if these crossings stay protected if we also include a finite superconducting pairing $\Delta$ in the Hamiltonian, which couples the two blocks $H_0$ and $-H_0^*$.</p>
<p>Of course we know the answer: the crossings stay protected due to the change in the Pfaffian invariant. So what we did was to construct a topologically non-trivial superconducting dot by adding particle-hole symmetry to a topological Hamiltonian with a lower symmetry.</p>
<p>Let’s now apply the same logic to a new system. Specifically, let’s add time-reversal symmetry to a Chern insulator. The Chern insulator has chiral edge states whose direction of propagation is flipped by time-reversal symmetry $\mathcal{T}$. So let’s consider a Hamiltonian of the form</p>
<p>$$<br>H =<br>\begin{pmatrix}<br>H_0 &amp; 0\<br>0 &amp; \mathcal{T}H_0\mathcal{T}^{-1}<br>\end{pmatrix},.<br>$$</p>
<p>If $H_0$ is the Hamiltonian of a Chern insulator with $N$ edge states, then $H$ will have $N$ pairs of counterpropagating edge states that transform into each other by time-reversal symmetry. Moreover, the full $H$ obeys time-reversal symmetry, which merely exchanges the two blocks.</p>
<p>The following sketch describes the situation in the case $N=1$:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_insulator.svg" alt></p>
<p>The next task which we now face is to understand if such edges stay topologically protected once we add coupling between the two blocks.</p>
<h1 id="A-perfectly-transmitted-channel-and-Kramers-degeneracy"><a href="#A-perfectly-transmitted-channel-and-Kramers-degeneracy" class="headerlink" title="A perfectly transmitted channel and Kramers degeneracy"></a>A perfectly transmitted channel and Kramers degeneracy</h1><p>We could try to see if all the edge states can be removed by adding some terms to the Hamiltonian, but instead we will use a closely related fact.</p>
<p>Let’s study transport through such edge states as a function of their total number and let’s only use the fact that time-reversal symmetry is present. Imagine, there is a total of $N$ states going in each direction along the edge, and that the edge is composed of a disordered region sandwiched between two clean regions. Again, let’s represent the situation for the case $N=1$.</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_scattering.svg" alt></p>
<h2 id="Scattering-states"><a href="#Scattering-states" class="headerlink" title="Scattering states"></a>Scattering states</h2><p>We label incoming states on the left and right with $\left|n,\textrm{L}\right\rangle$ and $\left|n,\textrm{R}\right\rangle$. The index $n$ goes from $1$ to $N$. The outgoing states are the time-reversed partners of the incoming states, so they are given by $\mathcal{T}\left|n,\textrm{L}\right\rangle$ and $\mathcal{T}\left|n,\textrm{R}\right\rangle$. Scattering states in the left and right regions are superpositions of incoming and outgoing states,</p>
<p>$$<br>\left|\Psi,\textrm{L}\right\rangle = \sum_{n=1}^N \alpha_{n,\textrm{L}},\left|n,\textrm{L}\right\rangle + \beta_{n,\textrm{L}},\mathcal{T}\left|n,\textrm{L}\right\rangle,,<br>$$<br>$$<br>\left|\Psi,\textrm{R}\right\rangle = \sum_{n=1}^N \alpha_{n,\textrm{R}},\left|n,\textrm{R}\right\rangle + \beta_{n,\textrm{R}},\mathcal{T}\left|n,\textrm{R}\right\rangle,.<br>$$</p>
<p>We can form vectors out of all the coefficients in the superposition, for instance $\alpha_\textrm{L} = (\alpha_{1,\textrm{L}},\dots,\alpha_{N,\textrm{L}})^T$ for the incoming states on the left side. Incoming and outgoing modes are then related by the scattering matrix $S$ of the disordered region,</p>
<p>$$<br>\begin{pmatrix} \beta_\textrm{L} \ \beta_\textrm{R} \end{pmatrix} = S \begin{pmatrix} \alpha_\textrm{L} \ \alpha_\textrm{R} \end{pmatrix}.<br>$$</p>
<p>There are a total of $2N$ incoming and $2N$ outgoing modes, so $S$ is a $2N\times 2N$ matrix. Since we are including all possible initial and final states, $S$ is also unitary, $S=S^\dagger$. It can be split into reflection and transmission blocks of dimension $N\times N$,</p>
<p>$$<br>S =<br>\begin{pmatrix}<br>r &amp; t\<br>t’ &amp; r’<br>\end{pmatrix},.<br>$$</p>
<p>If we can gap out the edges by adding some extra terms to the Hamiltonian, or backscatter them by adding disorder, then we should be able to achieve the situation where there is no transmission at all, $t = t’ = 0$. In this case, all modes must be reflected back, so the reflection blocks of the scattering matrix become unitary, $r^\dagger r = r’^\dagger r’ = 1$.</p>
<p>To see whether this is possible at all, we first have to understand the constraints that time-reversal symmetry imposes on $S$.</p>
<h2 id="Scattering-matrices-with-time-reversal-symmetry"><a href="#Scattering-matrices-with-time-reversal-symmetry" class="headerlink" title="Scattering matrices with time-reversal symmetry"></a>Scattering matrices with time-reversal symmetry</h2><p>Let’s recall some basic facts about time-reversal symmetry, which we already studied in the first week. Time-reversal symmetry has an antiunitary operator $\mathcal{T}$ which commutes with the Hamiltonian. Being antiunitary, $\mathcal{T}$ may come in two flavors - either $\mathcal{T}^2=1$ or $\mathcal{T}^2=-1$. The first case applies to systems with no or integer spin, such that $\mathcal{T}=\mathcal{K}$ in the simplest case, where $\mathcal{K}$ is the complex conjugation operator. The second case applies to systems with half-integer spin, and in the simplest case we have $\mathcal{T}=i\sigma_y\mathcal{K}$.</p>
<p>Let’s apply the time-reversal operator to our scattering states. We get</p>
<p>$$<br>\mathcal{T}\left|\Psi,\textrm{L}\right\rangle = \sum_{n=1}^N \alpha^<em>_{n,\textrm{L}},\mathcal{T}\left|n,\textrm{L}\right\rangle + \beta^</em><em>{n,\textrm{L}},\mathcal{T}^2\left|n,\textrm{L}\right\rangle,,<br>$$<br>$$<br>\mathcal{T}\left|\Psi,\textrm{R}\right\rangle = \sum</em>{n=1}^N \alpha^<em>_{n,\textrm{R}},\mathcal{T}\left|n,\textrm{R}\right\rangle + \beta^</em>_{n,\textrm{R}},\mathcal{T}^2\left|n,\textrm{R}\right\rangle,.<br>$$</p>
<p>Now, since time-reversal symmetry does not change the energy of a state, $\mathcal{T}\left|\Psi,\textrm{R}\right\rangle$ and $\mathcal{T}\left|\Psi,\textrm{L}\right\rangle$ are scattering states with the same energy as $\left|\Psi,\textrm{R}\right\rangle$ and $\left|\Psi,\textrm{L}\right\rangle$. Hence, the coefficients of incoming and outgoing modes are still related by the same scattering matrix $S$ as before. Note, however, that applying $\mathcal{T}$ exchanged the role of the $\alpha$’s and $\beta$’s, such that the $\alpha$’s now correspond to outgoing states and the $\beta$’s to incoming states. Hence, we have</p>
<p>$$<br> S\mathcal{T}^2 \begin{pmatrix}\beta^<em>_\textrm{L} \ \beta^</em>_\textrm{R} \end{pmatrix} = \begin{pmatrix} \alpha^<em>_\textrm{L} \ \alpha^</em>_\textrm{R} \end{pmatrix},.<br>$$</p>
<p>Multiplying both sides by $\mathcal{T}^2S^\dagger$ and taking the complex conjugate gives</p>
<p>$$<br>\begin{pmatrix} \beta_\textrm{L} \ \beta_\textrm{R} \end{pmatrix} = \mathcal{T}^2,S^T  \begin{pmatrix} \alpha_\textrm{L} \ \alpha_\textrm{R} \end{pmatrix}.<br>$$</p>
<p>By comparing this equation with the one a few lines above, we finally obtain</p>
<p>$$<br>S = \mathcal{T}^2 S^T.<br>$$</p>
<p>So if $\mathcal{T}^2=1$, the scattering matrix is symmetric ($S=S^T$), while if $\mathcal{T}^2=-1$, it is antisymmetric ($S=-S^T$).</p>
<p>What does this imply if we try to set $t=t’=0$?</p>
<p>If $S=S^T$, it turns out there is really nothing special we can tell. However, if $S=-S^T$ and $t=t’=0$, the $N\times N$ reflection matrix must be both unitary, $r^\dagger r=1$, and antisymmetric, $r=-r^T$.</p>
<p>If $N$ is odd, this isn’t possible at all, since any odd-dimensional antisymmetric matrix <a href="https://en.wikipedia.org/wiki/Skew-symmetric_matrix#Spectral_theory" target="_blank" rel="noopener">must have</a> a single zero eigenvalue, while unitary matrices only have eigenvalues with unit norm!</p>
<p>We are forced to conclude that it is impossible to have $r$ unitary, and therefore it is impossible to have $t=0$ in this case. Furthermore, this zero eigenvalue of $r$ means that there is always a single mode that is transmitted with unit probability.</p>
<p>This is the discovery that Charles Kane described in the introductory video. We can quickly check it by randomly selecting an antisymmetric scattering matrix with odd $N$, like the following one with $N=3$,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span></span><br><span class="line">np.random.seed(<span class="number">12</span>)</span><br><span class="line">S = kwant.rmt.circular(N * <span class="number">2</span>, sym=<span class="string">"AII"</span>)</span><br><span class="line"></span><br><span class="line">pprint_matrix(S)</span><br></pre></td></tr></table></figure>

<p>and looking at the eigenvalues of $r^\dagger r$ and $t^\dagger t$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r = S[:N, :N]</span><br><span class="line">print(<span class="string">"Reflection eigenvalues"</span>)</span><br><span class="line">pprint_matrix(np.linalg.eigvalsh(r @ r.T.conj()))</span><br><span class="line"></span><br><span class="line">t = S[:N, N:]</span><br><span class="line">print(<span class="string">"Transmission eigenvalues"</span>)</span><br><span class="line">pprint_matrix(np.linalg.eigvalsh(t @ t.T.conj())[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>We conclude that if $\mathcal{T}^2=-1$ and the number of edge states going in one direction is odd, they cannot be gapped out, and the system is topological. On the other hand, if there is an even number of such edge states, they can be gapped out. Since these are the only two options, the integer invariant of a Chern insulator is reduced to a $\pm 1$ invariant in the presence of time reversal symmetry. These topologically protected, counterpropagating edge states are often referred to as <strong>helical edge states</strong>.</p>
</blockquote>
<h1 id="Helical-edge-states-are-Kramers-pairs"><a href="#Helical-edge-states-are-Kramers-pairs" class="headerlink" title="Helical edge states are Kramers pairs"></a>Helical edge states are Kramers pairs</h1><p>You might ask yourself what makes $\mathcal{T}^2=-1$ special, leading to the topological protection of the helical edge states.</p>
<p>As was mentioned in the first week, if $\mathcal{T}^2=-1$ then Kramers’ theorem applies. Kramers’ theorem tells us that given an eigenstate $|\Psi\rangle$ of the Hamiltonian with energy $E$, its time-reversed partner $|\Psi_\mathcal{T}\rangle\equiv\mathcal{T}|\Psi\rangle$ has the same energy, and the two states are orthogonal, $\langle \Psi | \Psi_\mathcal{T}\rangle=0$. These two states form a so-called <strong>Kramers pair</strong>. As we already know, this leads to the fact that Hamiltonians with spinful time-reversal symmetry have two-fold degenerate energy levels - <strong>Kramers degeneracy</strong>.</p>
<p>Now, the two counterpropagating helical modes are time-reversed partners of each other, so they form precisely such a Kramers pair. The condition $\langle \Psi | \Psi_\mathcal{T}\rangle=0$ implies that it is impossible to introduce any backscattering between the two states, unless we break time-reversal symmetry. This is the origin of the unit transmission and of the topological protection of helical edge states.</p>
<p>To gain a more intuitive understanding of this fact at a more microscopic level, we can assume that the projection of the electrons’ spin along a given axis is conserved, say the axis $z$ perpendicular to the plane. Then at the edge you have, say, a right-moving mode with spin up and a left-moving mode with spin down, and no other modes if $N=1$. Let’s draw again the picture of a helical edge state entering the disordered region:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/spin_flip.svg" alt></p>
<p>Thus, an electron moving to the right must have spin up by assumption. In order to be reflected, its spin must also be flipped.  However, this spin-flip scattering process is forbidden, and again we conclude that the electron is transmitted with probability one.</p>
<p>In the case $\mathcal{T}^2=1$, there is no Kramers’ theorem. As a consequence, even though you can construct models which have counterpropagating edge states, you will find that they have no topological protection and can be gapped out without breaking the time-reversal symmetry.</p>
<h1 id="The-quantum-spin-Hall-effect"><a href="#The-quantum-spin-Hall-effect" class="headerlink" title="The quantum spin Hall effect"></a>The quantum spin Hall effect</h1><p>There is no really precise name for the 2D topological insulator with time-reversal symmetry. It is often called “$\mathbb{Z}_2$ topological insulator.” However, this simply indicates that there are only two values of the topological invariant, and so it isn’t a very specific name.</p>
<p>The most commonly used name for this system is “quantum spin Hall insulator.” To understand why, let’s analyse a Hall bar made of such a non-trivial insulator. We will only need a Hall bar with four terminals, as shown below:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_hallbar.svg" alt></p>
<p>We have a finite voltage applied to terminal 1, so electrons are injected into the system from there. You can see that because of the helical edge states, there are as many modes connecting terminal 1 to terminal 3 as there are to terminal 4. A moment of thought, or otherwise a quick calculation, should convince you that in this case there is no net current flowing orthogonal to the applied voltage. The Hall conductance is zero, which is the expected result if time-reversal symmetry is preserved, as it is in our system.</p>
<p>However, counterpropagating edge states have to have exactly opposite spin due to Kramers degeneracy. This means that there may be a net spin current across the sample, orthogonal to the applied voltage.</p>
<p>In particular, let’s again make the simple assumption that the spin projection along some axis is conserved. Then, in the figure above, all modes colored in red have spin up, and all modes colored in blue have spin down. So terminal 1 distributes electrons coming out of it according to their spin: all electrons with spin up end up in terminal 4, and all those with spin down in terminal 3. The system has a quantized spin current between terminals 3 and 4, hence the name “quantum spin Hall effect”.</p>
<p>However, the quantized spin Hall current is not a general property of a quantum spin Hall insulator. Here, it arises because we have combined time reversal symmetry with a spin conservation law, and as we learned in the first week, conservation laws are boring from a topological point of view.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"Consider the simple case where spin is conserved. "</span></span><br><span class="line">    <span class="string">"In the quantum spin Hall bar system above, what happens if, instead of applying a voltage between terminals 1 and 2, "</span></span><br><span class="line">    <span class="string">"you manage to apply a *spin-polarized* current between terminals 1 and 2?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The system will develop an opposite spin-polarized current to compensate the effect."</span>,</span><br><span class="line">    <span class="string">"A spin-polarized current will develop between terminals 3 and 4."</span>,</span><br><span class="line">    <span class="string">"A voltage difference will develop between terminals 3 and 4."</span>,</span><br><span class="line">    <span class="string">"It is impossible to apply such a current unless the bulk gap closes."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"The spin-polarized current will create an electron population imbalance between terminals 3 and 4. "</span></span><br><span class="line">    <span class="string">"Hence, similar to the Hall effect, a voltage will develop orthogonal to the current."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="A-model-for-the-quantum-spin-Hall-insulator"><a href="#A-model-for-the-quantum-spin-Hall-insulator" class="headerlink" title="A model for the quantum spin Hall insulator"></a>A model for the quantum spin Hall insulator</h1><p>There is an important model which can be used to describe quantum spin Hall insulators, known as the <strong>Bernevig-Hughes-Zhang model</strong> or, in short, BHZ model. In essence, this model is equivalent to two copies of the Chern insulator Hamiltonian on the square lattice that we studied in the fourth week.</p>
<p>The BHZ Hamiltonian takes the form</p>
<p>$$<br>H_\textrm{BHZ}(\mathbf{k}) = \begin{pmatrix} h(\mathbf{k}) &amp; 0 \ 0 &amp; h^*(-\mathbf{k}) \end{pmatrix},,<br>$$</p>
<p>with</p>
<p>$$<br>h(\mathbf{k}) = \epsilon(\mathbf{k}) + \mathbf{d}(\mathbf{k})\cdot \pmb{\sigma},.<br>$$</p>
<p>Here $\pmb\sigma = (\sigma_x, \sigma_y, \sigma_z)$ is a vector of Pauli matrices acting on the electron/hole degree of freedom (the original two bands of the Chern insulator), $\epsilon(\mathbf{k}) = C - D(k_x^2+k_y^2)$, the vector $\mathbf{d} = [A k_x, -A k_y, M(\mathbf{k})]$, and<br>$M(\mathbf{k}) = M - B(k_x^2+k_y^2)$.</p>
<p>You can see that it is basically two copies of the massive Dirac Hamiltonian we used to study Chern insulators. In particular, there is a linear coupling in momentum between the holes and the electrons. The gap in the Hamiltonian is given by the term $M(\mathbf{k})$, a momentum-dependent effective mass.</p>
<p>By changing the sign of $M$ from negative to positive, you get a gap closing at $\mathbf{k}=\pmb{0}$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">'png'</span></span><br><span class="line">p = SimpleNamespace(Bz=<span class="number">0.0</span>, **bhz_parameters[<span class="string">"topo2"</span>])</span><br><span class="line">syst = bhz(w=<span class="literal">None</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">"k_x"</span>: k, <span class="string">"k_y"</span>: k, <span class="string">"title"</span>: title&#125;</span><br><span class="line">Ms = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.M: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r"$M$"</span>])</span><br></pre></td></tr></table></figure>

<p>This gap closing turns your trivial insulator into a topologically non-trivial quantum spin Hall insulator.</p>
<p>In the rest of this lecture, we will use the BHZ model as a toy-model to illustrate the behavior of a quantum spin Hall insulator using numerical examples. The BHZ model, however, is more than a toy-model, and it can be used to capture the behavior of some real semiconducting materials. For this reason, the BHZ model will be a main protagonist in the next chapter, where we will discuss real materials and the experimental evidence for the quantum spin Hall effect.</p>
<h1 id="Alternative-point-of-view-fermion-parity-pump"><a href="#Alternative-point-of-view-fermion-parity-pump" class="headerlink" title="Alternative point of view: fermion parity pump"></a>Alternative point of view: fermion parity pump</h1><p>In the previous cases of the Kitaev chain and the quantum Hall effect, the bulk topological invariant that we eventually obtained was characterized by the response to some adiabatic experiment.</p>
<p>Since the time-reversal invariant topological insulator is two dimensional like a quantum Hall system, it is reasonable to put the system in a Corbino geometry and change the flux through the system, creating an azimuthal electric field:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_corbino.svg" alt></p>
<p>However, because of time-reversal symmetry, the system is forbidden from having a Hall conductance and therefore there cannot be any charge transfer between the two edges of the disk. For instance, if we consider two copies of the Haldane model with opposite spin, there will be two quantum Hall pumps working in opposite directions (one transferring charge from the inner edge to the outer edge, the other one from the outer edge to the inner one). So the net charge transferred is zero.</p>
<p>Because the two pumps act on electrons with opposite spin, you might be tempted to define a spin current, which would flow in response to the electric field, orthogonal to it. However, as we just discussed, the spin along a given direction may not be conserved, so generally this is not a good way to define a robust pumping effect.</p>
<p>To understand what exactly happens in the pumping process, let’s look at the energy spectrum of the edge states for the BHZ model in the cylinder geometry. As we discussed in the quantum Hall lectures, the cylinder geometry is really equivalent to the Corbino disk, except that it is easier to study.</p>
<p>You also learned that in a cylinder of finite circumference $L$, the momenta of the allowed edge states are quantized at values determined by the flux.</p>
<p>To make things more simple, you may actually imagine that the circumference of the cylinder is just a single unit cell long. We then have only one allowed value of the momentum $k$ along the edge, which is exactly proportional to the flux threaded through the cylinder, $k = 2\pi \Phi/\Phi_0$.</p>
<p>So let’s look at the energy spectrum of a cylinder as a function of $k$ (or equivalently $\Phi$), and compare a cylinder in the quantum spin Hall phase with a cylinder in the trivial insulating phase.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">half_pi_ticks = [(<span class="number">0</span>, <span class="string">"$0$"</span>), (np.pi / <span class="number">2</span>, <span class="string">r"$\pi/2$"</span>), (np.pi, <span class="string">r"$\pi$"</span>)]</span><br><span class="line">style = &#123;</span><br><span class="line">    <span class="string">"k_x"</span>: np.linspace(<span class="number">0</span>, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">"xdim"</span>: <span class="string">r"$k$"</span>,</span><br><span class="line">    <span class="string">"ydim"</span>: <span class="string">r"$E$"</span>,</span><br><span class="line">    <span class="string">"xticks"</span>: half_pi_ticks,</span><br><span class="line">    <span class="string">"yticks"</span>: np.linspace(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">9</span>),</span><br><span class="line">    <span class="string">"xlims"</span>: [<span class="number">0</span>, np.pi],</span><br><span class="line">    <span class="string">"ylims"</span>: [<span class="number">-2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="string">"title"</span>: title,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syst = bhz(<span class="number">20</span>)</span><br><span class="line">p1 = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">"topo"</span>])</span><br><span class="line">p2 = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">"triv"</span>])</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p1, **style).relabel(<span class="string">"Topological"</span>) * holoviews.HLine(<span class="number">0</span>)</span><br><span class="line">    + spectrum(syst, p2, **style).relabel(<span class="string">"Trivial"</span>) * holoviews.HLine(<span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In both cases you see that at $k=0$ there are isolated pairs of states with degenerate energies, between the valence and conduction bands. The Fermi energy is set at $E=0$, in the middle of the gap between conduction and valence bands. These states are the Kramers pairs at the edges - one pair for the topological case, two for the trivial case.<br>You also see the splitting of Kramers pairs as soon as $k$ goes away from zero. This is because $k = 0$ is a time-reversal invariant point, a point in momentum space that is mapped to itself by time-reversal symmetry.</p>
<p>The plot ends at $k=\pi$ (that is, $\Phi=h/2e$), which is another time-reversal invariant point. Indeed, time-reversal symmetry sends $\Phi\to-\Phi$, but for $\Phi=h/2e$ this corresponds exactly to adding or subtracting a flux quantum. Hence, all the physical properties of the system remain unchanged under the action of time-reversal for this value of the flux. And indeed you can see that all levels meet again and form Kramers pairs.</p>
<blockquote>
<p>We now see an interesting difference though. In the topological case, the Kramers pairs at $k=\pi$ are not the same as those at $k=0$. In the trivial case however, the pairs are the same. As a consequence, in the topological case there is an odd number of levels crossing zero-energy, while in the trivial cases there is an even number of them. Therefore changing the flux by $h/2e$ in the topological case changes the fermion parity at the edge, while it does nothing in the trivial case. We have thus obtained a <strong>fermion parity pump</strong>.</p>
</blockquote>
<p>Strangely, this reminds us of the topological superconducting ring that we studied in the second week of the course. There we also had a fermion parity change in response to a flux. It turns out that this is not a coincidence, as we will see when we discuss how to realize topological superconductors using topological insulators.</p>
<p>You may appreciate that our argument did not rely on spin being a good quantum number, or on any other detail of the system, but only on Kramers theorem. And in fact it holds very generally. Deforming the dispersion of Kramers pairs does not break the fermion parity pump, as long as the way states combine to form Kramers pairs at $k=0$ and $k=\pi$ is unchanged.</p>
<h1 id="Pumping-expression-for-the-topological-invariant"><a href="#Pumping-expression-for-the-topological-invariant" class="headerlink" title="Pumping expression for the topological invariant"></a>Pumping expression for the topological invariant</h1><p>At this point, following the same path we followed for Chern insulator, we would like to find an expression for a topological bulk invariant which characterizes the quantum spin Hall effect.</p>
<p>However, we now encounter a problem: for complicated topological systems in higher dimensions, it is hard to evaluate the topological invariant. We know when the system is topological, and we know which values the topological invariant can take (for now just two: trivial and non-trivial), but it becomes hard to find and evaluate the correct expression for it.</p>
<p>We were able to calculate the Chern number using Berry curvature. The analogous computation for the topological invariant of the quantum spin Hall insulator is too involved, and so we will not present it in our course.</p>
<p>The scattering formulation of the topological invariant, however, is easy to implement and utilize. We can apply it by taking the cylinder threaded by a flux and connecting it to leads in the following geometry:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_pumping.svg" alt></p>
<p>Let us now study what happens when we try to inject electrons into the edges of the cylinder. Since we have “rolled-up” our system along one direction, we have a one-dimensional scattering problem. Similar to a Thouless pump, we expect to be able to find a topological signature in the reflection matrix $r$ for an electron coming in from the left.</p>
<p>As we vary the flux, the reflection properties may change, leading to a $k$-dependent reflection matrix $r(k)$. We assume that the bulk is gapped, so transmission is suppressed, and therefore $r$ is unitary. Moreover, at $k=0$ and $k=\pi$, $r$ is also antisymmetric because of time-reversal symmetry.</p>
<p>It turns out that the topological invariant has a relatively simple form:</p>
<p>$$<br>Q = \frac{\textrm{Pf}[r(0)]}{\textrm{Pf}[r(\pi)]}\sqrt{\frac{\det[r(\pi)]}{\det[r(0)]}}<br>$$</p>
<p>This expression relies on the antisymmetry of $r$ at $k=0$ and $k=\pi$. At these values we can compute the Pfaffian. The eigenvalues of $r$ come in pairs of opposite sign $e^{i\alpha}$, $-e^{i\alpha}$, which correspond to the Kramers pairs formed by the helical edge states. This means we can calculate the Pfaffian at these momentum values, but its phase is arbitrary.</p>
<p>We can however compute $\sqrt{\det[r(k)]}$ for all the intermediate values of $k$. To get rid of the sign ambiguity of the square root, we require that $\sqrt{\det[r(k)]}$ is continuous for all $k$, and that $\sqrt{\det[r(0)]} = \textrm{Pf}[r(0)]$. This only gives a unique answer if $\det r \neq 0$ for all $k$.</p>
<p>This gives us a curve which starts at $\textrm{Pf}[r(0)]$ and ends at either $\textrm{Pf}[r(\pi)]$ or $-\textrm{Pf}[r(\pi)]$. These two cases distinguish the trivial and nontrivial systems.</p>
<p>In the plot below, we show how this trajectory changes for our cylinder geometry as the BHZ model is driven through the topological phase transition. In the right panel, the green dots give you the phase of $\textrm{Pf}[r(0)]$ and $\textrm{Pf}[r(\pi)]$, and the blue line the phase of $\det[r(k)]$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">'png'</span></span><br><span class="line">p = SimpleNamespace(a=<span class="number">1.0</span>, Bz=<span class="number">0.0</span>, ky=<span class="literal">None</span>, **bhz_parameters[<span class="string">"topo2"</span>])</span><br><span class="line">syst = bhz(w=<span class="literal">None</span>)</span><br><span class="line">scat_syst = make_scatter_sys()</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">"k_x"</span>: k, <span class="string">"k_y"</span>: k, <span class="string">"title"</span>: title&#125;</span><br><span class="line">Ms = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">(</span><br><span class="line">    holoviews.HoloMap(&#123;p.M: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r"$M$"</span>])</span><br><span class="line">    + holoviews.HoloMap(</span><br><span class="line">        &#123;p.M: scattering_det_pfaff(scat_syst, p) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r"$M$"</span>]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>We now have a quantity equal to $\pm 1$, which cannot change continuously unless there’s a gap closing (when there’s a gap closing, $\det r$ becomes equal to $0$). It is relatively hard to prove that this invariant counts the pumping of fermion parity, but if you’re interested, check out this paper:</p>
<ul>
<li>arXiv:1107.2215</li>
</ul>
<p>From reading the paper, or just from the above discussion, you see that it takes a lot of effort to derive an explicit expression for a topological invariant. Even though it is a hard task, sometimes one can guess the right result (one of us was indeed able to guess the above expression for $Q$ before it was known). Other times, one can invoke some simplification and obtain some important insight. This is what we will do in the next unit.</p>
<h1 id="A-simplification-inversion-symmetry"><a href="#A-simplification-inversion-symmetry" class="headerlink" title="A simplification: inversion symmetry"></a>A simplification: inversion symmetry</h1><p>As just mentioned, topological invariants in higher dimensions are often difficult to write down and evaluate in the general case. Luckily, in the presence of <a href="http://en.wikipedia.org/wiki/Parity_%28physics%29#Effect_of_spatial_inversion_on_some_variables_of_classical_physics" target="_blank" rel="noopener">inversion symmetry</a> - which reverses the lattice coordinates with respect to a symmetry center - the topological condition can be stated in rather simple terms.<br>This turns out to be quite useful to describe most topological materials, which happen to have crystal structure with inversion symmetry.</p>
<p>From our earlier discussion, we know that a system is a time-reversal invariant topological insulator if it has an odd number of helical edge states. We will now see how we can find an expression for the bulk topological invariant, using inversion symmetry and bulk-boundary correspondence.</p>
<p>So let’s consider a two-dimensional Bloch Hamiltonian $H(\mathbf{k})$ with both inversion and time-reversal symmetry. Inversion symmetry has a unitary operator $\mathcal{P}$ which maps $\mathbf{k}\rightarrow -\mathbf{k}$ and satisfies $\mathcal{P}^2=1$. If we have both inversion symmetry $\mathcal{P}$ and time-reversal $\mathcal{T}$, we get an anti-unitary symmetry $\mathcal{T}\otimes\mathcal{P}$, which preserves $\mathbf{k}$ and squares to $-1$.</p>
<blockquote>
<p>These are precisely the conditions needed for Kramers theorem to apply - only this time, every point $\mathbf{k}$ is mapped to itself because inversion symmetry is included as well. We conclude that every eigenstate at any $\mathbf{k}$ is two-fold degenerate.  We may label these two eigenstates with an index $\sigma=\pm$. If spin is a good quantum number, $\sigma$ labels two states with opposite spin. However, this may not be the case so we will just refer to it as a pseudospin associated with Kramers degeneracy.</p>
</blockquote>
<p>Note that the simplification obtained by adding inversion symmetry is that the spectrum is two-fold degenerate at all $\mathbf{k}$ in the Brillouin zone. Time-reversal symmetry alone cannot guarantee that, because it maps $\mathbf{k}$ to $-\mathbf{k}$.</p>
<p>Our next step is to calculate the effective description of helical edge states at a domain wall between a topological phase and a non-topological phase. This is something we already know how to do thanks to our experience with domain walls in the Kitaev chain and in Chern insulators. It will give us insight into the topological transition and the bulk topological invariant.</p>
<h2 id="Study-of-a-domain-wall"><a href="#Study-of-a-domain-wall" class="headerlink" title="Study of a domain wall"></a>Study of a domain wall</h2><p>Let’s imagine that the helical edge runs along the $y$ direction, and that the domain wall is described by a mass profile $M(x)$ along the $x$ direction, which is zero at the domain wall:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_domain_wall.svg" alt></p>
<p>In this configuration, $k_y$ is still a good quantum number, and we can study the energy dispersion of states bound to the domain wall as a function of $k_y$. If the edge is gapless there must be a momentum, say $\bar{k}_y$, where counterpropagating modes cross at the Fermi level. Let’s fix $k_y=\bar{k}_y$, and write down an effective Hamiltonian for the motion transverse to the domain wall.</p>
<p>We have in total four states, distinguished by two quantum numbers: their direction of propagation, which we denote with $b=\pm$, and their pseudospin $\sigma$. Inversion symmetry $\mathcal{P}$ flips the direction of propagation $b$, while the pseudo-spin degeneracy $\sigma$ is related to the combination of inversion and time-reversal $\mathcal{T}\otimes\mathcal{P}.$ To lowest order in the momentum $k_x$ perpendicular to the domain wall, the states at the transition point disperse linearly with $k_x$, and are two-fold degenerate. In fact, as we noted from Kramers degeneracy, the Hamiltonian must be chosen such that none of the terms break the two-fold degeneracy associated with the pseudospin $\sigma$. This means that the domain wall cannot couple states with different values of $\sigma$, which leads us to an effective Hamiltonian</p>
<p>$$<br>H(\bar{k}<em>y)=\sum</em>{\sigma,b},k_x b,|b,\sigma\rangle\langle b,\sigma|+M(x)(|+,\sigma\rangle\langle -,\sigma|+h.c.)],.<br>$$</p>
<p>where the factor $b$ is odd under time-reversal symmetry so that $k_x b$ is even under time-reversal symmetry.</p>
<p>We are back to an old friend, the one dimensional Dirac Hamiltonian with a position-dependent mass $M(x)$. Adapting our arguments from the first week, we can immediately say that the domain-wall hosts a pair of zero modes only if $M(x)$ changes sign.</p>
<p>As interesting as this sounds, we must remember that this pair of zero modes is present for $k_y=\bar{k}_y$. Because of inversion symmetry, there is necessarily an identical pair at $-\bar{k}_y$. So we get a total of 4 degenerate domain wall states from this type of gap closing - an even number of pairs. As we know form before, such pairs of gap closings do not affect the value of the topological invariant on the two sides of the domain walls. To change the value of the topological invariant, we would need an odd number of pairs crossing zero energy.</p>
<p>However, there are points in momentum space which are mapped onto each other by time-reversal symmetry, up to a reciprocal lattice vector. For these values, the above counting does not hold. People refer to these momenta as “time-reversal invariant momenta” or TRIMs. In the simple case of a square Brillouin zone, they are the points $(k_x, k_y) = (0,0), (0,\pi), (\pi,0),(\pi,\pi)$.</p>
<p>Since TRIMs are their own time-reversed partners, it is still possible for a gap closing at $\bar{k}_y=0$ or $\bar{k}_y=\pi$ to change the topology of the system. In this case, our doubling problem in momentum space is solved, and we can produce just one pair of edge modes at the domain wall. If we move the momentum $k_y$ slightly away from $\bar{k}_y$, the degenerate pair of modes splits linearly to form a single helical mode that produces a non-trivial fermion parity pump.</p>
<p>To make the distinction clear between a gap closing at a finite $\bar{k}_y$ and at a time-reversal invariant point, let’s draw a sketch of the edge dispersion in the two cases.</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_edge_dispersions.svg" alt></p>
<p>Kramers pairs are colored in red and blue and have the same linestyle. On the left, you have two pairs of Kramers partners, which however never meet at zero energy. On the right, there is a single Kramers pair meeting at zero energy. This argument summarizes the simplification that inversion symmetry brings to time-reversal invariant topological insulators.</p>
<blockquote>
<p>We can determine the topological invariant for the inversion symmetric topological insulators entirely from the bulk Hamiltonian at time-reversal invariant momenta, since gap closings at any other point can only add domain wall states in multiples of four.</p>
</blockquote>
<p>Does this mean that any gap closing at a TRIM is a topological transition? The states $|b,\sigma\rangle$ are Bloch states with definite values of $k_y$. We are considering a time-reversal invariant value of $k_y$, and since $b$ is flipped by inversion symmetry, we can apply inversion symmetry to conclude that the states $|\pm,\sigma\rangle$<br>transform into each other under inversion i.e. $\mathcal{P}|\pm,\sigma\rangle= |\mp,\sigma\rangle$. By combining these states<br>into symmetric and anti-symmetric superpositions</p>
<p>$$|e,\sigma\rangle=\frac{1}{\sqrt{2}}\left[|+,\sigma\rangle, + ,|-,\sigma\rangle\right],,\quad |o,\sigma\rangle=\frac{i}{\sqrt{2}}\left[|+,\sigma\rangle, - ,|-,\sigma\rangle\right],$$</p>
<p>we obtain states that are even ($e$) and odd ($o$) under inversion—they are eigenstates of $\mathcal{P}$ with eigenvalue $+1$ or $-1$. They are also eigenstates of $M$ at $k_x=k_y=0$. The factor of $i$ in $|o,\sigma\rangle$ ensures a consistency under the time-reversal transformation, such that $\mathcal{T}|(e,o),\sigma\rangle=\sigma|(e,o),\sigma\rangle$.</p>
<p>Every gap closing at a TRIM is an even parity state crossing with an odd parity state. The effective Hamiltonian of such a gap closing must also add an extra Kramers pair of states at the domain wall, and therefore indeed every gap closing at a TRIM is a topological phase transition, while gap closings at all the other momenta are unimportant due to inversion symmetry.</p>
<p>This leads to a simplified way of computing a topological invariant of quantum spin Hall insulators with inversion symmetry:</p>
<blockquote>
<p>To compute a bulk topological invariant for a two-dimensional topological state with time reversal and inversion symmetry we need to keep track of the parity $P$ of all the occupied eigenstates of $H(\mathbf{k})$ at the different time-reversal invariant momenta in the Brillouin zone. We may write such a bulk topological invariant as a product</p>
</blockquote>
<blockquote>
<p>$$Q=\prod_{n,j}P_{n,j},,$$</p>
</blockquote>
<blockquote>
<p>where $P_{n,j}$ is the parity, $n$ runs over the occupied bands of $H(\mathbf{k})$ and $j$ over the time-reversal invariant momenta.</p>
</blockquote>
<p>You might now worry whether this definition of the invariant relied on having a smooth domain wall. From the fermion parity pump argument, bulk-edge correspondence implies that the bulk must be topologically non-trivial once you have edge states for any termination. Reversing this argument, we know that once we have a topologically non-trivial bulk, we must have helical edge states for any termination.</p>
<p>Thus, by looking at smooth domain walls we are able to establish a connection between the topological invariant in the presence of time-reversal and inversion symmetry, and the existence of helical edge states and fermion-parity pumping that characterizes the two dimensional topological insulator.</p>
<p>As a bonus, thanks to the previous arguments we can begin to understand how to look for two-dimensional topological insulators among real materials, or how to create them. The main idea is to generate a “band-inversion” between an even and an odd parity band at a TRIM.</p>
<p>Such a band inversion is not impossible to achieve in real materials, and can be captured using the BHZ model. But let’s leave this to the next lecture.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"What is the value of the parity invariant $Q$ if you stack together two quantum spin Hall systems  "</span></span><br><span class="line">    <span class="string">"in the topological phase (i.e., both with $Q=-1$)?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The system has edge states and is therefore topologically non-trivial."</span>,</span><br><span class="line">    <span class="string">"The total number of odd parity occupied orbitals must be even, so you get $Q=1$."</span>,</span><br><span class="line">    <span class="string">"It depends on whether the helical states in the two layers have same "</span></span><br><span class="line">    <span class="string">"or opposite spin for a given direction."</span>,</span><br><span class="line">    <span class="string">"The invariant depends on the number of edge Dirac points at $k$ away from 0."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"Both layers have $Q=-1$ and hence an odd number of odd parity orbitals. Therefore, by combining the layers  "</span></span><br><span class="line">    <span class="string">"we get an even number of odd parity orbitals. Hence $Q$, which is the parity of odd parity orbitals must be "</span></span><br><span class="line">    <span class="string">"$Q=1$."</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"ft9ppqqLhH4"</span>, src_location=<span class="string">"5.1-summary"</span>, res=<span class="string">"360"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"QSHE - theory"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w4_haldane/w4_assignments" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w4_haldane/w4_assignments/"
    >src/w4_haldane/w4_assignments</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w4_haldane/w4_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.843Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-more-Chern-insulators"><a href="#Simulations-more-Chern-insulators" class="headerlink" title="Simulations: more Chern insulators"></a>Simulations: more Chern insulators</h1><p>As usual, start by grabbing the notebooks of this week (<code>w4_haldane</code>). They are once again over <a href="http://tiny.cc/topocm_smc" target="_blank" rel="noopener">here</a>.</p>
<h3 id="Yet-another-Chern-insulator"><a href="#Yet-another-Chern-insulator" class="headerlink" title="Yet another Chern insulator"></a>Yet another Chern insulator</h3><p>One more tight binding of a Chern insulator that you can encounter in the wild is a regular square lattice with half a flux quantum of magnetic field per unit cell. If you made the Hofstadter butterfly assignment from the previous week, it’s just in the middle of the butterfly. Half a flux quantum per unit cell means that the hoppings in one direction are purely imaginary, and different rows have alternating signs</p>
<p>$$t_y = t,\quad t_x = (-1)^y it.$$</p>
<p>This model has a dispersion very similar to graphene: it has two Dirac cones without a gap. Like graphene it also has two sites per unit cell, and sublattice symmetry.</p>
<p>Simulate this model. Think which parameters you need to add to it to make it a Chern insulator. Check that the edge states appear, and calculate the Berry curvature.</p>
<h3 id="Back-to-the-winding"><a href="#Back-to-the-winding" class="headerlink" title="Back to the winding"></a>Back to the winding</h3><p>Integration of Berry curvature is just another way to calculate the same quantity: the topological invariant. Verify that the winding of reflection phase gives the same results. To do that, make the pumping geometry out of a Chern insulator rolled into a cylinder, thread flux through it, and check that the topological invariant obtained through Berry curvature integration is the same as that obtained from winding.</p>
<p>We know that Berry curvature is concentrated close to the Dirac points. Do you notice anything similar for the pumped charge?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Labs"</span>, <span class="string">"Chern insulators"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1012-4723"><a href="#arXiv-1012-4723" class="headerlink" title="arXiv:1012.4723"></a>arXiv:1012.4723</h3><p><strong>Hint:</strong> The hunt for flat bands.</p>
<h3 id="arXiv-1409-6715"><a href="#arXiv-1409-6715" class="headerlink" title="arXiv:1409.6715"></a>arXiv:1409.6715</h3><p><strong>Hint:</strong> Making a Chern insulator more like quantum Hall effect.</p>
<h3 id="arXiv-1208-4579"><a href="#arXiv-1208-4579" class="headerlink" title="arXiv:1208.4579"></a>arXiv:1208.4579</h3><p><strong>Hint:</strong> A Chern insulator without lattice.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Reviews"</span>, <span class="string">"Chern insulators"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-src/w4_haldane/haldane_model" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/07/src/w4_haldane/haldane_model/"
    >src/w4_haldane/haldane_model</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w4_haldane/haldane_model/" class="article-date">
  <time datetime="2021-01-07T09:11:06.843Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"></span><br><span class="line">%output size=<span class="number">150</span> fig=<span class="string">'png'</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r"$-\pi$"</span>), (<span class="number">0</span>, <span class="string">"0"</span>), (np.pi, <span class="string">r"$\pi$"</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haldane</span><span class="params">(w=<span class="number">20</span>, boundary=<span class="string">"zigzag"</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape_zigzag</span><span class="params">(pos)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-0.5</span> / np.sqrt(<span class="number">3</span>) - <span class="number">0.1</span> &lt;= pos[<span class="number">1</span>] &lt; np.sqrt(<span class="number">3</span>) * w / <span class="number">2</span> + <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape_armchair</span><span class="params">(pos)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> &lt;= pos[<span class="number">0</span>] &lt; w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> site.family == a:</span><br><span class="line">            <span class="keyword">return</span> p.m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -p.m</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nn_hopping</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> p.t</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nnn_hopping</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1j</span> * p.t_2</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.honeycomb()</span><br><span class="line">    a, b = lat.sublattices</span><br><span class="line">    nnn_hoppings_a = (((<span class="number">-1</span>, <span class="number">0</span>), a, a), ((<span class="number">0</span>, <span class="number">1</span>), a, a), ((<span class="number">1</span>, <span class="number">-1</span>), a, a))</span><br><span class="line">    nnn_hoppings_b = (((<span class="number">1</span>, <span class="number">0</span>), b, b), ((<span class="number">0</span>, <span class="number">-1</span>), b, b), ((<span class="number">-1</span>, <span class="number">1</span>), b, b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> boundary == <span class="string">"zigzag"</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[lat.shape(ribbon_shape_zigzag, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> boundary == <span class="string">"armchair"</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">0</span>, np.sqrt(<span class="number">3</span>))))</span><br><span class="line">        syst[lat.shape(ribbon_shape_armchair, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[lat.neighbors()] = nn_hopping</span><br><span class="line">    syst[</span><br><span class="line">        [kwant.builder.HoppingKind(*hopping) <span class="keyword">for</span> hopping <span class="keyword">in</span> nnn_hoppings_a]</span><br><span class="line">    ] = nnn_hopping</span><br><span class="line">    syst[</span><br><span class="line">        [kwant.builder.HoppingKind(*hopping) <span class="keyword">for</span> hopping <span class="keyword">in</span> nnn_hoppings_b]</span><br><span class="line">    ] = nnn_hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Qi_Wu_Zhang</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.mu * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-0.5j</span> * p.delta * pauli.sy - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1j</span> * p.gamma * pauli.sx - p.gamma * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">    syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">berry_curvature</span><span class="params">(syst, p, ks, num_filled_bands=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Berry curvature of a system.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    sys : kwant.Builder</span></span><br><span class="line"><span class="string">        A 2D infinite system.</span></span><br><span class="line"><span class="string">    p : SimpleNamespace</span></span><br><span class="line"><span class="string">        The arguments expected by the system.</span></span><br><span class="line"><span class="string">    ks : 1D array-like</span></span><br><span class="line"><span class="string">        Values of momentum grid to be used for Berry curvature calculation.</span></span><br><span class="line"><span class="string">    num_filled_bands : int</span></span><br><span class="line"><span class="string">        The number of filled bands.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    bc : 2D array</span></span><br><span class="line"><span class="string">        Berry curvature on each square in a `ks x ks` grid.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># Calculate an array of eigenvectors.</span></span><br><span class="line">    B = np.array(syst.symmetry.periods).T</span><br><span class="line">    A = B @ np.linalg.inv(B.T @ B)</span><br><span class="line"></span><br><span class="line">    syst = kwant.wraparound.wraparound(syst).finalized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">energy</span><span class="params">(kx, ky)</span>:</span></span><br><span class="line">        k = np.array([kx, ky])</span><br><span class="line">        kx, ky = np.linalg.solve(A, k)</span><br><span class="line">        H = syst.hamiltonian_submatrix(params=dict(p=p, k_x=kx, k_y=ky), sparse=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> scipy.linalg.eigh(H)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    vectors = np.array(</span><br><span class="line">        [[energy(kx, ky)[:, :num_filled_bands] <span class="keyword">for</span> kx <span class="keyword">in</span> ks] <span class="keyword">for</span> ky <span class="keyword">in</span> ks]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The actual Berry curvature calculation</span></span><br><span class="line">    vectors_x = np.roll(vectors, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    vectors_xy = np.roll(vectors_x, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    vectors_y = np.roll(vectors, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    shifted_vecs = [vectors, vectors_x, vectors_xy, vectors_y]</span><br><span class="line"></span><br><span class="line">    v_shape = vectors.shape</span><br><span class="line"></span><br><span class="line">    shifted_vecs = [i.reshape(<span class="number">-1</span>, v_shape[<span class="number">-2</span>], v_shape[<span class="number">-1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> shifted_vecs]</span><br><span class="line"></span><br><span class="line">    dets = np.ones(len(shifted_vecs[<span class="number">0</span>]), dtype=complex)</span><br><span class="line">    <span class="keyword">for</span> vec, shifted <span class="keyword">in</span> zip(shifted_vecs, np.roll(shifted_vecs, <span class="number">1</span>, <span class="number">0</span>)):</span><br><span class="line">        dets *= [np.linalg.det(a.T.conj() @ b) <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(vec, shifted)]</span><br><span class="line">    bc = np.angle(dets).reshape(int(np.sqrt(len(dets))), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    bc = (bc + np.pi / <span class="number">2</span>) % (np.pi) - np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_berry_curvature</span><span class="params">(syst, p, ks=None, title=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ks <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ks = np.linspace(-np.pi, np.pi, <span class="number">150</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">    bc = berry_curvature(syst, p, ks)[<span class="number">1</span>:<span class="number">-1</span>, <span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line">    vmax = max(np.abs(bc).min(), np.abs(bc).max())</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">"bounds"</span>: (ks.min(), ks.min(), ks.max(), ks.max()),</span><br><span class="line">        <span class="string">"kdims"</span>: [<span class="string">r"$k_x$"</span>, <span class="string">r"$k_y$"</span>],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> callable(title):</span><br><span class="line">        kwargs[<span class="string">"label"</span>] = title(p)</span><br><span class="line"></span><br><span class="line">    plot = &#123;<span class="string">"xticks"</span>: pi_ticks, <span class="string">"yticks"</span>: pi_ticks&#125;</span><br><span class="line">    style = &#123;<span class="string">"clims"</span>: [-vmax, vmax]&#125;</span><br><span class="line">    <span class="keyword">return</span> holoviews.Image(bc, **kwargs).opts(plot=plot, style=style)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span><span class="params">(p)</span>:</span></span><br><span class="line">    title = <span class="string">r"$t=&#123;:.2&#125;$, $t_2=&#123;:.2&#125;$, $M=&#123;:.2&#125;$"</span></span><br><span class="line">    <span class="keyword">return</span> title.format(p.t, p.t_2, p.m)</span><br></pre></td></tr></table></figure>

<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Duncan Haldane from Princeton University will teach us about an interesting two dimensional toy-model which he <a href="http://faculty.washington.edu/cobden/papers/haldane88.pdf" target="_blank" rel="noopener">introduced</a> in 1988, and which has become a prototype for the anomalous quantum Hall effect.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"7nVO4uMm-do"</span>, src_location=<span class="string">"4.2-intro"</span>)</span><br></pre></td></tr></table></figure>

<p>We will now study the model in detail, starting from the beginning.  Along the way, we will also learn about the Chern number, the bulk topological invariant of a quantum Hall state.</p>
<h1 id="Dirac-cones-in-graphene"><a href="#Dirac-cones-in-graphene" class="headerlink" title="Dirac cones in graphene"></a>Dirac cones in graphene</h1><p>In the last chapter we saw how it is possible to obtain a quantum Hall state by coupling one-dimensional systems. At the end, our recipe was to first obtain a Dirac cone, add a mass term to it and finally to make this mass change sign. Following this recipe we were able to obtain chiral edge states without applying an external magnetic field.</p>
<p>There is a real (and a very important) two-dimensional system which has Dirac cones: <a href="http://en.wikipedia.org/wiki/Graphene" target="_blank" rel="noopener">graphene</a>. So in this chapter we will take graphene and make it into a topological system with chiral edge states.</p>
<p>Graphene is a single layer of carbon atoms arranged in a honeycomb lattice. It is a triangular lattice with two atoms per unit cell, type $A$ and type $B$, represented by red and blue sites in the figure:</p>
<p><img src="/2021/01/07/src/w4_haldane/haldane_model/graphene.svg" alt></p>
<p>Hence, the wave function in a unit cell can be written as a vector $(\Psi_A, \Psi_B)^T$ of amplitudes on the two sites $A$ and $B$. Taking a simple tight-binding model where electrons can hop between neighboring sites with hopping strength $t$, one obtains the Bloch Hamiltonian:</p>
<p>$$<br>H_0(\mathbf{k})= \begin{pmatrix} 0 &amp; h(\mathbf{k}) \ h^\dagger(\mathbf{k}) &amp; 0 \end{pmatrix},,<br>$$</p>
<p>with $\mathbf{k}=(k_x, k_y)$ and</p>
<p>$$h(\mathbf{k}) = t_1,\sum_i,\exp,\left(i,\mathbf{k}\cdot\mathbf{a}_i\right),.$$</p>
<p>Here $\mathbf{a}_i$ are the three vectors in the figure, connecting nearest neighbors of the lattice [we set the lattice spacing to one, so that for instance $\mathbf{a}_1=(1,0)$].  Introducing a set of Pauli matrices $\sigma$ which act on the sublattice degree of freedom, we can write the Hamiltonian in a compact form as</p>
<p>$$H_0(\mathbf{k}) = t_1,\sum_i,\left[\sigma_x,\cos(\mathbf{k}\cdot\mathbf{a}_i)-\sigma_y ,\sin(\mathbf{k}\cdot\mathbf{a}_i)\right],.$$</p>
<p>The energy spectrum $E(\mathbf{k}) = \pm ,\left|h(\mathbf{k})\right|$ gives rise to the famous band structure of graphene, with the two bands touching at the six corners of the Brillouin zone:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, t_2=<span class="number">0.0</span>, m=<span class="number">0.0</span>, phi=np.pi / <span class="number">2</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">"infinite"</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">150</span>)</span><br><span class="line">spectrum(syst, p, k_x=k, k_y=k, title=title)</span><br></pre></td></tr></table></figure>

<p>Only two of these six Dirac cones are really distinct, the ones at $\mathbf{K}=(2\pi/3, 2\pi/3\sqrt{3})$ and $\mathbf{K}’=(2\pi/3, -2\pi/3\sqrt{3})$. All the others can be obtained by adding some reciprocal lattice vector to $\mathbf{K}$ and $\mathbf{K}’$.</p>
<h1 id="Discrete-symmetries-of-graphene"><a href="#Discrete-symmetries-of-graphene" class="headerlink" title="Discrete symmetries of graphene"></a>Discrete symmetries of graphene</h1><p>The symmetries of graphene were discussed intensively in the video, so let’s review them.</p>
<p>As we already said in our first week, graphene is the prototype of a system with sublattice symmetry, which makes the Hamiltonian block off-diagonal with respect to the two sublattices. The sublattice symmetry reads</p>
<p>$$\sigma_z,H_0(\mathbf{k}),\sigma_z = -H_0(\mathbf{k}),.$$</p>
<p>Sublattice symmetry is only approximate, and it is consequence of the nearest neighbor tight-binding model. Just like the inversion symmetry mentioned in the video, it protects the Dirac points and needs to be broken in order to open a gap.</p>
<p>In addition to sublattice and inversion symmetry, the honeycomb lattice also has a three-fold rotation symmetry around the center of the unit cell. This symmetry is important to make the Dirac cones appear in the first place, but it will not play a role in all that follows.</p>
<p>Finally, there is time-reversal symmetry, which at the moment is perfectly preserved in our tight-binding model. Since we are not considering the spin degree of freedom of the electrons, the time-reversal symmetry operator in real space is just complex conjugation. In momentum space representation, time-reversal symmetry reads</p>
<p>$$ H_0(\mathbf{k}) = H_0^*(-\mathbf{k}),.$$</p>
<p>It’s important to note that time-reversal symmetry sends $\mathbf{K}$ into $\mathbf{K}’$ and therefore it exchanges the two Dirac cones.</p>
<p>The product of (approximate) sublattice and time-reversal symmetries yields a further discrete symmetry, a particle-hole symmetry $\sigma_z H^*(-\mathbf{k}),\sigma_z = -H_0(\mathbf{k})$.</p>
<h1 id="Making-graphene-topological"><a href="#Making-graphene-topological" class="headerlink" title="Making graphene topological"></a>Making graphene topological</h1><p>Let’s recall that our goal is to make our graphene sheet enter a quantum Hall state, with chiral edge states. The first necessary step is to make the bulk of the system gapped. </p>
<p>How can we open a gap in graphene? The Dirac points are protected by both sublattice (inversion) and time-reversal symmetry. So there are many ways we can think of to open an energy gap at $\mathbf{K}$ and $\mathbf{K}’$.</p>
<h2 id="First-try"><a href="#First-try" class="headerlink" title="First try"></a>First try</h2><p>The easiest way to break sublattice symmetry is to assign an opposite onsite energy $M$ or $-M$ to the $A$ or $B$ sites respectively. The Hamiltonian is then given by</p>
<p>$$ H_0(\mathbf{k}) + M,\sigma_z,.$$</p>
<p>This leads to a gapped spectrum,</p>
<p>$$E(\mathbf{k})=\pm \sqrt{\left|h(\mathbf{k})\right|^2 + M^2},.$$</p>
<p>However, we quickly realize that by doing this we end up in a rather boring situation. Taking the limit $\left|M\right| \gg t_1$, we obtain electronic states which are localized in one of the two sublattices $A$ or $B$, independent of the sign of $M$. Most importantly, there is no trace of edge states.</p>
<p>It’s easy to see why this mass term is hopeless: it preserves time-reversal symmetry. And with the time-reversal symmetry present, it is definitely impossible to obtain chiral edge states.</p>
<h2 id="Second-try"><a href="#Second-try" class="headerlink" title="Second try"></a>Second try</h2><p>There is another, more ingenious way to gap out the Dirac cones in graphene, which is the essence of today’s model. It involves adding imaginary second-nearest neighbor hoppings, with the following distinctive pattern:</p>
<p><img src="/2021/01/07/src/w4_haldane/haldane_model/haldane_hoppings.svg" alt></p>
<p>With the direction of the arrow, we denote the direction in which the hopping is $+it_2$ (it is $-it_2$ in the opposite direction).</p>
<p>Note the following things about these hoppings:</p>
<ul>
<li>they are purely imaginary and, furthermore, they all have the same chirality, in the sense that they all follow the orientation of your right hand, if the thumb points out from the screen.</li>
<li>they couple sites of same type: $A$ with $A$ and $B$ with $B$.</li>
</ul>
<p>These characteristics tell us that the new hoppings break both time-reversal symmetry and sublattice symmetry. Now the full Hamiltonian becomes</p>
<p>$$<br>H(\mathbf{k}) = H_0(\mathbf{k})+ M\sigma_z + 2t_2\sum_i,\sigma_z,\sin(\mathbf{k}\cdot\mathbf{b}_i),.<br>$$</p>
<p>The last term changes sign under time-reversal symmetry, breaking it. This is the Hamiltonian of the Haldane model.</p>
<p>Let’s see what happens to the system when these special second neighbor hoppings are turned on:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>, t_2=<span class="literal">None</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">"infinite"</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">"k_x"</span>: k, <span class="string">"k_y"</span>: k, <span class="string">"title"</span>: title&#125;</span><br><span class="line">t_2s = np.linspace(<span class="number">0</span>, <span class="number">0.10</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.t_2: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.t_2 <span class="keyword">in</span> t_2s&#125;, kdims=[<span class="string">r"$t_2$"</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>When $t_2=0$ and at a finite $M$, the system is in a boring gapped phase, generically without zero energy states. As you heard in the video, there might be zero energy states for some specific termination of the lattice, but these are not particularly interesting.</p>
<p>Adding a small $t_2$ initially does not change the situation, but when $t_2$ passes through a value $\pm M/3\sqrt{3}$ the gap closes and changes sign. Importantly, the gap closes <em>only at one of the two Dirac points</em>: at $\mathbf{K}’$ for $t_2=M/3\sqrt{3}$ and at $\mathbf{K}$ for $t_2=-M/3\sqrt{3}$.</p>
<p>And when it does, chiral edge states appear! We can see this by looking at the one-dimensional band structure of a ribbon of graphene. To convince you that they are of topological origin, let’s look at the bandstructure for ribbons with two different lattice terminations: armchair and zigzag. In a zigzag ribbon, $\mathbf{K}$ and $\mathbf{K}’$ correspond to different momenta parallel to the ribbon direction, while in an armchair one they correspond to the same one.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">'svg'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ribbon_bandstructure</span><span class="params">(t_2, boundary)</span>:</span></span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, t_2=t_2, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> boundary == <span class="string">"zigzag"</span>:</span><br><span class="line">        syst = haldane(w=<span class="number">20</span>, boundary=<span class="string">"zigzag"</span>)</span><br><span class="line">    <span class="keyword">elif</span> boundary == <span class="string">"armchair"</span>:</span><br><span class="line">        syst = haldane(w=<span class="number">20</span>, boundary=<span class="string">"armchair"</span>,)</span><br><span class="line"></span><br><span class="line">    style = &#123;</span><br><span class="line">        <span class="string">"k_x"</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">        <span class="string">"xdim"</span>: <span class="string">r"$k$"</span>,</span><br><span class="line">        <span class="string">"ydim"</span>: <span class="string">r"$E/t$"</span>,</span><br><span class="line">        <span class="string">"xticks"</span>: pi_ticks,</span><br><span class="line">        <span class="string">"yticks"</span>: [<span class="number">-3</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">        <span class="string">"ylims"</span>: [<span class="number">-3.2</span>, <span class="number">3.2</span>],</span><br><span class="line">        <span class="string">"title"</span>: title,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> spectrum(syst, p, **style)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t_2s = np.linspace(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">20</span>)</span><br><span class="line">boundaries = [<span class="string">"zigzag"</span>, <span class="string">"armchair"</span>]</span><br><span class="line">plots = &#123;</span><br><span class="line">    (t_2, boundary): ribbon_bandstructure(t_2, boundary)</span><br><span class="line">    <span class="keyword">for</span> t_2 <span class="keyword">in</span> t_2s</span><br><span class="line">    <span class="keyword">for</span> boundary <span class="keyword">in</span> boundaries</span><br><span class="line">&#125;</span><br><span class="line">holoviews.HoloMap(plots, kdims=[<span class="string">r"$t_2$"</span>, <span class="string">"Boundary"</span>])</span><br></pre></td></tr></table></figure>

<p>The appearance of edge states means that graphene has entered a topological phase after the gap closing. This phase is akin to the quantum Hall phase - the edge states are of the same kind. However, as Duncan Haldane explained in the introduction, it is realized without a strong magnetic field.</p>
<p>As you know, this means we have created a <strong>Chern insulator</strong>. The reason for this name will become obvious in the second part of the lecture.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"What happens if we take a Haldane model in the topological phase and turn "</span></span><br><span class="line">    <span class="string">"on a weak magnetic field?"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"Magnetic field introduces Landau levels, which change the number of edge states."</span>,</span><br><span class="line">    <span class="string">"Since the magnetic field is weak, nothing changes as long as it doesn't close the gap"</span>,</span><br><span class="line">    <span class="string">"The bulk gap closes and there are no edge states anymore."</span>,</span><br><span class="line">    <span class="string">"The gap doesn't close but the edge states may change direction "</span></span><br><span class="line">    <span class="string">"of propagation, depending on the sign of magnetic field."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">"Topological robustness is still present, so the number of edge states cannot change unless the gap closes."</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Pumping-in-terms-of-Berry-phase"><a href="#Pumping-in-terms-of-Berry-phase" class="headerlink" title="Pumping in terms of Berry phase"></a>Pumping in terms of Berry phase</h1><p>Last week we understood the quantum Hall effect in terms of a pumping argument that we attributed to Laughlin.</p>
<p>Our pumping argument involved putting our system on a cylinder and adiabatically pumping a magnetic flux $\Phi$ through the cylinder so that the Hamiltonian returns to itself. The flux enters the Hamiltonian through minimal substitution as $H(\mathbf{k})\rightarrow H(\mathbf{k}+e\mathbf{A})$ where ${\bf A}=\hat{\mathbf{y}},\Phi/L$.</p>
<p>Thus we can understand the effects of flux pumping on the Hamiltonian in terms of a change in momentum. When the flux is changed by the appropriate number of quanta, the momentum $\mathbf{k}$ changes by a reciprocal lattice vector and, hence the Bloch Hamiltonian returns to its original value. To simplify the discussion, in the following we will use a square Brillouin zone, with $k_x$ and $k_y$ defined in an interval $[0, 2\pi]$, but all our arguments also apply for the hexagonal Brillouin zone of graphene.</p>
<p>Let’s imagine the adiabatic time-evolution of an eigenstate $\left|\psi(\mathbf{k})\right\rangle$ of this Hamiltonian, with energy $E(\mathbf{k})$, as $\mathbf{k}$ is changed slowly. Suppose the Hamiltonian is such that $\left|\psi(\mathbf{k})\right\rangle$ remains non-degenerate as in the case of the Haldane model.  We can then adiabatically explore an energy band by moving $\mathbf{k}$, without the risk of encountering a level crossing. After a while, let’s say a time $T$, we bring $\mathbf{k}$ back to its initial value after going around the entire Brillouin Zone. For instance, we can consider the following closed path $C$, where $k_y$ changes by $2\pi$ at a fixed $k_x$, starting from $k_y=0$:</p>
<p><img src="/2021/01/07/src/w4_haldane/haldane_model/bz_path.svg" alt></p>
<p>We then ask: what is the final quantum state at the time $T$? For a long time people guessed that it would just be given by the initial state $\left|\psi(k_x, k_y+2\pi)\right\rangle\equiv\left|\psi(k_x, k_y)\right\rangle$ times  the usual phase $\exp\left(-i \int_0^T E[\mathbf{k}(t)],d t\right)$, which an eigenstate of the Hamiltonian accumulates with time. </p>
<p>This would be rather boring. Berry instead realized that for a closed loops there is an additional phase $\gamma$, which in our case may depend on $k_x$:</p>
<p>$$\gamma(C) = \oint_C,\mathbf{A}(\mathbf{k}),\cdot d\mathbf{k},.$$</p>
<p>Here, $\mathbf{A}(\mathbf{k})=i\left\langle,\psi(\mathbf{k}) ,|,\nabla_\mathbf{k},\psi(\mathbf{k})\right\rangle$ is a vector with two complex entries, which are obtained by taking the derivatives of $\left|\psi(\mathbf{k})\right\rangle$ with respect to $k_x$ and $k_y$ and then taking the inner product with $\left\langle\psi(\mathbf{k})\right|$. This vector goes by the rather obscure name of Berry connection. In our example, the final quantum state at the end of the cycle is thus</p>
<p>$$\exp,\left[i\gamma(k_x)\right],\exp,\left(-i \int_0^T E[\mathbf{k}(t)],d t\right),\left|\psi(\mathbf{k})\right\rangle,.$$</p>
<p>We have made explicit the fact that $\gamma$ in our case may depend on $k_x$. We will not derive the formula for the Berry phase, something which can be done directly from the Schrödinger equation, see for instance <a href="http://arxiv.org/abs/0907.2021" target="_blank" rel="noopener">here</a>. What is important to know about $\gamma$ is that it is a <strong>geometric phase</strong>: its value depends on the path $C$ but not on how the path is performed in time, so not on the particular expression for $\mathbf{k}(t)$. We’ll soon see that sometimes it can have an even stronger, topological character.  </p>
<h2 id="Flux-pumping"><a href="#Flux-pumping" class="headerlink" title="Flux pumping"></a>Flux pumping</h2><p>The phase $\gamma(k_x)$ must bear information about the charge pumped during an adiabatic cycle over $k_y$. Now we take advantage of pumped charge being invariant as long as the energy gap is preserved. This means that we have the freedom to change the energy dispersion $E(k_x,k_y)$ arbitrarily, as long as we do not close the gap.</p>
<p>It is convenient to make the energy dispersion completely flat along the $k_x$ direction for $k_y=0$, analogous to the case of Landau levels. In this way, since at fixed $k_y$ all the wave functions have the same energy, we can choose our initial quantum state to be localized in a single unit cell in the $x$ direction,</p>
<p>$$\left|\psi(n,t=0)\right\rangle=\int_0^{2\pi} dk_x, e^{i k_x n},\left|\psi(k_x, k_y=0)\right\rangle,.$$</p>
<p>Starting from this state, after one adiabatic cycle we obtain</p>
<p>$$\left|\psi(n,t=T)\right\rangle=\int_0^{2\pi} dk_x, e^{i k_x n},\exp,\left[i\gamma(k_x)-i\theta(k_x)\right],\left|\psi(k_x, k_y=2\pi)\right\rangle,$$</p>
<p>where $\theta(k_x)=\int_0^T E[k_x, k_y(t)],d t$ is the dynamical phase. Now we notice something strange. While $\theta(k_x)$ is a truly periodic function of $k_x$ because $E(k_x)=E(k_x+2\pi)$, the only restriction on the Berry phase $\gamma(k_x)$ is to be periodic modulo $2\pi$. That is, we can have $\gamma(k_x+2\pi)=\gamma(k_x)+2\pi W$ with $W$ an integer number.</p>
<p>Let’s try to deform the dispersion along $k_y$ in order to make the combination $\gamma(k_x)-\theta(k_x)$ as large as possible (just like before, this is allowed as long as we do not close the gap). The best we can do is choose $\theta(k_x)$ so that </p>
<p>$$\gamma(k_x)-\theta(k_x)=W k_x.$$</p>
<p>Plugging this in to the form of the wave-function we see that </p>
<p>$$\left|\psi(n,t=T)\right\rangle=\int dk_x e^{i k_x (n+W)},\left|\psi(k_x, k_y=0)\right\rangle,$$</p>
<p>which means that every wave function is shifted over by $W$ unit cells. Thus the system with the wave functions $\left|\psi(\mathbf{k})\right\rangle$ pumps $W$ units of charge if the Berry phase satisfies </p>
<p>$$\gamma(k_x+2\pi)-\gamma(k_x)=2\pi W.$$</p>
<blockquote>
<p>The quantity $W$ is called the <strong>Chern number</strong> and is the topological invariant characterizing the bandstructure of two dimensional quantum Hall systems. Because it is an integer, it cannot be changed by any continuous deformation of the Hamiltonian, provided the gap does not close. The Chern number is in fact the bulk topological invariant for all insulators with broken time-reversal symmetry. If $W=0$, we have a topologically trivial insulator with no chiral edge states. If $W=n$ there are $n$ chiral edge states at the boundary of the insulator.</p>
</blockquote>
<h1 id="Compact-form-of-the-Chern-number-as-Berry-curvature"><a href="#Compact-form-of-the-Chern-number-as-Berry-curvature" class="headerlink" title="Compact form of the Chern number as Berry curvature"></a>Compact form of the Chern number as Berry curvature</h1><p>We did not denote the Berry connection as $\mathbf{A}(\mathbf{k})$ just by chance. We picked that letter because this vector reminds us a lot of the vector potential $\mathbf{A}(\mathbf{r})$ that is used in electromagnetism.</p>
<p>Just like the vector potential, the definition of $\mathbf{A}(\mathbf{k})$ depends on a particular choice of the person making the calculation. If you decide to multiply the quantum state by a phase, $\left|\psi(\mathbf{k})\right\rangle,\to \exp,[i\lambda(\mathbf{k})],\left|\psi(\mathbf{k})\right\rangle$, then you get that the Berry connection transforms as $\mathbf{A}(\mathbf{k}),\to,\mathbf{A}(\mathbf{k})+\nabla_\mathbf{k} ,\lambda$. However, when you take the integral of $\mathbf{A}(\mathbf{k})$ on a closed path, the result is independent of $\lambda$. That’s why the Berry phase is only meaningful for closed paths. </p>
<p>Now that we have established an analogy with the vector potential, we cannot avoid the idea of taking the curl of the Berry connection, which is known as the <strong>Berry curvature</strong>:</p>
<p>$$\mathbf{\Omega}(\mathbf{k}) = \nabla_\mathbf{k} \times \mathbf{A}(\mathbf{k})=i\left[\left\langle \frac{\partial \psi(\mathbf{k})}{\partial k_x},\Bigg|,\frac{\partial,\psi(\mathbf{k})}{\partial k_y}\right\rangle-\left\langle \frac{\partial \psi(\mathbf{k})}{\partial k_y},\Bigg|,\frac{\partial,\psi(\mathbf{k})}{\partial k_x}\right\rangle\right],.$$</p>
<p>The Berry curvature is like a <em>magnetic field in momentum space</em>. Just like the magnetic field $\mathbf{B}(\mathbf{r})=\nabla_\mathbf{r}\times\mathbf{A}(\mathbf{r})$ in electromagnetism, it is a local quantity which does not suffer from the ambiguities of the vector potential (it is gauge independent).</p>
<p>The main advantage of introducing the analogy with the magnetic field is that it motivates us to use Stokes theorem. The Brillouin Zone has the shape of a torus. Therefore the curve $k_x=0$ and $k_x=2\pi$ on the torus bounds the entire Brillouin zone. Using Stokes theorem on this curve we can conclude that </p>
<p>$$2\pi W=\gamma(2\pi)-\gamma(0)=\iint_{\textrm{BZ}} \mathbf{\Omega}(\mathbf{k}),\cdot,d\mathbf{S},,$$</p>
<p>where the integral extends over the entire Brillouin Zone.</p>
<blockquote>
<p>As a result of this formalism, we have established two things. First, there is a Chern number which is defined entirely in terms of the momentum space wave functions. Second, the analogy with the magnetic field allows us to obtain an explicit expression for the Chern number in terms of derivatives of the wave functions.</p>
</blockquote>
<p>Loosely speaking, a situation with a non-zero Chern number is a bit like having a magnetic monopole, because we have a finite flux coming out of a closed surface. Now, you probably know that experimentally a magnetic monopole was never observed. For our Chern number in the Brillouin zone the situation is more exciting, as situations where it is non-zero are realized in nature.</p>
<p>To see how this can happen, we first have to understand the following: if there is Berry curvature in the Brillouin zone, what are its sources?</p>
<h1 id="Gap-closings-are-sources-of-Berry-curvature"><a href="#Gap-closings-are-sources-of-Berry-curvature" class="headerlink" title="Gap closings are sources of Berry curvature"></a>Gap closings are sources of Berry curvature</h1><p>The Berry phase can only be computed if the Hamiltonian has a gap. For a Hamiltonian $H(\mathbf{k})$ with many bands $E_n(\mathbf{k})$, this means that we can compute the Chern number only for an isolated band $E_n(\mathbf{k})$ which does not touch any other band. If there is a band touching, the Berry phase is undefined.</p>
<p>Now let’s go back to our analogy with electromagnetism. We know that we cannot compute the electric or magnetic flux through a surface if there are electric or magnetic charges sitting exactly on it. That’s because the electric or magnetic fields are <em>not defined</em> at the points where their sources are.</p>
<p>This analogy suggests the following: that the sources for Berry flux in momentum space are points where two bands touch, just like the Dirac points at the $\mathbf{K}$ and $\mathbf{K}’$ points of the Brillouin zone in graphene.</p>
<p>This may sound a bit abstract and confusing: where are these points located? We are used to thinking about sources of flux in real space, not in momentum space. In fact, just like you do with a two-dimensional sphere surrounding a charge in three-dimensional space, you can think of the Brillouin zone as lying in a three-dimensional space, with two directions given by $k_x$ and $k_y$ and the third given by the <strong>magnitude of the energy gap</strong>. </p>
<p>The situation is explained by the following sketch, which also gives a bird’s-eye view of the phase diagram of the Haldane model as a function of the ratio $t_2/M$:</p>
<img src="/2021/01/07/src/w4_haldane/haldane_model/phasediagram.svg" alt="Phase diagram" style="width: 70%">

<p>What you see in the sketch above is a schematic illustration of the energy spectrum close to the Dirac points in the Brillouin zone, for some representative values of $t_2/M$ (for simplicity we drew the Brillouin zone as a square and not a hexagon, but that’s not essential). The two massless Dirac cones appearing for $t_2=\pm M/(3\sqrt{3})$ are the sources of the Berry curvature, which then “spreads“ along the vertical axis, passing through the Brillouin zones of the gapped phases.</p>
<p>The $t_2=0$ Brillouin zone is “sandwiched“ between the two gap closings: it has opposite curvature for the two Dirac points, and a total Chern number of zero.</p>
<p>The Brillouin zones for $|t_2|&gt;M/(3\sqrt{3})$, on the other hand, have Berry curvature with the same sign for both Dirac points, and a total Chern number equal to $\pm 1$.</p>
<p>To see this more clearly, we can compute the Berry curvature numerically and plot it over the whole Brillouin zone as a function of $t_2$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>, t_2=<span class="literal">None</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">"infinite"</span>)</span><br><span class="line">kwargs = &#123;<span class="string">"title"</span>: title, <span class="string">"ks"</span>: np.linspace(<span class="number">-2</span> * np.pi, <span class="number">2</span> * np.pi, <span class="number">150</span>, endpoint=<span class="literal">False</span>)&#125;</span><br><span class="line">t_2s = np.linspace(<span class="number">-0.1</span>, <span class="number">0.1</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.t_2: plot_berry_curvature(syst, p, **kwargs) <span class="keyword">for</span> p.t_2 <span class="keyword">in</span> t_2s&#125;, kdims=[<span class="string">r"$t_2$"</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">"How does time-reversal symmetry influence the Berry curvature?"</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The Berry curvature breaks time-reversal, so it must be zero if time-reversal is present."</span>,</span><br><span class="line">    <span class="string">"Time reversal symmetry doesn't constrain Berry curvature at all."</span>,</span><br><span class="line">    <span class="string">"There is no constraint, only the integral of Berry curvature (Chern number) should be zero."</span>,</span><br><span class="line">    <span class="string">"The Berry curvature and momentum change sign under time-reversal, so that the Berry curvature "</span></span><br><span class="line">    <span class="string">"at one momentum becomes opposite to the Berry curvature at opposite momentum."</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(question=question, answers=answers, correct_answer=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>You can see that the Berry curvature is really located around the Dirac points. Around $t_2=0$, the two Dirac points give canceling contributions. After a gap closing however, the contribution of one of the two Dirac points changes sign, so that the two add to $\pm 1$ instead of canceling each other.</p>
<p>From both the plots above, you can also infer that each Dirac point always contributes a Berry curvature equal to $\pm 1/2$, depending on the sign of the mass in the effective Dirac Hamiltonian. We always obtain an integer number because the number of Dirac points in the Brillouin zone is even. It also implies that when the gap changes sign at a Dirac point, the Chern number changes by exactly one!</p>
<p>At the same time it’s important to know that the particular distribution of the Berry curvature depends on all the details of the eigenstates of the Hamiltonian, so it changes a lot from model to model. And in fact, it is a special feature of the Haldane model that the Berry curvature is focused around two distinct points in the Brillouin zone.</p>
<p>For instance, here is a slider plot for the Berry curvature for the quantum Hall lattice model studied in the previous chapter.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, gamma=<span class="number">-0.5</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = Qi_Wu_Zhang()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title_Qi</span><span class="params">(p)</span>:</span></span><br><span class="line">    title = <span class="string">r"$t=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$, $\gamma=&#123;:.2&#125;$"</span></span><br><span class="line">    <span class="keyword">return</span> title.format(p.t, p.mu, p.delta, p.gamma)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kwargs = &#123;<span class="string">"title"</span>: title_Qi&#125;</span><br><span class="line">mus = np.linspace(<span class="number">-2</span>, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: plot_berry_curvature(syst, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r"$\mu$"</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>You can see that for $\mu &lt; -2t - 2\gamma$ there is a net curvature, and that when $\mu = -2t - 2\gamma$ some flux of opposite sign appears at $k_x = k_y=0$, the Dirac point, which leaves no net curvature and leads to a change in the Chern number. This is the signature of the topological transition seen from the Berry curvature.</p>
<h1 id="Summary-extending-the-model-to-spinful-electrons-and-photons"><a href="#Summary-extending-the-model-to-spinful-electrons-and-photons" class="headerlink" title="Summary: extending the model to spinful electrons and photons"></a>Summary: extending the model to spinful electrons and photons</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"0gxE68kvdmw"</span>, src_location=<span class="string">"4.2-summary"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"Haldane model"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020-2021
        huyi
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>

      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="O"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/logs/">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="www.huyiph.xyz:8000">网盘</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/aria">aria2</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['----------------------', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>




  <script src='https://unpkg.com/mermaid@v8.4.8/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


    
  </div>
</body>

</html>