<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="demon" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> O</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/icon.svg" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
      <script src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js"></script>
      
    <link rel="alternate" href="/atom.xml" title="O" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/my_cover2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">O</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['————————————————————————————————————————', '', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  <article class="articles">
    
    
    
    
    <article
  id="post-src/w4_haldane/ComputingChern"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w4_haldane/ComputingChern/" class="article-date">
  <time datetime="2021-01-07T09:11:06.836Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Additional-notes-on-computing-Chern-number"><a href="#Additional-notes-on-computing-Chern-number" class="headerlink" title="Additional notes on computing Chern number"></a>Additional notes on computing Chern number</h2><p>Computing the Chern number from the Berry connection  $\bf{a}(\bf {k})=i\langle u(\bf{k})|\bf{\nabla}(|u(\bf{k})\rangle)$ is annoying because one needs to find a gauge where the Bloch wave-functions $u_n({\bf k})$ are continuous.</p>
<p>On the other hand, the Chern number is really the integral of the Berry curvature </p>
<p>$${\bf{b}(k)}={\bf\nabla\times a(k)}$$ </p>
<p>as</p>
<p>$$\Phi=\oint d^2\bf{k}\bf{z}\cdot \bf{b}(\bf{k}).$$</p>
<p>Numerically it is more convenient to compute the integral $\Phi$ by breaking them down into small plaquettes. So that </p>
<p>$$\Phi=\sum_n \oint_{\Gamma_n} d^2\bf{k}\bf{z}\cdot \bf{b}(\bf{k})=\sum_n \oint_{\Gamma_n} d{\bf k}\cdot {\bf a(k)},$$<br>is broken down into chunks<br>$$\Phi_n=i\oint_{\Gamma_n} d{\bf k}\cdot {\langle u(\bf{k})|\bf{\nabla}(|u(\bf{k})\rangle)}.$$</p>
<p>For sufficiently small chunks $\Phi_n$ is small and one can get away with computing the exponential </p>
<p>$$e^{i\Phi_n}=e^{\oint_{\Gamma_n} d{\bf k}\cdot {\langle u(\bf{k})|\bf{\nabla}(|u(\bf{k})\rangle)}}=\prod_p e^{\delta{\bf k}<em>{n,p}\cdot {\langle u(\bf{k}</em>{n,p})|\bf{\nabla}(|u(\bf{k}<em>{n,p})\rangle)}}\approx \prod_p (1+\delta k</em>{n,p}\langle u(\bf{k}<em>{n,p})|\bf{\nabla}(|u(\bf{k}</em>{n,p})\rangle)\approx \prod_p \langle u(\bf{k}<em>{n,p})|u(\bf{k}</em>{n,p+1})\rangle.$$</p>
<p>The flux on the small plaquette can be computed as </p>
<p>$$\Phi_n=\textrm{Arg}(\prod_p \langle u({\bf k}<em>{n,p})|u({\bf k}</em>{n,p+1})\rangle).$$</p>
<p>What is nice about this product is that it is gauge invariant as can be checked by multiplying each wave-function $|u({\bf k}<em>{n,p})\rangle\rightarrow e^{i\varphi({\bf k}</em>{n,p})}|u({\bf k}_{n,p})\rangle$.</p>
<p>The nice thing about this expression is that one can also generalize this to multiband systems to calculate the total Chern number so that the contribution from each plaquette </p>
<p>$$e^{i\Phi_n}\approx \prod_p\prod_s \langle u_s(\bf{k}<em>{n,p})|u_s(\bf{k}</em>{n,p+1})\rangle=\prod_p Det[\langle u_s(\bf{k}<em>{n,p})|u_s(\bf{k}</em>{n,p+1})\rangle],$$<br>where $s$ labels the band index.</p>
<p>What Vanderbilt and coworkers pointed out is that this expression can be written as<br>$$e^{i\Phi_n}=\prod_p Det[\langle u_s(\bf{k}<em>{n,p})|u</em>{s’}(\bf{k}<em>{n,p+1})\rangle],$$<br>is related to determinants of a bunch of matrices $\langle u_s(\bf{k}</em>{n,p})|u_{s’}(\bf{k}_{n,p+1})\rangle$, which in the diagonal basis of eigenstates is nearly diagonal, which takes us back to the previous expression.</p>
<p>The main advantage of this expression is that it is actually $U(N)$ invariant for any unitary transformation of the $N$ occupied eigenstates.</p>
<h2 id="Final-recipe"><a href="#Final-recipe" class="headerlink" title="Final recipe"></a>Final recipe</h2><p>So the final recipe to compute the Chern number is as follows:</p>
<ul>
<li><p>grid up the BZ into small plaquettes labelled by $n$</p>
</li>
<li><p>Compute the flux through each plaquette $$\Phi_n=Arg[\prod_p Det[\langle u_s(\bf{k}<em>{n,p})|u</em>{s’}(\bf{k}<em>{n,p+1})\rangle]],$$<br>where ${\bf k}</em>{n,p}$ are momenta on the corners of the lattice.</p>
</li>
<li><p>The Chern number is calculated as $$\nu=(2\pi)^{-1}\sum_n \Phi_n.$$</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w4_haldane/QHE_lattice"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w4_haldane/QHE_lattice/" class="article-date">
  <time datetime="2021-01-07T09:11:06.836Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size=<span class="number">150</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Qi_Wu_Zhang</span>(<span class="params">w=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.mu * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0.5j</span> * p.delta * pauli.sy - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1j</span> * p.gamma * pauli.sx - p.gamma * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> w == <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= pos[<span class="number">1</span>] &lt; w</span><br><span class="line"></span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        syst = kwant.Builder(sym)</span><br><span class="line">        syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$t=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$, $\gamma=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    title = title.<span class="built_in">format</span>(p.t, p.mu, p.delta, p.gamma)</span><br><span class="line">    <span class="keyword">return</span> title</span><br></pre></td></tr></table></figure>

<h1 id="Introduction-stacking-wires"><a href="#Introduction-stacking-wires" class="headerlink" title="Introduction: stacking wires"></a>Introduction: stacking wires</h1><p>Looking back at the material from the past weeks, you might have the impression that the quantum Hall effect and one dimensional topological superconductors are really different topics, and not connected at all.</p>
<p>Xiaoliang Qi from Stanford University will now explain that this is not the case, and will also introduce this week’s topic - Chern insulators.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;osKP6x0Ewbo&quot;</span>, src_location=<span class="string">&quot;4.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Pairs-of-chiral-edges-in-a-1D-wire"><a href="#Pairs-of-chiral-edges-in-a-1D-wire" class="headerlink" title="Pairs of chiral edges in a 1D wire"></a>Pairs of chiral edges in a 1D wire</h1><p>Last week, we started with a phenomenological description of the quantum Hall effect. We learned that one way to get a quantum Hall state is to place electrons in an external magnetic field.</p>
<p>However, we still don’t have a simple lattice Hamiltonian describing the quantum Hall effect - we’d like to have something like the Kitaev chain model, which was very useful to understand Majoranas in the first two weeks of the course. An added benefit of finding this tight binding model is that it would not need an external magnetic field to exhibit the unique properties of quantum Hall effect.</p>
<p>These models exist, and they are referred to as <em>Chern insulators</em>. The quantum Hall effect without an external magnetic field is also referred to as the <em>quantum anomalous Hall effect</em>. Duncan Haldane, from who we will hear in the next chapter, invented the first model of a Chern insulator now known as <em>Haldane model</em>. However, in this chapter, we will use a more natural route that fits better into the context of our course so far.</p>
<h2 id="General-strategy-to-construct-a-lattice-model-for-the-Quantum-Hall-Effect"><a href="#General-strategy-to-construct-a-lattice-model-for-the-Quantum-Hall-Effect" class="headerlink" title="General strategy to construct a lattice model for the Quantum Hall Effect"></a>General strategy to construct a lattice model for the Quantum Hall Effect</h2><p>What we will do to get a model for a Chern insulator is to follow a “domino prescription”, as we did to get the Kitaev model in week 1. Our strategy will have two key aspects:</p>
<ul>
<li><p>Focusing on the unique property of the quantum Hall edge that cannot exist in isolation from a bulk, and can only be present because of bulk-boundary correspondence. For the Kitaev chain, this property was the presence of unpaired Majorana modes. In the quantum Hall effect, it is the chiral edge states.</p>
</li>
<li><p>Finding a lower dimensional building block, from which we can somehow “extract“ in a clever way the exotic object we are interested in. In the Kitaev chain, these were the fermionic sites, which we could think of as a pair of Majorana modes.</p>
</li>
</ul>
<p>So we need to find a one-dimensional system which can host a pair of chiral edge states. Since they are one-dimensional, these states will necessarily be spatially on top of each other, essentially a pair of propagating modes with opposite velocity. Once we have this building block, we can follow the domino prescription: couple the counter-propagating states in pairs, just like we did with Majorana modes. We then end up with a pair of spatially separated chiral edge states, and so a quantum Hall insulator without magnetic field.</p>
<p>So our plan is to turn the system on the left into the system on the right:</p>
<p><img src="/2021/01/07/src/w4_haldane/QHE_lattice/coupled_chains.svg" alt></p>
<p>Voilà - we have a lattice model for the 2D quantum Hall state!</p>
<h2 id="Getting-a-one-dimensional-wire-with-a-pair-of-edge-states"><a href="#Getting-a-one-dimensional-wire-with-a-pair-of-edge-states" class="headerlink" title="Getting a one dimensional wire with a pair of edge states"></a>Getting a one dimensional wire with a pair of edge states</h2><p>Let’s focus on the first essential step of our plan: finding a one dimensional system with a pair of counter-propagating chiral states.</p>
<p>You might guess that the easiest way to get a pair of states moving in opposite directions is to take the usual one dimensional single electron Hamiltonian with an effective mass. Such a system has a parabolic dispersion and the low energy excitations at a finite Fermi wave-vector $k=\pm k_F$ move in opposite directions. The catch is that these two states have different momenta, and it is tricky (though not impossible) to deal with momentum conservation when pairing the edges. So we will avoid this approach.</p>
<p>The more educated guess we make a model that we have already encountered, the Dirac model $H= \Delta,k, \tau_y$ of the Kitaev chain at the topological phase transition.</p>
<p>More specifically, in the first week we wrote the Kitaev Hamiltonian in momentum space as $H(k)=-(2 t\cos{k}+\mu),\tau_z+\Delta \sin{k}\tau_y$.  At the critical point $\mu=-2t$, we found the Kitaev Hamiltonian to become</p>
<p>$$H=-2t(\cos{k}-1),\tau_z+\Delta\sin{k},\tau_y.$$</p>
<p>We see that at $k\approx 0$ we have a pair of states with wave functions the eigenvalues $\pm 1$ of $\tau_y$, and with opposite and equal velocities.</p>
<p>At this point you might worry that the Kitaev model has superconductivity, and so the $\tau$ matrices refer to particle and hole degrees of freedom. Indeed, these ingredients should not enter in the description of the quantum Hall effect. But this is not a real issue, because we can just interpret the $\tau$ matrices as acting in the space of left- and right-movers. This flexibility in interpreting the Hamiltonian terms in different ways, depending on the context, is part of the advantage of thinking in terms of toy models.</p>
<p>Finally, before we go on with our plan, keep in mind that considering the phase transition point of a lower dimensional model turns out to be a fairly generic strategy to construct higher dimensional topological models.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;It seems that both a quantum Hall bar and a Kitaev chain can have chiral states. &quot;</span></span><br><span class="line">    <span class="string">&quot;Apart from the two systems having different dimensionality&quot;</span></span><br><span class="line">    <span class="string">&quot;, what&#x27;s the fundamental difference between the two cases?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The quantum Hall edge states go in opposite directions, while the Kitaev states go in the same direction.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The quantum Hall edge states go in the same direction, while the Kitaev states go in opposite directions.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The quantum Hall edges always cross zero energy at zero momentum while the Kitaev states don&#x27;t.&quot;</span>,</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;The Kitaev chiral states exist only at specific parameter values, &quot;</span></span><br><span class="line">        <span class="string">&quot;while the quantum Hall edge states don&#x27;t.&quot;</span></span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The pair of chiral states in the Kitaev model only exists at &quot;</span></span><br><span class="line">    <span class="string">&quot;the phase transition point, when the chain becomes gapless. &quot;</span></span><br><span class="line">    <span class="string">&quot;On the other hand, chiral edge states are a topological property of the quantum Hall state. &quot;</span></span><br><span class="line">    <span class="string">&quot;They are separated by a gapped bulk which protects them, and they exist for a full range of parameter values.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="QHE-without-a-magnetic-field"><a href="#QHE-without-a-magnetic-field" class="headerlink" title="QHE without a magnetic  field"></a>QHE without a magnetic  field</h1><h2 id="Deriving-the-model-Hamiltonian"><a href="#Deriving-the-model-Hamiltonian" class="headerlink" title="Deriving the model Hamiltonian"></a>Deriving the model Hamiltonian</h2><p>Let us now couple the wires to get the quantum Hall system as promised. We take a stack of chains all extending along the horizontal $x$ direction, like in the figure above. We stack them one next to the other along the $y$ direction, so that we form a square lattice. If we take a large (ideally infinite) stack of chains we have a truly two-dimensional system.</p>
<p>Now let us make this formal by first labeling the chains by an index $n_y$, which takes integer values. Let us also replace $k\rightarrow k_x$ to denote the wave-vector along a chain. Hence a single chain has the Hamiltonian $\left[-(2 t\cos{k_x}+\mu),\tau_z+\Delta \sin{k_x}\tau_y\right],\otimes,\left|,n_y\right\rangle\left\langle n_y\right|$. The projector $\left|,n_y\right\rangle\left\langle n_y\right|$ is needed to single out one chain from the stack. </p>
<p>Now all that we have to do is to couple the $\tau_y=-1$ branch of one chain to the $\tau_y=+1$ branch of a neighboring chain,  and we will have a quantum Hall state.</p>
<p>A term coupling opposite movers from different chains is $\left|,n_y\right\rangle\left\langle n_y+1\right|\otimes (\tau_z+i\tau_x)$. The first part couples neighboring chains and the matrix $(\tau_z+i\tau_x)$ turns a right mover into a left mover, which is what we want. Let’s call the strength of this coupling $\gamma$.</p>
<p>To obtain the complete Hamiltonian of the stack of chains we just need to sum over $n_y$, and we obtain</p>
<p>$$H=\sum_{n_y},\left[-(2 t\cos{k_x}+\mu)\tau_z+\Delta \sin{k_x}\tau_y\right],\otimes,\left|,n_y\right\rangle\left\langle n_y\right|,-,\gamma,\sum_{n_y},\left[\left|,n_y\right\rangle\left\langle n_y+1\right|\otimes (\tau_z+i\tau_x),+,\textrm{h.c.}\right].$$</p>
<p>This Hamiltonian should in principle suffice to produce a quantum Hall state.</p>
<h2 id="Gap-and-edge-states"><a href="#Gap-and-edge-states" class="headerlink" title="Gap and edge states"></a>Gap and edge states</h2><p>Let’s first consider a finite number of chains $n_y=1,\dots,N$. If you tune each chain individually to the point $\mu = -2t$, it’s easy to check that at $k_x \approx 0$ the above Hamiltonian has one right-moving edge eigenstate for $n_y=1$ with eigenvalue $\approx \Delta , k_x$, and a left-moving edge eigenstate for $n_y=N$  with eigenvalue $\approx -\Delta,k_x$.</p>
<p>The next thing we need to check is that these are the only eigenstates close to zero energy. In other words, is the system gapped in the two-dimensional bulk?  To see this, let’s switch to an infinite stack of chains along the $y$ direction. We then have full translational invariance, so we can go to momentum space in the $y$ direction.</p>
<p>This leads us to the two-dimensional Bloch Hamiltonian </p>
<p>$$H(k_x,k_y)=[-(2t\cos{k_x}+\mu)\tau_z+\Delta\sin{k_x}\tau_y]-2\gamma,[\cos{k_y}\tau_z+\sin{k_y}\tau_x].$$ </p>
<p>Since this Hamiltonian is a sum of three Pauli matrices, the energy spectrum can be written down as </p>
<p>$$E(k_x,k_y)=\pm\sqrt{\Delta^2\sin^2{k_x}+(2\gamma\cos{k_y}+\mu+2t\cos{k_x}))^2+4\gamma^2\sin^2{k_y}}.$$ </p>
<p>Aside from special points, this spectrum is gapped, just like we wanted. For instance it is gapped if $\mu&lt;-2t-2\gamma$. If we start from this point and increase the value of $\mu$, the gap closes at the point $\mu = -2t-2\gamma$ and then reopens:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.3</span>, gamma=-<span class="number">0.5</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = Qi_Wu_Zhang()</span><br><span class="line">mus = np.linspace(-<span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: spectrum(syst, p, zticks=[-<span class="number">4</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>], title=title) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$\mu$&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>As a check that everything worked, let’s look at the dispersion of a ribbon with finite width along the $y$ direction. If there are edge states, we should see a Dirac-like crossing around $k_x=0$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.3</span>, gamma=-<span class="number">0.5</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = Qi_Wu_Zhang(w=<span class="number">15</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">style = &#123;</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E/t$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">2.2</span>, <span class="number">2.2</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(&#123;p.mu: spectrum(syst, p, **style) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>We see that the crossing is there, and it disappears when the gap closes. So we can identify the point $\mu=-2t-2\gamma$ as a critical point at which the quantum Hall state becomes topologically trivial.</p>
<p>While details such as the bulk spectrum and edge dispersion are different from the case with a magnetic field, the bulk-edge correspondence tells us that the edge states are as robust as those of the quantum Hall effect we studied last week.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;How does our lattice model with no magnetic field differ from the original quantum Hall effect?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Since there is no magnetic field the quantum Hall effect on a lattice preserves time reversal symmetry.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Quantum Hall effect in a magnetic field has Landau levels &quot;</span></span><br><span class="line">    <span class="string">&quot;that do not disperse in k while they disperse in the lattice.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Quantum Hall effect in the lattice has no chiral edge states, which arise from skipping orbits in a magnetic field.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;In a magnetic field the filling fraction is fixed to integer per flux quantum, while in the &quot;</span></span><br><span class="line">    <span class="string">&quot;lattice the filling fraction per unit cell is arbitrary.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = <span class="string">&quot;In a lattice one gets a non-constant bandstructure which forms a Dirac cone near the phase transition.&quot;</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Dirac-equation-at-the-phase-transition"><a href="#Dirac-equation-at-the-phase-transition" class="headerlink" title="Dirac equation at the phase transition"></a>Dirac equation at the phase transition</h1><p>Back in week 1, we saw with the Kitaev chain that the “domino argument” led to two distinct phases. The same is true for our model, even though the parameter space is larger than before, with three distinct parameters $\mu, t, \gamma$, which we have not explored fully. But let’s not worry about establishing the full phase diagram. For now it’s more interesting to study the transition point we have found.</p>
<p>The two phases around this point are easy to understand. One is the quantum Hall phase with chiral edge states, which was our initial goal. The other one is a topologically trivial phase. The trivial phase can be understood by first taking $\mu$ very positive and large, and then taking $\gamma\to 0$. Then we just have a bunch of gapped 1D chains next to each other without any tunneling between them, a trivial phase with no edge states.</p>
<p>It is once again useful to write down the effective Hamiltonian near to the transition point at $k_x\approx 0$ and $k_y\approx 0$. It is given by a 2D Dirac Hamiltonian:</p>
<p>$$H_{\textrm{Dirac}}=[\Delta k_x\tau_y-2\gamma k_y\tau_x+m\tau_z],$$ </p>
<p>The combination $m=-(\mu +2t+2\gamma)$ serves as the ‘mass’ in this Dirac model. As before, we see that the gapless phase transition point at $m=0$ is described by a massless Dirac Hamiltonian. The phase transition separates the topological from the trivial phase, and the two phases are characterized by a different sign of the mass (in this case $m&gt;0$ in the topological phase and $m&lt;0$ in the trivial phase).</p>
<p>As with Kitaev chains, the Dirac model gives us another way to construct chiral edge states at the domain wall between topological and non-topological phases. Back in week 1, we saw that for a one dimensional Dirac model, a domain wall in the mass $m$ supports a non-degenerate zero mode. Fixing  $k_y=0$, we see that the one dimensional Dirac Hamiltonian here is identical to the one we saw in week 1, where the zero mode at the domain wall between $m&lt;0$ and $m&gt;0$ was an eigenstate of $\tau_x$ with eigenvalue $+1$. </p>
<p>Unlike the one-dimensional case, the zero mode is not stationary in the two dimensional case. By adding $2\gamma k_y\tau_x$ as a perturbation, we see that the energy of the state increases as </p>
<p>$$\epsilon(k_y)\approx 2\gamma k_y,,$$</p>
<p>so it has a velocity $v=2\gamma$, the direction of which depends on the sign of $\gamma$. So we see how we can get the chiral edge modes analytically.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;CXgAcOOVlag&quot;</span>, src_location=<span class="string">&quot;4.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Chern insulators&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w3_pump_QHE/w3_assignments"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w3_pump_QHE/w3_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.835Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-Disorder-butterflies-and-honeycombs"><a href="#Simulations-Disorder-butterflies-and-honeycombs" class="headerlink" title="Simulations: Disorder, butterflies, and honeycombs"></a>Simulations: Disorder, butterflies, and honeycombs</h1><p>As usual, start by grabbing the notebooks of this week (<code>w3_pump_QHE</code>). They are once again over <a target="_blank" rel="noopener" href="http://tiny.cc/topocm_smc">here</a>.</p>
<p>There are really plenty of things that one can study with the quantum Hall effect and pumps. Remember, that you don’t need to do everything at once (but of course all of the simulations are quite fun!)</p>
<h3 id="Pumping-with-disorder"><a href="#Pumping-with-disorder" class="headerlink" title="Pumping with disorder"></a>Pumping with disorder</h3><p>Grab the simulations of the Thouless pump, and see what happens to the pump when you add disorder. Try both the winding in a pump with reservoirs attached, and the spectrum of a closed pump. Can you explain what you observe?</p>
<h3 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h3><p>Take a look at how we calculate numerically the spectrum of Landau levels in the Laughlin argument chapter.<br>We were always careful to only take weak fields so that the flux per unit cell of the tight binding lattice is small.<br>This is done to avoid certain <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hofstadter%27s_butterfly">notorious insects</a>, but nothing should prevent you from cranking up the magnetic field and seeing this beautiful phenomenon.</p>
<p>Plot the spectrum of a quantum Hall layer rolled into a cylinder at a fixed momentum as a function of $B$ as $B$ goes to one flux quantum per unit cell, so in lattice units $B = 2\pi$. Bonus (requires more work): attach a lead to the cylinder, calculate pumping, and color the butterfly according to the pumped charge.</p>
<h3 id="Graphene"><a href="#Graphene" class="headerlink" title="Graphene"></a>Graphene</h3><p>Take a look at how to implement a honeycomb lattice in Kwant <a target="_blank" rel="noopener" href="http://kwant-project.org/doc/1.0/tutorial/tutorial4">tutorials</a>, and modify the Hall bar from the Laughlin argument notebook to be made of graphene. Observe the famous <a target="_blank" rel="noopener" href="http://arxiv.org/abs/cond-mat/0602565">unconventional quantum Hall effect</a>.</p>
<p>Bonus: See what happens to the edge states as you introduce a constriction in the middle of the Hall bar. This is an extremely useful experimental tool used in making quantum Hall interferometers (also check out the density of states using the code from the edge states notebook).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Quantum Hall effect&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><p>For the third week we have these papers:</p>
<h3 id="arXiv-1109-5983"><a href="#arXiv-1109-5983" class="headerlink" title="arXiv:1109.5983"></a>arXiv:1109.5983</h3><p><strong>Hint:</strong> Topological pumping can be used to characterize quasicrystals too!<br>Whether this is really unique to quasicrystals is debated though arXiv:1307.2577.</p>
<h3 id="arXiv-cond-mat-0602645"><a href="#arXiv-cond-mat-0602645" class="headerlink" title="arXiv:cond-mat/0602645"></a>arXiv:cond-mat/0602645</h3><p><strong>Hint:</strong> Quantum Hall effect applies beyond parabolic dispersions with interesting twists.<br>Figure out what different features arise from other cases.</p>
<h3 id="arXiv-1201-4167"><a href="#arXiv-1201-4167" class="headerlink" title="arXiv:1201.4167"></a>arXiv:1201.4167</h3><p><strong>Hint:</strong> An experiment detecting the interesting consequences of coexistence of quantum Hall and ferromagnetism in graphene.</p>
<h3 id="arXiv-0710-2806"><a href="#arXiv-0710-2806" class="headerlink" title="arXiv:0710.2806"></a>arXiv:0710.2806</h3><p><strong>Hint:</strong> Aharonov-Bohm interference using quantum hall edge quasiparticles.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Quantum Hall effect&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w3_pump_QHE/pumps"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w3_pump_QHE/pumps/" class="article-date">
  <time datetime="2021-01-07T09:11:06.834Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">from</span> holoviews.core.options <span class="keyword">import</span> Cycle</span><br><span class="line"></span><br><span class="line">%output size=<span class="number">120</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ts_modulated_wire</span>(<span class="params">L=<span class="number">50</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create an infinite wire with a periodic potential</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Chain lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, A, phase</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The period of the potential is 2*pi/L.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    omega = <span class="number">2</span> * np.pi / L</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        x = site.pos[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * p.t - p.mu + p.A * (np.cos(omega * x + p.phase) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry([-L])</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    syst[(lat(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modulated_wire</span>(<span class="params">L=<span class="number">50</span>, dL=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a pump. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Chain lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    L is the length of the pump,</span></span><br><span class="line"><span class="string">    dL is the length of the clean regions next to the pump,</span></span><br><span class="line"><span class="string">            useful for demonstration purposes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, A, omega, phase</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        x = site.pos[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * p.t - p.mu + p.A * (np.cos(p.omega * x + p.phase) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    lead_onsite = <span class="keyword">lambda</span> site, p: <span class="number">2</span> * p.t - p.mu_lead</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[(lat(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry([-<span class="number">1</span>])</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line">    lead[lat(<span class="number">0</span>)] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total_charge</span>(<span class="params">value_array</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate the pumped charge from the list of reflection matrices.&quot;&quot;&quot;</span></span><br><span class="line">    determinants = [np.linalg.det(r) <span class="keyword">for</span> r <span class="keyword">in</span> value_array]</span><br><span class="line">    charge = np.cumsum(np.angle(np.roll(determinants, -<span class="number">1</span>) / determinants))</span><br><span class="line">    charge = charge - charge[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> charge / (<span class="number">2</span> * np.pi)</span><br></pre></td></tr></table></figure>

<h1 id="Thouless-pumps"><a href="#Thouless-pumps" class="headerlink" title="Thouless pumps"></a>Thouless pumps</h1><p>Dganit Meidan from Ben Gurion University will introduce Thouless pumps,.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;gKZK9IGY9wo&quot;</span>, src_location=<span class="string">&quot;3.1-intro&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Hamiltonians-with-parameters"><a href="#Hamiltonians-with-parameters" class="headerlink" title="Hamiltonians with parameters"></a>Hamiltonians with parameters</h1><p>Previously, when studying the topology of systems supporting Majoranas (both the Kitaev chain and the nanowire), we were able to calculate topological properties by studying the bulk Hamiltonian $H(k)$.</p>
<p>There are two points of view on this Hamiltonian. We could either consider it a Hamiltonian of an infinite system with momentum conservation</p>
<p>$$H = H(k) |k\rangle\langle k|,$$</p>
<p>or we could equivalently study a finite system with only a small number of degrees of freedom (corresponding to a single unit cell), and a Hamiltonian which depends on some continuous periodic parameter $k$.</p>
<p>Of course, without specifying that $k$ is the real space momentum, there is no meaning in bulk-edge correspondence (since the edge is an edge in real space), but the topological properties are still well-defined.</p>
<p>Sometimes we want to know how a physical system changes if we slowly vary some parameters of the system, for example a bias voltage or a magnetic field. Because the parameters change with time, the Hamiltonian becomes time-dependent, namely</p>
<p>$$H = H(t).$$</p>
<p>The slow <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Adiabatic_theorem">adiabatic</a> change of parameters ensures that if the system was initially in the ground state, it will stay in the ground state, so that the topological properties are useful.</p>
<p>A further requirement for topology to be useful is the <em>periodicity</em> of time evolution:</p>
<p>$$H(t) = H(t+T).$$</p>
<p>The period can even go to $\infty$, in which case $H(-\infty) = H(+\infty)$. The reasons for the requirement of periodicity are somewhat abstract. If the Hamiltonian has parameters, we’re studying the topology of a <em>mapping</em> from the space of parameter values to the space of all possible gapped Hamiltonians. This mapping has nontrivial topological properties only if the space of parameter values is compact.</p>
<p>For us, this simply means that the Hamiltonian has to be periodic in time.</p>
<p>Of course, if we want systems with bulk-edge correspondence, then in addition to $t$ our Hamiltonian must still depend on the real space coordinate, or the momentum $k$.</p>
<h1 id="Quantum-pumps"><a href="#Quantum-pumps" class="headerlink" title="Quantum pumps"></a>Quantum pumps</h1><p>In the image below (source: Chambers’s Encyclopedia, 1875, via Wikipedia) you see a very simple periodic time-dependent system, an Archimedes screw pump.</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/pumps/Archimedes_screw.jpg" alt></p>
<p>The changes to the system are clearly periodic, and the pump works the same no matter how slowly we use it (that is, change the parameters), so it is an adiabatic tool.</p>
<p>What about a quantum analog of this pump? Turns out it is just as simple as you would think.</p>
<p>Let’s take a one-dimensional region, coupled to two electrodes on both sides, and apply a strong sine-shaped confining potential in this region. As we move the confining potential, we drag the electrons captured in it.</p>
<p>So our system now looks like this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Plot of the potential in the pumping system as a function of coordinate.</span></span><br><span class="line"><span class="comment"># Some part of the leads is shown with a constant potential.</span></span><br><span class="line"><span class="comment"># Regions with E &lt; 0 should be shaded to emulate Fermi sea.</span></span><br><span class="line">A = <span class="number">0.6</span></span><br><span class="line">L = <span class="number">10</span></span><br><span class="line">lamb = (<span class="number">10</span> / <span class="number">5.3</span>) / (<span class="number">2</span> * np.pi)</span><br><span class="line">mu = -<span class="number">0.4</span></span><br><span class="line">mu_lead = -<span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0.0</span>:</span><br><span class="line">        <span class="keyword">return</span> mu_lead</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0.0</span> <span class="keyword">and</span> x &lt;= L:</span><br><span class="line">        <span class="keyword">return</span> mu + A * (<span class="number">1.0</span> - np.cos(x / lamb))</span><br><span class="line">    <span class="keyword">if</span> x &gt; L:</span><br><span class="line">        <span class="keyword">return</span> mu_lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">15</span>, <span class="number">1000</span>)</span><br><span class="line">y = [f(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;k&quot;</span>, lw=<span class="number">1.2</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">2.5</span>, <span class="number">12.5</span>)</span><br><span class="line">plt.ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">y = [i <span class="keyword">if</span> i &lt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> y]</span><br><span class="line">plt.fill_between(</span><br><span class="line">    x, y, <span class="number">0</span>, color=<span class="string">&quot;r&quot;</span>, where=np.array(y) &lt; <span class="number">0.0</span>, alpha=<span class="number">0.5</span>, edgecolor=<span class="string">&quot;k&quot;</span>, lw=<span class="number">1.5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">plt.arrow(<span class="number">2.0</span>, <span class="number">1.25</span>, <span class="number">5</span>, <span class="number">0</span>, head_width=<span class="number">0.15</span>, head_length=<span class="number">1.0</span>, fc=<span class="string">&quot;k&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;$x$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;$U(x)$&quot;</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>It is described by the Hamiltonian</p>
<p>$$H(t) = \frac{k^2}{2m} + A [1 - \cos(x/\lambda + 2\pi t/T)].$$</p>
<p>As we discussed, if we change $t$ very slowly, the solution will not depend on how fast $t$ varies.</p>
<p>When $A \gg 1 /m \lambda^2$ the confining potential is strong, and additionally if the chemical potential $\mu \ll A$, the states bound in the separate minima of the potential have very small overlap.</p>
<p>The potential near the bottom of each minimum is approximately quadratic, so the Hamiltonian is that of a simple Harmonic oscillator. This gives us discrete levels of the electrons with energies $E_n = (n + \tfrac{1}{2})\omega_c$, with $\omega_c = \sqrt{A/m\lambda^2}$ the oscillator frequency.</p>
<p>We can quickly check how continuous bands in the wire become discrete evenly spaced bands as we increase $A$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.0</span>, phase=<span class="number">0.0</span>, A=<span class="literal">None</span>)</span><br><span class="line">syst = ts_modulated_wire(L=<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Band structure, $A=&#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(p.A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.2</span>, <span class="number">1.3</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>],</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.A: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.A <span class="keyword">in</span> np.linspace(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">10</span>)&#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$A$&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>So unless $\mu = E_n$ for some $n$, each minimum of the potential contains an integer number of electrons $N$.</p>
<p>Electron wave functions from neighboring potential minima do not overlap, so when we change the potential by one time period, we move exactly $N$ electrons.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;Why are some levels in the band structure flat while some are not?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The flat levels are the ones whose energies are not sensitive to the offset of confining potential.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Destructive interference of the wave functions in neighboring minima suppresses the dispersion.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The flat levels are localized deep in the potential minima, &quot;</span></span><br><span class="line">    <span class="string">&quot;so the bandwidth is exponentially small.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The flat levels correspond to filled states, and the rest to empty states.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The dispersion of the bands in a perodic potential appears &quot;</span></span><br><span class="line">    <span class="string">&quot;when the wave functions from neighboring minima overlap.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Quantization-of-pumped-charge"><a href="#Quantization-of-pumped-charge" class="headerlink" title="Quantization of pumped charge"></a>Quantization of pumped charge</h1><p>As we already learned, integers are important, and they could indicate that something topological is happening.</p>
<p>At this point we should ask ourselves these questions: Is the number of electrons $N$ pumped per cycle topological, or can we pump any continuous amount of charge? How important is it that the potential well of the pump is deep?</p>
<h3 id="Thought-experiment"><a href="#Thought-experiment" class="headerlink" title="Thought experiment"></a>Thought experiment</h3><p>To simplify the counting let’s “dry out” the pump: We can define a procedure that empties the middle region, and pushes $n_L$ extra electrons to the left and $n_R$ electrons to the right.</p>
<p>For example, we can do this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Same plot as above, but now with an extra rectangular barrier in the</span></span><br><span class="line"><span class="comment"># middle, and with arrows both ways showing that the barrier widens.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot of the potential in the pumping system as a function of coordinate.</span></span><br><span class="line"><span class="comment"># Some part of the leads is shown with a constant potential.</span></span><br><span class="line"><span class="comment"># Regions with E &lt; 0 should be shaded to emulate Fermi sea.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot of the potential in the pumping system as a function of coordinate.</span></span><br><span class="line"><span class="comment"># Some part of the leads is shown with a constant potential.</span></span><br><span class="line"><span class="comment"># Regions with E &lt; 0 should be shaded to emulate Fermi sea.</span></span><br><span class="line">A = <span class="number">0.6</span></span><br><span class="line">L = <span class="number">10</span></span><br><span class="line">lamb = (<span class="number">10</span> / <span class="number">5.3</span>) / (<span class="number">2</span> * np.pi)</span><br><span class="line">mu = -<span class="number">0.4</span></span><br><span class="line">mu_lead = -<span class="number">0.8</span></span><br><span class="line">a = <span class="number">4.5</span></span><br><span class="line">b = <span class="number">6.5</span></span><br><span class="line">top = <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0.0</span>:</span><br><span class="line">        <span class="keyword">return</span> mu_lead</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0.0</span> <span class="keyword">and</span> x &lt;= a:</span><br><span class="line">        <span class="keyword">return</span> mu + A * (<span class="number">1.0</span> - np.cos(x / lamb))</span><br><span class="line">    <span class="keyword">if</span> x &gt; a <span class="keyword">and</span> x &lt; b:</span><br><span class="line">        <span class="keyword">return</span> top</span><br><span class="line">    <span class="keyword">if</span> x &gt;= b <span class="keyword">and</span> x &lt;= L:</span><br><span class="line">        <span class="keyword">return</span> mu + A * (<span class="number">1.0</span> - np.cos(x / lamb))</span><br><span class="line">    <span class="keyword">if</span> x &gt; L:</span><br><span class="line">        <span class="keyword">return</span> mu_lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">15</span>, <span class="number">1000</span>)</span><br><span class="line">y = [f(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;k&quot;</span>, lw=<span class="number">1.2</span>)</span><br><span class="line">plt.xlim(-<span class="number">2.5</span>, <span class="number">12.5</span>)</span><br><span class="line">plt.ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">y = [i <span class="keyword">if</span> i &lt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> y]</span><br><span class="line">plt.fill_between(</span><br><span class="line">    x, y, <span class="number">0</span>, color=<span class="string">&quot;r&quot;</span>, where=np.array(y) &lt; <span class="number">0.0</span>, alpha=<span class="number">0.5</span>, edgecolor=<span class="string">&quot;k&quot;</span>, lw=<span class="number">1.5</span>,</span><br><span class="line">)</span><br><span class="line">plt.arrow(a, <span class="number">1.05</span>, -<span class="number">1</span>, <span class="number">0</span>, head_width=<span class="number">0.1</span>, head_length=<span class="number">0.4</span>, fc=<span class="string">&quot;k&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.arrow(b, <span class="number">1.05</span>, +<span class="number">1</span>, <span class="number">0</span>, head_width=<span class="number">0.1</span>, head_length=<span class="number">0.4</span>, fc=<span class="string">&quot;k&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;$x$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;$U(x)$&quot;</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>A reverse of this procedure does the reverse of course, so it reduces the number of charges on the left and right sides.</p>
<p>Now here comes the trick:</p>
<ol>
<li><p>When the middle region is emptied, the two sides are completely disconnected, and so the number of electrons on either side must be integer for every eigenstate of the Hamiltonian.</p>
</li>
<li><p>Next, if we performed the manipulation adiabatically, then if we start in an eigenstate of the Hamiltonian, we will also end in an eigenstate of the Hamiltonian. This is a consequence of the adiabatic theorem.</p>
</li>
<li><p>In light of 1. and 2., we conclude that in the process of drying the middle out, we pumped an integer number of charges.</p>
</li>
<li><p>Finally, adiabatic manipulation is only possible if the Hamiltonian stays gapped at all times.</p>
</li>
</ol>
<p>Bonus: In our argument we didn’t use the shape or the strength of the potential, so it applies universally to any possible pump.</p>
<p>So without doing any calculations, we can conclude that:</p>
<blockquote>
<p>The number of electrons pumped per cycle of a quantum pump is an integer as long as<br>the bulk of the pump is gapped. Therefore it is a <strong>topological invariant</strong>.</p>
</blockquote>
<h1 id="Counting-electrons-through-reflection"><a href="#Counting-electrons-through-reflection" class="headerlink" title="Counting electrons through reflection."></a>Counting electrons through reflection.</h1><p>The expression for the pumped charge in terms of the bulk Hamiltonian $H(k, t)$ is complicated.</p>
<p>It’s an integral over both $k$ and $t$, called a <strong>Chern number</strong> or in other sources a TKNN integer. Its complexity is beyond the scope of our course, but is extremely important, so we will have to study it… next week.</p>
<p>There is a much simpler way to calculate the same quantity using scattering formalism. From the previous two weeks, recall that we may infer the presence or absence of Majoranas at an end of a system by calculating either $Q = \textrm{sign}[\textrm{Pf},H(0),\textrm{Pf},H(\pi)]$ or $Q=\textrm{sign}\det r$, where $r$ is the reflection matrix from one end of the Majorana wire.</p>
<p>In order to derive the scattering expression, we need to understand how the pumped charge manifests in the reflection matrix.</p>
<p>Let’s start from the case when there’s just one mode in the reservoir. We’ll count the charge pumped by making the reservoir finite but very large.</p>
<p>Now all the levels in the reservoir are quantized, and are standing waves, so they are equal weight superpositions of waves going to the left $\psi_L$ and to the right $\psi_R$,</p>
<p>$$<br>\psi_n = \psi_L(x) + \psi_R(x) \propto \exp(ik_n x) + \exp(-ik_n x + i\phi),<br>$$</p>
<p>where the wave number $k_n$ is of course a function of energy. The relative phase shift $\phi$ is necessary to satisfy the boundary condition at $x=0$, where $\psi_L = r \psi_R$, and so $\exp(i \phi) = r$. The energies of the levels are determined by requiring that the phases of $\psi_L$ and $\psi_R$ also match at $x = -L$.</p>
<p>Now, what happens when we pump one extra charge into the reservoir? All the energy levels are shifted up by one, that is $E_n \rightarrow E_{n+1}$, and accordingly the wave functions also change $\psi_n \rightarrow \psi_{n+1}$.</p>
<blockquote>
<p>We conclude that the charge can only be pumped as the reflection phase $\phi$ advances by $2\pi$.</p>
</blockquote>
<p>It’s very easy to generalize our argument to many modes. For that we just need to sum all of the reflection phase shifts, which means we need to look at the phase of $\det r$.</p>
<p>We conclude that there’s a very compact relation between charge $dq$ pumped by an infinitesimal change of an external parameter and the change in reflection matrix $dr$:</p>
<p>$$<br>dq = \frac{d \log \det r}{2\pi i} = \operatorname{Tr}\frac{r^\dagger dr }{ 2 \pi i}.<br>$$</p>
<p>While we derived this relation only for the case when all incoming particles reflect, and $r$ is unitary, written in form of trace it also holds if there is transmission.<a target="_blank" rel="noopener" href="https://arxiv.org/abs/cond-mat/9808347">¹</a></p>
<p>Let’s check if this expression holds to our expectations. If $||r||=1$, this is just the number of times the phase of $\det r$ winds around zero, and it is certainly an integer, as we expected.</p>
<h1 id="Applying-the-topological-invariant"><a href="#Applying-the-topological-invariant" class="headerlink" title="Applying the topological invariant"></a>Applying the topological invariant</h1><p>We’re left with a simple exercise.</p>
<p>We know now how to calculate the pumped charge during one cycle, so let’s just see how it works in practice.</p>
<p>The scattering problem in 1D can be solved quickly, so let’s calculate the pumped charge as a function of time for different values of the chemical potential in the pump.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">%%opts Path.Q (color=Cycle(values=[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]))</span><br><span class="line">%%opts HLine (color=Cycle(values=[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]) linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_charge</span>(<span class="params">mu</span>):</span></span><br><span class="line">    energy = <span class="number">0.0</span></span><br><span class="line">    phases = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">100</span>)</span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1</span>, mu=mu, mu_lead=mu, A=<span class="number">0.6</span>, omega=<span class="number">0.3</span>)</span><br><span class="line">    syst = modulated_wire(L=<span class="number">100</span>).finalized()</span><br><span class="line">    rs = [</span><br><span class="line">        kwant.smatrix(syst, energy, params=<span class="built_in">dict</span>(p=p)).submatrix(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> p.phase <span class="keyword">in</span> phases</span><br><span class="line">    ]</span><br><span class="line">    wn = -total_charge(rs)</span><br><span class="line">    title = <span class="string">&quot;$\mu=&#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(mu)</span><br><span class="line">    kdims = [<span class="string">r&quot;$t/T$&quot;</span>, <span class="string">r&quot;$q/e$&quot;</span>]</span><br><span class="line">    plot = holoviews.Path(</span><br><span class="line">        (phases / (<span class="number">2</span> * np.pi), wn), kdims=kdims, label=title, group=<span class="string">&quot;Q&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;<span class="string">r&quot;$q/e$&quot;</span>: (-<span class="number">0.5</span>, <span class="number">3.5</span>)&#125;).opts(</span><br><span class="line">        plot=&#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.2</span>, <span class="number">1.3</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>],</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="keyword">lambda</span> p: <span class="string">&quot;Band structure, $A=&#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(p.A),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.0</span>, phase=<span class="number">0.0</span>, A=<span class="number">0.6</span>)</span><br><span class="line">syst = ts_modulated_wire(L=<span class="number">17</span>)</span><br><span class="line">mus = [<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0.9</span>]</span><br><span class="line">HLines = holoviews.Overlay([holoviews.HLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus])</span><br><span class="line">spectrum(syst, p, **kwargs) * HLines + holoviews.Overlay(</span><br><span class="line">    [plot_charge(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus]</span><br><span class="line">).relabel(<span class="string">&quot;Pumped charge&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>In the left plot, we show the band structure, where the different colors correspond to different chemical potentials. The right plot shows the corresponding pumped charge. During the pumping cycle the charge may change, and the relation between the offset $\phi$ of the potential isn’t always linear. However we see that after a full cycle, the pumped charge exactly matches the number of filled levels in a single potential well.</p>
<p>As a final mental exercise about pumps, let’s think about what happens if we disconnect the leads and consider the spectrum of a closed system.</p>
<p>As the periodic potential moves, it tries to increase the energies of all the states at the right of the system and reduce the energy of all the states to the left (that’s what pumping does after all).</p>
<p>So there should be states crossing the bulk band gap. Let’s see if it’s true.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.0</span>, mu_lead=<span class="number">0</span>, A=<span class="number">0.6</span>, omega=<span class="number">0.3</span>, phase=<span class="literal">None</span>)</span><br><span class="line">syst = modulated_wire(L=<span class="number">110</span>).finalized()</span><br><span class="line">phases = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">251</span>)</span><br><span class="line">en = [np.linalg.eigvalsh(syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p))) <span class="keyword">for</span> p.phase <span class="keyword">in</span> phases]</span><br><span class="line">en = np.array(en)</span><br><span class="line">ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]&#125;</span><br><span class="line">kdims = [<span class="string">r&quot;$t/T$&quot;</span>, <span class="string">r&quot;$E$&quot;</span>]</span><br><span class="line">holoviews.Path((phases / (<span class="number">2</span> * np.pi), en), kdims=kdims)[:, <span class="number">0</span>:<span class="number">1.2</span>].opts(plot=ticks)</span><br></pre></td></tr></table></figure>

<p>Indeed, the levels in the bulk stay flat and have a high degeneracy, but we see that there are also single levels that get pushed across the gap. Since the bulk is homogeneous, these states have to be localized at the edge.</p>
<p>Of course, since we have a finite system, the charge cannot be pumped forever from one end into the other. So the pumping breaks down when you see the edge states crossing the bulk bands. At these moments the charge can flow back through the bulk.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens to the dependence of the reflection phase shift on time if we &quot;</span></span><br><span class="line">    <span class="string">&quot;remove one of the reservoirs and leave the other one?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;It becomes constant.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;For most of the cycle it stays the same, but there appear &quot;</span></span><br><span class="line">    <span class="string">&quot;sharp jumps such that the total winding becomes zero.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Nothing changes, since the two ends of the pump are &quot;</span></span><br><span class="line">    <span class="string">&quot;far apart from each other, and the pump is not conducting.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The reflection phase gets a new time dependence with zero winding, unrelated to the original one.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The total pumped charge must become equal to zero since there&#x27;s nowhere to place the charge, but &quot;</span></span><br><span class="line">    <span class="string">&quot;since the pump is insulating, the phase cannot change &quot;</span></span><br><span class="line">    <span class="string">&quot;for most of the cycle unless a sharp resonance appears&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Quantized-charge-and-scattering-invariant"><a href="#Quantized-charge-and-scattering-invariant" class="headerlink" title="Quantized charge and scattering invariant"></a>Quantized charge and scattering invariant</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;6lXRAZ7hv7E&quot;</span>, src_location=<span class="string">&quot;3.1-summary&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Quantum pumps&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w3_pump_QHE/QHEedgestates"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w3_pump_QHE/QHEedgestates/" class="article-date">
  <time datetime="2021-01-07T09:11:06.828Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size=<span class="number">150</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_hall_bar</span>(<span class="params">L=<span class="number">50</span>, W=<span class="number">10</span>, w_lead=<span class="number">10</span>, w_vert_lead=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a hall bar system. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns finalized kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    L = <span class="number">2</span> * (L // <span class="number">2</span>)</span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line">    w_lead = <span class="number">2</span> * (w_lead // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> w_vert_lead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        w_vert_lead = w_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        w_vert_lead = <span class="number">2</span> * (w_vert_lead // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bar shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (x &gt;= -L / <span class="number">2</span> <span class="keyword">and</span> x &lt;= L / <span class="number">2</span>) <span class="keyword">and</span> (y &gt;= -W / <span class="number">2</span> <span class="keyword">and</span> y &lt;= W / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ax</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        xt, yt = site1.pos</span><br><span class="line">        xs, ys = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (xt + xs) * (yt - ys))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_lead_hop_y</span>(<span class="params">x0</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ay</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">            xt, yt = site1.pos</span><br><span class="line">            xs, ys = site2.pos</span><br><span class="line">            <span class="keyword">return</span> -p.t * np.exp(-<span class="number">1j</span> * p.B * x0 * (yt - ys))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hopping_Ay</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_hop_vert</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(bar, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping_Ax</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt;= y &lt;= w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_onsite = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line"></span><br><span class="line">    sym_lead_vertical = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead_vertical1 = kwant.Builder(sym_lead_vertical)</span><br><span class="line">    lead_vertical2 = kwant.Builder(sym_lead_vertical)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical1</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= -L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical2</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> +L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= +L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_vertical1[lat.shape(lead_shape_vertical1, (-L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical1[lat.neighbors()] = lead_hop_vert</span><br><span class="line">    lead_vertical2[lat.shape(lead_shape_vertical2, (L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical2[lat.neighbors()] = lead_hop_vert</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1)</span><br><span class="line">    syst.attach_lead(lead_vertical2)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1.<span class="built_in">reversed</span>())</span><br><span class="line">    syst.attach_lead(lead_vertical2.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (-<span class="number">1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(-L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line"></span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line">    lead[lat.shape(lead_shape, (-<span class="number">1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_ribbon</span>(<span class="params">W, periodic=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Creates a ribbon with magnetic field through it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If we have periodic boundary conditions, the flux through a single </span></span><br><span class="line"><span class="string">    unit cell is quantized.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -W / <span class="number">2</span> &lt;= y &lt;= W / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        xt, yt = site1.pos</span><br><span class="line">        xs, ys = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (xt - xs) * (yt + ys))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_periodic</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        xt, yt = site1.pos</span><br><span class="line">        xs, ys = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(</span><br><span class="line">            -<span class="number">0.5j</span> * <span class="built_in">int</span>(p.B) * <span class="number">2</span> * np.pi / (W + <span class="number">1</span>) * (xt - xs) * (yt + ys)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym_syst = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym_syst)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line">        syst[lat.neighbors()] = hopping_periodic</span><br><span class="line">        syst[lat(<span class="number">0</span>, -W / <span class="number">2</span>), lat(<span class="number">0</span>, +W / <span class="number">2</span>)] = hopping_periodic</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_corbino</span>(<span class="params">r_out=<span class="number">100</span>, r_in=<span class="number">65</span>, w_lead=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create corbino disk. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, B, phi</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ring shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ring</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        rsq = x ** <span class="number">2</span> + y ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> r_in ** <span class="number">2</span> &lt; rsq &lt; r_out ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crosses_branchcut</span>(<span class="params">hop</span>):</span></span><br><span class="line">        xt, yt = hop[<span class="number">0</span>].pos</span><br><span class="line">        xs, ys = hop[<span class="number">1</span>].pos</span><br><span class="line">        <span class="keyword">return</span> yt &lt; <span class="number">0</span> <span class="keyword">and</span> xt &gt; <span class="number">0.5</span> <span class="keyword">and</span> xs &lt; <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        xt, yt = site1.pos</span><br><span class="line">        xs, ys = site2.pos</span><br><span class="line">        <span class="comment"># Check for correctness!</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (xt - xs) * (yt + ys))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">branchcut_hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hopping(site1, site2, p) * np.exp(<span class="number">1j</span> * p.phi)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ring, (<span class="number">0</span>, r_in + <span class="number">1</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding special hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hops_across_cut</span>(<span class="params">syst</span>):</span></span><br><span class="line">        <span class="keyword">for</span> hop <span class="keyword">in</span> kwant.builder.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat, lat)(syst):</span><br><span class="line">            <span class="keyword">if</span> crosses_branchcut(hop):</span><br><span class="line">                <span class="keyword">yield</span> hop</span><br><span class="line"></span><br><span class="line">    syst[hops_across_cut] = branchcut_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt; y &lt; w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line">    lead[lat.neighbors()] = <span class="keyword">lambda</span> site1, site2, p: -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attach the leads and return the system.</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead, origin=lat(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br></pre></td></tr></table></figure>

<h1 id="Where-do-the-pumped-electrons-come-from-and-go-to"><a href="#Where-do-the-pumped-electrons-come-from-and-go-to" class="headerlink" title="Where do the pumped electrons come from and go to?"></a>Where do the pumped electrons come from and go to?</h1><p>You have just seen that Laughlin’s argument explains the quantization of the Hall conductance in terms of a pump which moves electrons through the bulk of a Hall cylinder, from one edge to the other of the cylinder.</p>
<p>Compare the situation with the simple electron pump which you studied earlier in the lecture. There, the pump moved electrons from one metallic lead to the other. Clearly the pump worked thanks to the availability of electronic states at the Fermi level in the two metallic leads. Otherwise, it would have no electrons to take and no place to drop them. Without the metallic leads, the pump would be like an empty carousel.</p>
<p>When applied to the Hall cylinder, this simple reasoning shows that Laughlin’s argument necessarily implies the presence of <strong>electronic states localized at the edges</strong> of the sample.</p>
<p>It is in fact very easy to convince ourselves that such states must exist. We just need to think again about the classical trajectory of an electron with velocity $v$ moving in a perpendicular magnetic field $B$. This trajectory is a circular orbit with radius given by the cyclotron radius.</p>
<p>What happens to the classical trajectory of an electron when the center of the orbit is too close to the edge of the cylinder, say closer than a cyclotron radius? It is easier drawn than said:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/QHEedgestates/skipping_orbits.svg" alt></p>
<p>The electrons cannot exit the sample, and need to bounce back inside. This creates a so-called <strong>skipping orbit</strong>. In a real sample, there will be a confining electrostatic potential which keeps the electrons inside the Hall bar, or cylinder. The combination of a strong magnetic field in the bulk and a confining potential creates trajectories at the edges which are not closed, but travel along the full extent of the edges.</p>
<blockquote>
<p>On the lower edge there are only left-moving states, and on the upper edge only right moving ones. On each edge there are only states moving in one direction, and the direction is opposite for opposite edges. These strange states obtained at the edges are often referred to as <strong>chiral edge states</strong>.</p>
</blockquote>
<p>The chirality of the edges is determined by the orientation of the magnetic field (out of the plane vs. into the plane), and it would be reversed at both edges if the magnetic field were reversed.</p>
<p>The cartoon above is purely based on classical physics, and needs to be supplemented with quantum considerations before it can give quantitative predictions. We will soon see that the quantum version of the cartoon above can give an explanation of the quantized Hall effect, complementary to Laughlin’s argument.</p>
<p>But before we move on to that, we should realize that the picture above is in fact a manifestation of the <strong>bulk-boundary correspondence</strong>. Chiral edge states could not exist without the bulk of the quantum Hall sample.</p>
<h1 id="A-closer-look-at-the-chiral-edge-states"><a href="#A-closer-look-at-the-chiral-edge-states" class="headerlink" title="A closer look at the chiral edge states"></a>A closer look at the chiral edge states</h1><p>So let’s look at the edges of a Hall system in more detail. Let’s think about the ribbon geometry, that we used when we discussed the Laughlin pump in a Hall cylinder. This time, we will take into account explicitly that the ribbon has a finite width $W$ in the $y$ direction.</p>
<p>In practice, in order to confine the electrons in this region there must be a potential barrier $V(y)$, which has to be added to the Hamiltonian:</p>
<p>$$H=p_y^2+(\hbar k-e B y-\Phi)^2,+V(y).$$</p>
<p>Let’s recall that $k=2\pi n/L$ because of periodic boundary conditions over $x$. We do not really care about the particular shape of the potential. Generically, it will be very flat in the middle of the ribbon and very steep right at its boundaries:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/QHEedgestates/confining_potential.svg" alt></p>
<p>How does the potential affect the energy eigenvalues of $H$? In the bulk of the ribbon, away from the edges, the potential is flat, so we can safely set $V(y)=0$ there. In the bulk, we still get flat Landau levels, with energy $E$ independent of $k$. These are the states corresponding to the cyclotron orbits in the classical sketch shown above.</p>
<p>But let’s now move closer to the edges. That is, let’s consider states which are centered at a position $y_0 = \hbar c k/eB$ which is not more than a few magnetic lengths away from the edges. These states are very sensitive to the confining potential, so their energies will be affected. The precise form of the spectrum is not universal and depends on the particular shape of $V(y)$. In general, however, we expect the energy $E(y_0)$ to increase by an amount proportional to $V(y_0)$ with respect to the original Landau level.</p>
<p>Because $y_0$ is proportional to $k$, this means the states close to the edge will acquire a dependence on $k$. Let’s see if this is true, by plotting $E(k)$ for our ribbon:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.5</span>, B=<span class="number">0.15</span>)</span><br><span class="line">syst = qhe_ribbon(W=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.5</span>, <span class="number">0.5</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spectrum(syst, p, **kwargs) * holoviews.HLine(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>You can see that, as a consequence of this bending of the Landau levels, even if the Fermi level is placed in the middle of a bulk gap as in the figure, there are states crossing it. We can associate the levels at negative $k$ with states localized at the bottom edge of the ribbon, and those at positive $k$ with states localized at the top edge. For each edge, there are as many edge states as there are filled Landau levels in the bulk of the system.</p>
<p>The particular shape of the dispersion $E(k)$ will depend on the details of the confining potential (which in this case was an infinite square well). However, close to the Fermi level we can always approximate the dispersion $E(k)$ of the edge states as a straight line. We then obtain, for each edge state, a linear relation between energy and momentum,</p>
<p>$$E = \hbar v (k-k_F).$$</p>
<p>Here $k_F$ is the Fermi momentum, which in the case of our ribbon is equal to $k_F = 2\pi N / L$, with $N$ the number of electrons in the system.</p>
<p>Because the slope of the potential is just the local electric field $\mathcal{E}_y=-\partial_y V(y)$ perpendicular to the edge of the sample, the velocity $v$ of the edge states can be simply interpreted as the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Guiding_center">drift velocity</a> of a skipping state,</p>
<p>$$v = \mathcal{E}_y/B,.$$</p>
<p>The velocity is opposite at the two edges because the local electric field $\mathcal{E}$ created by the confining potential always points towards the interior of the sample.</p>
<p>An important thing to note is that the presence of edge states does not depend in any way on the particular shape of the sample as well. You can cut a quantum Hall system in any way you want, but as long as it has edges, it will have edge states. To demonstrate this, let’s take a “picture” of the edge states by plotting the local density of states at the Fermi level in a Hall bar.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.6</span>, mu_lead=<span class="number">0.6</span>, B=<span class="number">0.15</span>, phi=<span class="number">0.0</span>)</span><br><span class="line">syst = qhe_hall_bar(L=<span class="number">200</span>, W=<span class="number">100</span>).finalized()</span><br><span class="line">ldos = kwant.ldos(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=[<span class="number">20</span>, <span class="number">20</span>])</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(syst, ldos, num_lead_cells=<span class="number">20</span>, colorbar=<span class="literal">False</span>, ax=ax)</span><br></pre></td></tr></table></figure>

<p>The local density of states beautifully reveals the presence of edge states in the sample. You can see that each filled Landau level produces a maximum in the density of states, which goes all around the edges of the sample. In this case, our simulation had two filled Landau levels in the bulk.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;In the plot above, which edge state moves faster, the one closer to the edge or the one further away ?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;They go at the same velocity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The one more towards the bulk, because it is not slowed by the confining potential.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The one closer to the edge, because the local electric field there is stronger.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;One cannot tell, because it depends on microscopic details.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The drift velocity is given by the ratio of the local electric field and the magnetic field. &quot;</span></span><br><span class="line">    <span class="string">&quot;The slope of the confinement potential increases sharply at the edge, hence the local electric field &quot;</span></span><br><span class="line">    <span class="string">&quot;is stronger there.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="The-harmless-anomaly-of-the-chiral-edges"><a href="#The-harmless-anomaly-of-the-chiral-edges" class="headerlink" title="The harmless anomaly of the chiral edges"></a>The harmless anomaly of the chiral edges</h1><p>The chiral edge states can be described in such simple terms, that you might doubt the fact that they cannot exist without a bulk. After all, couldn’t we just build a theory of a single chiral edge state, neglecting the bulk of the quantum Hall system and the existence of the other edge? Can’t a truly one-dimensional system just show the same behavior of the chiral edge state of the quantum Hall effect?</p>
<p>Let’s consider the equation $E=\hbar v (k-k_F)$ which describes these chiral states. We can imagine that a constant electric field $\mathcal{E}$ can be applied along the edge, pallel to the momentum $k$. (In the Hall cylinder, this can be done by threading a time-dependent flux through the cylinder, as you have seen in the previous part of the lecture).</p>
<p>The momentum $k$ changes according to the equation $\hbar \dot{k} = -e\mathcal{E}$. After a time $t$, the energy of a state with momentum $k$ has changed to $\hbar v (k - k_F - e\mathcal{E}t/\hbar)$. This increase corresponds to a time-dependent shift of the Fermi momentum, $k_F,\to,k_F + e\mathcal{E}t/\hbar$. Recall that $k_F = 2\pi N/L$ where $N$ is the number of electrons, so the rate of change of $k_F$ gives</p>
<p>$$\dot{N} = \mathcal{E}L/\Phi_0,$$</p>
<p>with $\Phi_0=h/e$ a flux quantum! Since the number of electrons is changing, <strong>charge is not conserved</strong>. In particular, after a time such that $\mathcal{E}L t = \Phi_0$, it seems that exactly one electron has popped out of nowhere at the edge.</p>
<p>At this point, you should understand what’s happening. This is just how the Laughlin pump manifests itself if you only look at one edge. The number of electrons at one edge can increase, because electrons are being depleted from the other edge (which is not included in our “theory”) and pumped through the bulk until they appear.</p>
<blockquote>
<p>This property of the edge is referred to as the <strong>chiral anomaly</strong>. The chiral anomaly tells us that we cannot have a consistent theory for a chiral edge state without a bulk, which at the same time conserves electric charge. Chiral edge states, or anything else that exhibits a chiral anomaly, are an example of the bulk edge correspondence, since they can only appear at the edge of a two dimensional system and never in isolation.</p>
</blockquote>
<p>We called the anomaly “harmless” since the non-conservation of charge at the edge has a very simple explanation when the rest of the system is included in the picture. If you ever encounter other “anomalous” theories, it might well be a sign that the system under consideration is only the edge of something else!</p>
<h1 id="Quantization-of-Hall-Conductance-from-edge-states"><a href="#Quantization-of-Hall-Conductance-from-edge-states" class="headerlink" title="Quantization of Hall Conductance from edge states"></a>Quantization of Hall Conductance from edge states</h1><p>To conclude our case about chiral edge states, we will now show that both signatures of the quantum Hall effect can be explained solely in terms of the edge states, as long as the interactions between electrons are neglected. In principle, this exercise can be done in any of the sample geometries that you have seen so far: the 6-terminal Hall bar, the Hall cylinder, and the Corbino geometry. We will choose the last one for the sake of convenience.</p>
<p>So let’s take again our Corbino disk immersed in an external magnetic field. With respect to last time, we now apply a small voltage difference $V$ between the edges, and there is no flux passing through in the middle of the Corbino disk.</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/QHEedgestates/corbino_voltage.svg" alt></p>
<p>In this new drawing, we have also added arrows to indicate that we now know that each edge of the Corbino supports one chiral  state. We cannot resist the temptation of showing you another beautiful plot of the local density of states, showing edge states in the Corbino geometry:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">W = <span class="number">60</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.9</span>, mu_lead=<span class="number">0.9</span>, B=<span class="number">0.15</span>, phi=<span class="number">0.0</span>)</span><br><span class="line">syst = qhe_corbino(<span class="number">2</span> * W, W).finalized()</span><br><span class="line">ldos = kwant.ldos(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">fig = plt.figure(figsize=[<span class="number">15</span>, <span class="number">15</span>])</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(syst, ldos, num_lead_cells=<span class="number">20</span>, colorbar=<span class="literal">False</span>, ax=ax)</span><br></pre></td></tr></table></figure>

<p>Note how the local density of states for each edge state oscillates between maxima and minima. This is because the edge state wave functions are standing waves which go all around the Corbino disk.</p>
<p>But back to the point. We want to consider the case when the system is in equilibrium, and we ask what are the currents that flow in the system as a consequence of the small applied voltage $V$.</p>
<p>First, $V$ does not determine the presence of a current <em>between the edges</em>. Even though electrons can be injected in the edges, these are separated by the bulk of the system, where due to the position of the Fermi level there are no states available to carry a current. Furthermore, there is no time-dependent flux being threaded through the Corbino disk, so the Laughlin pump is not in motion. Since there is no charge transfer at all in the direction parallel to the applied voltage, we have that the longitudinal conductance $\sigma_L=0$.</p>
<p>However, what is the current $I_\circlearrowleft$ flowing <em>around</em> the ring? Because such a current would flow <em>orthogonally</em> with respect to the applied voltage, it is associated with the Hall conductance, $I_\circlearrowleft= \sigma_H V$.</p>
<p>Let’s first consider the case $V=0$. The Fermi level is then the same at both edges. There are as many electrons going around the ring clockwise on the outer edge, as there are going around counterclockwise on the inner edge. In this case there is no net current flowing around the ring.</p>
<p>A small voltage difference $V$ creates a small imbalance in the electron population between the edges. There will be, say, more electrons running counterclockwise on the inner edge than running clockwise on the outer edge. So we do expect a net current flowing around the ring.</p>
<p>Let’s compute the intensity of the current, it’s quite simple.</p>
<p>Every chiral edge state is a <em>transport channel</em> for the current. Now, the defining property of chiral edge states is that they only allow electrons to travel along the edge in one direction. Electrons have no chance to reverse their velocity, or in other words no chance to <em>backscatter</em>.  This means that chiral edge states are perfect transport channels to carry a current, so they have the highest conductance possible. Quantum mechanics limits the maximum conductance that a single transport channel can have to the value $G_0=e^2/h$, which is the conductance quantum you already met last week. With $n$ of these channels, we obtain precisely</p>
<p>$$I_\circlearrowleft = n ,\frac{e^2}{h} V,.$$</p>
<blockquote>
<p>Thus, the relevant electromagnetic responses, namely the longitudinal and Hall conductivities $\sigma_L=0$ and $\sigma_H=ne^2/h$, can both be derived directly by only considering the chiral edge states.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;At which energy did we set the Fermi level in the density of states plot for the Corbino disk?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;It is impossible to answer on the base of the plot alone, because it depends on the voltages applied to the leads.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Exactly at the same energy as the third Landau level.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Between the second and the third Landau levels.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Between the third and the fourth Landau levels.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;There are three edge states visible in the figure. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence there are three filled Landau levels in the bulk, &quot;</span></span><br><span class="line">    <span class="string">&quot;so the Fermi level lies somewhere above the third, but below the fourth Landau level.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Important-things-to-know-about-edge-states"><a href="#Important-things-to-know-about-edge-states" class="headerlink" title="Important things to know about edge states"></a>Important things to know about edge states</h1><p>The physical picture that we presented this week is very simple, and it is also somewhat simplified.</p>
<p>In the summary video of this week, Bert Halperin from Harvard University will discuss how disorder and interactions enter in the description of the quantum Hall effect, and where the electric current is really carried. In 1982, Bert was the <a target="_blank" rel="noopener" href="http://sites.fas.harvard.edu/~phys191r/References/e3/halperin1982.pdf">first to understand</a> that the quantum Hall effect could be explained by the existence of chiral edge states, so we are very happy that you can learn the story directly from him.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;rQs12c-SieE&quot;</span>, src_location=<span class="string">&quot;3.3-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Chiral edge states&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w3_pump_QHE/Laughlinargument"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w3_pump_QHE/Laughlinargument/" class="article-date">
  <time datetime="2021-01-07T09:11:06.828Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_corbino</span>(<span class="params">r_out=<span class="number">100</span>, r_in=<span class="number">65</span>, w_lead=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create corbino disk. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, B, phi</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ring shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ring</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        rsq = x ** <span class="number">2</span> + y ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> r_in ** <span class="number">2</span> &lt; rsq &lt; r_out ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crosses_branchcut</span>(<span class="params">hop</span>):</span></span><br><span class="line">        x1, y1 = hop[<span class="number">0</span>].pos</span><br><span class="line">        x2, y2 = hop[<span class="number">1</span>].pos</span><br><span class="line">        <span class="keyword">return</span> y1 &lt; <span class="number">0</span> <span class="keyword">and</span> x1 &gt; <span class="number">0.5</span> <span class="keyword">and</span> x2 &lt; <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="comment"># Check for correctness!</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">branchcut_hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hopping(site1, site2, p) * np.exp(<span class="number">1j</span> * p.phi)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ring, (<span class="number">0</span>, r_in + <span class="number">1</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding special hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hops_across_cut</span>(<span class="params">syst</span>):</span></span><br><span class="line">        <span class="keyword">for</span> hop <span class="keyword">in</span> kwant.builder.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat, lat)(syst):</span><br><span class="line">            <span class="keyword">if</span> crosses_branchcut(hop):</span><br><span class="line">                <span class="keyword">yield</span> hop</span><br><span class="line"></span><br><span class="line">    syst[hops_across_cut] = branchcut_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt; y &lt; w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line">    lead[lat.neighbors()] = <span class="keyword">lambda</span> site1, site2, p: -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment">#### Attach the leads and return the system. ####</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead, origin=lat(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total_charge</span>(<span class="params">value_array</span>):</span></span><br><span class="line">    determinants = [np.linalg.det(s) <span class="keyword">for</span> s <span class="keyword">in</span> value_array]</span><br><span class="line">    charge = np.cumsum(np.angle(determinants / np.roll(determinants, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> charge / (<span class="number">2</span> * np.pi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_ribbon</span>(<span class="params">W, periodic=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Creates ribbon system</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If we have periodic boundary conditions, the flux through a single </span></span><br><span class="line"><span class="string">    unit cell is quantized.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -W / <span class="number">2</span> &lt;= y &lt;= W / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_periodic</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(</span><br><span class="line">            -<span class="number">1j</span></span><br><span class="line">            * np.pi</span><br><span class="line">            / (W + <span class="number">1</span>)</span><br><span class="line">            * np.<span class="built_in">round</span>((W + <span class="number">1</span>) * p.B / (<span class="number">2</span> * np.pi))</span><br><span class="line">            * (x1 - x2)</span><br><span class="line">            * (y1 + y2)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym_syst = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym_syst)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line">        syst[lat.neighbors()] = hopping_periodic</span><br><span class="line">        syst[lat(<span class="number">0</span>, -W / <span class="number">2</span>), lat(<span class="number">0</span>, +W / <span class="number">2</span>)] = hopping_periodic</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Quantum hall bar codes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_hall_bar</span>(<span class="params">L=<span class="number">50</span>, W=<span class="number">10</span>, w_lead=<span class="number">10</span>, w_vert_lead=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a hall bar system. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    L = <span class="number">2</span> * (L // <span class="number">2</span>)</span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line">    w_lead = <span class="number">2</span> * (w_lead // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> w_vert_lead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        w_vert_lead = w_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        w_vert_lead = <span class="number">2</span> * (w_vert_lead // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bar shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (x &gt;= -L / <span class="number">2</span> <span class="keyword">and</span> x &lt;= L / <span class="number">2</span>) <span class="keyword">and</span> (y &gt;= -W / <span class="number">2</span> <span class="keyword">and</span> y &lt;= W / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ax</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (x1 + x2) * (y1 - y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_lead_hop_y</span>(<span class="params">x0</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ay</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">            x1, y1 = site1.pos</span><br><span class="line">            x2, y2 = site2.pos</span><br><span class="line">            <span class="keyword">return</span> -p.t * np.exp(-<span class="number">1j</span> * p.B * x0 * (y1 - y2))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hopping_Ay</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_hop_vert</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(bar, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping_Ax</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt;= y &lt;= w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_onsite = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line"></span><br><span class="line">    sym_lead_vertical = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead_vertical1 = kwant.Builder(sym_lead_vertical)</span><br><span class="line">    lead_vertical2 = kwant.Builder(sym_lead_vertical)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical1</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= -L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical2</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> +L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= +L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_vertical1[lat.shape(lead_shape_vertical1, (-L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical1[lat.neighbors()] = lead_hop_vert</span><br><span class="line">    lead_vertical2[lat.shape(lead_shape_vertical2, (L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical2[lat.neighbors()] = lead_hop_vert</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1)</span><br><span class="line">    syst.attach_lead(lead_vertical2)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1.<span class="built_in">reversed</span>())</span><br><span class="line">    syst.attach_lead(lead_vertical2.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (-<span class="number">1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(-L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line"></span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line">    lead[lat.shape(lead_shape, (-<span class="number">1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_sigmas</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="comment"># reduce by one dimension G -&gt; G[temp, temp]</span></span><br><span class="line">    temp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    G = G[temp, :]</span><br><span class="line">    G = G[:, temp]</span><br><span class="line">    <span class="comment"># invert R = G^-1</span></span><br><span class="line">    <span class="comment"># find out whether it is a numpy object</span></span><br><span class="line">    r = np.linalg.inv(G)</span><br><span class="line">    <span class="comment"># Voltages follow: V = R I[temp]</span></span><br><span class="line">    V = r @ np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Completely solved the six terminal system.</span></span><br><span class="line">    <span class="comment"># Consider the 2x2 conductance now: Use I = sigma U</span></span><br><span class="line">    E_x = V[<span class="number">1</span>] - V[<span class="number">0</span>]</span><br><span class="line">    E_y = V[<span class="number">1</span>] - V[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># formula above</span></span><br><span class="line">    sigma_xx = E_x / (E_x ** <span class="number">2</span> + E_y ** <span class="number">2</span>)</span><br><span class="line">    sigma_xy = E_y / (E_x ** <span class="number">2</span> + E_y ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> sigma_xx, sigma_xy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pumping</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    p.mu_lead = p.mu</span><br><span class="line">    phis = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">40</span>)</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    rs = [kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).submatrix(<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">for</span> p.phi <span class="keyword">in</span> phis]</span><br><span class="line">    charges = -total_charge(rs)</span><br><span class="line">    style = &#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&quot;aspect&quot;</span>: <span class="string">&quot;square&quot;</span>&#125;</span><br><span class="line">    kdims = [<span class="string">&quot;$\phi/2\pi$&quot;</span>, <span class="string">&quot;$q_&#123;pump&#125;$&quot;</span>]</span><br><span class="line">    title = <span class="string">&quot;$\mu = &#123;:.2&#125;$, $\sigma_H = &#123;:&#125; \cdot e^2/h$&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        p.mu, <span class="built_in">int</span>(<span class="built_in">round</span>(charges[-<span class="number">1</span>]))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> holoviews.Path((phis / (<span class="number">2</span> * np.pi), charges), kdims=kdims, label=title).opts(</span><br><span class="line">        plot=style</span><br><span class="line">    )[:, <span class="number">0</span>:<span class="number">3.1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Ady Stern from the Weizmann Institute of Science will introduce the quantum Hall effect.</p>
<p>Ady thanks Dr. Dan Arav and Gil Novik from the School of Media Studies of the<br>College of Management - Academic Studies for their help in preparing the videos.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;QC3tQT7MD00&quot;</span>, src_location=<span class="string">&quot;3.2-intro&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="The-Hall-effect"><a href="#The-Hall-effect" class="headerlink" title="The Hall effect"></a>The Hall effect</h1><p>We now move on to the quantum Hall effect, the mother of all topological effects in condensed matter physics.</p>
<p>But let’s start from the classical <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hall_effect">Hall effect</a>, the famous phenomenon by which a current flows perpendicular to an applied voltage, or vice versa a voltage develops perpendicular to a flowing current.</p>
<p>How does one get a Hall effect? The key is to break time-reversal symmetry. A flowing current breaks time-reversal symmetry, while an electric field doesn’t. Hence, any system with a Hall effect must somehow break time-reversal symmetry.</p>
<p>But wait a minute, you might catch me and ask, what about a normal electric current flowing parallel to an electric field? This is what happens in a metal on a regular basis, and a metal does not break time-reversal symmetry.</p>
<p>The key difference there is that such a longitudinal current breaks time-reversal through energy dissipation, which turns into heat that breaks time-reversal by the second law of thermodynamics. A Hall current is special in that it is <strong>dissipationless</strong>. We can drive a Hall current without wasting any energy because the current flows perpendicular to the voltage gradient.</p>
<blockquote>
<p>Thus to get a Hall effect we must somehow break time-reversal symmetry. We will examine the simplest way to achieve this, an external magnetic field.</p>
</blockquote>
<h2 id="How-to-measure-the-Hall-effect"><a href="#How-to-measure-the-Hall-effect" class="headerlink" title="How to measure the Hall effect"></a>How to measure the Hall effect</h2><p>Let’s consider a two dimensional gas of electrons immersed in a strong, perpendicular magnetic field. In particular, we take the following geometry, which is called a Hall bar and is routinely used in experiments:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/hall_bar.svg" alt></p>
<p>The electron gas is contacted by six electrodes, numbered in the figure. We can use this Hall bar geometry set-up to measure the transport characteristics of the gas, as follows.</p>
<p>The transport characteristics are tabulated using the 4 components $\sigma_{xx},\sigma_{yy},\sigma_{xy}$ and $\sigma_{yx}$ of the so-called conductivity tensor. Once we know the conductivity tensor, we can use it to calculate how the current density $\mathbf{j} = (j_x,j_y)$ flows in response to the electric field $\mathbf{E} = (E_x,E_y)$ in the metal, through the equation  </p>
<p>$$j_\alpha=\sum_\beta \sigma_{\alpha\beta}E_{\beta}.$$</p>
<p>By inverting this set of relations between current densities and electric field, we obtain the resistivities $\rho_{xx}, \rho_{xy}, \dots$, which are more often reported in experimental data. Also, in two-dimensional systems there is no real difference between conductance and conductivity (or resistance and resistivity) - they have the same physical units. So the terms are somehow interchangeable.</p>
<p>The way to use the Hall bar device is to drive a current $I$ along the $x$ direction, so that there is a current density $j_x=(I/W)$ where $W$ is the width of the sample. There is no current density in the perpendicular direction.</p>
<p>We can measure the electric field using the Hall bar geometry from the voltage drops between the probes with voltages $V_{1,2,3,4}$.<br>We can then measure the $x$-component of the electric field from the longitudinal voltage drop $V_L\sim (V_1-V_2)$ or  $(V_3-V_4)$ according to the averaged equation </p>
<p>$$E_x \equiv \frac{V_1+V_3-V_2-V_4}{2L}.$$</p>
<p>Similarly, we can measure the $y$-component of the electric field from the  Hall voltage $V_H=(V_1-V_3)$ or $(V_2-V_4)$. Specifically we can calculate the electric field as: </p>
<p>$$E_y \equiv \frac{V_1+V_2-V_4-V_3}{2W}.$$</p>
<p>The Hall bar can only measure the conductance completely for isotropic or rotationally invariant systems. If we rotate the system by 90 degrees we can transform $x\rightarrow y$ and $y\rightarrow -x$. So we expect $\sigma_{xx}=\sigma_{yy}=\sigma_L$, the longitudinal conductance. If we apply this same rotation transformation we conclude that $\sigma_{xy}=-\sigma_{yx}=\sigma_H$, the <em>Hall conductance</em>. </p>
<p>So with rotational invariance the 4 component conductance tensor has only 2 independent components i.e. the longitudinal and Hall conductance. We can calculate these using the two electric fields $E_{x,y}$ that we measure using the Hall bar.<br>To do this, we solve the set of equations $j_y=\sigma_L E_y - \sigma_H E_x=0$ and $j_x=\sigma_L E_x+\sigma_H E_y$ to obtain $\sigma_{L,H}$. We obtain the Hall conductance</p>
<p>$$\sigma_H=\frac{j_x E_y}{E_x^2+E_y^2}.$$</p>
<h1 id="The-classical-Hall-effect-is-a-linear-effect"><a href="#The-classical-Hall-effect-is-a-linear-effect" class="headerlink" title="The classical Hall effect is a linear effect"></a>The classical Hall effect is a linear effect</h1><p>Let’s now try to obtain an alternative expression for the Hall conductance $\sigma_H$ of our Hall bar. In general we expect the electric and magnetic fields present in our Hall bar to apply a force to the electrons, and increase their velocity. </p>
<p>Instead of solving the problem directly, let us make the ansatz that the electrons enter a state, which is obtained from the usual electron ground state by doing a Galilean transformation to a reference frame moving with velocity $\bf{v}$ with respect to the original reference frame.</p>
<p>Since the average velocity of the electrons is $\bf v$ in the original reference frame, the average force on the electrons is </p>
<p>$${\bf F}= e,(\mathbf{E}+\mathbf{v}\times \mathbf{B}).$$</p>
<p>If we want to be a steady state then $\bf F=0$, which means that ${\bf v}= (\mathbf{E}\times \mathbf{B})/B^2$. Since the electrons move with an average velocity $\bf v$, and if $n$ denotes the electron density, we can easily guess that the current density is ${\bf j}=n e {\bf v}=(n e/ B) ,(\mathbf{E}\times \mathbf{z})$.</p>
<blockquote>
<p>Comparing with the previous subsection, we can thus conclude that simply based on Galilean invariance, an electron gas in a magnetic field must have a Hall conductance that is given by </p>
</blockquote>
<p>$$\sigma_H=n e B^{-1}.$$</p>
<p>This relation, which says that $\sigma_H\propto n$, is extremely general in the sense that it does not depend on how the electrons interact with each other or anything else. It is referred to as the Streda relation. If we define the so-called “filling factor” as $\nu=n h/ e B$ the Hall conductance can be written as a multiple of the quantum of conductance as $\sigma_H=\nu \frac{e^2}{h}$.</p>
<p>As you already heard from Ady Stern in the intro video, people have measured the Hall conductance of this exact system to incredible precision. At relatively high density, the Hall conductance of this system behaves itself accordingly and scales linearly with gate voltage, which is tuned to control the density. At low filling factors, one would expect many non-idealities like disorder and interaction to break the Galilean invariance based argument and lead to a Hall conductance $\sigma_H$ that varies from sample to sample and depends on disorder. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;What is the longitudinal conductance for the ideal electron gas in a magnetic field?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Infinity since there are no impurities in the system.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Finite and inversely proportional to the magnetic field like the Hall conductance.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Finite and proportional to density but independent of magnetic field.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Zero since current is perpendicular to electric field.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = <span class="string">&quot;As we saw the velocity is related to the cross-product of the electric and magnetic field.&quot;</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="The-quantum-Hall-effect-experimental-data"><a href="#The-quantum-Hall-effect-experimental-data" class="headerlink" title="The quantum Hall effect: experimental data"></a>The quantum Hall effect: experimental data</h1><p>Instead, a completely unexpected result was measured for the first time by Klaus von Klitzing. Typical experimental data looks like this (taken from M.E. Suddards, A. Baumgartner, M. Henini and C. J. Mellor, <a target="_blank" rel="noopener" href="http://iopscience.iop.org/1367-2630/14/8/083015">New J. Phys. 14 083015</a>):</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/QHE.png" alt></p>
<blockquote>
<p>As the average density is varied, the Hall conductance $\sigma_H$ appears to form plateaus at integer filling fractions $\nu=1,2,3,\dots$. These plateaus are incredibly sample independent and occur at the same value in many other materials. At the same time, the longitudinal conductivity appears to vanish except at the transition points between the plateaus. This is the integer “Quantum Hall effect”. </p>
</blockquote>
<p>This setup is easy to try to reproduce numerically, but there’s one complication:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syst = qhe_hall_bar(L=<span class="number">60</span>, W=<span class="number">100</span>, w_lead=<span class="number">90</span>, w_vert_lead=<span class="number">28</span>).finalized()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.3</span>, mu_lead=<span class="number">0.3</span>, B=<span class="literal">None</span>)</span><br><span class="line">Bs = np.linspace(<span class="number">0.02</span>, <span class="number">0.15</span>, <span class="number">200</span>)</span><br><span class="line">num_leads = <span class="built_in">len</span>(syst.leads)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    smatrix = kwant.smatrix(syst, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    G = [</span><br><span class="line">        [smatrix.transmission(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_leads)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_leads)</span><br><span class="line">    ]</span><br><span class="line">    G -= np.diag(np.<span class="built_in">sum</span>(G, axis=<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> calculate_sigmas(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sigmasxx, sigmasxy = np.array([G(syst, p) <span class="keyword">for</span> p.B <span class="keyword">in</span> Bs]).T</span><br><span class="line"></span><br><span class="line">kdims = [<span class="string">r&quot;$B^&#123;-1&#125; [a.u.]$&quot;</span>, <span class="string">&quot;$\sigma_&#123;xx&#125;, \sigma_&#123;xy&#125;\,[e^2/h]$&quot;</span>]</span><br><span class="line">plot_xx = holoviews.Path((<span class="number">1</span> / Bs, sigmasxx), label=<span class="string">r&quot;$\sigma_&#123;xx&#125;$&quot;</span>, kdims=kdims).opts(</span><br><span class="line">    style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line">plot_xy = holoviews.Path((<span class="number">1</span> / Bs, sigmasxy), label=<span class="string">r&quot;$\sigma_&#123;xy&#125;$&quot;</span>, kdims=kdims).opts(</span><br><span class="line">    style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(plot_xx * plot_xy).opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">0</span>, <span class="string">&quot;yticks&quot;</span>: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">8</span>))&#125;)</span><br></pre></td></tr></table></figure>

<p>Numerical systems are so good that the longitudinal conductivity always stays low even at the transition.</p>
<p>But other than that small problem everything works just the same.</p>
<h1 id="Quantized-Hall-conductance-from-pumping-Laughlin-argument"><a href="#Quantized-Hall-conductance-from-pumping-Laughlin-argument" class="headerlink" title="Quantized Hall conductance from pumping: Laughlin argument"></a>Quantized Hall conductance from pumping: Laughlin argument</h1><p>Why is the quantized Hall conductance $\sigma_H$ so robust and independent of system details? Clearly there must be a topological argument at play.</p>
<p>Soon after the experimental discovery, Laughlin came up with an elegant argument that mapped the Hall conductance problem to a topological pumping problem and in the process explained the robustness. Let us go through this argument.</p>
<h2 id="The-Corbino-geometry"><a href="#The-Corbino-geometry" class="headerlink" title="The Corbino geometry"></a>The Corbino geometry</h2><p>To start with, we imagine doing the Hall measurement in a system cut out as an annulus, which is referred to as the Corbino disk:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/corbino_flux.svg" alt></p>
<p>We will also try to do the experiment in reverse i.e. apply an electric field along the circumference of the disk and measure the current $I$ in the radial direction, as shown in the figure. The radial current is easy to measure - we just measure the amount of charge $\Delta Q$ transferred between the inner and outer edges of the Corbino geometry and obtain the radial current $I=\Delta Q/\Delta T$, where $\Delta T$ is the time over which this is done.</p>
<p>But how do we apply an electric field in the tangential direction?  The easiest way to do this is to apply a time-dependent magnetic field in the centre of the disc and use the Faraday effect. </p>
<p>We can calculate the electric field from the changing magnetic field using Faraday’s law as $\oint d{\bf{r}\cdot\bf{E}}=\partial_t \Phi$, where $\Phi$ is the magnetic flux resulting from the field in the center of the disk. Assuming that the electric field depends only on the radius $R$ we find that the resulting tangential electric field is given by</p>
<p>$$E(R,t)=\frac{1}{2\pi R},\partial_t \Phi.$$ </p>
<p>Given $I$, we can also calculate the other component of the measurement of the Hall conductance $\sigma_H$ i.e. the radial current density $j=I/(2\pi R)$ at the same radius $R$ as we calculated the electric field. </p>
<p>Now that we know both the circumferential electric field and also the radial current density, the Hall conductance can be measured easily in this geometry as </p>
<p>$$\sigma_H=\frac{j}{E(r,t)}=\frac{I}{\partial_t \Phi}.$$</p>
<p>You might worry that we were a bit simplistic and ignored the longitudinal conductance in this geometry. We could measure the longitudinal conductivity by applying a voltage difference between the inner and outer edges and measuring the resulting radial current $I$. For the remainder of this discussion, we assume that the longitudinal conductivity vanishes as is observed experimentally.</p>
<h2 id="Laughlin-pump"><a href="#Laughlin-pump" class="headerlink" title="Laughlin pump"></a>Laughlin pump</h2><p>We are now ready to present the pumping argument to explain why the low temperature Hall effect is quantized.</p>
<p>To do this, we change the magnetic field in the center of the Corbino disc so that the flux changes by $\Delta \Phi=\Phi_0=h/e$, i.e. a <strong>flux quantum</strong> over the time $\Delta T$. (Note that this flux quantum is only half of the superconducting flux quantum that we were using last week. That’s because now the current is being carried by electrons and not Cooper pairs. It is customary to use the same symbol $\Phi_0$ for both, since they often appear in different contexts). Assuming that we have a system with Hall conductance $\sigma_H$, we obtain the charge transferred as </p>
<p>$$\Delta Q=I \Delta T=\sigma_H, \Delta T, \partial_t\Phi =\sigma_H,\Delta\Phi=\sigma_H, \frac{h}{e}.$$</p>
<p>Writing $\sigma_H=\nu e^2/h$, we obtain $\Delta Q=\nu e$. Since the longitudinal conductance $\sigma_L=0$, we expect the system to be gapped in the bulk of the disc and we expect the entire charge transfer $\Delta Q$ to occur between the edges.</p>
<blockquote>
<p>Since the flux $\Phi$ in the center is a flux quantum $\Phi_0$, the wave functions of the electrons all return to being the same as at $\Phi=0$. Therefore only an integer number of charges $\Delta Q=n e$ can be pumped between the edges. This is Laughlin’s argument for why the Hall conductance must be quantized as</p>
</blockquote>
<p>$$\sigma_{xy}=n e^2/h.$$</p>
<p>What you notice at this point is that we basically have a pump similar to the last unit.</p>
<p>Here an integer number of charges is pumped from one edge to the other as the flux $\Phi$ is increased by $\Phi_0$. As one sees below, one can simulate electrons in a Corbino geometry and check that indeed an integer number of charges is pumped between the edges as the flux $\Phi$ is changed by $\Phi_0$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">W = <span class="number">20</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, B=<span class="number">2</span> * np.pi / (W + <span class="number">1</span>), phi=<span class="literal">None</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = qhe_corbino(r_out=<span class="number">2</span> * W, r_in=<span class="number">20</span>, w_lead=<span class="number">10</span>)</span><br><span class="line">mus = np.linspace(<span class="number">0.4</span>, <span class="number">1.4</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.mu: plot_pumping(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Experimentally the quantum Hall conductance jumps - what does this mean about the &quot;</span></span><br><span class="line">    <span class="string">&quot;robustness of the Laughlin pumping argument?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The Laughlin argument breaks down because it assumes specific values of the magnetic field.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Laughlin argument assumes there is no longitudinal conductivity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hall conductance is not a topological invariant since it changes.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The flux in the corbino geometry was changed by a value that was not a multiple of the flux quantum.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The key ingredient in the Laughlin argument was that there is no states at the fermi level in &quot;</span></span><br><span class="line">    <span class="string">&quot;the bulk which is equivalent to no longitudinal conductivity&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Landau-levels-a-microscopic-model-for-the-quantum-hall-effect"><a href="#Landau-levels-a-microscopic-model-for-the-quantum-hall-effect" class="headerlink" title="Landau levels: a microscopic model for the quantum hall effect"></a>Landau levels: a microscopic model for the quantum hall effect</h1><p>The general argument so far is great in that it applies to virtually any complicated electron system with interactions and in a real material, but we would probably feel better if we could calculate the Hall conductance directly for some simple system. So let us try to do this for the simplest case of electrons in a magnetic field.</p>
<p>For starters, let us forget about the Corbino disk and just ask what do quantum mechanical electrons do in a magnetic field. </p>
<h2 id="Landau-levels-on-the-back-of-an-envelope"><a href="#Landau-levels-on-the-back-of-an-envelope" class="headerlink" title="Landau levels on the back of an envelope"></a>Landau levels on the back of an envelope</h2><p>We know what classical electrons do in a perpendicular magnetic field: They go around in <em>cyclotron orbits</em>, because of the Lorentz force. The cyclotron radius in a magnetic field of strength $B$ for an electron with velocity $v$ is $r_c = mv/eB$. An electron performing a cyclotron orbit at velocity $v$ has angular momentum $L=mvr_c=eB r^2_c$. In quantum mechanics, however, only orbits with a quantized angular momentum $L=n\hbar$ will be allowed. From the equality $r^2_c = n\hbar/eB$ one obtains that only some discrete values are allowed for the radius, $r_n = \sqrt{n} l_B$, where $l_B = \sqrt{\hbar/eB}$ is called the magnetic length.</p>
<p>All cyclotron orbits, independent of the radius, circle at the same frequency $\omega_c=eB/m$. The energy of the electron in this quantized orbit is equal to $L\omega_c = n\hbar\omega_c$. So the energy spectrum really looks like that of a harmonic oscillator. All the energy levels are also shifted up from zero energy by the zero-point motion of the harmonic oscillator, $\hbar\omega_c/2$. We finally obtain that the allowed energy levels are</p>
<p>$$E_n = \hbar \omega_c ,\left(n+\tfrac{1}{2}\right),.$$</p>
<p>These quantized energy levels of electrons in a magnetic field are called <strong>Landau levels</strong>.</p>
<p>You can put many electrons in the same Landau level: one for every flux quantum of the magnetic flux passing through the system. Therefore Landau levels have a huge degeneracy, proportional to the area of the sample.</p>
<h2 id="Landau-levels-from-the-Hamiltonian"><a href="#Landau-levels-from-the-Hamiltonian" class="headerlink" title="Landau levels from the Hamiltonian"></a>Landau levels from the Hamiltonian</h2><p>Now that we know the answer in advance, we can solve the Schrödinger equation for electrons in a magnetic field without stress. It will still be important to understand the quantum Hall effect in a bit more detail. The Hamiltonian is</p>
<p>$$H=(\textbf{p}-e \textbf{ A})^2.$$ </p>
<p>The vector potential $\bf{A}$ depends on position, which makes this Hamiltonian complicated to solve in general. For a uniform magnetic field, we can make our life easier by choosing a Landau gauge </p>
<p>$$\textbf{A}(x,y)=\hat{\textbf{x}}B y ,$$ </p>
<p>where the vector potential does not depend on $x$. In this gauge, the entire Hamiltonian is translationally invariant along the $x$ direction, and therefore commutes with the corresponding momentum $p_x$. This allows us to choose $p_x=\hbar k$ as a good quantum number, and our two dimensional Hamiltonian reduces to a one dimensional one:</p>
<p>$$H(k)=p_y^2+(\hbar k-e B y)^2.$$</p>
<p>Apart from a shift of the $y$ coordinate by $y_0(k)=\hbar k/eB$, this is exactly the Hamiltonian of a simple harmonic oscillator! Its eigenvalues are the Landau levels, which are independent of $k$. The corresponding wave functions are those of the harmonic oscillator along the $y$ direction, and plane waves with momentum $k$ along the $x$ direction. In the $y$ direction, they are localized in space within a length $\sim l_B$.</p>
<p>This gives us another way to understand the quantized Hall conductance for ideal two dimensional electron gases.</p>
<p>Now, the electron energies are quantized in Landau levels, and if $n$ Landau levels are filled at a given chemical potential, the filling factor is $\nu=n$. The Streda formula then predicts the Hall conductance as $\sigma_H=\nu e^2/h=n e^2/h$. The longitudinal conductivity must vanish since the gapped system does not allow dissipation of energy in the bulk.</p>
<h1 id="Flux-pumping-of-electrons-in-a-Hall-cylinder"><a href="#Flux-pumping-of-electrons-in-a-Hall-cylinder" class="headerlink" title="Flux pumping of electrons in a Hall cylinder"></a>Flux pumping of electrons in a Hall cylinder</h1><p>We can now see explicitly how the Laughlin pumping argument works, starting from the microscopic description of electrons in terms of Landau levels. Starting from the formulas we derived, it is a little difficult to do so in the Corbino geometry, which has an angular symmetry rather than a translational symmetry. It is very easy if we consider the Laughlin pump for electrons in a cylinder:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/hall_cylinder.svg" alt></p>
<p>In fact the cylinder drawn above and the Corbino disk are completely equivalent - you can imagine deforming one into the other. The advantage of the cylinder is that we get to keep our $(x, y)$ coordinates. The Hall cylinder that we considered for Laughlin’s argument is in fact equivalent to a ribbon in the $(x, y)$ plane, with periodic boundary conditions $x\equiv x+L$ in the $x$ direction ($L$ is the circumference of the cylinder).<br>The periodic boundary conditions along the $x$ direction discretize the allowed values of $k$ as $k=2\pi n/L$.</p>
<p>For the Laughlin pumping argument, we need to introduce a flux through the cylinder. Using Stokes’ theorem, we know that the line integral of the vector potential around the cylinder must be equal to the flux passing through it, $\oint \textbf{dr}\cdot\textbf{A(r)}=\Phi$. So we can introduce a flux through the cylinder by choosing our vector potential $\bf{A}$ as </p>
<p>$$\textbf{A}(x,y)=(B y +\Phi/L),\hat{\textbf{x}},,$$ </p>
<p>very similar to the previous calculation. The resulting Hamiltonian for the states labeled by $n$ is  </p>
<p>$$H=p_y^2+\left(\frac{\hbar 2\pi n}{L}-e B y-\frac{e\Phi}{L}\right)^2,.$$</p>
<p>Comparing the above equation to the quantum harmonic oscillator, we see that the harmonic oscillator levels<br>must be centered at </p>
<p>$$y_0(n) = \left(n-\frac{\Phi}{\Phi_0}\right)\frac{h}{e B L},.$$</p>
<blockquote>
<p>We see from this that the Landau level wave-functions are centered around a discrete set of rings at $y_0(n)$ on the cylinder axis that are labelled by the integer $n$.  As $\Phi$ is increased we see that the centers $y_0$ move so that after one flux quantum $\Delta\Phi=\Phi_0=h/e$ all the electrons have moved down by one step along $y$, i.e. $n \rightarrow n-1$. If $n$ Landau levels are filled then a total charge of $\Delta Q=n e$ will be transferred between the edges, in exact accordance with the Laughlin argument.</p>
</blockquote>
<p>We can now look again at the Laughlin pump, monitoring at the same time the Landau levels. You can see that the total pumped charge jumps in integer steps each time a Landau level passes through the Fermi level.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">1.1</span>, <span class="number">1.1</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="keyword">lambda</span> p: <span class="string">&quot;Landau levels&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">W = <span class="number">20</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, B=<span class="number">2</span> * np.pi / (W + <span class="number">1</span>), phi=<span class="literal">None</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = qhe_corbino(r_out=<span class="number">2</span> * W, r_in=<span class="number">20</span>, w_lead=<span class="number">10</span>)</span><br><span class="line">sys1 = qhe_ribbon(W, <span class="literal">True</span>)</span><br><span class="line">HLine = holoviews.HLine(<span class="number">0</span>).opts(style=&#123;<span class="string">&quot;linestyle&quot;</span>: <span class="string">&quot;--&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;)</span><br><span class="line">mus = np.linspace(<span class="number">0.4</span>, <span class="number">1.4</span>, <span class="number">11</span>)</span><br><span class="line">hm1 = holoviews.HoloMap(&#123;p.mu: plot_pumping(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br><span class="line">hm2 = holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: spectrum(sys1, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>]</span><br><span class="line">)</span><br><span class="line">hm1 + hm2 * HLine</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider a cylinder of height $W$, circumference $L$, subject to a magnetic field $B$, &quot;</span></span><br><span class="line">    <span class="string">&quot;and with 2 Landau levels filled. &quot;</span></span><br><span class="line">    <span class="string">&quot;Approximately, how many electrons does it contain?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [<span class="string">&quot;$2.\,$&quot;</span>, <span class="string">&quot;$2 W/L\,.$&quot;</span>, <span class="string">&quot;$2 B WL / \Phi_0\, $.&quot;</span>, <span class="string">&quot;$ B L^2/\Phi_0\,$.&quot;</span>]</span><br><span class="line">explanation = <span class="string">&quot;Based on the form of the Hamiltonian, $y$ goes from $0$ to $W$ and therefore $n$ goes from 0 to $B W L/\Phi_0$.&quot;</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;2u8_2isyi7o&quot;</span>, src_location=<span class="string">&quot;3.2-summary&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Laughlin argument&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w2_majorana/w2_assignments"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w2_majorana/w2_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.827Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulation-tweaking-the-nanowire"><a href="#Simulation-tweaking-the-nanowire" class="headerlink" title="Simulation: tweaking the nanowire"></a>Simulation: tweaking the nanowire</h1><p>We have two choices for your coding assignments of this week. Consider the task complete when you finish one of the two.</p>
<p>This is especially true since both of the assignments constitute a complete paper :)</p>
<p>As usual, start by grabbing the notebooks of this week (<code>w2_majorana</code>). They are once again over <a target="_blank" rel="noopener" href="http://tiny.cc/topocm_smc">here</a>.</p>
<h2 id="Tilted-magnetic-field"><a href="#Tilted-magnetic-field" class="headerlink" title="Tilted magnetic field"></a>Tilted magnetic field</h2><p>Explore what happens when we change one the important knobs of the nanowire model, the external magnetic field. We studied what happens when $B$ is pointing along the $z$ direction. However, what happens when the magnetic field is tilted?</p>
<p>Generalize the Hamiltonian of the nanowire to the case of a magnetic field with three components $B_x, B_y, B_z$. How do the new terms look like?</p>
<p>Go into the <code>nanowire</code> notebook. Modify the <code>nanowire_chain</code> function to include the magnetic field pointing in general direction.<br>Plot the band structure for different field directions, and compare to the original case of having only $B_z$. What changes?</p>
<p>Compare your results with what you find over here:</p>
<ul>
<li>arXiv:1403.4464</li>
</ul>
<h2 id="From-4-pi-to-2-pi"><a href="#From-4-pi-to-2-pi" class="headerlink" title="From $4\pi$ to $2\pi$."></a>From $4\pi$ to $2\pi$.</h2><p>Now let’s switch to the signatures of Majoranas. The code for these is in the <code>signatures</code> notebook.</p>
<p>How does the $4\pi$-periodic Josephson effect disapper? We argued that we cannot just remove a single crossing. Also periodicity isn’t a continuous variable and cannot just change. So what is happening?</p>
<p>Study the spectrum of a superconducting ring as a function of magnetic field, as you make a transition between the trivial and the topological regimes.</p>
<p>What do you see? Compare your results with the paper below.</p>
<ul>
<li>arXiv:1210.3237</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Majorana nanowire&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><p>As we mentioned, there are really hundreds of papers that use the models and concepts that we used in the lecture.</p>
<p>Here is a small selection of the ones that you may find interesting.</p>
<h3 id="arXiv-1204-2792’"><a href="#arXiv-1204-2792’" class="headerlink" title="arXiv:1204.2792’,"></a>arXiv:1204.2792’,</h3><p><strong>Hint:</strong> Welcome to the real world.</p>
<h3 id="arXiv-1101-5795’"><a href="#arXiv-1101-5795’" class="headerlink" title="arXiv:1101.5795’,"></a>arXiv:1101.5795’,</h3><p><strong>Hint:</strong> Majorana conductance with many modes.</p>
<h3 id="arXiv-1006-4395’"><a href="#arXiv-1006-4395’" class="headerlink" title="arXiv:1006.4395’,"></a>arXiv:1006.4395’,</h3><p><strong>Hint:</strong> To play a nice melody, you just need a keyboard.<br>This paper first showed how Majoranas in wire networks can be moved around</p>
<h3 id="arXiv-1008-0629"><a href="#arXiv-1008-0629" class="headerlink" title="arXiv:1008.0629"></a>arXiv:1008.0629</h3><p><strong>Hint:</strong> Real nanowires are more complicated.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Majoranas&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w2_majorana/signatures"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w2_majorana/signatures/" class="article-date">
  <time datetime="2021-01-07T09:11:06.826Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line">dims = SimpleNamespace(</span><br><span class="line">    G=holoviews.Dimension(<span class="string">r&quot;$G/G_0$&quot;</span>),</span><br><span class="line">    V_bias=holoviews.Dimension(<span class="string">&quot;$V_&#123;bias&#125;$&quot;</span>),</span><br><span class="line">    phi=holoviews.Dimension(<span class="string">r&quot;$\Phi/\Phi_0$&quot;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_system_spectroscopy</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># We apply a magnetic field in all parts of the system</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_sc</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (<span class="number">2</span> * p.t - p.mu_sc) * pauli.s0sz + p.Ez * pauli.sxs0 + p.delta * pauli.s0sx</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_normal</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu_l) * pauli.s0sz + p.Ez * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_barrier</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu_l + p.Vbarrier) * pauli.s0sz + p.Ez * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The hopping is the same in all subsystems. There is normal hopping and</span></span><br><span class="line">    <span class="comment"># spin orbit interaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.s0sz + <span class="number">1j</span> * p.alpha * pauli.sysz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.chain(norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The first subsystem just consists of the tunnel barrier (one site with a</span></span><br><span class="line">    <span class="comment"># potential)</span></span><br><span class="line">    syst[lat(<span class="number">0</span>)] = onsite_barrier</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The second subsystem is a normal lead</span></span><br><span class="line">    <span class="comment"># The translational symmetry makes it semi-infinite.</span></span><br><span class="line">    lead1 = kwant.Builder(</span><br><span class="line">        kwant.TranslationalSymmetry(*lat.prim_vecs), conservation_law=-pauli.s0sz</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># Define a unit cell (in this case the unit cell consists of a single site)</span></span><br><span class="line">    lead1[lat(<span class="number">0</span>)] = onsite_normal</span><br><span class="line">    <span class="comment"># Define the hopping between unitcells</span></span><br><span class="line">    lead1[lat(<span class="number">1</span>), lat(<span class="number">0</span>)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The third subsystem is a superconducting lead. A Majorana bound state</span></span><br><span class="line">    <span class="comment"># can arise at the edge of this system.</span></span><br><span class="line">    lead2 = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">    <span class="comment"># Again: Define a unit cell</span></span><br><span class="line">    lead2[lat(<span class="number">0</span>)] = onsite_sc</span><br><span class="line">    <span class="comment"># Again define hopping between unit cells</span></span><br><span class="line">    lead2[lat(<span class="number">1</span>), lat(<span class="number">0</span>)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a connection between the first subsystem (the tunnel barrier, system name: syst)</span></span><br><span class="line">    <span class="comment"># and the other two subsystems (the normal and the superconducting lead)</span></span><br><span class="line">    syst.attach_lead(lead1)</span><br><span class="line">    syst.attach_lead(lead2)</span><br><span class="line"></span><br><span class="line">    syst = syst.finalized()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_chain</span>(<span class="params">L=<span class="literal">None</span>, periodic=<span class="literal">False</span></span>):</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        L = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">onsite, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu) * pauli.szs0 + p.B * pauli.s0sz + p.delta * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        syst[lat(x)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 - <span class="number">0.5j</span> * p.alpha * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_with_flux</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        phase = np.exp(<span class="number">1j</span> * p.flux / <span class="number">2</span>)</span><br><span class="line">        phase_factors = np.kron(np.diag([phase, phase.conj()]), pauli.s0)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.7</span> * phase_factors @ hop(site1, site1, p)</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line">        syst[lat(<span class="number">0</span>), lat(L - <span class="number">1</span>)] = hopping_with_flux</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tunnel_spectroscopy</span>(<span class="params">syst, p, Es</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Andreev_cond</span>(<span class="params">E</span>):</span></span><br><span class="line">        sm = kwant.smatrix(syst, energy=E, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">        <span class="comment"># (i, j) means we call for block j of lead i in the scattering matrix.</span></span><br><span class="line">        <span class="comment"># The normal lead is i = 0 here, where block j = 0 corresponds to electrons</span></span><br><span class="line">        <span class="comment"># and block j = 1 holes.</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            sm.submatrix((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>)).shape[<span class="number">0</span>]</span><br><span class="line">            - sm.transmission((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            + sm.transmission((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    Gs = [Andreev_cond(E) <span class="keyword">for</span> E <span class="keyword">in</span> Es]</span><br><span class="line">    <span class="keyword">return</span> np.array(Gs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_spectroscopy</span>(<span class="params">Vbarrier</span>):</span></span><br><span class="line">    syst = make_system_spectroscopy()</span><br><span class="line">    Es = np.linspace(-<span class="number">0.15</span>, <span class="number">0.15</span>, <span class="number">101</span>)</span><br><span class="line">    p = SimpleNamespace(</span><br><span class="line">        t=<span class="number">1</span>, mu_l=<span class="number">0.5</span>, mu_sc=<span class="number">0</span>, alpha=<span class="number">0.15</span>, delta=<span class="number">0.1</span>, Vbarrier=Vbarrier</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Trivial, because the magnetic field is zero (third argument)</span></span><br><span class="line">    p.Ez = <span class="number">0</span></span><br><span class="line">    Gs_trivial = tunnel_spectroscopy(syst, p, Es)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Non-trivial</span></span><br><span class="line">    p.Ez = <span class="number">0.25</span></span><br><span class="line">    Gs_topological = tunnel_spectroscopy(syst, p, Es)</span><br><span class="line">    kdims = [dims.V_bias, dims.G]</span><br><span class="line">    plot = holoviews.Path((Es, Gs_trivial), kdims=kdims, label=<span class="string">&quot;trivial&quot;</span>).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    plot *= holoviews.Path((Es, Gs_topological), kdims=kdims, label=<span class="string">&quot;topological&quot;</span>).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    style_overlay = &#123;</span><br><span class="line">        <span class="string">&quot;xticks&quot;</span>: [-<span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.1</span>],</span><br><span class="line">        <span class="string">&quot;yticks&quot;</span>: [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>],</span><br><span class="line">        <span class="string">&quot;show_legend&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;legend_position&quot;</span>: <span class="string">&quot;top&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fig_size&quot;</span>: <span class="number">150</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    style_path = &#123;<span class="string">&quot;show_legend&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=&#123;<span class="string">&quot;Overlay&quot;</span>: style_overlay, <span class="string">&quot;Path&quot;</span>: style_path&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_spectrum</span>(<span class="params">trivial=<span class="literal">False</span></span>):</span></span><br><span class="line">    B = <span class="number">0.2</span> <span class="keyword">if</span> trivial <span class="keyword">else</span> <span class="number">1.0</span></span><br><span class="line">    p = SimpleNamespace(mu=<span class="number">0.4</span>, t=<span class="number">1.0</span>, alpha=<span class="number">0.2</span>, delta=<span class="number">0.1</span>, B=B)</span><br><span class="line">    syst = nanowire_chain(L=<span class="number">100</span>, periodic=<span class="literal">True</span>).finalized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">energy</span>(<span class="params">flux</span>):</span></span><br><span class="line">        p.flux = flux</span><br><span class="line">        H = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">        <span class="keyword">return</span> np.linalg.eigvalsh(H)</span><br><span class="line"></span><br><span class="line">    fluxes = np.linspace(<span class="number">0</span>, <span class="number">4</span> * np.pi, <span class="number">51</span>)</span><br><span class="line">    spectrum = np.array([energy(flux) <span class="keyword">for</span> flux <span class="keyword">in</span> fluxes])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the two subgap states.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trivial:</span><br><span class="line">        N = spectrum.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line">        non_trivial = np.where((fluxes &gt; np.pi) &amp; (fluxes &lt; <span class="number">3</span> * np.pi))</span><br><span class="line">        spectrum[non_trivial, N - <span class="number">1</span> : N + <span class="number">1</span>] = spectrum[</span><br><span class="line">            non_trivial, N : N - <span class="number">2</span> : -<span class="number">1</span></span><br><span class="line">        ].copy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fluxes, spectrum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_spectrum_nanowire</span>(<span class="params">fluxes, spectrum, ylim=[-<span class="number">0.2</span>, <span class="number">0.2</span>]</span>):</span></span><br><span class="line">    N = spectrum.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line">    kdims = [dims.phi, <span class="string">&quot;$E$&quot;</span>]</span><br><span class="line">    plot = holoviews.Path((fluxes, spectrum), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>, <span class="string">&quot;alpha&quot;</span>: <span class="number">0.4</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    plot *= holoviews.Path((fluxes, spectrum[:, N - <span class="number">1</span>]), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    plot *= holoviews.Path((fluxes, spectrum[:, N]), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (<span class="number">2</span> * np.pi, <span class="string">&quot;1&quot;</span>), (<span class="number">4</span> * np.pi, <span class="string">&quot;2&quot;</span>)]&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;<span class="string">&quot;$E$&quot;</span>: (-<span class="number">0.11</span>, <span class="number">0.11</span>)&#125;).opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_gse_sc_nanowire</span>(<span class="params">fluxes, spectrum</span>):</span></span><br><span class="line">    N = spectrum.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line">    energy_gs = np.<span class="built_in">sum</span>(spectrum[:, :N], axis=<span class="number">1</span>)</span><br><span class="line">    energy_gs -= np.<span class="built_in">max</span>(energy_gs)</span><br><span class="line">    current = np.diff(energy_gs) * <span class="built_in">len</span>(energy_gs)</span><br><span class="line"></span><br><span class="line">    xdim = dims.phi</span><br><span class="line">    ydim = <span class="string">r&quot;$E_&#123;tot&#125;(\Phi)$&quot;</span></span><br><span class="line"></span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (<span class="number">2</span> * np.pi, <span class="string">&quot;1&quot;</span>), (<span class="number">4</span> * np.pi, <span class="string">&quot;2&quot;</span>)]&#125;</span><br><span class="line">    plot = holoviews.Path((fluxes, energy_gs), kdims=[xdim, ydim], label=<span class="string">&quot;Energy&quot;</span>).opts(</span><br><span class="line">        plot=ticks</span><br><span class="line">    )</span><br><span class="line">    ydim = <span class="string">r&quot;$I(\Phi)$&quot;</span></span><br><span class="line">    plot += holoviews.Path(</span><br><span class="line">        ((fluxes[<span class="number">1</span>:] + fluxes[:-<span class="number">1</span>]) / <span class="number">2</span>, current), kdims=[xdim, ydim], label=<span class="string">&quot;Current&quot;</span></span><br><span class="line">    ).opts(plot=ticks)</span><br><span class="line">    <span class="keyword">return</span> plot</span><br></pre></td></tr></table></figure>

<h1 id="How-to-detect-Majoranas"><a href="#How-to-detect-Majoranas" class="headerlink" title="How to detect Majoranas"></a>How to detect Majoranas</h1><p>Our second guest lecturer for this week is Carlo Beenakker, from Leiden University.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;WAhNblNbadA&quot;</span>, src_location=<span class="string">&quot;2.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Andreev-reflection"><a href="#Andreev-reflection" class="headerlink" title="Andreev reflection"></a>Andreev reflection</h1><p>To understand how conductance through a Majorana works, we first have to learn how charge is transferred from a metallic lead to a superconductor. In general this transfer takes place via a mechanism known as Andreev reflection. Before we discuss the conductance signatures of a Majorana zero mode, it is useful to learn what Andreev reflection is.</p>
<p>Let’s consider the following very simple circuit with two electrodes:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/ns_interface.svg" alt></p>
<p>One electrode is a normal metal, the other a superconductor, and they are kept at a voltage difference $V$. At the interface between the normal metal and the superconductor (in short, NS interface) there is a barrier. We are particularly interested in the case when the voltage difference is very small compared to the energy gap in the superconductor, $eV &lt; \Delta$, where $e$ is the charge of the electron.</p>
<p>What happens when electrons arrive at the interface with superconductor? The superconductor has no states available up to an energy $\Delta$ around the Fermi level, and the voltage is not enough to provide for this energy difference. How can a current develop?</p>
<p>To understand this, let’s look more closely at an electron arriving at the interface with the superconductor. There are two possible processes that can take place, <em>normal reflection</em> and <em>Andreev reflection</em>. In normal reflection, the electron is simply reflected at the interface with the superconductor:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/normal_reflection.svg" alt></p>
<p>With normal reflection, there is no net charge transfer from the left electrode to the right electrode. Hence this process does not contribute any net current. Normal reflection obviously doesn’t even require a superconductor and would take place also if the right electrode was normal.</p>
<p>Andreev reflection, instead, is unique to the NS interface. In Andreev reflection, an electron is converted to a hole by the superconductor, and a Cooper pair is created in the superconductor.</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/andreev_reflection.svg" alt></p>
<p>You can see that a net charge of $2e$ is transferred from the left to the right electrode, and at low voltages Andreev reflection is the only process responsible for the electrical current.</p>
<p>Above the superconducting gap, $eV &gt; \Delta$ transmission of an incident electron into the superconductor also contributes to the current.</p>
<p>You can also think of Andreev <em>reflection</em> as a <em>transmission</em> problem. Because of the presence of the superconductor, both electrons and holes participate in the transfer of charge in the normal metal lead. Conceptually, you can imagine to separate the left lead into two leads, one only carrying electrons and one only carrying holes. These two leads are connected by the superconductor, which converts incoming electrons in the first lead into outgoing holes in the second lead, and viceversa:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/andreev_as_transmission.svg" alt></p>
<p>With this picture, you can understand that Andreev reflection is very similar to the problem of transmission through a double barrier.</p>
<p>Let’s call $r_{eh}$ the amplitude for Andreev reflection. Its absolute value squared, $\left|r_{eh}\right|^2$, is the probability that an incoming electron from the normal metal is Andreev reflected as a hole. Once we know $r_{eh}$, we can compute the conductance $G(V)$, which relates the current $I$ that develops as a response to a small voltage $V$, $G(V) = dI/dV$. The conductance is given by the following formula:</p>
<p>$$G(V)=2G_0|r_{eh}|^2.$$</p>
<p>We will not derive this equation, since it can be understood intuitively. The conductance is proportional to the probability $|r_{eh}|^2$ of Andreev reflection, since we know that at low voltages this is the only process that transfers electric charge from the left to the right electrode.</p>
<p>The factor of $2$ is due to each Andreev reflection transferring a charge of a Cooper pair, $2e$. Finally, $G_0=e^2/h$ is the <strong>conductance quantum</strong>, the fundamental proportionality constant which relates currents to voltages.</p>
<h1 id="Andreev-reflection-off-a-Majorana-zero-mode"><a href="#Andreev-reflection-off-a-Majorana-zero-mode" class="headerlink" title="Andreev reflection off a Majorana zero mode"></a>Andreev reflection off a Majorana zero mode</h1><p>Now that we understand a conventional NS interface, let’s see what happens if our superconductor is topological:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/ns_majorana_interface.svg" alt></p>
<p>You can imagine that the superconducting electrode is now a nanowire in the topological phase, like the one you have just studied. Because the superconductor is topological, there is a Majorana mode at the NS interface, whose wave function will “leak” a bit into the normal metal, through the barrier. Of course, there will be also a second Majorana mode, but we place it far enough from the NS interface, so that it does not have a role in the transport. Does the Majorana zero mode at the interface change the Andreev reflection properties?</p>
<p>Yes, and in a rather drastic way. Going back to the picture of Andreev reflection as a transmission process through a double barrier, the crucial difference is that the Majorana mode now appears as a bound state between the two barriers:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/resonant_transmission_through_majorana.svg" alt></p>
<p>In the double barrier problem in quantum mechanics, you can have <strong>resonant</strong> transmission in the presence of a bound state. This means that the probability $\left|r_{eh}\right|^2$ to pass through the barriers is dramatically enhanced if the energy of the incident electron matches the energy of the bound state. In our case, the energy of the incident electron is $V$, and the energy of the bound state, the Majorana mode, is zero. So the presence of the Majorana mode leads to a <strong>resonant peak</strong> in the conductance of the NS interface at $V=0$.</p>
<h1 id="Quantization-of-the-Majorana-resonance"><a href="#Quantization-of-the-Majorana-resonance" class="headerlink" title="Quantization of the Majorana resonance"></a>Quantization of the Majorana resonance</h1><p>Seeing the resonant peak is the most direct way we know to measure the presence of a Majorana zero mode.</p>
<p>However, the presence of a resonance associated with Majorana modes is not uniquely topological, because tunneling into any low energy bound state produces resonance.</p>
<p>Is there anything in particular which distinguishes the Majorana resonance from any other resonance?</p>
<p>Let’s just look at what happens if we compare conductance of an NS interface in the cases when S is trivial and non-trivial, and see how the conductance changes as we alter the tunnel barrier strength.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;V: plot_spectroscopy(V) <span class="keyword">for</span> V <span class="keyword">in</span> np.arange(<span class="number">1</span>, <span class="number">4.25</span>, <span class="number">0.25</span>)&#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$V_&#123;barrier&#125;$&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>We see a very robust and persistent characteristic:<br>the peak height of the Majorana resonance is quantized to the value of $2G_0$, independent of the strength of the voltage barrier. From the formula above, this means that if a Majorana is present we have $\left|r_{eh}\right|^2=1$, that is we have <strong>perfect Andreev reflection</strong>.</p>
<p>To understand why it is robust, we need to go beyond drawing cartoon figures.</p>
<h2 id="Reflection-matrix-of-a-normal-metal-superconductor-interface"><a href="#Reflection-matrix-of-a-normal-metal-superconductor-interface" class="headerlink" title="Reflection matrix of a normal metal-superconductor interface"></a>Reflection matrix of a normal metal-superconductor interface</h2><p>Quantum-mechanically, we can describe transport through the NS interface as a scattering problem. An incoming wave function $\Psi_\textrm{in}$ propagates in the left electrode, until it is reflected back at the interface with the superconductor, turning into an outgoing wave function $\Psi_\textrm{out}$. Because of the presence of the superconductor, both the incoming and outgoing states can be electrons $\Psi_e$ or holes $\Psi_h$. At <strong>zero energy</strong>, they are related to each other by particle-hole symmetry:</p>
<p>$$\Psi_e(E) = \mathcal{P},\Psi_h(-E),$$</p>
<p>The reflection enforces a linear relation between incoming and ingoing waves:</p>
<p>$$\Psi_\textrm{out} = r(V) ,\Psi_\textrm{in},$$</p>
<p>$$r(V)=\left(\begin{array}{cc}r_{ee}&amp;r_{eh}\r_{he}&amp;r_{hh}\end{array}\right).$$</p>
<p>The matrix $r$ is known as the <strong>reflection matrix</strong>. Its complex elements are the amplitudes of normal and Andreev reflection of an incoming electron - $r_{ee}$ and $r_{eh}$ - and normal and Andreev reflection of an incoming hole - $r_{hh}$ and $r_{he}$. (For brevity we don’t write out explicitly that each of those depends on $V$.)</p>
<p>If there is more than one incoming electron state (in our case there are two due to spin), all 4 elements of $r$ become matrices themselves. They then describe scattering between all the possible incoming and outgoing states.</p>
<p>Because for $eV\ll \Delta$ there are no propagating waves in the superconductor, the reflection process which relates $\Psi_\textrm{out}$ and $\Psi_\textrm{in}$ is unitary, $r^\dagger r=1$. This implies that</p>
<p>$$\left|r_{ee}\right|^2+\left|r_{eh}\right|^2 = \left|r_{he}\right|^2+\left|r_{hh}\right|^2 = 1,.$$</p>
<p>This is the mathematical way of saying that an electron (or hole) arriving at the interface has no alternatives other than being normal-reflected or Andreev-reflected.</p>
<p>Can we add any other constraint to $r$, that might help to distinguish any characteristic of the Majorana mode? Just like we did last week, let’s try to study $r$ using symmetry and topology. Our circuit involves a superconductor, so we must have particle-hole symmetry in the problem.</p>
<p>In order to derive $r$ explicitly we could start directly from the Bogoliubov-de Gennes Hamiltonian of the NS system, and solve it for an energy $V$. This is a lot of work, which we won’t do, but knowing this fact we can understand the consequences of particle-hole symmetry for $r$.</p>
<p>First, particle-hole symmetry exchanges electrons and hole components of the wave function, so it involves a Pauli matrix $\tau_x$ acting on $\Psi_\textrm{in}$ or $\Psi_\textrm{out}$. Second, it is an anti-unitary symmetry, so it involves complex conjugation. Third, it changes the sign of the energy so it sends $V$ into $-V$. Hence we arrive at the following symmetry for the reflection matrix:</p>
<p>$$\tau_x r^*(-V) \tau_x = r(V),.$$</p>
<p>Together with unitarity, particle-hole symmetry imposes that the conductance is symmetric around zero voltage, $G(V)=G(-V)$. In the most interesting point, $V=0$ we have:</p>
<p>$$ \tau_x r^*_0 \tau_x = r_0 ,.$$</p>
<p>where we defined $r_0\equiv r(V=0)$. So much for the impact of symmetry on $r$. What about topology?</p>
<h1 id="Topological-invariant-of-the-reflection-matrix"><a href="#Topological-invariant-of-the-reflection-matrix" class="headerlink" title="Topological invariant of the reflection matrix"></a>Topological invariant of the reflection matrix</h1><p>The Majorana zero mode is the consequence of a topological phase in the topological superconductor, and its presence is dictated by the bulk-boundary correspondence. Can we find any consequence of this fact in $r_0$? It turns out that reflection matrices $r$ with particle-hole symmetry are also topological in their own way. Their topological invariant is </p>
<p>$$Q = \det,r_0,.$$</p>
<p>Again, we will not <em>derive</em> this equation, but rather convince ourselves this expression is correct.</p>
<p>First of all, the determinant of a unitary matrix such as $r_0$ is always a complex number with unit norm, so $\left|\det,r_0,\right|=1$. Second, because of particle-hole symmetry, the determinant is real: $\det r_0 = \det, (\tau_x r^<em>_0,\tau_x) = \det,r_0^*,=(\det,r_0)^</em>$. Hence, $\det,r_0,= \pm 1$. This is quite promising! Two possible discrete values, just like the Pfaffian invariant of the Kitaev chain.</p>
<p>Because it is just dictated by unitarity and particle-hole symmetry, the determinant of $r_0$ cannot change from $+1$ to $-1$ under a change of the properties of the NS interface. For instance, you can vary the height of the potential barrier at the interface, but this cannot affect the determinant of $r_0$.</p>
<p>The only way to make the determinant change sign is to close the bulk gap in the superconducting electrode. If the gap goes to zero, then it is not true that an incoming electron coming from the normal metal can only be normal-reflected or Andreev-reflected. It can also just enter the superconducting electrode as an electron. Hence the reflection matrix no longer contains all the possible processes taking place at the interface, and it won’t be unitary anymore. This allows the determinant to change sign. We conclude that $Q=\det,r$ is a good topological invariant.</p>
<p>Explicitly, we have that</p>
<p>$$Q=|r_{ee}|^2-|r_{eh}|^2\equiv\pm 1,.$$</p>
<p>We already saw that unitarity requires that $|r_{ee}|^2+|r_{eh}|^2=1$. There are only two possibilities for both conditions to be true: either $|r_{ee}|=1$ (<strong>perfect  normal reflection</strong>) or $|r_{eh}|=1$ (<strong>perfect Andreev reflection</strong>). The situation cannot change without a phase transition. Thus the quantized conductance of the Majorana mode is topologically robust in this case, and in fact survives past the tunneling limit. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Imagine we replace the superconducting electrode with an insulating material, &quot;</span></span><br><span class="line">    <span class="string">&quot;and imagine that at the interface with the normal metal there is a bound state. &quot;</span></span><br><span class="line">    <span class="string">&quot;How is the current through the interface different with respect &quot;</span></span><br><span class="line">    <span class="string">&quot;to that through an NS interface with a Majorana?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;It is not quantized but still non-zero.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is zero because there cannot be Andreev reflection without a superconductor.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is not symmetric in voltage but it is still non-zero.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It has a resonance peak whose width is independent of the barrier strength.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;A current requires an exit path for the charge. &quot;</span></span><br><span class="line">    <span class="string">&quot;No current can flow through the insulator, since there are no excitations at the Fermi level in an insulator. &quot;</span></span><br><span class="line">    <span class="string">&quot;A superconductor is also gapped with respect to excitations, but is different than a normal insulator. &quot;</span></span><br><span class="line">    <span class="string">&quot;It has a condensate of Cooper pairs, so a current can develop thanks to Andreev reflection at the interface.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Flux-induced-fermion-parity-switch-in-topological-superconductors"><a href="#Flux-induced-fermion-parity-switch-in-topological-superconductors" class="headerlink" title="Flux-induced fermion parity switch in topological superconductors"></a>Flux-induced fermion parity switch in topological superconductors</h1><p>How do we probe the Pfaffian topological invariant of a topological superconductor directly? Last week, we introduced a thought-experiment where we probed the bulk-edge correspondence of Majorana modes by changing the sign of the hopping across a bond. The non-trivial value of the topological invariant results in a fermion parity switch as a result of the change in sign of the hopping $t$ across the junction i.e. </p>
<p>$$t\rightarrow -t.$$</p>
<p>It turns out that the sign change in the hopping across the junction might also be obtained by introducing a magnetic flux through the superconducting ring (similar to the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Aharonov-Bohm_effect">Aharonov-Bohm effect</a>). The role of the special bond is now played by a Josephson junction, which is just an insulating barrier interrupting the ring, as in the following sketch:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/josephson_majorana_ring.svg" alt></p>
<p>How does the magnetic flux enter the Hamiltonian? By following the usual argument for introducing magnetic fields into lattice Hamiltonians using <a target="_blank" rel="noopener" href="http://topocondmat.org/w2_majorana/Peierls.html">Peierls substitution</a>, the flux $\Phi$ can be accounted for simply by changing the phase of the hopping across the junction in the ring:</p>
<p>$$t,\to,t,\exp (i\phi/2).$$</p>
<p>Here, $\phi = 2\pi\Phi/\Phi_0$ is usually called the <strong>superconducting phase difference</strong> across the junction, and $\Phi_0=2e/h$ is the <strong>superconducting flux quantum</strong>. Notice that when $\Phi=\Phi_0$ the hopping changes sign: $t ,\to, \exp (i\pi) t = -t$, exactly as we had last week!</p>
<blockquote>
<p>Thus, the introduction of a flux quantum $\Phi=\Phi_0$, changes the sign of the hopping $t\rightarrow t e^{i\phi}=-t$, which as discussed last week changes the fermion parity of the ground state for topological superconductors. This fermion parity switch is related to a pair of Majorana modes coupled at the junction (as in the figure above).</p>
</blockquote>
<p>To see how this happens explicitly, let’s look at the spectrum of a topological superconducting ring as a function of flux,  obtained using our nanowire model:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fluxes, spectrum = nanowire_spectrum()</span><br><span class="line">plot_spectrum_nanowire(fluxes, spectrum)</span><br></pre></td></tr></table></figure>

<p>Staring at the spectrum we see that, lo and behold, the fermion parity switch appears, around $\Phi=\Phi_0/2$. Can we measure this fermion parity switch in our superconducting ring?</p>
<h1 id="Detecting-the-fermion-parity-switch-using-the-Josephson-effect"><a href="#Detecting-the-fermion-parity-switch-using-the-Josephson-effect" class="headerlink" title="Detecting the fermion parity switch using the Josephson effect"></a>Detecting the fermion parity switch using the Josephson effect</h1><p>The change in fermion parity of the ground state can be detected using the so-called <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Josephson_effect">Josephson effect</a>. The Josephson current can be computed from the expectation value of the derivative of the energy operator with respect to flux,</p>
<p>$$I(\Phi)=\frac{1}{2}\frac{d E_\textrm{tot}(\Phi)}{d \Phi},$$</p>
<p>where $E_\textrm{tot}(\Phi)=\left\langle H_{BdG}(\Phi)\right\rangle$ is the total energy of the system corresponding to the BdG Hamiltonian $H_{BdG}(\Phi)$. </p>
<blockquote>
<p>The key idea to detecting the ground state fermion parity switch is to note that changing the flux $\Phi$ adiabatically cannot change the fermion parity of the system. If you start with the system in the ground state and advance the magnetic flux from $\Phi$ to $\Phi+\Phi_0$, you end up in an excited state, because in the meantime the fermion parity has changed. To go back to the initial ground state with the same fermion parity, you need to advance $\Phi$ by $2\Phi_0$.</p>
</blockquote>
<p>Note that this argument relies on the absence of a reservoir of electrons, such as a metallic lead. In this case, when the two levels cross at zero energy and the ground state fermion parity changes, there is no electron that can enter or leave the system. </p>
<p>The fermion parity switch, together with fermion parity conservation of the ring, result in the energy $E_\textrm{tot}(\Phi)$ and the corresponding current (that can be measured) showing a $2\Phi_0$ periodicity in $\Phi$ - that is, a $4\pi$ periodicity in $\phi$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fluxes, spectrum = nanowire_spectrum()</span><br><span class="line">plot_gse_sc_nanowire(fluxes, spectrum)</span><br></pre></td></tr></table></figure>

<p>At this point you might wonder, what is so unique about the $2\Phi_0$ periodicity of the Josephson effect?</p>
<p>To answer this question, we need to review an alternative way of thinking about the Josephson effect in terms of just connecting a pair of superconductors by a junction without having to wrap the superconductor in a ring. In this case,  the hopping phase  $\phi$ (which we also referred to as the <em>superconducting phase</em>) that appeared in the tunneling term proportional to $t e^{i\phi/2}$ can be eliminated by shifting the fermion operators on one side of the junction by a phase i.e.  $c^\dagger\rightarrow c^\dagger e^{-i\phi/2}$. For superconducting systems, this transformation has the interesting effect of changing the superconducting phase on one side of the junction as </p>
<p>$$\Delta\rightarrow \Delta e^{i\phi}.$$ </p>
<p>Now you see why $\phi$ was referred to as <em>superconducting phase</em> in the first place. After this transformation (also called a gauge transformation) $\phi$ really becomes the complex phase of the superconducting term proportional to $\Delta$.</p>
<blockquote>
<p>But this also tells you one more thing - following the gauge transformation the Hamiltonian $H_{BdG}$ only depends on $\phi$ through the term $\Delta e^{i\phi}$, so one expects the energy to be $2\pi$ periodic in $\phi$. This leads to the conventional wisdom that the Josephson effect is $2\pi$-periodic (or equivalently $\Phi_0$-periodic in the case of a ring). </p>
</blockquote>
<p>As seen from the plots below, this is exactly what happens in the non-topological phase. In this case, when we look at the energy spectrum, no fermion parity switches appear:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fluxes, spectrum = nanowire_spectrum(trivial=<span class="literal">True</span>)</span><br><span class="line">plot_spectrum_nanowire(fluxes, spectrum, ylim=[-<span class="number">0.11</span>, <span class="number">0.11</span>])</span><br></pre></td></tr></table></figure>

<p>In turn, this means that energy and current are periodic with period $\Phi_0$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fluxes, spectrum = nanowire_spectrum(trivial=<span class="literal">True</span>)</span><br><span class="line">plot_gse_sc_nanowire(fluxes, spectrum)</span><br></pre></td></tr></table></figure>

<p>At this point, you might be a little worried about how the topological superconductor managed to get around this <em>conventional wisdom</em>. The answer is subtle, and relies on the implicit assumption of the ground state fermion parity of the junction being fixed as one changes $\phi$. Topological superconductors violate this assumption and therefore can create the $4\pi$ periodic (or fractional) Josephson effect. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Suppose that in your topological nanowire junction, positive energy quasiparticles can escape &quot;</span></span><br><span class="line">    <span class="string">&quot;into a reservoir very quickly, making the junction always relax to the ground state. &quot;</span></span><br><span class="line">    <span class="string">&quot;How would this affect the periodicity of the Josephson effect?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;It would make the periodicity random because of the quasiparticles jumping around randomly.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;If the system can always relax to the ground state, the current would have a period of $\Phi_0$ (hence $2\pi)$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since the Josephson effect is topologically protected, these processes have no effect on the periodicity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The period becomes $\Phi_0/2$ because it is easier for the quasiparticles to jump out at this value of the flux.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;A particle tunneling out means that the fermion parity of the ground state changes. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence the lowest between the red and black energy levels is always occupied, and both energy and current &quot;</span></span><br><span class="line">    <span class="string">&quot;turn out to have a period $\Phi_0$.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;sSacO5RpW5A&quot;</span>, src_location=<span class="string">&quot;2.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Signatures of Majorana modes&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w2_majorana/nanowire"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w2_majorana/nanowire/" class="article-date">
  <time datetime="2021-01-07T09:11:06.825Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size=<span class="number">110</span></span><br><span class="line"><span class="keyword">from</span> holoviews.core.options <span class="keyword">import</span> Cycle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_chain</span>():</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">onsite, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu) * pauli.szs0 + p.B * pauli.s0sz + p.delta * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    syst[lat(<span class="number">0</span>)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 - <span class="number">0.5j</span> * p.alpha * pauli.szsx</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spinful_kitaev_chain</span>():</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu) * pauli.szs0 + p.B * pauli.szsz</span><br><span class="line"></span><br><span class="line">    syst[lat(<span class="number">0</span>)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 - <span class="number">1j</span> * p.delta * pauli.sys0</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_gap</span>(<span class="params">syst, p, resolution=<span class="number">1e-4</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find gap in a system by doing a binary search in energy.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This tells us if there are modes at a certain energy.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(syst.modes(energy=<span class="number">0</span>, params=<span class="built_in">dict</span>(p=p))[<span class="number">0</span>].momenta):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    gap = step = <span class="built_in">min</span>(<span class="built_in">abs</span>(kwant.physics.Bands(syst, params=<span class="built_in">dict</span>(p=p))(k=<span class="number">0</span>))) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> step &gt; resolution:</span><br><span class="line">        step /= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(syst.modes(gap, params=<span class="built_in">dict</span>(p=p))[<span class="number">0</span>].momenta):</span><br><span class="line">            gap -= step</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gap += step</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spinorbit_band_gap</span>(<span class="params">syst, mu, t, delta, Bs</span>):</span></span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    alphas = [<span class="number">0.0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>]</span><br><span class="line">    p = SimpleNamespace(mu=mu, t=t, delta=delta)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gap</span>(<span class="params">syst, p, alpha, B</span>):</span></span><br><span class="line">        p.alpha = alpha</span><br><span class="line">        p.B = B</span><br><span class="line">        <span class="keyword">return</span> find_gap(syst, p)</span><br><span class="line"></span><br><span class="line">    gaps = [gap(syst, p, alpha, B) <span class="keyword">for</span> alpha <span class="keyword">in</span> alphas <span class="keyword">for</span> B <span class="keyword">in</span> Bs]</span><br><span class="line">    gaps = np.reshape(gaps, (<span class="built_in">len</span>(alphas), -<span class="number">1</span>))</span><br><span class="line">    dims = &#123;<span class="string">&quot;kdims&quot;</span>: [<span class="string">r&quot;$B$&quot;</span>], <span class="string">&quot;vdims&quot;</span>: [<span class="string">&quot;Band gap&quot;</span>]&#125;</span><br><span class="line">    B_crit = holoviews.VLine(np.sqrt(p.delta ** <span class="number">2</span> + p.mu ** <span class="number">2</span>))</span><br><span class="line">    plot = [</span><br><span class="line">        holoviews.Curve((Bs, gaps[i]), label=<span class="string">r&quot;$\alpha=&#123;&#125;$&quot;</span>.<span class="built_in">format</span>(alphas[i]), **dims)</span><br><span class="line">        * B_crit</span><br><span class="line">        <span class="keyword">for</span> i, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(alphas)</span><br><span class="line">    ]</span><br><span class="line">    title = <span class="string">r&quot;$\Delta=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(p.delta, p.mu)</span><br><span class="line">    style = &#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">0.1</span>], <span class="string">&quot;fig_size&quot;</span>: <span class="number">150</span>&#125;</span><br><span class="line">    plot = holoviews.Overlay(plot)</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=style)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        title = <span class="string">r&quot;$\alpha=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$, $B=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$&quot;</span></span><br><span class="line">        title = title.<span class="built_in">format</span>(p.alpha, p.mu, p.B, p.delta)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        title = <span class="string">r&quot;$\mu=&#123;:.2&#125;$, $B=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$&quot;</span></span><br><span class="line">        title = title.<span class="built_in">format</span>(p.mu, p.B, p.delta)</span><br><span class="line">    <span class="keyword">return</span> title</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">style = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E/t$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;xlims&quot;</span>: [-<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">1.5</span>, <span class="number">1.5</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="From-Kitaev-model-to-an-experiment"><a href="#From-Kitaev-model-to-an-experiment" class="headerlink" title="From Kitaev model to an experiment"></a>From Kitaev model to an experiment</h1><p>We have a special guest to begin this week’s lecture, Yuval Oreg from the Weizmann Institute in Rehovot.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;GQLfs4i22ms&quot;</span>, src_location=<span class="string">&quot;2.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Small-parameters"><a href="#Small-parameters" class="headerlink" title="Small parameters"></a>Small parameters</h1><p>We are now all set to make Majoranas in a real system. Or at least to invent a way to make Majoranas in a real system.</p>
<p>The way we approach this problem is by considering the Kitaev chain a ‘skeleton’, and ‘dressing’ it with real physics phenomena until it becomes real. </p>
<blockquote>
<p>Interestingly, this is not at all how the condensed matter community came to this model.<br>Instead, the path to it was from complex to simple. The whole story started from what we’ll consider in the very end of the course, fractional particles.</p>
</blockquote>
<blockquote>
<p>Then it was simplified to topological superconductors (that still do not exist in nature, as far as we know).<br>Majoranas were then predicted to exist (week 7) in a combination of a 3D topological insulator (week 6), which was then simplified to a two-dimensional topological insulator (week 5), and only after a few more simplification steps, the nanowire model was developed.</p>
</blockquote>
<p>So once again, here is our ‘skeleton’, the Kitaev model Hamiltonian written in momentum space:</p>
<p>$$H_{Kitaev} = (-2 t \cos k -\mu) \tau_z + 2 \Delta \tau_y \sin k.$$</p>
<p>The model seems OK for a start, because it has some superconducting pairing $\Delta$ and some normal dispersion given by terms proportional to $\mu$ and $t$.</p>
<p>Before we proceed further, let’s understand the relation between these parameters.</p>
<p>First of all, we want to make a controllable system, so that we can tweak its parameters. That means that we need a <strong>semiconductor</strong>. In semiconductors the electron density is very low, so that the chemical potential is near the bottom of the band. This makes it easier to define $\mu$ with respect to the bottom of the band:</p>
<p>$$\mu \rightarrow \mu - 2t.$$</p>
<p>Now the transition between trivial and non-trivial states happens when $\mu = 0$.</p>
<p>Of course semiconductors are never additionally superconducting. Luckily this is easy for us to resolve. We just paste a superconductor and semiconductor together into a hybrid structure, and let the superconductor induce superconductivity in the semiconductor. Making such a hybrid is extremely challenging from the material science point of view, but it’s definitely not our problem for now.</p>
<p>The next thing we should consider is that $\mu$ will always stay small compared to the bandwidth, so $\mu \ll 2t$. The same holds for superconducting pairing: $\Delta \ll t$. This is because superconductivity is a very weak effect compared to the kinetic energy of electrons. These two inequalities combined mean that we can expand the $\cos k$ term and only work with the continuum limit of the Kitaev model:</p>
<p>$$H = (k^2/2m - \mu) \tau_z + 2 \Delta \tau_y k.$$</p>
<p>The effective electron mass $m$ is just the coefficient of the expansion. Let’s take a look at the band structure in this regime, both in the topological regime and in the trivial regime:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syst = spinful_kitaev_chain()</span><br><span class="line">p1 = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.1</span>, mu=-<span class="number">0.3</span>, B=<span class="number">0.0</span>, alpha=<span class="number">0.0</span>)</span><br><span class="line">p2 = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.1</span>, mu=<span class="number">0.3</span>, B=<span class="number">0.0</span>, alpha=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p1, **style).relabel(<span class="string">&quot;Trivial bandstructure&quot;</span>)</span><br><span class="line">    + spectrum(syst, p2, **style).relabel(<span class="string">&quot;Topological bandstructure&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="The-need-for-spin"><a href="#The-need-for-spin" class="headerlink" title="The need for spin"></a>The need for spin</h1><p>Still, there is one obvious thing missing from the model, namely electron spin. This model works with some hypothetical spinless fermions, that do not really exist. So to make the model physical, we need to remember that every single particle has spin, and the Hamiltonian has some action in spin space, described by the Pauli matrices $\sigma$.</p>
<p>The simplest thing which we can do is to just add the spin as an extra degeneracy, that is to multiply every term in the Hamiltonian by $\sigma_0$. Obviously this doesn’t change the spectrum, and a zero energy solution stays a zero energy solution.</p>
<p>Just kidding, this would be very bad! The problem about adding spin is that the whole point of a Kitaev chain is to create <em>unpaired</em> Majorana modes. If we add an extra spin degeneracy to these Majoranas, the edge of our chain will host two Majoranas, or in other words one regular fermion fine-tuned to zero energy.</p>
<p>What’s the correct way of introducing spin then? We still need to add it. Let’s add spin such that the Kitaev chain corresponding to one spin species is topologically trivial, and the Kitaev chain corresponding to the other spin species non-trivial. We know that the chemical potential $\mu$ controls whether a Kitaev chain is topological or trivial, so if say spin up has $\mu &gt; 0$ and spin down $\mu &lt; 0$, we’re back in business.</p>
<p>We achieve this by adding Zeeman coupling of the spin to an external magnetic field:</p>
<p>$$H = (k^2/2m - \mu - B \sigma_z) \tau_z + 2 \Delta \tau_y k.$$</p>
<p>Whenever the Zeeman energy $|B|$ is larger than $\mu$ we have one Majorana fermion at the end of the chain.</p>
<p>Let’s look at what happens with the dispersion as we increase the magnetic field from zero to a value larger than $\mu$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syst = spinful_kitaev_chain()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.1</span>, mu=<span class="number">0.3</span>, B=<span class="literal">None</span>)</span><br><span class="line">Bs = np.linspace(<span class="number">0</span>, <span class="number">0.4</span>, <span class="number">10</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.B: spectrum(syst, p, **style) <span class="keyword">for</span> p.B <span class="keyword">in</span> Bs&#125;, kdims=[<span class="string">r&quot;$B$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>We now see that we resolved the first problem:</p>
<blockquote>
<p>A high enough <strong>Zeeman splitting</strong> allows to separate the different spins.<br>Then we can make one spin species trivial, while the other one is topological and hosts Majoranas.</p>
</blockquote>
<h1 id="Realistic-superconducting-pairing"><a href="#Realistic-superconducting-pairing" class="headerlink" title="Realistic superconducting pairing"></a>Realistic superconducting pairing</h1><p>The next part for us to worry about is the superconductor.</p>
<p>Something that you probably saw in the Kitaev chain Hamiltonian is that the superconducting pairing $\Delta$ has a peculiar form. It pairs electrons from <em>neighboring</em> sites, and not those from the same site. In momentum space this means that the superconducting pairing is proportional to $\Delta k$.</p>
<p>Of course, in a Kitaev chain the superconducting pairing cannot couple two electrons from the same site since there is just one particle per site!</p>
<p>Real world superconductors are different. Most of them, and specifically all the common superconductors like $Al$, $Nb$, $Pb$, $Sn$ have $s$-wave pairing. This means that the pairing has no momentum dependence, and is local in real space. The Kitaev chain pairing is proportional to the first power of momentum and so it is a $p$-wave pairing.</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/High-temperature_superconductivity">High temperature superconductors</a> like cuprates or pnictides do have a momentum-dependent pairing, but it’s yet another type ($d$-wave, or a more exotic $s\pm$-wave).</p>
<p>So if we want to invent a way to make Majoranas, we will need to use $s$-wave pairing. And then, as you should remember from the previous week, due to the fermionic statistics the pairing function should be antisymmetric. In a Kitaev chain the antisymmetry is due to the real space structure of the pairing, but in an $s$-wave superconductor, the antisymmetry of the pairing should arise due to its spin structure.</p>
<p>This leaves only one option. All the $s$-wave superconductors are spin-singlet:</p>
<p>$$H_{pair} = \Delta(c_\uparrow c_\downarrow - c_\downarrow c_\uparrow) + \text{h.c.}$$</p>
<p>This means that now we need to modify the pairing, but before that we’ll need to do one other important thing.</p>
<h3 id="Important-and-useful-basis-change"><a href="#Important-and-useful-basis-change" class="headerlink" title="Important and useful basis change."></a>Important and useful basis change.</h3><p>When you see Bogoliubov-de-Gennes Hamiltonians in the literature, you will find them written in two different bases.<br>One variant is the one which we introduced last week:</p>
<p>$$<br>H_\textrm{BdG} = \begin{pmatrix} H &amp; \Delta \ -\Delta^* &amp; -H^* \end{pmatrix}.<br>$$</p>
<p>It has the particle-hole symmetry $H_\textrm{BdG} = - \tau_x H^*_\textrm{BdG} \tau_x$. In this basis, the $s$-wave pairing is proportional to $\sigma_y$.</p>
<p>However for systems with complicated spin and orbital structure, there is a different basis which makes the bookkeeping much easier.</p>
<p>If we have a time-reversal symmetry operator $\mathcal{T} = U \mathcal{K}$, we can apply the unitary transformation $U$ to the holes, so that in the new basis we get the Bogoliubov-de-Gennes Hamiltonian</p>
<p>$$<br>H_\textrm{BdG} = \begin{pmatrix} H &amp; \Delta’ \ \Delta’^\dagger &amp; -\mathcal{T} H \mathcal{T}^{-1}\end{pmatrix},<br>$$</p>
<p>with $\Delta’ = \Delta U^\dagger$.</p>
<p>Why is this basis useful?</p>
<ul>
<li>First of all, because in this new basis the $s$-wave pairing is a unit matrix regardless of the system we consider.</li>
<li>Second, because it’s easy to get the Hamiltonian of holes. We take the Hamiltonian for electrons, and change the signs of all terms that respect time-reversal symmetry, but not for those that break it, such as the term proportional to the magnetic field $B$. So if the electrons have a Hamiltonian $H(B)$, the Hamiltonian of the holes just becomes $-H(-B)$.</li>
</ul>
<p>There is one disadvantage. The particle-hole symmetry now becomes more complicated. For our system with only one orbital and spin it is $\mathcal{P} = \sigma_y \tau_y \mathcal{K}$. But, let us tell you, the advantages are worth it.</p>
<h1 id="s-wave-superconductor-with-magnetic-field"><a href="#s-wave-superconductor-with-magnetic-field" class="headerlink" title="s-wave superconductor with magnetic field"></a>s-wave superconductor with magnetic field</h1><p>Let’s look at how our chain looks once we change the superconducting coupling to be $s$-wave. The Zeeman field (or anything of magnetic origin) changes sign under time-reversal symmetry. </p>
<p>This means that the Zeeman field has the same form for electrons and for holes in the new basis, and the full Hamiltonian is now:</p>
<p>$$<br>H_\textrm{BdG} = (k^2/2m - \mu)\tau_z + B \sigma_z + \Delta \tau_x.<br>$$</p>
<p>This Hamiltonian is easy to diagonalize since every term only has either a $\tau$ matrix or a $\sigma$ matrix. At $k=0$ it has 4 levels with energies $E = \pm B \pm \sqrt{\mu^2 + \Delta^2}$.</p>
<p>We can use this expression to track the crossings. We also know that when $B=0$ the system is trivial due to spin degeneracy.<br>Together this means that we expect the system to be non-trivial (and will have a negative Pfaffian invariant) when</p>
<p>$$ B^2 &gt; \Delta^2 + \mu^2.$$</p>
<p>Are we now done? Not quite.</p>
<h3 id="Problem-with-singlets"><a href="#Problem-with-singlets" class="headerlink" title="Problem with singlets"></a>Problem with singlets</h3><p>A singlet superconductor has an important property: Since electrons are created in singlets, the total spin of every excitation is conserved. Zeeman field conserves the spin in $z$-direction, so together every single state of our system has to have a definite spin, <em>including the Majoranas</em>.</p>
<p>And that is a big problem. Majoranas are their own particle-hole partners, and that means that they cannot have any spin (energy, charge, or any other observable property at all).</p>
<p>So does this now mean that we “broke” the bulk-edge correspondence? Let’s look at the band structure (tweak the Zeeman energy):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syst = nanowire_chain()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.0</span>, delta=<span class="number">0.1</span>, alpha=<span class="number">0.0</span>, B=<span class="literal">None</span>)</span><br><span class="line">Bs = np.linspace(<span class="number">0</span>, <span class="number">0.4</span>, <span class="number">10</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.B: spectrum(syst, p, **style) <span class="keyword">for</span> p.B <span class="keyword">in</span> Bs&#125;, kdims=[<span class="string">r&quot;$B$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>Of course we didn’t break bulk-edge correspondence. Majoranas in our system would have to have a spin, which isn’t possible. That in turn means that they cannot appear, and that means that the system cannot be gapped.</p>
<p>We can also approach this differently. From all the spin Pauli matrices, only $\sigma_z$ appears in the Hamiltonian, so there’s a conservation law. The two bands that cross at zero energy in the band structure above belong to opposite spin bands, and so cannot be coupled.</p>
<p>Now we need to solve this final problem before we are done.</p>
<h1 id="How-to-open-the-gap"><a href="#How-to-open-the-gap" class="headerlink" title="How to open the gap?"></a>How to open the gap?</h1><p>The final stretch is straightforward.</p>
<p>We know that there is no gap because of conservation of one of the spin projections, so we need to break the spin conservation.</p>
<p>If we don’t want to create an inhomogeneous magnetic field, we have to use a different term that couples to spin. That term is spin-orbit interaction. In it’s <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Rashba_effect">simplest form</a> this interaction appears in our wire as</p>
<p>$$H_{SO} = \alpha \sigma_y k,$$</p>
<p>so it is like a Zeeman field pointing in $y$-direction with a strength proportional to the particle momentum. Note that this term is invariant under time reversal symmetry (both $\sigma_y$ and $k$ change sign). So now we have our final Hamiltonian:</p>
<p>$$<br>H_\textrm{wire} = (k^2/2m + \alpha \sigma_y k - \mu)\tau_z + B \sigma_z + \Delta \tau_x.<br>$$</p>
<p>At $k = 0$, spin-orbit coupling vanishes, so it has no effect on the system being topologically trivial or non-trivial.</p>
<p>Let’s now check that it does what we want, namely open the gap at a finite momentum:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syst = nanowire_chain()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.1</span>, delta=<span class="number">0.1</span>, B=<span class="number">0.2</span>, alpha=<span class="literal">None</span>)</span><br><span class="line">alphas = np.linspace(<span class="number">0</span>, <span class="number">0.4</span>, <span class="number">10</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.alpha: spectrum(syst, p, **style) <span class="keyword">for</span> p.alpha <span class="keyword">in</span> alphas&#125;, kdims=[<span class="string">r&quot;$\alpha$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Yep, it does :)</p>
<p>An important remark: You might now think that since spin-orbit interaction depends on spin, it makes the magnetic field unnecessary. This is not true: Since spin-orbit interaction preserves time-reversal symmetry, in the absence of a magnetic field the energy spectrum of the model would have a <em>Kramers degeneracy</em>, as you learned last week. To get one unpaired Majorana mode per edge and not two, we need to break Kramers degeneracy and therefore break time-reversal symmetry. So the combination of both Zeeman field and spin-orbit coupling is needed.</p>
<h1 id="Putting-everything-together"><a href="#Putting-everything-together" class="headerlink" title="Putting everything together"></a>Putting everything together</h1><p>Let’s now rest for a moment and reflect on what we have done.</p>
<p>We started from a toy model, which has a very special feature. Then one by one we fixed the parts of the model that we found unrealistic and ended up with a new system. It still has a relatively simple Hamiltonian, but already gives hope of being realizable in a lab.</p>
<p>Now try to guess: how many papers were written studying this exact model? The exact number is hard to obtain, but the count is in the hundreds!</p>
<p>Despite the model being very simple and the fact that it can be written in one line, it has four independent parameters already in our simplest formulation. Let’s enumerate the parameters once again:</p>
<ul>
<li>The chemical potential $\mu$, which sets the overall electron density in the wire.</li>
<li>The induced superconducting gap $\Delta$, which is required to make particle-hole symmetry play a role.</li>
<li>The spin-orbit coupling $\alpha$, which breaks spin conservation.</li>
<li>The Zeeman field $B$, which breaks Kramers degeneracy.</li>
</ul>
<p>We need to control every single parameter out of these 4 to create Majoranas (and there are even more). This is why the task of creating Majoranas is extremely challenging.</p>
<p>As a final point in our story, let’s see how the four parameters work together in determining how large the gap in our system is.</p>
<p>Obviously, this is the key parameter that we care about when creating Majoranas.<br>The smaller the gap, the worse the protection of Majoranas, and the more we need to worry about the effects of finite temperature.</p>
<p>Let’s calculate the gap as a function of all of the relevant parameters.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%%opts Curve (color=Cycle(values=[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]))</span><br><span class="line">%%opts Overlay [show_legend=<span class="literal">True</span> legend_position=<span class="string">&#x27;top&#x27;</span>]</span><br><span class="line"></span><br><span class="line">syst = nanowire_chain()</span><br><span class="line">Bs = np.linspace(<span class="number">0</span>, <span class="number">0.3</span>, <span class="number">71</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">0.05</span>, <span class="number">0.15</span>, <span class="number">5</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;mu: spinorbit_band_gap(syst, mu, <span class="number">1.0</span>, <span class="number">0.1</span>, Bs) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Here the vertical line denotes the critical value of the Zeeman field at which the wire becomes topological.</p>
<p>Let’s summarize our observations:</p>
<ul>
<li>So we see that the closer $\mu$ is to 0, the lower $B$ is required to reach the topological regime.</li>
<li>After reaching the topologically nontrivial regime, the gap slowly grows as we go away from the transition region, and after reaching its peak value, it starts dropping.</li>
<li>Finally, we see that the higher the spin-orbit coupling, the larger the optimal gap in the topological regime.</li>
</ul>
<p>We finish our investigation of this model for now with a final simple picture of the band structure of our system.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syst = nanowire_chain()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, B=<span class="number">0.07</span>, delta=<span class="number">0.025</span>, alpha=<span class="number">0.8</span>, mu=<span class="literal">None</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">0.18</span>, <span class="number">0.22</span>, <span class="number">10</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.mu: spectrum(syst, p, **style) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>When $\mu$ is very negative we see two split electron bands at positive energy corresponding to two spin orientations.</p>
<p>The lower of these two bands has a characteristic double minimum due to spin-orbit coupling.</p>
<p>As we increase $\mu$, the bands move down in energy, until they couple with the hole bands at $E=0$. This only happens due to the combination of superconductivity and spin-orbit coupling.</p>
<p>At $k=0$ the spin-orbit coupling is ineffective, so the electron and hole bands pass through each other, changing the system first from trivial to topological and then back.</p>
<p>The non-monotonous behavior of the gap versus $B$ that we saw earlier is a consequence of this complicated band structure: There are different values of momenta where the dispersion has local minima. When we are close to the phase transition, $k=0$ defines the gap, while for large $B$, it is the gap at finite momentum that becomes smallest.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;What happens if we align the magnetic field $B$ along the $y$-direction instead of the $z$-direction?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Then we do not need spin-orbit coupling anymore in order to get Majoranas.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Then the spin projection along the $y$ direction is conserved, so we can&#x27;t get Majoranas.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It&#x27;s impossible, because a magnetic field can only be applied along $z$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Then the spin-orbit term is automatically modified to point along the $z$ direction, so nothing really changes.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;If both the magnetic field and the spin orbit coupling point in the $y$ direction, &quot;</span></span><br><span class="line">    + <span class="string">&quot;then the Hamiltonian commutes with $\sigma_y$, and spin projection along $y$ is a good quantum number. &quot;</span></span><br><span class="line">    + <span class="string">&quot;So we are back to the problem that a gap at finite momentum does not open, &quot;</span></span><br><span class="line">    + <span class="string">&quot;and we do not get a topological phase supporting Majoranas.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;MsFyJBAMFLI&quot;</span>, src_location=<span class="string">&quot;2.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Majoranas in nanowires&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-src/w2_majorana/braiding"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w2_majorana/braiding/" class="article-date">
  <time datetime="2021-01-07T09:11:06.819Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Braiding-of-Majoranas"><a href="#Braiding-of-Majoranas" class="headerlink" title="Braiding of Majoranas"></a>Braiding of Majoranas</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;Ndf2Z84g1R0&quot;</span>, src_location=<span class="string">&quot;2.3-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Majorana-zero-modes-in-nanowire-networks"><a href="#Majorana-zero-modes-in-nanowire-networks" class="headerlink" title="Majorana zero modes in nanowire networks"></a>Majorana zero modes in nanowire networks</h1><p>As you just heard in the video, the goal of this lecture is to compute the quantum statistics of Majorana zero modes. In order to do this, we will have in mind a nanowire network where Majorana modes can be exchanged in space, like this one:</p>
<p><img src="/2021/01/07/src/w2_majorana/braiding/nanowire_network.svg" alt></p>
<p>In the drawing, you can see a nanowire with many T-shaped junctions in between several Majorana zero modes (which is why we call it a network). We will not worry about the microscopic description of the nanowire network, which will differ in irrelevant ways from similar structures in alternative platforms for Majoranas (we’ll learn about those later, in week 7). Just to fix the ideas, you can imagine that the system can be effectively described by the Kitaev chain toy-model, and that the Majoranas are at the positions of domain walls where the gap changes sign, as you saw in the first week of the course.</p>
<p>The only thing that distinguishes the Majorana zero modes is their position in the network. They have no other “flavour” that would allow us to characterize them. They are identical to each other, just like all electrons are identical to each other. If we exchanged two Majoranas in space, the system after the exchange would look exactly the same as it looked before the exchange.</p>
<blockquote>
<p>It is very interesting to ask what is the behaviour of the quantum state $\left|\Psi\right\rangle$ of a system of identical particles under the exchange of two of the particles. You already know that for bosons and fermions $\left|\Psi\right\rangle,\to,\pm\left|\Psi\right\rangle$. To see what happens in the case of Majoranas, we first have to learn how to write down the quantum state $\left|\Psi\right\rangle$ corresponding to a set of Majoranas like the one sketched above.</p>
</blockquote>
<h2 id="The-Hilbert-space-of-a-set-of-Majoranas"><a href="#The-Hilbert-space-of-a-set-of-Majoranas" class="headerlink" title="The Hilbert space of a set of Majoranas"></a>The Hilbert space of a set of Majoranas</h2><p>From now on, it is important to keep in mind that by considering only the states corresponding to the Majorana zero modes, we are neglecting the existence of the states that live in the bulk. As mentioned in the video, we assume that the energy spectrum looks like this:</p>
<p><img src="/2021/01/07/src/w2_majorana/braiding/gs_manifold.svg" alt></p>
<p>Based on your knowledge of the Kitaev chain, this assumption should sound reasonable to you. Because you have several Majoranas, there will be several states all at zero energy, forming a “ground state manifold”.</p>
<p>Let’s now explore more in detail the ground state manifold defined by this degenerate sets of states.</p>
<p>In the drawing you see six Majoranas, that is three pairs, but let’s consider here the more general case of $N$ pairs. It might appear that since the $\gamma_n$s don’t appear in the Hamiltonian, there is a degenerate quantum state for each of the $2N$ values of $n$. However, just as Majorana modes appear in pairs, they can be assigned quantum states only in pairs.</p>
<blockquote>
<p>To assign quantum states to Majoranas, we can pair the Majoranas and form fermionic modes,<br>$$<br>c^\dagger_n = \tfrac{1}{2}(\gamma_{2n-1}+i\gamma_{2n}),,\<br>c_n =\tfrac{1}{2}(\gamma_{2n-1}-i\gamma_{2n}),,<br>$$<br>for $n=1,\dots, N$. Using this notation, we have chosen to pair neighboring Majoranas into a fermionic mode. We have now a set of $N$ fermionic modes with corresponding creation and annihilation operators. Every mode can be empty or it can be occupied by a fermion, giving us two possible degenerate quantum states $\left|0\right\rangle$ and $\left|1\right\rangle$ for each pair of Majoranas.</p>
</blockquote>
<p>Going back to our sketch, we can represent the situation as follows:</p>
<p><img src="/2021/01/07/src/w2_majorana/braiding/majoranas_pairing.svg" alt></p>
<p>The coloring of the Majorana modes now makes explicit our choice of how to pair them into fermionic modes. In total, the system above has 8 possible states, corresponding to all the possible combinations of the occupation numbers of the 3 fermionic modes. Generalizing, we will have $2^N$ possible quantum states for $N$ pairs of Majoranas. We can represent each such state with a ket</p>
<p>$$\left| s_1, s_2, \dots, s_N\right\rangle,,$$</p>
<p>where $s_n$ is equal to $0$ if the $n$-th fermionic mode is not occupied, and equal to $1$ if it is occupied. These states are a <em>complete basis</em> for the Hilbert space of the set of Majorana modes. Note that these basis states are all eigenstates of the operators $P_n \equiv 1-2c^\dagger_n c_n \equiv i\gamma_{2n-1}\gamma_{2n}$. For instance, we have that</p>
<p>$$ P_1 \left| 0, \dots \right\rangle\ = (1-2c^\dagger_1 c_1)\left|0, \dots \right\rangle= + \left|0, \dots \right\rangle,, $$<br>$$ P_1 \left| 1, \dots \right\rangle\ = (1-2c^\dagger_1 c_1)\left|1, \dots \right\rangle= - \left|1, \dots \right\rangle,, $$</p>
<p>and so on. The operator $P_n$ is the <em>fermion parity operator</em> for the pair of Majoranas $\gamma_{2n-1}$ and $\gamma_{2n}$. At this point it is useful to remind you that different Majorana operators all anticommute with each other. This means that the product of a pair of Majorana operators commutes with the product of a different pair, for instance:</p>
<p>$$(\gamma_1\gamma_2)(\gamma_3\gamma_4) = (\gamma_3\gamma_4)(\gamma_1\gamma_2),.$$</p>
<p>However, if the two pairs share a Majorana, then they do not commute anymore, for instance:</p>
<p>$$(\gamma_1\gamma_2)(\gamma_2\gamma_3) = - (\gamma_2\gamma_3)(\gamma_1\gamma_2),.$$<br>Of course, the product above can also be simplified: since $\gamma_2^2=1$, you have that $(\gamma_1\gamma_2)(\gamma_2\gamma_3)=\gamma_1\gamma_3$.<br> All $P_n$’s commute with each other, because they all involve a different pair of Majoranas. </p>
<blockquote>
<p>Thus the  Hilbert space of states $|\Psi\rangle$ of a set of $N$ pairs of Majorana modes is spanned by the simultaneous eigenstates $|s_1,s_2,\dots,s_N\rangle$ of the commuting fermion parity operators $P_n$ and is written as $$\left|\Psi\right\rangle= \sum_{s_n=0,1} \alpha_{s_1s_2\dots s_N},\left| s_1, s_2, \dots, s_N\right\rangle, $$<br> with complex coefficients $\alpha_{s_1s_2\dots s_N}$. </p>
</blockquote>
<p> At this point an important consideration is in order. You will remember learning during the first week that, while a superconducting Hamiltonian may not conserve the total number of electrons due to the creation and annihilation of Cooper pairs, the parity of the number of electrons is always conserved.<br>We can obtain the <em>total fermion parity</em> by multiplying all the operators $P_n$,</p>
<p>$$ P_\textrm{tot}=P_1\cdot P_2\cdot, \dots, \cdot P_N = i^N,\gamma_1\gamma_2\dots\gamma_{2N},.$$</p>
<p>The operator $P_\textrm{tot}$ has eigenvalues $s_1 s_2\dots s_N=\pm 1$, depending on whether the total number of occupied fermionic modes is even or odd. Applied to our case, this means that it is only meaningful to consider states $\left|\Psi\right\rangle$ which are <em>eigenstates</em> of the operator $P_\textrm{tot}$, that is</p>
<p>$$P_\textrm{tot}\left|\Psi\right\rangle=\pm\left|\Psi\right\rangle,.$$</p>
<p>In particular, linear combinations of states with different total parity are forbidden. You can see this condition as a constraint on the allowed values of the coefficients $\alpha_{s_1s_2\dots s_N}$.</p>
<p>This consideration only applies to closed systems. It does not apply if we are considering a system which is in contact with a reservoir of electrons, such as a metallic lead, in which case electrons may tunnel in and out of the lead, changing the total parity of the system. Equivalently, it does not apply if we are considering only a part of the total system. You could for instance imagine that, in our sketch, there are more Majorana zero modes in the part of the network which is not drawn explicitly (represented by the dots which “continue” the nanowire). In such a case it is perfectly possible that the <em>total</em> network is in, say, a state of even parity, but that the subsystem under consideration is in a superposition of even and odd parity states.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider an isolated system with N=7 pairs of Majoranas, and an even total fermion parity. &quot;</span></span><br><span class="line">    <span class="string">&quot;What is the ground state degeneracy of the system?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Trick question - it is not possible to get N=7 pairs of Majorana modes with even parity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2^7.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2^6.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;14&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The system has an energy gap, so it cannot be degenerate.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;7 pairs of Majoranas means a Hilbert space with dimension 2^7, &quot;</span></span><br><span class="line">    <span class="string">&quot;out of which half have even total parity and half have odd total parity. &quot;</span></span><br><span class="line">    <span class="string">&quot;So the degeneracy at fixed even parity is 2^6.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Non-Abelian-statistics-of-Majoranas"><a href="#Non-Abelian-statistics-of-Majoranas" class="headerlink" title="Non-Abelian statistics of Majoranas"></a>Non-Abelian statistics of Majoranas</h1><p>Let’s now imagine that experimentalists are not only able to build such a network, but also to move the position of the domain walls and swap the positions of two Majoranas, for instance by performing the following trajectory:</p>
<p><img src="/2021/01/07/src/w2_majorana/braiding/nanowire_network_exchange.svg" alt></p>
<p>Let’s suppose that the trajectory takes a time $T$. During the trajectory, the system is described by a time-dependent Hamiltonian $H(t)$, $0\leq t \leq T$. This Hamiltonian contains all the details of the system, such as the positions of the domain walls where the Majoranas are located. Because the final configuration of the system is identical to the initial one, for instance all the domain walls are in the same positions as in the beginning, we have that $H(0)=H(T)$. In other words, we are considering a <em>closed trajectory</em> which brings the Hamiltonian back into itself. To ensure that the wave-function for the system does not leave the ground state manifold of states $|\Psi\rangle$, we need to change the Hamiltonian $H(t)$ slowly enough to obey the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Adiabatic_theorem">adiabatic theorem</a>. </p>
<p>So let’s imagine that we are in the adiabatic limit and that we exchange two Majoranas $\gamma_n$ and $\gamma_m$. As usual in quantum mechanics, the initial and final quantum states are connected by a unitary operator $U$ ($U^{-1}=U^\dagger$),</p>
<p>$$\left|\Psi\right\rangle ,\to, U \left|\Psi\right\rangle,.$$</p>
<p>Because the quantum state $\left|\Psi\right\rangle$ never leaves the ground state manifold, which has $2^N$ states, the operator $U$ can be written a $2^N\times 2^N$ unitary matrix.</p>
<p>We can derive the exact form of $U$ without a direct calculation, which would require knowing $H(t)$, but only based on the following, general considerations. First, the adiabatic exchange of two Majoranas does not change the parity of the number of electrons in the system, so $U$ commutes with the total fermion parity, $[U, P_\textrm{tot}]=0$. Second, it is reasonable to assume that $U$ only depends on the Majoranas involved in the exchange, or in other words that it is a function of $\gamma_n$ and $\gamma_m$, and of no other operator. And because it has to preserve fermion parity, it can only depend on their product, that is on the parity operator $-i\gamma_n\gamma_m$, which is Hermitian. Finally, the exponential of $i$ times a Hermitian operator is a unitary operator. So, in general $U$ must take the form</p>
<p>$$U\equiv\exp(\beta \gamma_n \gamma_m) = \cos(\beta) + \gamma_n\gamma_m \sin(\beta),,$$</p>
<p><em>up to an overall phase</em>. Here, $\beta$ is a real coefficient to be determined, and in the last equality we have used the fact that $(\gamma_n\gamma_m)^2=-1$. To determine $\beta$, it is convenient to go to the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Heisenberg_picture">Heisenberg picture</a> and look at the evolution of the Majorana operators in time. We have that</p>
<p>$$<br>\gamma_n,\to,  U,\gamma_n,U^\dagger,,\<br>\gamma_m,\to,  U,\gamma_m,U^\dagger,.<br>$$</p>
<p>Inserting our guess for $U$ we obtain:</p>
<p>$$<br>\gamma_n,\to,   \cos (2\beta),\gamma_n  - \sin(2\beta),\gamma_m,,\<br>\gamma_m,\to,   \cos (2\beta),\gamma_m  + \sin(2\beta),\gamma_n,.<br>$$</p>
<p>Now we have to remember that at time $T$ we have completed a closed trajectory, so that the Majorana $\gamma_n$ is now in the place initially occupied by $\gamma_m$, and vice versa. This condition leads to the choice $\beta = \pm \pi/4$. It is not strange that we find that both signs are possible - this distinguishes the clockwise and the counterclockwise exchange of the Majoranas. </p>
<blockquote>
<p>Thus, we can write the unitary operator that exchanges the Majorana modes $\gamma_n$ and $\gamma_m$ in an explicit (and somewhat non-trivial looking!) form as:<br>$$U = \exp \left(\pm\frac{\pi}{4}\gamma_n \gamma_m\right) = \tfrac{1}{\sqrt{2}}\left(1\pm\gamma_n\gamma_m\right)$$</p>
</blockquote>
<p>To fix our ideas and study the consequences of $U$ more closely, it is convenient to just focus on four Majoranas $\gamma_1,\gamma_2,\gamma_3$ and $\gamma_4$. For this discussion we will assume that counter-clockwise exchanges pick the $+$ sign in $U$. Their ground state manifold has four states, which in the notation introduced before we write down as</p>
<p>$$\left|00\right\rangle, \left|11\right\rangle, \left|01\right\rangle, \left|10\right\rangle,,$$</p>
<p>where the first digit is the occupation number of the fermionic mode $c^\dagger_1=\tfrac{1}{2}(\gamma_1+i\gamma_2)$ and the second digit the occupation number of $c^\dagger_2=\tfrac{1}{2}(\gamma_3+i\gamma_4)$. The most generic possible wave function is a superposition</p>
<p>$$\left|\Psi\right\rangle = s_{00}\left|00\right\rangle + s_{11} \left|11\right\rangle + s_{01} \left|01\right\rangle + s_{10} \left|10\right\rangle,,$$</p>
<p>which we can also represent as a vector with four entries, $\left|\Psi\right\rangle = (s_{00}, s_{11}, s_{01}, s_{10})^T$. The operator $U$ at this point can be written as a $4\times 4$ matrix. In order to do so, you just have to compute the action of a product of Majoranas on the basis states. This a simple but tedious operation, which we skip here. It results in the following matrices for the operators $U_{12}, U_{23}$ and $U_{34}$ exchanging neighboring Majoranas:</p>
<p>$$<br>U_{12} = \exp\left(\frac{\pi}{4}\gamma_1 \gamma_2\right) \equiv\begin{pmatrix}<br>e^{-i\pi/4} &amp; 0 &amp; 0 &amp; 0 \0 &amp; e^{i\pi/4} &amp; 0 &amp;0 \0 &amp; 0&amp; e^{-i\pi/4} &amp;0 \ 0&amp;0&amp; 0&amp; e^{i\pi/4}<br>\end{pmatrix},,<br>$$</p>
<p>$$<br>U_{23} = \exp\left(\frac{\pi}{4}\gamma_2 \gamma_3\right) \equiv\frac{1}{\sqrt{2}}\begin{pmatrix}<br>1 &amp; -i &amp; 0 &amp; 0\ -i &amp; 1 &amp; 0&amp; 0\ 0&amp; 0&amp; 1 &amp; -i\ 0&amp; 0&amp; -i &amp; 1<br>\end{pmatrix},,<br>$$</p>
<p>$$<br>U_{34} = \exp\left(\frac{\pi}{4}\gamma_3 \gamma_4\right) \equiv\begin{pmatrix}<br>e^{-i\pi/4} &amp; 0 &amp; 0 &amp; 0\ 0&amp; e^{i\pi/4} &amp; 0&amp; 0\ 0&amp; 0&amp; e^{i\pi/4} &amp; 0\ 0&amp; 0&amp; 0&amp; e^{-i\pi/4}<br>\end{pmatrix},.<br>$$</p>
<p>These matrices indeed act in a very non-trivial way on the wave function. For instance, if we start from the state $\left|00\right\rangle$ and we exchange $\gamma_2$ and $\gamma_3$, we obtain</p>
<p>$$\left|00\right\rangle,\to,U_{23}\left|00\right\rangle=\tfrac{1}{\sqrt{2}}\left(\left|00\right\rangle-i\left|11\right\rangle\right),,$$</p>
<p>which is a superposition of states! Hence we have seen explicitly that the effect of the exchange two Majoranas on the wavefunction amounts to much more than just an overall phase, as it happens for bosons and fermions.</p>
<p>Let’s now try a sequence of two exchanges. In this case, we have to multiply the corresponding $U$s, ordering them from right to the left according to the order of the exchanges. Given that the matrices above are not diagonal, it is not surprising that the order in the product matters a lot. For instance you can check that</p>
<p>$$U_{23}U_{12}\neq U_{12}U_{23},$$</p>
<blockquote>
<p>We have just shown that exchanging two Majorana modes leads to a non trivial rotation in the ground state manifold, and that changing the order of the exchanges changes the final result. These properties make Majorana modes <strong>non-Abelian anyons</strong>. The exchange of two non-Abelian anyons is usually called <strong>braiding</strong>, a name which is suggestive of the fact that, when thinking of the trajectories of the different particles, a sequence of exchanges looks like a braid made out of different strands.</p>
</blockquote>
<p>Finally, you might object to the fact that the network of nanowires drawn in the figures only allows to exchange neighbouring Majoranas, even though our derivation of $U=\exp(\pi\gamma_n\gamma_m/4)$ seems to hold for any pair of Majoranas. This geometric constraint is not a big problem: by carefully composing many exchanges between neighbours, we can exchange any pair of Majoranas. As an example, you have that $U_{13}\equiv\exp\left(\pi\gamma_1 \gamma_3/4\right) = U_{12}^\dagger,U^\dagger_{23},U_{12}$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider a system with only one pair of Majorana modes, thus with just two degenerate states with different fermion parity. &quot;</span></span><br><span class="line">    <span class="string">&quot;What happens when we exchange the pair of Majorana modes, starting from a given fermion parity eigenstate?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The fermion parity of the state flips.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Nothing happens.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The system wave-function picks up a phase that depends on the fermion parity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You end up in a superposition of the two states.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The total fermion parity cannot change, &quot;</span></span><br><span class="line">    <span class="string">&quot;but the two states can pick up a different phase. &quot;</span></span><br><span class="line">    <span class="string">&quot;This is indeed what happens since the operator $U$ describing the exchange depends on fermion parity.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Majoranas-and-quantum-computation-basic-ideas"><a href="#Majoranas-and-quantum-computation-basic-ideas" class="headerlink" title="Majoranas and quantum computation: basic ideas"></a>Majoranas and quantum computation: basic ideas</h1><p>The non-Abelian statistics of Majorana modes is a very special property. Furthermore, it has some practical interest, since it could be used to realize a robust <strong>quantum computer</strong>. (If you are not yet interested in quantum computation, you can skip this part, even though we suggest that you get interested in it! Quantum computation is a huge topic of research, but <a target="_blank" rel="noopener" href="http://arxiv.org/abs/quant-ph/9708022">this</a> is a good place to start learning.)</p>
<p>Let’s discuss very briefly how this can be done.</p>
<p>First, we can think of our network of nanowires with $2N$ Majoranas as a small computer. The $2^N$ states of the ground state manifold can encode a string of $N$ bits, so it’s like having a small <em>register</em>. As always in quantum computation, and unlike in a classical computer, the register can be in a superposition of different states. So far, nothing really special about Majoranas.</p>
<p>How do we execute an <em>algorithm</em> on our register? Simply by exchanging the Majorana modes! Because of the non-Abelian statistics, different sequences of exchanges will yield different algorithms. Of course, to execute an interesting algorithm we may need a lot of Majorana modes and a very very long sequence of exchanges. However, it all begins with the small building blocks, the matrices that you have just studied in detail.</p>
<p>You might say that this is just another way to obtain a given unitary operator acting on the wave function. The beautiful thing, though, is that both the state of the register and the algorithms are <em>topologically protected</em>. Let’s explain what we mean by that.</p>
<p>The state of the register is encoded in the fermion parity degrees of freedom, which are shared <em>non-locally</em> by the Majoranas. This means that no local perturbation can change the state of the register and cause <em>decoherence</em> of the quantum state. The environment cannot access the information stored in the Majoranas, as long as they are kept far away from each other. The only exception is a change in fermion parity due to the tunnelling of a stray quasiparticle into the system (this is the problem of quasiparticle poisoning, the same that can hinder the detection of the $4\pi$-periodic Josephson effect of Majorana modes, as you heard from Carlo Beenakker). But except from this, the Majoranas are a great <em>quantum memory</em>.</p>
<p>On the other hand, every step of the algorithm will be extremely accurate because it is given by an exchange of two Majoranas, which corresponds to <em>exactly</em> $\exp(\pi\gamma_n\gamma_m/4)$. When you are in the adiabatic limit, this operator does not depend on any of the details on how the exchange between Majoranas is performed. It does not depend on <em>how</em> you move the Majoranas, or on the particular trajectory that $\gamma_n$ and $\gamma_m$ followed, or on the timing of the trajectory. So the final result is extremely reliable.</p>
<p>These are the basic ideas of <strong>topological quantum computation</strong>. It is incredible that we can find condensed matter systems, such as networks of Majoranas, which are naturally endowed with these characteristics. </p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;V3e9r4S8GHs&quot;</span>, src_location=<span class="string">&quot;2.3-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below.</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Non-Abelian statistics of Majorana modes&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2021
        <i class="ri-heart-fill heart_icon"></i> huyi
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/icon.svg" alt="O"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/logs/">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://pan.ihuyi.xyz">网盘</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://aria.ihuyi.xyz">aria2</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>