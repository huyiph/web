<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="demon" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    src/w3_pump_QHE/Laughlinargument |  O
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-src/w3_pump_QHE/Laughlinargument" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  src/w3_pump_QHE/Laughlinargument
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/07/src/w3_pump_QHE/Laughlinargument/" class="article-date">
  <time datetime="2021-01-07T09:11:06.828Z" itemprop="datePublished">2021-01-07</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">4.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">29 min</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">"../../code"</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_corbino</span><span class="params">(r_out=<span class="number">100</span>, r_in=<span class="number">65</span>, w_lead=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Create corbino disk. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, B, phi</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># ring shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ring</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        rsq = x ** <span class="number">2</span> + y ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> r_in ** <span class="number">2</span> &lt; rsq &lt; r_out ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crosses_branchcut</span><span class="params">(hop)</span>:</span></span><br><span class="line">        x1, y1 = hop[<span class="number">0</span>].pos</span><br><span class="line">        x2, y2 = hop[<span class="number">1</span>].pos</span><br><span class="line">        <span class="keyword">return</span> y1 &lt; <span class="number">0</span> <span class="keyword">and</span> x1 &gt; <span class="number">0.5</span> <span class="keyword">and</span> x2 &lt; <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="comment"># Check for correctness!</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(<span class="number">-0.5j</span> * p.B * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">branchcut_hopping</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hopping(site1, site2, p) * np.exp(<span class="number">1j</span> * p.phi)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ring, (<span class="number">0</span>, r_in + <span class="number">1</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding special hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hops_across_cut</span><span class="params">(syst)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> hop <span class="keyword">in</span> kwant.builder.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat, lat)(syst):</span><br><span class="line">            <span class="keyword">if</span> crosses_branchcut(hop):</span><br><span class="line">                <span class="keyword">yield</span> hop</span><br><span class="line"></span><br><span class="line">    syst[hops_across_cut] = branchcut_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((<span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt; y &lt; w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line">    lead[lat.neighbors()] = <span class="keyword">lambda</span> site1, site2, p: -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment">#### Attach the leads and return the system. ####</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead, origin=lat(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total_charge</span><span class="params">(value_array)</span>:</span></span><br><span class="line">    determinants = [np.linalg.det(s) <span class="keyword">for</span> s <span class="keyword">in</span> value_array]</span><br><span class="line">    charge = np.cumsum(np.angle(determinants / np.roll(determinants, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> charge / (<span class="number">2</span> * np.pi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_ribbon</span><span class="params">(W, periodic=False)</span>:</span></span><br><span class="line">    <span class="string">""" Creates ribbon system</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If we have periodic boundary conditions, the flux through a single </span></span><br><span class="line"><span class="string">    unit cell is quantized.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -W / <span class="number">2</span> &lt;= y &lt;= W / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(<span class="number">-0.5j</span> * p.B * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_periodic</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(</span><br><span class="line">            <span class="number">-1j</span></span><br><span class="line">            * np.pi</span><br><span class="line">            / (W + <span class="number">1</span>)</span><br><span class="line">            * np.round((W + <span class="number">1</span>) * p.B / (<span class="number">2</span> * np.pi))</span><br><span class="line">            * (x1 - x2)</span><br><span class="line">            * (y1 + y2)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym_syst = kwant.TranslationalSymmetry((<span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym_syst)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line">        syst[lat.neighbors()] = hopping_periodic</span><br><span class="line">        syst[lat(<span class="number">0</span>, -W / <span class="number">2</span>), lat(<span class="number">0</span>, +W / <span class="number">2</span>)] = hopping_periodic</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Quantum hall bar codes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_hall_bar</span><span class="params">(L=<span class="number">50</span>, W=<span class="number">10</span>, w_lead=<span class="number">10</span>, w_vert_lead=None)</span>:</span></span><br><span class="line">    <span class="string">"""Create a hall bar system. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    L = <span class="number">2</span> * (L // <span class="number">2</span>)</span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line">    w_lead = <span class="number">2</span> * (w_lead // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> w_vert_lead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        w_vert_lead = w_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        w_vert_lead = <span class="number">2</span> * (w_vert_lead // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bar shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (x &gt;= -L / <span class="number">2</span> <span class="keyword">and</span> x &lt;= L / <span class="number">2</span>) <span class="keyword">and</span> (y &gt;= -W / <span class="number">2</span> <span class="keyword">and</span> y &lt;= W / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span><span class="params">(site, p)</span>:</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ax</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(<span class="number">-0.5j</span> * p.B * (x1 + x2) * (y1 - y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_lead_hop_y</span><span class="params">(x0)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ay</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">            x1, y1 = site1.pos</span><br><span class="line">            x2, y2 = site2.pos</span><br><span class="line">            <span class="keyword">return</span> -p.t * np.exp(<span class="number">-1j</span> * p.B * x0 * (y1 - y2))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hopping_Ay</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_hop_vert</span><span class="params">(site1, site2, p)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(bar, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping_Ax</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((<span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt;= y &lt;= w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_onsite = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line"></span><br><span class="line">    sym_lead_vertical = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead_vertical1 = kwant.Builder(sym_lead_vertical)</span><br><span class="line">    lead_vertical2 = kwant.Builder(sym_lead_vertical)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical1</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= -L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical2</span><span class="params">(pos)</span>:</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> +L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= +L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_vertical1[lat.shape(lead_shape_vertical1, (-L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical1[lat.neighbors()] = lead_hop_vert</span><br><span class="line">    lead_vertical2[lat.shape(lead_shape_vertical2, (L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical2[lat.neighbors()] = lead_hop_vert</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1)</span><br><span class="line">    syst.attach_lead(lead_vertical2)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1.reversed())</span><br><span class="line">    syst.attach_lead(lead_vertical2.reversed())</span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">-1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(-L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line"></span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">-1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead.reversed())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_sigmas</span><span class="params">(G)</span>:</span></span><br><span class="line">    <span class="comment"># reduce by one dimension G -&gt; G[temp, temp]</span></span><br><span class="line">    temp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    G = G[temp, :]</span><br><span class="line">    G = G[:, temp]</span><br><span class="line">    <span class="comment"># invert R = G^-1</span></span><br><span class="line">    <span class="comment"># find out whether it is a numpy object</span></span><br><span class="line">    r = np.linalg.inv(G)</span><br><span class="line">    <span class="comment"># Voltages follow: V = R I[temp]</span></span><br><span class="line">    V = r @ np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line">    <span class="comment"># Completely solved the six terminal system.</span></span><br><span class="line">    <span class="comment"># Consider the 2x2 conductance now: Use I = sigma U</span></span><br><span class="line">    E_x = V[<span class="number">1</span>] - V[<span class="number">0</span>]</span><br><span class="line">    E_y = V[<span class="number">1</span>] - V[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># formula above</span></span><br><span class="line">    sigma_xx = E_x / (E_x ** <span class="number">2</span> + E_y ** <span class="number">2</span>)</span><br><span class="line">    sigma_xy = E_y / (E_x ** <span class="number">2</span> + E_y ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> sigma_xx, sigma_xy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pumping</span><span class="params">(syst, p)</span>:</span></span><br><span class="line">    p.mu_lead = p.mu</span><br><span class="line">    phis = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">40</span>)</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    rs = [kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=dict(p=p)).submatrix(<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">for</span> p.phi <span class="keyword">in</span> phis]</span><br><span class="line">    charges = -total_charge(rs)</span><br><span class="line">    style = &#123;<span class="string">"xticks"</span>: [<span class="number">0</span>, <span class="number">1</span>], <span class="string">"yticks"</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">"aspect"</span>: <span class="string">"square"</span>&#125;</span><br><span class="line">    kdims = [<span class="string">"$\phi/2\pi$"</span>, <span class="string">"$q_&#123;pump&#125;$"</span>]</span><br><span class="line">    title = <span class="string">"$\mu = &#123;:.2&#125;$, $\sigma_H = &#123;:&#125; \cdot e^2/h$"</span>.format(</span><br><span class="line">        p.mu, int(round(charges[<span class="number">-1</span>]))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> holoviews.Path((phis / (<span class="number">2</span> * np.pi), charges), kdims=kdims, label=title).opts(</span><br><span class="line">        plot=style</span><br><span class="line">    )[:, <span class="number">0</span>:<span class="number">3.1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Ady Stern from the Weizmann Institute of Science will introduce the quantum Hall effect.</p>
<p>Ady thanks Dr. Dan Arav and Gil Novik from the School of Media Studies of the<br>College of Management - Academic Studies for their help in preparing the videos.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"QC3tQT7MD00"</span>, src_location=<span class="string">"3.2-intro"</span>, res=<span class="string">"360"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="The-Hall-effect"><a href="#The-Hall-effect" class="headerlink" title="The Hall effect"></a>The Hall effect</h1><p>We now move on to the quantum Hall effect, the mother of all topological effects in condensed matter physics.</p>
<p>But let’s start from the classical <a href="http://en.wikipedia.org/wiki/Hall_effect" target="_blank" rel="noopener">Hall effect</a>, the famous phenomenon by which a current flows perpendicular to an applied voltage, or vice versa a voltage develops perpendicular to a flowing current.</p>
<p>How does one get a Hall effect? The key is to break time-reversal symmetry. A flowing current breaks time-reversal symmetry, while an electric field doesn’t. Hence, any system with a Hall effect must somehow break time-reversal symmetry.</p>
<p>But wait a minute, you might catch me and ask, what about a normal electric current flowing parallel to an electric field? This is what happens in a metal on a regular basis, and a metal does not break time-reversal symmetry.</p>
<p>The key difference there is that such a longitudinal current breaks time-reversal through energy dissipation, which turns into heat that breaks time-reversal by the second law of thermodynamics. A Hall current is special in that it is <strong>dissipationless</strong>. We can drive a Hall current without wasting any energy because the current flows perpendicular to the voltage gradient.</p>
<blockquote>
<p>Thus to get a Hall effect we must somehow break time-reversal symmetry. We will examine the simplest way to achieve this, an external magnetic field.</p>
</blockquote>
<h2 id="How-to-measure-the-Hall-effect"><a href="#How-to-measure-the-Hall-effect" class="headerlink" title="How to measure the Hall effect"></a>How to measure the Hall effect</h2><p>Let’s consider a two dimensional gas of electrons immersed in a strong, perpendicular magnetic field. In particular, we take the following geometry, which is called a Hall bar and is routinely used in experiments:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/hall_bar.svg" alt></p>
<p>The electron gas is contacted by six electrodes, numbered in the figure. We can use this Hall bar geometry set-up to measure the transport characteristics of the gas, as follows.</p>
<p>The transport characteristics are tabulated using the 4 components $\sigma_{xx},\sigma_{yy},\sigma_{xy}$ and $\sigma_{yx}$ of the so-called conductivity tensor. Once we know the conductivity tensor, we can use it to calculate how the current density $\mathbf{j} = (j_x,j_y)$ flows in response to the electric field $\mathbf{E} = (E_x,E_y)$ in the metal, through the equation  </p>
<p>$$j_\alpha=\sum_\beta \sigma_{\alpha\beta}E_{\beta}.$$</p>
<p>By inverting this set of relations between current densities and electric field, we obtain the resistivities $\rho_{xx}, \rho_{xy}, \dots$, which are more often reported in experimental data. Also, in two-dimensional systems there is no real difference between conductance and conductivity (or resistance and resistivity) - they have the same physical units. So the terms are somehow interchangeable.</p>
<p>The way to use the Hall bar device is to drive a current $I$ along the $x$ direction, so that there is a current density $j_x=(I/W)$ where $W$ is the width of the sample. There is no current density in the perpendicular direction.</p>
<p>We can measure the electric field using the Hall bar geometry from the voltage drops between the probes with voltages $V_{1,2,3,4}$.<br>We can then measure the $x$-component of the electric field from the longitudinal voltage drop $V_L\sim (V_1-V_2)$ or  $(V_3-V_4)$ according to the averaged equation </p>
<p>$$E_x \equiv \frac{V_1+V_3-V_2-V_4}{2L}.$$</p>
<p>Similarly, we can measure the $y$-component of the electric field from the  Hall voltage $V_H=(V_1-V_3)$ or $(V_2-V_4)$. Specifically we can calculate the electric field as: </p>
<p>$$E_y \equiv \frac{V_1+V_2-V_4-V_3}{2W}.$$</p>
<p>The Hall bar can only measure the conductance completely for isotropic or rotationally invariant systems. If we rotate the system by 90 degrees we can transform $x\rightarrow y$ and $y\rightarrow -x$. So we expect $\sigma_{xx}=\sigma_{yy}=\sigma_L$, the longitudinal conductance. If we apply this same rotation transformation we conclude that $\sigma_{xy}=-\sigma_{yx}=\sigma_H$, the <em>Hall conductance</em>. </p>
<p>So with rotational invariance the 4 component conductance tensor has only 2 independent components i.e. the longitudinal and Hall conductance. We can calculate these using the two electric fields $E_{x,y}$ that we measure using the Hall bar.<br>To do this, we solve the set of equations $j_y=\sigma_L E_y - \sigma_H E_x=0$ and $j_x=\sigma_L E_x+\sigma_H E_y$ to obtain $\sigma_{L,H}$. We obtain the Hall conductance</p>
<p>$$\sigma_H=\frac{j_x E_y}{E_x^2+E_y^2}.$$</p>
<h1 id="The-classical-Hall-effect-is-a-linear-effect"><a href="#The-classical-Hall-effect-is-a-linear-effect" class="headerlink" title="The classical Hall effect is a linear effect"></a>The classical Hall effect is a linear effect</h1><p>Let’s now try to obtain an alternative expression for the Hall conductance $\sigma_H$ of our Hall bar. In general we expect the electric and magnetic fields present in our Hall bar to apply a force to the electrons, and increase their velocity. </p>
<p>Instead of solving the problem directly, let us make the ansatz that the electrons enter a state, which is obtained from the usual electron ground state by doing a Galilean transformation to a reference frame moving with velocity $\bf{v}$ with respect to the original reference frame.</p>
<p>Since the average velocity of the electrons is $\bf v$ in the original reference frame, the average force on the electrons is </p>
<p>$${\bf F}= e,(\mathbf{E}+\mathbf{v}\times \mathbf{B}).$$</p>
<p>If we want to be a steady state then $\bf F=0$, which means that ${\bf v}= (\mathbf{E}\times \mathbf{B})/B^2$. Since the electrons move with an average velocity $\bf v$, and if $n$ denotes the electron density, we can easily guess that the current density is ${\bf j}=n e {\bf v}=(n e/ B) ,(\mathbf{E}\times \mathbf{z})$.</p>
<blockquote>
<p>Comparing with the previous subsection, we can thus conclude that simply based on Galilean invariance, an electron gas in a magnetic field must have a Hall conductance that is given by </p>
</blockquote>
<p>$$\sigma_H=n e B^{-1}.$$</p>
<p>This relation, which says that $\sigma_H\propto n$, is extremely general in the sense that it does not depend on how the electrons interact with each other or anything else. It is referred to as the Streda relation. If we define the so-called “filling factor” as $\nu=n h/ e B$ the Hall conductance can be written as a multiple of the quantum of conductance as $\sigma_H=\nu \frac{e^2}{h}$.</p>
<p>As you already heard from Ady Stern in the intro video, people have measured the Hall conductance of this exact system to incredible precision. At relatively high density, the Hall conductance of this system behaves itself accordingly and scales linearly with gate voltage, which is tuned to control the density. At low filling factors, one would expect many non-idealities like disorder and interaction to break the Galilean invariance based argument and lead to a Hall conductance $\sigma_H$ that varies from sample to sample and depends on disorder. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">"What is the longitudinal conductance for the ideal electron gas in a magnetic field?"</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"Infinity since there are no impurities in the system."</span>,</span><br><span class="line">    <span class="string">"Finite and inversely proportional to the magnetic field like the Hall conductance."</span>,</span><br><span class="line">    <span class="string">"Finite and proportional to density but independent of magnetic field."</span>,</span><br><span class="line">    <span class="string">"Zero since current is perpendicular to electric field."</span>,</span><br><span class="line">]</span><br><span class="line">explanation = <span class="string">"As we saw the velocity is related to the cross-product of the electric and magnetic field."</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="The-quantum-Hall-effect-experimental-data"><a href="#The-quantum-Hall-effect-experimental-data" class="headerlink" title="The quantum Hall effect: experimental data"></a>The quantum Hall effect: experimental data</h1><p>Instead, a completely unexpected result was measured for the first time by Klaus von Klitzing. Typical experimental data looks like this (taken from M.E. Suddards, A. Baumgartner, M. Henini and C. J. Mellor, <a href="http://iopscience.iop.org/1367-2630/14/8/083015" target="_blank" rel="noopener">New J. Phys. 14 083015</a>):</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/QHE.png" alt></p>
<blockquote>
<p>As the average density is varied, the Hall conductance $\sigma_H$ appears to form plateaus at integer filling fractions $\nu=1,2,3,\dots$. These plateaus are incredibly sample independent and occur at the same value in many other materials. At the same time, the longitudinal conductivity appears to vanish except at the transition points between the plateaus. This is the integer “Quantum Hall effect”. </p>
</blockquote>
<p>This setup is easy to try to reproduce numerically, but there’s one complication:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syst = qhe_hall_bar(L=<span class="number">60</span>, W=<span class="number">100</span>, w_lead=<span class="number">90</span>, w_vert_lead=<span class="number">28</span>).finalized()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.3</span>, mu_lead=<span class="number">0.3</span>, B=<span class="literal">None</span>)</span><br><span class="line">Bs = np.linspace(<span class="number">0.02</span>, <span class="number">0.15</span>, <span class="number">200</span>)</span><br><span class="line">num_leads = len(syst.leads)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G</span><span class="params">(syst, p)</span>:</span></span><br><span class="line">    smatrix = kwant.smatrix(syst, params=dict(p=p))</span><br><span class="line">    G = [</span><br><span class="line">        [smatrix.transmission(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(num_leads)] <span class="keyword">for</span> j <span class="keyword">in</span> range(num_leads)</span><br><span class="line">    ]</span><br><span class="line">    G -= np.diag(np.sum(G, axis=<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> calculate_sigmas(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sigmasxx, sigmasxy = np.array([G(syst, p) <span class="keyword">for</span> p.B <span class="keyword">in</span> Bs]).T</span><br><span class="line"></span><br><span class="line">kdims = [<span class="string">r"$B^&#123;-1&#125; [a.u.]$"</span>, <span class="string">"$\sigma_&#123;xx&#125;, \sigma_&#123;xy&#125;\,[e^2/h]$"</span>]</span><br><span class="line">plot_xx = holoviews.Path((<span class="number">1</span> / Bs, sigmasxx), label=<span class="string">r"$\sigma_&#123;xx&#125;$"</span>, kdims=kdims).opts(</span><br><span class="line">    style=&#123;<span class="string">"color"</span>: <span class="string">"k"</span>&#125;</span><br><span class="line">)</span><br><span class="line">plot_xy = holoviews.Path((<span class="number">1</span> / Bs, sigmasxy), label=<span class="string">r"$\sigma_&#123;xy&#125;$"</span>, kdims=kdims).opts(</span><br><span class="line">    style=&#123;<span class="string">"color"</span>: <span class="string">"r"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(plot_xx * plot_xy).opts(plot=&#123;<span class="string">"xticks"</span>: <span class="number">0</span>, <span class="string">"yticks"</span>: list(range(<span class="number">8</span>))&#125;)</span><br></pre></td></tr></table></figure>

<p>Numerical systems are so good that the longitudinal conductivity always stays low even at the transition.</p>
<p>But other than that small problem everything works just the same.</p>
<h1 id="Quantized-Hall-conductance-from-pumping-Laughlin-argument"><a href="#Quantized-Hall-conductance-from-pumping-Laughlin-argument" class="headerlink" title="Quantized Hall conductance from pumping: Laughlin argument"></a>Quantized Hall conductance from pumping: Laughlin argument</h1><p>Why is the quantized Hall conductance $\sigma_H$ so robust and independent of system details? Clearly there must be a topological argument at play.</p>
<p>Soon after the experimental discovery, Laughlin came up with an elegant argument that mapped the Hall conductance problem to a topological pumping problem and in the process explained the robustness. Let us go through this argument.</p>
<h2 id="The-Corbino-geometry"><a href="#The-Corbino-geometry" class="headerlink" title="The Corbino geometry"></a>The Corbino geometry</h2><p>To start with, we imagine doing the Hall measurement in a system cut out as an annulus, which is referred to as the Corbino disk:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/corbino_flux.svg" alt></p>
<p>We will also try to do the experiment in reverse i.e. apply an electric field along the circumference of the disk and measure the current $I$ in the radial direction, as shown in the figure. The radial current is easy to measure - we just measure the amount of charge $\Delta Q$ transferred between the inner and outer edges of the Corbino geometry and obtain the radial current $I=\Delta Q/\Delta T$, where $\Delta T$ is the time over which this is done.</p>
<p>But how do we apply an electric field in the tangential direction?  The easiest way to do this is to apply a time-dependent magnetic field in the centre of the disc and use the Faraday effect. </p>
<p>We can calculate the electric field from the changing magnetic field using Faraday’s law as $\oint d{\bf{r}\cdot\bf{E}}=\partial_t \Phi$, where $\Phi$ is the magnetic flux resulting from the field in the center of the disk. Assuming that the electric field depends only on the radius $R$ we find that the resulting tangential electric field is given by</p>
<p>$$E(R,t)=\frac{1}{2\pi R},\partial_t \Phi.$$ </p>
<p>Given $I$, we can also calculate the other component of the measurement of the Hall conductance $\sigma_H$ i.e. the radial current density $j=I/(2\pi R)$ at the same radius $R$ as we calculated the electric field. </p>
<p>Now that we know both the circumferential electric field and also the radial current density, the Hall conductance can be measured easily in this geometry as </p>
<p>$$\sigma_H=\frac{j}{E(r,t)}=\frac{I}{\partial_t \Phi}.$$</p>
<p>You might worry that we were a bit simplistic and ignored the longitudinal conductance in this geometry. We could measure the longitudinal conductivity by applying a voltage difference between the inner and outer edges and measuring the resulting radial current $I$. For the remainder of this discussion, we assume that the longitudinal conductivity vanishes as is observed experimentally.</p>
<h2 id="Laughlin-pump"><a href="#Laughlin-pump" class="headerlink" title="Laughlin pump"></a>Laughlin pump</h2><p>We are now ready to present the pumping argument to explain why the low temperature Hall effect is quantized.</p>
<p>To do this, we change the magnetic field in the center of the Corbino disc so that the flux changes by $\Delta \Phi=\Phi_0=h/e$, i.e. a <strong>flux quantum</strong> over the time $\Delta T$. (Note that this flux quantum is only half of the superconducting flux quantum that we were using last week. That’s because now the current is being carried by electrons and not Cooper pairs. It is customary to use the same symbol $\Phi_0$ for both, since they often appear in different contexts). Assuming that we have a system with Hall conductance $\sigma_H$, we obtain the charge transferred as </p>
<p>$$\Delta Q=I \Delta T=\sigma_H, \Delta T, \partial_t\Phi =\sigma_H,\Delta\Phi=\sigma_H, \frac{h}{e}.$$</p>
<p>Writing $\sigma_H=\nu e^2/h$, we obtain $\Delta Q=\nu e$. Since the longitudinal conductance $\sigma_L=0$, we expect the system to be gapped in the bulk of the disc and we expect the entire charge transfer $\Delta Q$ to occur between the edges.</p>
<blockquote>
<p>Since the flux $\Phi$ in the center is a flux quantum $\Phi_0$, the wave functions of the electrons all return to being the same as at $\Phi=0$. Therefore only an integer number of charges $\Delta Q=n e$ can be pumped between the edges. This is Laughlin’s argument for why the Hall conductance must be quantized as</p>
</blockquote>
<p>$$\sigma_{xy}=n e^2/h.$$</p>
<p>What you notice at this point is that we basically have a pump similar to the last unit.</p>
<p>Here an integer number of charges is pumped from one edge to the other as the flux $\Phi$ is increased by $\Phi_0$. As one sees below, one can simulate electrons in a Corbino geometry and check that indeed an integer number of charges is pumped between the edges as the flux $\Phi$ is changed by $\Phi_0$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">W = <span class="number">20</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, B=<span class="number">2</span> * np.pi / (W + <span class="number">1</span>), phi=<span class="literal">None</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = qhe_corbino(r_out=<span class="number">2</span> * W, r_in=<span class="number">20</span>, w_lead=<span class="number">10</span>)</span><br><span class="line">mus = np.linspace(<span class="number">0.4</span>, <span class="number">1.4</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.mu: plot_pumping(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r"$\mu$"</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"Experimentally the quantum Hall conductance jumps - what does this mean about the "</span></span><br><span class="line">    <span class="string">"robustness of the Laughlin pumping argument?"</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">"The Laughlin argument breaks down because it assumes specific values of the magnetic field."</span>,</span><br><span class="line">    <span class="string">"The Laughlin argument assumes there is no longitudinal conductivity."</span>,</span><br><span class="line">    <span class="string">"The Hall conductance is not a topological invariant since it changes."</span>,</span><br><span class="line">    <span class="string">"The flux in the corbino geometry was changed by a value that was not a multiple of the flux quantum."</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">"The key ingredient in the Laughlin argument was that there is no states at the fermi level in "</span></span><br><span class="line">    <span class="string">"the bulk which is equivalent to no longitudinal conductivity"</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Landau-levels-a-microscopic-model-for-the-quantum-hall-effect"><a href="#Landau-levels-a-microscopic-model-for-the-quantum-hall-effect" class="headerlink" title="Landau levels: a microscopic model for the quantum hall effect"></a>Landau levels: a microscopic model for the quantum hall effect</h1><p>The general argument so far is great in that it applies to virtually any complicated electron system with interactions and in a real material, but we would probably feel better if we could calculate the Hall conductance directly for some simple system. So let us try to do this for the simplest case of electrons in a magnetic field.</p>
<p>For starters, let us forget about the Corbino disk and just ask what do quantum mechanical electrons do in a magnetic field. </p>
<h2 id="Landau-levels-on-the-back-of-an-envelope"><a href="#Landau-levels-on-the-back-of-an-envelope" class="headerlink" title="Landau levels on the back of an envelope"></a>Landau levels on the back of an envelope</h2><p>We know what classical electrons do in a perpendicular magnetic field: They go around in <em>cyclotron orbits</em>, because of the Lorentz force. The cyclotron radius in a magnetic field of strength $B$ for an electron with velocity $v$ is $r_c = mv/eB$. An electron performing a cyclotron orbit at velocity $v$ has angular momentum $L=mvr_c=eB r^2_c$. In quantum mechanics, however, only orbits with a quantized angular momentum $L=n\hbar$ will be allowed. From the equality $r^2_c = n\hbar/eB$ one obtains that only some discrete values are allowed for the radius, $r_n = \sqrt{n} l_B$, where $l_B = \sqrt{\hbar/eB}$ is called the magnetic length.</p>
<p>All cyclotron orbits, independent of the radius, circle at the same frequency $\omega_c=eB/m$. The energy of the electron in this quantized orbit is equal to $L\omega_c = n\hbar\omega_c$. So the energy spectrum really looks like that of a harmonic oscillator. All the energy levels are also shifted up from zero energy by the zero-point motion of the harmonic oscillator, $\hbar\omega_c/2$. We finally obtain that the allowed energy levels are</p>
<p>$$E_n = \hbar \omega_c ,\left(n+\tfrac{1}{2}\right),.$$</p>
<p>These quantized energy levels of electrons in a magnetic field are called <strong>Landau levels</strong>.</p>
<p>You can put many electrons in the same Landau level: one for every flux quantum of the magnetic flux passing through the system. Therefore Landau levels have a huge degeneracy, proportional to the area of the sample.</p>
<h2 id="Landau-levels-from-the-Hamiltonian"><a href="#Landau-levels-from-the-Hamiltonian" class="headerlink" title="Landau levels from the Hamiltonian"></a>Landau levels from the Hamiltonian</h2><p>Now that we know the answer in advance, we can solve the Schrödinger equation for electrons in a magnetic field without stress. It will still be important to understand the quantum Hall effect in a bit more detail. The Hamiltonian is</p>
<p>$$H=(\textbf{p}-e \textbf{ A})^2.$$ </p>
<p>The vector potential $\bf{A}$ depends on position, which makes this Hamiltonian complicated to solve in general. For a uniform magnetic field, we can make our life easier by choosing a Landau gauge </p>
<p>$$\textbf{A}(x,y)=\hat{\textbf{x}}B y ,$$ </p>
<p>where the vector potential does not depend on $x$. In this gauge, the entire Hamiltonian is translationally invariant along the $x$ direction, and therefore commutes with the corresponding momentum $p_x$. This allows us to choose $p_x=\hbar k$ as a good quantum number, and our two dimensional Hamiltonian reduces to a one dimensional one:</p>
<p>$$H(k)=p_y^2+(\hbar k-e B y)^2.$$</p>
<p>Apart from a shift of the $y$ coordinate by $y_0(k)=\hbar k/eB$, this is exactly the Hamiltonian of a simple harmonic oscillator! Its eigenvalues are the Landau levels, which are independent of $k$. The corresponding wave functions are those of the harmonic oscillator along the $y$ direction, and plane waves with momentum $k$ along the $x$ direction. In the $y$ direction, they are localized in space within a length $\sim l_B$.</p>
<p>This gives us another way to understand the quantized Hall conductance for ideal two dimensional electron gases.</p>
<p>Now, the electron energies are quantized in Landau levels, and if $n$ Landau levels are filled at a given chemical potential, the filling factor is $\nu=n$. The Streda formula then predicts the Hall conductance as $\sigma_H=\nu e^2/h=n e^2/h$. The longitudinal conductivity must vanish since the gapped system does not allow dissipation of energy in the bulk.</p>
<h1 id="Flux-pumping-of-electrons-in-a-Hall-cylinder"><a href="#Flux-pumping-of-electrons-in-a-Hall-cylinder" class="headerlink" title="Flux pumping of electrons in a Hall cylinder"></a>Flux pumping of electrons in a Hall cylinder</h1><p>We can now see explicitly how the Laughlin pumping argument works, starting from the microscopic description of electrons in terms of Landau levels. Starting from the formulas we derived, it is a little difficult to do so in the Corbino geometry, which has an angular symmetry rather than a translational symmetry. It is very easy if we consider the Laughlin pump for electrons in a cylinder:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/hall_cylinder.svg" alt></p>
<p>In fact the cylinder drawn above and the Corbino disk are completely equivalent - you can imagine deforming one into the other. The advantage of the cylinder is that we get to keep our $(x, y)$ coordinates. The Hall cylinder that we considered for Laughlin’s argument is in fact equivalent to a ribbon in the $(x, y)$ plane, with periodic boundary conditions $x\equiv x+L$ in the $x$ direction ($L$ is the circumference of the cylinder).<br>The periodic boundary conditions along the $x$ direction discretize the allowed values of $k$ as $k=2\pi n/L$.</p>
<p>For the Laughlin pumping argument, we need to introduce a flux through the cylinder. Using Stokes’ theorem, we know that the line integral of the vector potential around the cylinder must be equal to the flux passing through it, $\oint \textbf{dr}\cdot\textbf{A(r)}=\Phi$. So we can introduce a flux through the cylinder by choosing our vector potential $\bf{A}$ as </p>
<p>$$\textbf{A}(x,y)=(B y +\Phi/L),\hat{\textbf{x}},,$$ </p>
<p>very similar to the previous calculation. The resulting Hamiltonian for the states labeled by $n$ is  </p>
<p>$$H=p_y^2+\left(\frac{\hbar 2\pi n}{L}-e B y-\frac{e\Phi}{L}\right)^2,.$$</p>
<p>Comparing the above equation to the quantum harmonic oscillator, we see that the harmonic oscillator levels<br>must be centered at </p>
<p>$$y_0(n) = \left(n-\frac{\Phi}{\Phi_0}\right)\frac{h}{e B L},.$$</p>
<blockquote>
<p>We see from this that the Landau level wave-functions are centered around a discrete set of rings at $y_0(n)$ on the cylinder axis that are labelled by the integer $n$.  As $\Phi$ is increased we see that the centers $y_0$ move so that after one flux quantum $\Delta\Phi=\Phi_0=h/e$ all the electrons have moved down by one step along $y$, i.e. $n \rightarrow n-1$. If $n$ Landau levels are filled then a total charge of $\Delta Q=n e$ will be transferred between the edges, in exact accordance with the Laughlin argument.</p>
</blockquote>
<p>We can now look again at the Laughlin pump, monitoring at the same time the Landau levels. You can see that the total pumped charge jumps in integer steps each time a Landau level passes through the Fermi level.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">"ylims"</span>: [<span class="number">-1.1</span>, <span class="number">1.1</span>],</span><br><span class="line">    <span class="string">"xticks"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"yticks"</span>: [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">"xdim"</span>: <span class="string">r"$k$"</span>,</span><br><span class="line">    <span class="string">"ydim"</span>: <span class="string">r"$E$"</span>,</span><br><span class="line">    <span class="string">"k_x"</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">"title"</span>: <span class="keyword">lambda</span> p: <span class="string">"Landau levels"</span>,</span><br><span class="line">&#125;</span><br><span class="line">W = <span class="number">20</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, B=<span class="number">2</span> * np.pi / (W + <span class="number">1</span>), phi=<span class="literal">None</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = qhe_corbino(r_out=<span class="number">2</span> * W, r_in=<span class="number">20</span>, w_lead=<span class="number">10</span>)</span><br><span class="line">sys1 = qhe_ribbon(W, <span class="literal">True</span>)</span><br><span class="line">HLine = holoviews.HLine(<span class="number">0</span>).opts(style=&#123;<span class="string">"linestyle"</span>: <span class="string">"--"</span>, <span class="string">"color"</span>: <span class="string">"r"</span>&#125;)</span><br><span class="line">mus = np.linspace(<span class="number">0.4</span>, <span class="number">1.4</span>, <span class="number">11</span>)</span><br><span class="line">hm1 = holoviews.HoloMap(&#123;p.mu: plot_pumping(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r"$\mu$"</span>])</span><br><span class="line">hm2 = holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: spectrum(sys1, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r"$\mu$"</span>]</span><br><span class="line">)</span><br><span class="line">hm1 + hm2 * HLine</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">"Consider a cylinder of height $W$, circumference $L$, subject to a magnetic field $B$, "</span></span><br><span class="line">    <span class="string">"and with 2 Landau levels filled. "</span></span><br><span class="line">    <span class="string">"Approximately, how many electrons does it contain?"</span></span><br><span class="line">)</span><br><span class="line">answers = [<span class="string">"$2.\,$"</span>, <span class="string">"$2 W/L\,.$"</span>, <span class="string">"$2 B WL / \Phi_0\, $."</span>, <span class="string">"$ B L^2/\Phi_0\,$."</span>]</span><br><span class="line">explanation = <span class="string">"Based on the form of the Hamiltonian, $y$ goes from $0$ to $W$ and therefore $n$ goes from 0 to $B W L/\Phi_0$."</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">"2u8_2isyi7o"</span>, src_location=<span class="string">"3.2-summary"</span>, res=<span class="string">"360"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">"Questions"</span>, <span class="string">"Laughlin argument"</span>)</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>Copyright： </strong>
              Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://huyiph.xyz/2021/01/07/src/w3_pump_QHE/Laughlinargument/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2021/01/07/src/w3_pump_QHE/QHEedgestates/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            src/w3_pump_QHE/QHEedgestates
          
        </div>
      </a>
    
    
      <a href="/2021/01/07/src/w2_majorana/w2_assignments/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">src/w2_majorana/w2_assignments</div>
      </a>
    
  </nav>


  

  
  
  

  
  
  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020-2021
        huyi
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>

      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="O"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/logs/">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://pan.huyiph.xyz" target="_blank" rel="noopener">网盘</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://aria2.huyiph.xyz" target="_blank" rel="noopener">aria2</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['----------------------', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>




  <script src='https://unpkg.com/mermaid@v8.4.8/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


    
  </div>
</body>

</html>