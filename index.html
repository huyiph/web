<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="demon" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> O</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
      <script src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js"></script>
      
    <link rel="alternate" href="/atom.xml" title="O" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">O</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['————————————————————————————————————————', '', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-hexo部署"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/16/hexo%E9%83%A8%E7%BD%B2/" class="article-date">
  <time datetime="2021-01-16T01:46:40.902Z" itemprop="datePublished">2021-01-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="用Hexo部署博客到Ubuntu服务器"><a href="#用Hexo部署博客到Ubuntu服务器" class="headerlink" title="用Hexo部署博客到Ubuntu服务器"></a>用Hexo部署博客到Ubuntu服务器</h1><h1 id="本地安装Hexo-node-js-git"><a href="#本地安装Hexo-node-js-git" class="headerlink" title="本地安装Hexo,node.js,git"></a>本地安装Hexo,node.js,git</h1><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>首先需要一台Ubuntu服务器，并且可以用<code>ubuntu</code>用户身份正常登陆.</p>
<h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>配置服务器的登陆选项，添加SSH，SSH公钥就用之前安装git时生成的公钥即可.</p>
<p>在本地下载Xshell等工具，登陆方式也可以选为本地的私钥.</p>
<blockquote>
<p>注意在使用Xshell等终端时，若不小心键入了<code>ctrl+s</code>, 则这个命令为暂时挂起终端，只需要按<code>ctrl+q</code>即可继续输入</p>
</blockquote>
<h2 id="安装Git和Nginx"><a href="#安装Git和Nginx" class="headerlink" title="安装Git和Nginx"></a>安装Git和Nginx</h2><p>Git 用于版本管理和部署，Nginx 用于静态博客托管。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git nginx -y</span><br></pre></td></tr></table></figure>

<h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><p>在<code>/var/repo/</code>下创建名为<code>hexo_static</code>的裸仓库。用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/repo/</span><br><span class="line">sudo chown -R $USER:$USER /var/repo/</span><br><span class="line">sudo chmod -R 755 /var/repo/</span><br><span class="line"></span><br><span class="line">cd /var/repo/</span><br><span class="line">git init --bare hexo_static.git</span><br></pre></td></tr></table></figure>

<h2 id="配置Nginx托管文件目录"><a href="#配置Nginx托管文件目录" class="headerlink" title="配置Nginx托管文件目录"></a>配置Nginx托管文件目录</h2><p>创建<code>/var/www/hexo</code>目录，用于Nginx托管，修改目录所有权和权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /var/www/hexo</span><br><span class="line"></span><br><span class="line">sudo chown -R $USER:$USER /var/www/hexo</span><br><span class="line">sudo chmod -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure>

<p>随后修改Nginx的<code>default</code>设置，使<code>root</code>指向<code>hexo</code>目录.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-available/<span class="keyword">default</span></span><br></pre></td></tr></table></figure>

<p>注意一定要加<code>sudo</code>,否则会提醒<code>default</code>是只读文件.</p>
<p>修改文件中对应的项</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span> default_server;</span><br><span class="line">    listen [::]:<span class="number">80</span> default_server ipv6only=<span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line">    root /<span class="keyword">var</span>/www/hexo; # 需要修改的部分</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Vim的操作方法比较特殊，可以在网上查查</p>
</blockquote>
<p>重启Nginx服务，使得改动生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>

<h2 id="创建Git钩子"><a href="#创建Git钩子" class="headerlink" title="创建Git钩子"></a>创建Git钩子</h2><blockquote>
<p>不清楚钩子是什么</p>
</blockquote>
<p>在自动生成的 hooks 目录下创建一个新的钩子文件：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<p>在该文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f</span><br></pre></td></tr></table></figure>

<p>保存并退出文件，并让该文件变为可执行文件。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<h1 id="回到本地配置"><a href="#回到本地配置" class="headerlink" title="回到本地配置"></a>回到本地配置</h1><h2 id="修改Hexo的默认配置"><a href="#修改Hexo的默认配置" class="headerlink" title="修改Hexo的默认配置"></a>修改Hexo的默认配置</h2><p>在站点config.yml中修改博客的地址<code>url</code></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site <span class="keyword">is</span> put <span class="keyword">in</span> a subdirectory, <span class="keyword">set</span> url <span class="keyword">as</span> <span class="string">&#x27;http://yoursite.com/child&#x27;</span> and root <span class="keyword">as</span> <span class="string">&#x27;/child/&#x27;</span></span><br><span class="line"></span><br><span class="line">url: http:<span class="comment">//server-ip # 没有绑定域名时填写服务器的实际 IP 地址。</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>

<h2 id="通过Git部署"><a href="#通过Git部署" class="headerlink" title="通过Git部署"></a>通过Git部署</h2><p>先在任意位置处打开powershell, 从服务器上把<code>hexo_static</code>仓库克隆下来, 以此来将服务器地址添加到受信任的站点中。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ubuntu<span class="variable">@server_ip</span><span class="symbol">:/var/repo/hexo_static</span>.git</span><br></pre></td></tr></table></figure>

<p>注意在第一次进行这一步时会提示是否继续，选yes即可。</p>
<p>再编辑Hexo的<code>config.yml</code>文件，找到Deployment, 修改为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line">  <span class="symbol">type:</span> git</span><br><span class="line">   <span class="symbol">repo:</span> ubuntu<span class="variable">@server_ip</span><span class="symbol">:/var/repo/hexo_static</span>.git</span><br><span class="line">  <span class="symbol">branch:</span> master</span><br></pre></td></tr></table></figure>

<p>最后记得安装Hexo部署到Git仓库的包.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>于是就可用<code>hexo d</code>命令来部署了。大功告成。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w1_topointro/0d"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w1_topointro/0d/" class="article-date">
  <time datetime="2021-01-07T09:19:47.980Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line">%opts Layout [sublabel_format=<span class="string">&#x27;&#x27;</span> aspect_weight=<span class="number">1</span> figure_size=(<span class="number">100</span>) vspace=<span class="number">0.4</span>]</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">randn = np.random.randn</span><br><span class="line"></span><br><span class="line">alphas = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">dims = SimpleNamespace(</span><br><span class="line">    E=holoviews.Dimension(<span class="string">r&quot;$E$&quot;</span>),</span><br><span class="line">    alpha=holoviews.Dimension(<span class="string">r&quot;$\alpha$&quot;</span>),</span><br><span class="line">    Q=holoviews.Dimension(<span class="string">r&quot;$Q$&quot;</span>),</span><br><span class="line">    Q_BdG=holoviews.Dimension(<span class="string">r&quot;$Q_&#123;BdG&#125;$&quot;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_real_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = randn(N, N)</span><br><span class="line">    H += H.T</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cons_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = np.kron(pauli.s0, randn(N, N)) + np.kron(pauli.sz, randn(N, N))</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_symplectic_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="keyword">if</span> N % <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Matrix dimension should be a multiple of 2&quot;</span>)</span><br><span class="line">    sy = np.kron(np.eye(N // <span class="number">2</span>), np.array([[<span class="number">0</span>, -<span class="number">1j</span>], [<span class="number">1j</span>, <span class="number">0</span>]]))</span><br><span class="line">    h = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    h += h.T.conj()</span><br><span class="line">    Th = sy @ h.conj() @ sy</span><br><span class="line">    <span class="keyword">return</span> (h + Th) / <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_chiral_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    temp1 = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    temp2 = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    H = np.kron(pauli.sx, temp1) + np.kron(pauli.sy, temp2)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_BdG_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="comment"># This is antisymmetric basis</span></span><br><span class="line">    H = <span class="number">1j</span> * randn(<span class="number">2</span> * N, <span class="number">2</span> * N)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">energies</span>(<span class="params">alpha, H0, H1</span>):</span></span><br><span class="line">    H = (<span class="number">1</span> - alpha) * H0 + alpha * H1</span><br><span class="line">    <span class="keyword">return</span> np.linalg.eigvalsh(H)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_spectrum</span>(<span class="params">alphas, H0, H1</span>):</span></span><br><span class="line">    spectrum = [energies(a, H0, H1) <span class="keyword">for</span> a <span class="keyword">in</span> alphas]</span><br><span class="line">    <span class="keyword">return</span> np.array(spectrum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_Q</span>(<span class="params">spectrum</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds the number of bands that are under zero energy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    spectrum : numpy array</span></span><br><span class="line"><span class="string">        Array that contains the energies levels for every alpha.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    Q : list</span></span><br><span class="line"><span class="string">        Number of bands under zero energy.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">len</span>(s[s &lt; <span class="number">0</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> spectrum]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_hamiltonian_spectrum</span>(<span class="params">alphas, spectrum, E_range=(<span class="params">-<span class="number">4</span>, <span class="number">4</span></span>)</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function that plots a spectrum for a range of alphas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    spectrum : numpy array</span></span><br><span class="line"><span class="string">        Array that contains the energies levels for every alpha.</span></span><br><span class="line"><span class="string">    E_range : tuple</span></span><br><span class="line"><span class="string">        The upper and lower limit of the y-dimension.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    plot : holoviews.Path object</span></span><br><span class="line"><span class="string">        Plot of alphas vs. spectrum.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    E_min, E_max = E_range</span><br><span class="line">    energy = dims.E.clone()</span><br><span class="line">    energy.<span class="built_in">range</span> = <span class="built_in">tuple</span>(E_range)</span><br><span class="line">    plot = (holoviews.Path((alphas, spectrum), kdims=[dims.alpha, energy]) * holoviews.HLine(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [E_min, <span class="number">0</span>, E_max]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_Q</span>(<span class="params">alphas, Q, Q_range, Q_dim=dims.Q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function that plots value of Q for a range of alphas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    Q : numpy array</span></span><br><span class="line"><span class="string">        Vector that contains the value of Q for every alpha.</span></span><br><span class="line"><span class="string">    Q_range : tuple</span></span><br><span class="line"><span class="string">        The upper and lower limit of the y-dimension.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    plot : holoviews.Path object</span></span><br><span class="line"><span class="string">        Plot of alphas vs. Q.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    Q_min, Q_max = Q_range</span><br><span class="line">    Q_mid = (Q_max + Q_min) / <span class="number">2</span></span><br><span class="line">    Q_dim = Q_dim.clone()</span><br><span class="line">    Q_dim.<span class="built_in">range</span> = <span class="built_in">tuple</span>(Q_range)</span><br><span class="line">    plot = holoviews.Area((alphas, Q), kdims=[dims.alpha], vdims=[Q_dim]).opts(style=&#123;<span class="string">&quot;alpha&quot;</span>: <span class="number">0.4</span>&#125;)</span><br><span class="line">    plot *= holoviews.Curve((alphas, Q), kdims=[dims.alpha], vdims=[Q_dim])</span><br><span class="line">    <span class="keyword">return</span> plot.opts(</span><br><span class="line">        plot=&#123;</span><br><span class="line">            <span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</span><br><span class="line">            <span class="string">&quot;yticks&quot;</span>: [<span class="built_in">int</span>(Q_min), <span class="built_in">int</span>(Q_mid), <span class="built_in">int</span>(Q_max)],</span><br><span class="line">            <span class="string">&quot;aspect&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="Topology-and-symmetry"><a href="#Topology-and-symmetry" class="headerlink" title="Topology and symmetry"></a>Topology and symmetry</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;5ysdSoorJz4&quot;</span>, src_location=<span class="string">&quot;1.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Zero-dimensional-quantum-systems"><a href="#Zero-dimensional-quantum-systems" class="headerlink" title="Zero-dimensional quantum systems"></a>Zero-dimensional quantum systems</h1><p>Imagine a quantum system with a finite number of states $N$. The Hamiltonian of such a system is represented by a matrix $H$ of dimension $N\times N$.<br>This matrix is Hermitian, $H=H^\dagger$. Its real eigenvalues $E_n$ correspond to the allowed energies of the system,</p>
<p>$$H,\left|n\right\rangle = E_n,\left|n\right\rangle,,$$</p>
<p>with $\left|n\right\rangle$ the corresponding eigenstate. Let’s say that $H$ describes a small quantum dot with a few levels. We can imagine that the quantum dot is in weak contact with a metallic lead, as in the following sketch:</p>
<p><img src="/2021/01/07/src/w1_topointro/0d/dot.svg" alt></p>
<p>The presence of a metallic lead allows us to measure all the energies $E_n$ of the electronic states in the dot with respect to the Fermi level $E_F$ of the electrons in the metallic lead. In the following we will set $E_F=0$. Hence, all negative energies $E_n&lt;0$ correspond to filled states in the dot, and all positive energies $E_n&gt;0$ to empty states. In the sketch, the lead and the dot are separated by a potential barrier, such that they are only coupled very weakly. Thus, we can still consider the dot as an isolated system, to a good approximation.</p>
<p>We are now ready to start on the main theme of this course, topology.</p>
<h2 id="Topology-and-gapped-quantum-systems"><a href="#Topology-and-gapped-quantum-systems" class="headerlink" title="Topology and gapped quantum systems"></a>Topology and gapped quantum systems</h2><p>Topology studies whether objects can be transformed continuously into each other. In condensed matter physics we can ask whether the Hamiltonians of two quantum systems can be continuously transformed into each other. If that is the case, then we can say that two systems are ‘topologically equivalent’.</p>
<p>If we considered all Hamiltonians without any constraint, every Hamiltonian could be continuously deformed into every other Hamiltonian, and all quantum systems would be topologically equivalent. This changes drastically if we restrict ourselves to systems with an energy gap. This means that there is a finite energy cost to excite the system above its ground state.<br>If an energy gap is present, then the Hamiltonian of the system has no eigenvalues in a finite interval around zero energy.</p>
<p>We can now use the following criterion: we say that two gapped quantum systems are topologically equivalent if their Hamiltonians can be continuously deformed into each other <em>without ever closing the energy gap</em>.</p>
<p>In the following, we will see that often one is interested in some more specific criterion: for instance, that some symmetry may be preserved throughout the continuous path which connects two Hamiltonians.</p>
<p>However, for the moment let’s just see these ideas at play using our quantum dot as a simple test case. Imagine our dot is initially described by a random $H$, such as:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">30</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure>

<p>For simplicity, we have taken $H$ to be real. Let’s now deform this Hamiltonian into another Hamiltonian $H’$, also real. We can imagine that this deformation describes the changes that occur to the dot as an external parameter, such as a gate voltage, is varied. We can parameterize the deformation by</p>
<p>$H(\alpha) = \alpha H’ + (1-\alpha) H,$</p>
<p>so that at $\alpha=0$ we are at the initial Hamiltonian and at $\alpha=1$ we are at the final Hamiltonian. Let’s see what the energy levels do as a function of $\alpha$ (we use more levels here than in the matrix above so that the spectrum looks more interesting).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">69</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum)</span><br></pre></td></tr></table></figure>

<p>You may notice from the plot that as $\alpha$ varies, it can happen that an energy level crosses zero energy. When this happens, we break the condition that there should be an energy gap in the system. Notice, however, that this does not necessarily mean that there is no continuous transformation between $H$ and $H’$ such that the gap does not close. It simply means that this particular path has gap closings. Perhaps it is possible to find another path which does not.</p>
<p>So are $H$ and $H’$ topologically equivalent or not? Let’s look at this situation:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">6</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum)</span><br></pre></td></tr></table></figure>

<p>We see that one level does cross zero (even twice), but it seems obvious that we can just push it down a little bit and we find a continuous path between two Hamiltonians. So we need to come up with an easier way to figure out if Hamiltonians can be transformed into each other or not.</p>
<h1 id="The-concept-of-a-topological-invariant"><a href="#The-concept-of-a-topological-invariant" class="headerlink" title="The concept of a topological invariant"></a>The concept of a topological invariant</h1><p>In order to know whether there is any path which connects $H$ and $H’$ without closing the gap, we can count the number of levels below zero energy, i.e. the number of filled energy levels. This is possible because the eigenvalues of gapped Hamiltonians can move freely as long as they don’t cross zero energy. Therefore continuous transformations exist exactly between Hamiltonians with the same number of energy levels below zero.</p>
<p>Since this number can not change under continuous transformations inside the set of gapped Hamiltonians, we call it a <em>topological invariant</em> $Q$.</p>
<p>Below, we plot the energy levels along our path from $H$ to $H’$ again, together with our topological invariant, the number of filled energy levels. You can see that this number changes between 3, 4 and 5. Hence we can say that $H$ and $H’$ are not topologically equivalent.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">69</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum)</span><br><span class="line">    + plot_Q(alphas, Q, [<span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line">).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>The plot makes it clear that we do not actually have to count the number of filled energy levels for both $H$ and $H’$, so it is enough to keep track of <em>zero energy crossings</em>. Whenever an energy level crosses zero energy, the number of levels below zero energy changes. Such a crossing therefore changes the topological invariant. We call that a <em>topological phase transition</em>.</p>
<p>If two Hamiltonians have a different topological invariant, they must be separated by such a transition. In other words, it is impossible to go from one to the other without closing the gap.</p>
<p>On the other hand, if there are equally many levels crossing from below to above zero energy as the other way around, the number of levels below zero energy does not change. The topological invariant is therefore the same for the initial and final Hamiltonian. In this case, there must be a continuous transformation between the initial and final Hamiltonian which does not close the gap.</p>
<p>Once we have identified a topological invariant, we can <em>classify</em> all quantum Hamiltonians according to its value. In this way we create classes of Hamiltonians which are all topologically equivalent, and we can keep track of all the different <em>topological phases</em> that these Hamiltonians can support.</p>
<h2 id="Role-of-conservation-laws"><a href="#Role-of-conservation-laws" class="headerlink" title="Role of conservation laws"></a>Role of conservation laws</h2><p>Let’s now consider the case that the Hamiltonian of the quantum dot satisfies a symmetry constraint. This means that there is a unitary matrix, for example $U = \sigma_z \otimes 1!!1$ where $\sigma_z$ is the third Pauli matrix, such that the Hamiltonian commutes with this matrix:</p>
<p>$$U^\dagger H U = H.$$</p>
<p>This means that the system has a conservation law, and that the Hamiltonian can be brought to a block-diagonal form:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modes = <span class="number">5</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">H0 = make_cons_ham(<span class="number">2</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure>

<p>We can now look at the spectrum and the topological invariant of each subblock individually,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%%opts Layout [aspect_weight=<span class="number">1</span> fig_inches=(<span class="number">8</span>, <span class="number">6</span>) fig_size=<span class="number">100</span> ]</span><br><span class="line">np.random.seed(<span class="number">13</span>)</span><br><span class="line">H0 = make_cons_ham(modes)</span><br><span class="line">H1 = make_cons_ham(modes)</span><br><span class="line">spectrum1 = find_spectrum(alphas, H0[:modes, :modes], H1[:modes, :modes])</span><br><span class="line">spectrum2 = find_spectrum(alphas, H0[modes:, modes:], H1[modes:, modes:])</span><br><span class="line">Q1 = find_Q(spectrum1)</span><br><span class="line">Q2 = find_Q(spectrum2)</span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum1, [-<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    + plot_hamiltonian_spectrum(alphas, spectrum2, [-<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    + plot_Q(alphas, Q1, [<span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">    + plot_Q(alphas, Q2, [<span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">).cols(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>and combine them to get the spectrum and the topological invariant of the whole system:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>As you can see, unitary symmetries play a rather boring role. As usual, they allow to reduce the dimension of the problem at hand, but nothing more. There are however other symmetries which can have a rich influence on topology. An important example is time-reversal symmetry, as we will see next.</p>
<h1 id="Time-reversal-symmetry"><a href="#Time-reversal-symmetry" class="headerlink" title="Time-reversal symmetry"></a>Time-reversal symmetry</h1><p>In our previous examples, you might have wondered, whether there was anything special with choosing real matrices? Indeed there was something special. A real Hamiltonian is a manifestation of time-reversal symmetry. Time-reversal symmetry is represented by an anti-unitary operator, and as such it can always be written as the product $\mathcal{T}=U\mathcal{K}$ of a unitary matrix times complex conjugation. In the case above, we had simply $\mathcal{T}\equiv\mathcal{K}$. Our real Hamiltonians clearly obeyed time-reversal symmetry since $H=H^*$.</p>
<p>Let’s now break time-reversal symmetry, create random Hamiltonians with complex entries and see what happens.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">91</span>)</span><br><span class="line">H0 = make_random_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">92</span>)</span><br><span class="line">H0 = make_random_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>As you can see, there aren’t really many differences with the previous case. The different energy levels move, and the topological invariant changes when one of them crosses zero.</p>
<p>There is, however, a very important case where time-reversal symmetry makes a real difference. For systems with spin $1/2$, time-reversal symmetry has the operator</p>
<p>$$<br>\mathcal{T}=i\sigma_y \mathcal{K},<br>$$</p>
<p>with $\sigma_y$ the second Pauli matrix acting on the spin degree of freedom. In that case $\mathcal{T}^2=-1$. A Hamiltonian with this type of time-reversal symmetry obeys the equation</p>
<p>$$<br>H = \sigma_y, H^* \sigma_y.<br>$$</p>
<p>The following matrix is an example of such Hamiltonian:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">49</span>)</span><br><span class="line">H0 = make_random_symplectic_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure>

<p>Hamiltonians of this type have the following property: every energy eigenvalue $E_n$ is doubly degenerate (Kramers’ degeneracy). We can see the consequences of Kramers’ degeneracy on our game of deforming one random Hamiltonian into another.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">2285</span>)</span><br><span class="line">H0 = make_random_symplectic_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_symplectic_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>While the spectrum looks quite similar to the previous ones, whenever a line crosses zero energy, our topological invariant makes a jump of two, and not one! In this case, time-reversal symmetry constrains the topological invariant to only take even values. This is an example of how topological properties can be influenced by discrete symmetries.</p>
<h1 id="Sublattice-symmetry"><a href="#Sublattice-symmetry" class="headerlink" title="Sublattice symmetry"></a>Sublattice symmetry</h1><p>We just saw that time-reversal symmetry can forbid the topological invariant to take a certain set of values. We now study another case where a symmetry changes the topological properties dramatically.</p>
<p>Let’s now take a system where we can split all the degrees of freedom into two groups (say group $A$ and group $B$) such that the Hamiltonian only has nonzero matrix elements between two groups, and not inside each group. This situation arises naturally when the lattice has two sublattices, as in the hexagonal carbon lattice of graphene. So let’s imagine our quantum dot is now a graphene dot:</p>
<p><img src="/2021/01/07/src/w1_topointro/0d/graphene_dot.svg" alt></p>
<p>As a consequence of sublattice symmetry, the Hamiltonian of the graphene dot looks like this:</p>
<p>$$<br>H =<br>\begin{pmatrix}<br>0 &amp; H_{AB} \<br>H_{AB}^\dagger &amp; 0<br>\end{pmatrix}.<br>$$</p>
<p>We can once again generate a random Hamiltonian with sublattice symmetry, here:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">98</span>)</span><br><span class="line">pprint_matrix(make_chiral_ham(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>If we introduce a diagonal matrix $\sigma_z$ that equals $+1$ for sites on sublattice $A$, and $-1$ for sites on sublattice $B$, we can write the sublattice symmetry of the Hamiltonian as</p>
<p>$$<br>\sigma_z H \sigma_z = -H.<br>$$</p>
<p>This immediately means that if $(\psi_A, \psi_B)^T$ is an eigenvector of the Hamiltonian with energy $\varepsilon$, then<br>$(\psi_A, -\psi_B)^T$ is an eigenvector with energy $-\varepsilon$. A symmetric spectrum is the consequence of sublattice symmetry.</p>
<p>What does this mean for the topological classification?<br>Clearly, the number of states with negative energy is the same as the number of states with positive energy, and that means we don’t ever expect a single level to cross zero energy.</p>
<p>Let’s once again see if this is correct by transforming a random Hamiltonian with sublattice symmetry into another one.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modes = <span class="number">10</span></span><br><span class="line">np.random.seed(<span class="number">99</span>)</span><br><span class="line">H0 = make_chiral_ham(modes)</span><br><span class="line">H1 = make_chiral_ham(modes)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">3</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>Indeed, we can deform all the Hamiltonians with sublattice symmetry into one another without closing the gap.<br>This means that an extra symmetry may render topological classification trivial.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;OK, let&#x27;s see what we have so far. Which symmetry certainly &quot;</span></span><br><span class="line">    <span class="string">&quot;does not restrict the values that the topological invariant can take?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Spinless time-reversal symmetry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sublattice symmetry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Conservation law&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Spinful time-reversal symmetry&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;We cannot be sure about the conservation law, since the blocks may have different remaining symmetries. &quot;</span></span><br><span class="line">    <span class="string">&quot;And we just saw that sublattice symmetry makes every system trivial, while spinful time-reversal &quot;</span></span><br><span class="line">    <span class="string">&quot;makes the numbers of levels even.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">0</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Particle-hole-symmetry"><a href="#Particle-hole-symmetry" class="headerlink" title="Particle-hole symmetry"></a>Particle-hole symmetry</h1><p>There is another symmetry that has a strong influence on topology: particle-hole symmetry. It shows up in superconducting systems. As an example, imagine bringing our quantum dot in contact with a superconductor, like this:</p>
<p><img src="/2021/01/07/src/w1_topointro/0d/SCdot.svg" alt></p>
<p>A superconductor will create and annihilate pairs of electrons by breaking apart <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cooper_pair">Cooper pairs</a> and forming them.<br>This results in a Hamiltonian:</p>
<p>$$<br>\mathcal{H} = \sum_{nm} H_{nm} c^\dagger_nc_m + \tfrac{1}{2} (\Delta_{nm} c^\dagger_n c^\dagger_m + \Delta^*_{nm} c_m c_n),<br>$$</p>
<p>where $c^\dagger_n, c_n$ are the creation and annihilation operators of the electrons. We recall that these operators anticommute, obeying the relations $c_nc_m+c_mc_n=0$ and $c^\dagger_n c_m + c_m c^\dagger_n = \delta_{mn}$, where $\delta_{mn}=0$ if $m\neq n$ and $1$ if $m=n$.</p>
<p>The $H$-term is the dynamics of the electrons in the dot, while $\Delta$ describes the pair creation and annihilation. The matrix $\Delta$ is antisymmetric because the fermion operators anticommute. Now $\mathcal{H}$ does not conserve the number of electrons, but still conserves the parity of the number of electrons, that is whether the number of electrons is even or odd. We can now group all the creation and annihilation operators in a vector, $C = (c_1, \dots, c_n, c^\dagger_1, \dots, c^\dagger_n)^T$. Then we write $\mathcal{H}$ in the form ‘row multiplies matrix multiplies column’:</p>
<p>$$<br>\mathcal{H} = \frac{1}{2} C^\dagger H_\textrm{BdG},C,.<br>$$</p>
<p>The matrix $H_\textrm{BdG}$ is known as the Bogoliubov-de Gennes Hamiltonian, and it has the following structure:</p>
<p>$$<br>H_\textrm{BdG} = \begin{pmatrix} H &amp; \Delta \ -\Delta^* &amp; -H^* \end{pmatrix}.<br>$$</p>
<p>The Bogoliubov-de Gennes Hamiltonian acts on wave functions whose first half is composed out of annihilation operators of electrons, and the second half out of creations operators of the same electrons.<br>We can think of them as annihilation operators of an extra set of holes, so that we double the amount of degrees of freedom in the system.</p>
<p>Since holes are related to the electrons, $H_{BdG}$ automatically has an extra symmetry.<br>This symmetry exchanges electrons with holes, and has an antiunitary operator $\mathcal{P}=\tau_x \mathcal{K}$, where the Pauli matrix $\tau_x$ acts on the particle and hole blocks. We have that:</p>
<p>$$<br>\mathcal{P} H_\textrm{BdG} \mathcal{P}^{-1} = -H_\textrm{BdG}.<br>$$</p>
<p>Particle-hole symmetry is represented by an anti-unitary operator which anti-commutes with the Hamiltonian (compare this situation with that of time-reversal and sublattice symmetries). Because of the minus sign in the particle-hole symmetry, the spectrum of $H_\textrm{BdG}$ must be symmetric around zero energy (that is, the Fermi level). Indeed, for every eigenvector $\psi = (u, v)^T$ of $H_\textrm{BdG}$ with energy $E$, there will be a particle-hole symmetric eigenvector $\mathcal{P}\psi=(v^<em>, u^</em>)^T$ with energy $-E$.</p>
<h2 id="Fermi-level-crossings-in-a-random-Bogoliubov-de-Gennes-Hamiltonian"><a href="#Fermi-level-crossings-in-a-random-Bogoliubov-de-Gennes-Hamiltonian" class="headerlink" title="Fermi level crossings in a random Bogoliubov-de Gennes Hamiltonian"></a>Fermi level crossings in a random Bogoliubov-de Gennes Hamiltonian</h2><p>Let’s generate a random Bogoliubov-de Gennes Hamiltonian $H_\textrm{BdG}$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modes = <span class="number">2</span></span><br><span class="line">np.random.seed(<span class="number">101</span>)</span><br><span class="line">H0 = make_BdG_ham(modes)</span><br><span class="line">H1 = make_BdG_ham(modes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print in &#x27;normal&#x27; basis</span></span><br><span class="line">H0_normal = np.kron(np.array([[<span class="number">1</span>, -<span class="number">1j</span>], [<span class="number">1</span>, <span class="number">1j</span>]]), np.identity(modes)) @ H0</span><br><span class="line">H0_normal = H0_normal @ np.kron(np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1j</span>, -<span class="number">1j</span>]]), np.identity(modes))</span><br><span class="line">pprint_matrix(H0_normal)</span><br></pre></td></tr></table></figure>

<p>We can now see what happens when we deform it into a second one. You can indeed see clearly that the spectrum is mirrored around the line $E=0$, just like it was in the presence of sublattice symmetry.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modes = <span class="number">10</span></span><br><span class="line">np.random.seed(<span class="number">5</span>)</span><br><span class="line">H0 = make_BdG_ham(modes)</span><br><span class="line">H1 = make_BdG_ham(modes)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">3</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>You can however notice that, unlike in the case of sublattice symmetry, energy levels do not repel around zero energy, so that crossings at zero energy appear.</p>
<h2 id="Fermion-parity-switches"><a href="#Fermion-parity-switches" class="headerlink" title="Fermion parity switches"></a>Fermion parity switches</h2><p>Let’s think a bit more about these crossings. At first, they might look a bit mysterious. In general a crossing between energy levels happens in the presence of a conserved quantity, and our random Bogoliubov-de Gennes Hamiltonian does not seem to have an obvious one. Let’s however recall what we said earlier: While the mean-field Hamiltonian of a superconductor does not conserve the number of particles, it conserves the parity of this number. In other words, forming and breaking Cooper pairs does not affect whether the superconducting quantum dots contains an even or odd number of electrons. In short, fermion parity is a conserved quantity (provided that isolated electrons do not enter or leave the dot, a possibility which we will disregard).</p>
<p>The above observation reveals that the existence of crossings is due to the fermion parity conservation. Fermion parity, however, is a many-body quantity, which cannot be directly described in terms of the single particle picture of the Bogoliubov-de Gennes Hamiltonian.<br>To understand the existence of the crossings, recall that to obtain a Bogoliubov-de Gennes description of the superconductor we had to double the number of degrees of freedom by introducing holes.<br>Hence, unlike in the case of sublattice symmetry, a pair of $\pm E$ energy levels does not corresponds to two distinct quantum states, but to a <em>single</em> quantum state.<br>This quantum state is a coherent superposition of electrons and holes - a <em>Bogoliubov quasiparticle</em>: it has an excitation energy $E$, and it is created by an operator $a^\dagger = u c^\dagger + v c$.<br>Populating the partner state at energy $-E$ is the same as emptying the positive energy state.</p>
<p>When a pair of levels crosses zero energy, the excitation energy $E$ of the Bogoliubov quasiparticle changes sign and it becomes favorable to add a Bogoliubov quasiparticle to, or remove it from the superconducting quantum dot. In other words, at each crossing the fermion parity in the ground state of the dot changes from even to odd, or vice versa. Hence these crossings are <em>fermion parity switches</em>.</p>
<p>Since the ground state fermion parity is preserved by the superconducting Hamiltonian if there are no Bogoliubov quasiparticles crossing zero energy, the ground state fermion parity is the topological invariant of this system. It is clear however that this invariant is of a different nature than the one of the non-superconducting systems, which is given by the number of negative eigenvalues of the Hamiltonian. The latter cannot change for a Bogoliubov-de Gennes Hamiltonian, which has a symmetric energy spectrum, and hence it is not suitable to describe changes in fermion parity. Is there a way to compute this new invariant directly from the Bogoliubov-de Gennes Hamiltonian?</p>
<h2 id="The-Pfaffian-invariant"><a href="#The-Pfaffian-invariant" class="headerlink" title="The Pfaffian invariant"></a>The Pfaffian invariant</h2><p>In order to introduce the new invariant, we have to start with a basis transformation, that makes the Hamiltonian an antisymmetric matrix. We use the following unitary transformation in particle-hole space,</p>
<p>$$<br>\tilde{H}<em>{BdG}=\frac{1}{2}\left( \begin{array}{cc}<br>1 &amp; 1 \<br>i &amp; -i \end{array} \right)<br>H</em>{BdG}<br>\left( \begin{array}{cc}<br>1 &amp; -i \<br>1 &amp; i \end{array} \right),.<br>$$</p>
<p>We then have</p>
<p>$$<br>\tilde{H}_\textrm{BdG} = \frac{1}{2}\begin{pmatrix} H-H^<em>+\Delta-\Delta^</em> &amp; -iH-iH^<em>+i\Delta+i\Delta^</em> \ +iH+iH^<em>+i\Delta+i\Delta^</em> &amp; H-H^<em>-\Delta+\Delta^</em> \end{pmatrix}.<br>$$</p>
<p>We already know that the pairing matrix $\Delta$ is antisymmetric. Since $H$ is Hermitian $H-H^<em>$ is also antisymmetric and $H+H^</em>$ is symmetric. Then we can see that $\tilde{H}_\textrm{BdG}$ is antisymmetric.</p>
<p>There is a special number that we can compute for antisymmetric matrices, the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Pfaffian">Pfaffian</a>. Its rigorous definition is not important for our course. The basic idea is simple: The eigenvalues of antisymmetric matrices always come in pairs. In the case of our $\tilde{H}_{BdG}$, these are the energy eigenvalues $\pm E_n$. By taking their product we obtain the determinant of the matrix, equal to $\prod_n (-E_n^2)$. The key property of the Pfaffian is that it allows to take a square root of the determinant, equal to $\pm \prod_n iE_n$, in such a way that the sign of the product is uniquely defined. At a fermion parity switch a single $E_n$ changes sign, so the Pfaffian changes sign as well (while the determinant stays the same).</p>
<p>This feature of the Pfaffian really makes it what we are looking for. Let’s try out the sign of the Pfaffian as our topological invariant $Q_\textrm{BdG}$:</p>
<p>$$ Q_\textrm{BdG} = \textrm{sign}\left[,\textrm{Pf} (i H_\textrm{BdG}),\right],.$$</p>
<p>We have included a factor of $i$ just for convenience, so that the Pfaffian is a real number.</p>
<p>Whenever we need to compute a Pfaffian we just use the <a target="_blank" rel="noopener" href="http://arxiv.org/abs/1102.3440">Pfapack</a> package that calculates Pfaffians for numerical matrices. Let’s use that package and check that the Pfaffian indeed allows us to calculate the fermion parity of the ground state of $H_\textrm{BdG}$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_pfaffian</span>(<span class="params">alphas, H0, H1</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function caculates the Pfaffian for a Hamiltonian.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    H0 : numpy array</span></span><br><span class="line"><span class="string">        Hamiltonian, same size as H1.</span></span><br><span class="line"><span class="string">    H1 : numpy array</span></span><br><span class="line"><span class="string">        Hamiltonian, same size as H0.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    pfaffians : numpy array</span></span><br><span class="line"><span class="string">        Pfaffians for each alpha.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">H</span>(<span class="params">alpha</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> - alpha) * H0 + alpha * H1</span><br><span class="line"></span><br><span class="line">    pfaffians = [np.sign(np.real(pf.pfaffian(<span class="number">1j</span> * H(a)))) <span class="keyword">for</span> a <span class="keyword">in</span> alphas]</span><br><span class="line">    <span class="keyword">return</span> np.array(pfaffians)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pfaffian = find_pfaffian(alphas, H0, H1)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">1.5</span>, <span class="number">1.5</span>])</span><br><span class="line">    + plot_Q(alphas, pfaffian, [-<span class="number">1.2</span>, <span class="number">1.2</span>], dims.Q_BdG)</span><br><span class="line">).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>You can see how the Pfaffian invariant $Q_\textrm{BdG}$ changes its value from $+1$ to $-1$ at every zero-energy crossing.<br>This means that it is the correct expression for the ground state fermion parity and for the topological invariant.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens to the topological invariant if we take the superconducting&quot;</span></span><br><span class="line">    + <span class="string">&quot; Hamiltonian and set $\Delta=0$?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The Pfaffian invariant still captures all of the topological properties.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hamiltonian loses particle-hole symmetry and becomes topologically trivial.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hamiltonian now has a new conservation law so there are two blocks, each with its own invariant.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It isn&#x27;t allowed to set $\Delta=0$&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;If $\Delta=0$ the numbers of filled electron and hole states is conserved, and so the invariant once again&quot;</span></span><br><span class="line">    <span class="string">&quot; becomes just the number of filled states.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;C7HoXjVbpoM&quot;</span>, src_location=<span class="string">&quot;1.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Hamiltonians, Topology and Symmetry&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w0_background/band_structures"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w0_background/band_structures/" class="article-date">
  <time datetime="2021-01-07T09:15:40.285Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="A-quick-review-of-band-structures"><a href="#A-quick-review-of-band-structures" class="headerlink" title="A quick review of band structures"></a>A quick review of band structures</h1><p>For the material of this course we assume familiarity with basic linear algebra, quantum mechanics and solid state physics.<br>In this chapter, we briefly review the concepts most relevant to this course.<br>If you think you know how you would proceed if you are given to compute the bandstructure of graphene then you can likely skip this chapter.</p>
<h2 id="Quantum-mechanics-electrons-as-waves"><a href="#Quantum-mechanics-electrons-as-waves" class="headerlink" title="Quantum mechanics: electrons as waves"></a>Quantum mechanics: electrons as waves</h2><p>Quantum mechanics begins with stating that particles such as electrons should really be treated<br>as waves. These waves are described by the famous Schrodinger equation<br>$$i\hbar\partial_t \Psi = H\Psi,$$<br>where at this point $\Psi$ is the “wave-function” and $H$ is the Hamiltonian.<br>The problem of analyzing this Schrodinger equation can be reduced to the eigenvalue problem in linear algebra, though in many cases the vector space might be infinite dimensional.<br>In the following, we assume familiarity with basic finite dimensional linear (matrix) algebra.</p>
<h3 id="Schrodinger-equation-besides-electrons"><a href="#Schrodinger-equation-besides-electrons" class="headerlink" title="Schrodinger equation besides electrons"></a>Schrodinger equation besides electrons</h3><p>Our main focus is quantum-mechanical systems, however, as we will see, many ideas apply also in completely classical context of sound propagation and elasticity.<br>To see this, let us  convert a familiar wave-equation for a string in to a Schrodinger-like form.<br>You must have seen a wave-equation for a string that looks like<br>$$\partial_t^2 h-c^2\partial_x^2 h=0,$$<br>where $h(x,t)$ is the vertical displacement of the string.<br>This wave-equation is second order in time.<br>Let’s try to make it first order like the Schrodinger equation by defining $h_1(x,t)=c^{-1} \partial_t h(x,t)$ and $h_2(x,t)=\partial_x h(x,t)$.<br>After doing this we see that our wave-equation turns into a pair of equations that are linear order in time:<br>$$\partial_t h_2 = c\partial_x h_1$$<br>and<br>$$\partial_t h_1=-c\partial_x h_2.$$</p>
<p>We can turn this into the Schrodinger equation if we define:<br>$$\Psi(x,t)=\left(\begin{array}{c}h_1(x,t)\h_2(x,t)\end{array}\right)\quad H=c\left(\begin{array}{cc}0&amp; i\-i &amp; 0\end{array}\right)(-i\partial_x).$$<br>Now those of you who know basic quantum mechanics might say this is a very strange Schrodinger equation.<br>But this indeed is the wave-function for helical Majorana particles that we encounter later on.</p>
<h3 id="Applying-the-Schrodinger-equation"><a href="#Applying-the-Schrodinger-equation" class="headerlink" title="Applying the Schrodinger equation"></a>Applying the Schrodinger equation</h3><p>The wave-function $\Psi$ in the Schrodinger equation that describes electrons is typically a complex though the Hamiltonian is not a matrix (thankfully):<br>$$H=-\frac{\hbar^2}{2m}\partial_x^2 + V(x),$$<br>where $m$ is the mass of the electron and $V(x)$ is the background potential energy over which the electron is moving.</p>
<p>The main things that you should remember about wave equations for electrons are:  </p>
<ul>
<li>$\Psi(x,t)$ is complex, </li>
<li>$H$ is a Hermitian  matrix or operator </li>
<li>density of electrons are related to $|\Psi(x,t)|^2$.</li>
<li>If $N$ is the number of electrons, one must occupy $N$ orthogonal wave-functions.</li>
</ul>
<p>The last point is more subtle and is called the <strong>Pauli exclusion principle</strong>. We elaborate on orthogonality later.</p>
<p>Since we are interested in static properties of electrons in materials for much of our course, it helps to make the simplifying ansatz: $\Psi=e^{-i E t/\hbar}\psi$.<br>This ansatz simplifies the Schrodinger equation to a time-independent form:<br>$$H\psi=E\psi,$$<br>which is an eigenvalue problem in linear algebra.</p>
<p>We can often model electrons in materials within the  <strong>tight-binding</strong> approximation where electrons are assumed to occupy a discrete set of orbitals.<br>We then take $\psi_a$ to be the wave-function of the electron on orbital $a$.<br>The wave-functions $\psi_a$ can be combined into $\psi$, which is then a vector.<br>In this case, the Hamiltonian $H$ becomes a matrix with components $H_{ab}$.<br>These definitions transform the time-independent Schrodinger equation into a matrix eigenvalue problem from linear algebra.<br>Once we know how to set-up the matrix $H_{ab}$ to model a particular material, we can extract the properties of the material from the wave-function components $\psi_a$ and energy (eigenvalue) $E$.<br>A few key properties of the Schrodinger equation $H\psi^{(n)}=E^{(n)}\psi^{(n)}$ are: </p>
<ul>
<li>if $H$ is an $N\times N$ matrix, the eigenvalue index $n$ goes from $n=1,\dots,N$. </li>
<li>$H$ is Hermitian i.e. $H_{ab}=H_{ba}^*$. </li>
<li>Eigenstates are orthogonal i.e. $\psi^{(n)\dagger} \psi^{(m)}=0$ for $m\neq n$.</li>
</ul>
<p>Physicists have a convenient notation for doing linear algebra called the Dirac <strong>bra-ket</strong> notation.<br>In this notation, wave-functions such as $\psi$ are represented by <strong>kets</strong> i.e. $\psi\rightarrow |\psi\rangle$.<br>We construct the ket $|\psi\rangle$ from the components of the wave-function $\psi_a$ using the equation: $$|\psi\rangle=\sum_a \psi_a |a\rangle.$$<br>Similarly, we turn the Hamiltonian $H$ in to  an <strong>operator</strong> using the equation :$$H=\sum_{ab}H_{ab}|a\rangle \langle b|,$$<br>where $H_{ab}$ are the elements of the matrix $H$ from the last paragraph.<br>We call the object $\langle b|$ a <strong>bra</strong> and together with the ket it forms a bra-ket with the property $\langle b| a\rangle=\delta_{ab}$.<br>The Schrodinger equation now looks like $$H|\psi\rangle = E|\psi\rangle,$$<br>which can be checked to be the same equation as the linear algebra form. </p>
<h3 id="Example-Atomic-triangle"><a href="#Example-Atomic-triangle" class="headerlink" title="Example: Atomic triangle"></a>Example: Atomic triangle</h3><p>Let’s now work out the simple example of electrons moving in a triangle of atoms, where each atom has one orbital. We label the orbitals as $|0\rangle,|1\rangle,|2\rangle$.<br>With this labeling, the <strong>hopping</strong> amplitude $t$ of electrons between orbitals has the Hamiltonian<br>$$H=-t(|0\rangle \langle 1|+|1\rangle \langle 2|+|2\rangle \langle 0|)+h.c,$$<br>where $h.c.$ stands for Hermitian conjugate, which means that you reverse the ordering of the labels and take a complex conjugate.<br>We can also write the Hamiltonian in matrix form<br>$$H_{ab}=-\left(\begin{array}{ccc}0&amp;t&amp;t^<em>\t^</em>&amp;0&amp;t\t&amp;t^*&amp;0\end{array}\right).$$<br>Diagonalizing this matrix is a straightforward exercise that results in three eigenvectors $\psi^{(n)}_a$ (with $n=1,2,3$)<br>corresponding to energy eigenvalues<br>$$E^{(n)}=-2 |t| \cos{\theta},|t|\cos{\theta}\pm |t|\sqrt{3}\sin{\theta}$$<br>(where $t=|t|e^{i\theta}$).<br>The corresponding eigenvectors<br>$$\psi^{(n)}_a=3^{-1/2}(1,1,1),3^{-1/2}(1,\omega,\omega^2),3^{-1/2}(1,\omega^2,\omega)$$<br>where $\omega$ is the cube-root of unity (i.e. $\omega^3=1$).</p>
<h2 id="Bloch’s-theorem-for-bulk-electrons"><a href="#Bloch’s-theorem-for-bulk-electrons" class="headerlink" title="Bloch’s theorem for bulk electrons"></a>Bloch’s theorem for bulk electrons</h2><p>Actually, we can even solve the problem of an electron in an N site ring (triangle being $N=3$).<br>The trick to doing this is a neat theorem called Bloch’s theorem.<br>Bloch’s theorem is the key to understanding electrons in a crystal.<br>The defining property of a crystal is that the atomic positions repeat in a periodic manner in space.<br>We account for ALL the atoms in the crystal by first identifying a finite group of orbitals called the <strong>unit-cell</strong>.<br>We choose the unit-cell so that we can construct the crystal by translating the unit cell by a discrete set of vectors called lattice vectors to $n$.<br>We label the orbitals in the unit-cell by the index $l$, which takes a finite set of values.<br>By combining the unit cell and the lattice vectors, we  construct positions $a=(l,n)$<br>of all the orbitals in the crystal.<br>For our example of an atomic ring of size $N$, the index $l$ wouldn’t be needed since there is only one orbital per unit-cell and $n$ would take values $1$ to $N$.<br>In a three-dimensional crystal, $n=(n_x,n_y,n_z)$ would be a vector of integers.<br>The Hamiltonian for a crystal has matrix elements that satisfy $H_{(l,n),(l’,m)}=H_{(l,n-m),(l’,0)}$ for all pairs of unit-cell $n$ and $m$. </p>
<blockquote>
<p>Bloch’s theorem states that the Schrodinger equation for such Hamiltonians in crystals can be solved by the ansatz: $$\psi_{(l,n)}=e^{i k n}u_l,$$<br>where $u_l$ is the periodic part of the Bloch function which is identical in each unit-cell.</p>
</blockquote>
<p>The parameter $k$ is called crystal momentum and is quite analogous to momentum (apart from a factor of $\hbar$)<br>except that it is confined in the range $k\in [-\pi,\pi]$ which is referred to as the <strong>Brillouin Zone</strong>.<br>You can now substitute this ansatz into the Schrodinger equation: $\sum_{l’m}H_{(l,n),(l’,m)}u_{l’}e^{i k m}=E(k) e^{i k n}u_{l}(k)$.<br> Thus the Bloch functions $u(k)$ and energies $E(k)$ are obtained from the eigenvalue equation (so-called Bloch equation) $$H(k)u(k)=E(k)u(k),$$<br>where $$H(k)<em>{ll’}=\sum</em>{m}H_{(l,-m),(l’,0)}e^{-i k m}.$$<br>The Bloch equation written above is an eigenvalue problem at any momentum $k$.<br>The resulting eigenvalues $E^{(n)}(k)$ consitute the bandstructure of a material, where the eigenvalue label $n$ is also called a band index. </p>
<h3 id="Example-Su-Schrieffer-Heeger-model"><a href="#Example-Su-Schrieffer-Heeger-model" class="headerlink" title="Example: Su-Schrieffer-Heeger model"></a>Example: Su-Schrieffer-Heeger model</h3><p>Let us now work through an example.<br>The Su-Schrieffer-Heeger (SSH) model is the simplest model for polyacetylene, which to a physicist can be thought of as a chain of atoms with one orbital per atom.<br>However, the hopping strength alternates (corresponding to the alternating bond-length ) between $t_1$ and $t_2$.<br>Ususally you could assume that since each orbital has one atom there is only one atom per unit cell.<br>But this would mean all the atoms are identical.<br>On the other hand, in polyacetylene, half the atoms are on the right end of a short bond and half of them are on the left.<br>Thus there are two kinds of atoms - the former kind we label $R$ and the latter $L$. Thus there are two orbitals per unit cell that we label $|L,n\rangle$ and $|R,n\rangle$ with $n$ being the unit-cell label.</p>
<p><img src="/2021/01/07/src/w0_background/band_structures/Trans-_CH_n.svg" alt></p>
<p>The Hamiltonian for the SSH model is<br>$$H=\sum_n {t_1(|L,n\rangle\langle R,n|+|R,n\rangle\langle L,n|)+t_2(|L,n\rangle\langle R,n-1|+|R,n-1\rangle\langle L,n|)}.$$<br>This Hamiltonian is clearly periodic with shift of $n$ and the non-zero matrix elements of the Hamiltonian can be written as $H_{(L,0),(R,0)}=H_{(R,0),(L,0)}=t_1$ and $H_{(L,1),(R,0)}=H_{(R,-1),(L,0)}=t_2$.<br>The $2\times 2$ Bloch Hamiltonian is calculated to be: $$H(k)_{ll’=1,2}=\left(\begin{array}{cc}0&amp; t_1+t_2 e^{i k}\t_1+t_2 e^{-ik}&amp;0\end{array}\right).$$</p>
<p>We can calculate the eigenvalues of this Hamiltonian by taking determinants and we find that the eigenvalues are<br>$$E^{(\pm)}(k)=\pm \sqrt{t_1^2+t_2^2+2 t_1 t_2\cos{k}}.$$<br>Since $L$ and $R$ on a given unit-cell surrounded one of the shorter bonds (i.e. with larger hopping ) we expect $t_1&gt;t_2$. As $k$ varies across $[-\pi,\pi]$, $E^{(+)}(k)$ goes from $t_1-t_2$ to $t_1+t_2$. Note that the other energy eigenvalue is just the negative $E^{(-)}(k)=-E^{(+)}(k)$. </p>
<blockquote>
<p>As $k$ varies no energy eigenvalue $E^{(\pm)}(k)$ ever enters the range $-|t_1-t_2|$ to $|t_1-t_2|$. This range is called an <strong>band gap</strong>, which is the first seminal prediction of Bloch theory that explains insulators.</p>
</blockquote>
<p>This notion of an insulator is rather important in our course.<br>So let us dwell on this a bit further. Assuming we have a periodic ring with $2N$ atoms so that $n$ takes $N$ values, single valuedness of the wave-function $\psi_{(l,n)}$ requires that $e^{i k N}=1$.<br>This means that $k$ is allowed $N$ discrete values separated by $2\pi/N$ spanning the range $[-\pi,\pi]$.<br>Next to describe the lower-energy state of the electrons we can fill only the lower eigenvalue $E^{(-)}(k)$ with ane electron at each $k$ leaving the upper state empty.<br>This describes a state with $N$ electrons. Furthermore, we can see that to excite the system one would need to transfer an electron from a negative energy state to a positive energy state that would cost at least $2(t_1-t_2)$ in energy.<br> Such a gapped state with a fixed number of electrons cannot respond to an applied voltage and as such must be an insulator. </p>
<p>This insulator is rather easy to understand in the $t_2=0$ limit and corresponds to the double bonds in the polyacetylene chain being occupied by localized electrons. </p>
<h2 id="k-cdot-p-perturbation-theory"><a href="#k-cdot-p-perturbation-theory" class="headerlink" title="$k\cdot p$ perturbation theory"></a>$k\cdot p$ perturbation theory</h2><p>Let us now think about how we can use the smoothness of $H(k)$ to predict energies and wave-functions at finite $k$ from $H(k=0)$ and its derivatives.<br>We start by expanding the Bloch Hamiltonian<br>$$H(k)\approx H(k=0)+k H^{‘}(k=0)+(k^2/2)H^{‘’}(k=0)$$.<br>Using standard perturbation theory we can conclude that:<br>  the velocity and mass of a non-degenerate band near $k\sim 0$ is written as<br>  $$v_n =\partial_k E^{(n)}(k)= u^{(n)\dagger} H^{‘}(k=0) u^{(n)}$$<br>  and<br>  $$m_n^{-1}=\partial^2_k E^{(n)}(k)=u^{(n)\dagger} H^{‘’}(k=0) u^{(n)}+\sum_{m\neq n}\frac{|u^{(n)\dagger} H^{‘}(k=0) u^{(m)}|^2}{E^{(n)}(k=0)-E^{(m)}(k=0)},$$<br>where $E^{(n)}(k=0)$ and $u^{(n)}(k=0)$ are energy eigenvalues and eigenfunctions of $H(k=0)$. One of the immediate consequences of this is that the effective mass $m_n $ vanishes as the energy denominator $E^{(n)}(k=0)-E^{(m)}(k=0)$ (i.e. gap ) becomes small. This can be checked to be the case by expanding<br>$$E^{(-)}(k)\simeq -(t_1-t_2)-\frac{t_2^2}{(t_1-t_2)}k^2$$. </p>
<h3 id="Discretizing-continuum-models-for-materials"><a href="#Discretizing-continuum-models-for-materials" class="headerlink" title="Discretizing continuum models for materials"></a>Discretizing continuum models for materials</h3><p>The series expansion of $H(k)$ that we discussed in the previous paragraph is a continuum description of a material.<br>This is because the series expansion is valid for small $k$ that is much smaller than the Brillouin zone.<br>The continuum Hamiltonian is obtained by replacing $k$ in the series expasion by $\hbar^{-1}p$, where $p=-i\hbar\partial_x$ is the momentum operator. </p>
<p>A continuum Hamiltonian is sometimes easier to work with analytically then the crystal lattice of orbitals.<br>On the other hand, we need to discretize the continuum Hamiltonian to simulate it numerically. We can do this representing $k$ as a discrete derivative operator: $$k=-i\partial_x\approx -i(2\Lambda)^{-1}\sum_n (|n+1\rangle\langle n|-|n\rangle\langle n+1|).$$<br>The label $n$ is discrete-analogous to the unit-cell label, where the unit cell has size $\Lambda$.<br>To check that this is a representation of the derivative, apply $i k=\partial_x$ to $|\psi\rangle$ as $i k|\psi\rangle\approx \sum_n \frac{\psi_{n+1}-\psi_{n-1}}{2\Lambda}|n\rangle$.<br>In addition, we need to represent the $N\times N$ matrix structure of $H(k=0)$.<br>This is done by introducing label $a=1,\dots N$ so that the Hamiltonian is defined on a space labeled by $|a,n\rangle$.<br>Applying these steps to the the $k\cdot p$ Hamiltonian takes the discrete form:<br>$$H(k)\approx \sum_{n,a,b} H(k=0)<em>{ab}|a,n\rangle \langle b,n| +i H^{‘}(k=0)</em>{ab}(|a,n+1\rangle\langle b,n|-|a,n\rangle\langle b,n+1|),$$<br>where we have dropped the $k^2$ term for compactness.<br>For future reference, $k^2$ would discretize into $k^2=-\sum_n (|n\rangle \langle n+2|+|n+2\rangle\langle n|-2|n\rangle \langle n|)$.</p>
<p>But wait! Didn’t we just go in a circle by starting in a lattice Hamiltonian and coming back to a discrete Hamiltonian?<br>Well, actually, the lattice in the newly discretized model has almost nothing to do with the microscopic lattice we started with.<br>More often than not, the lattice constant $\Lambda$ (i.e. effective size of the unit-cell) in the latter representation is orders of magnitude larger than the microscopic lattice constant.<br>So the discrete model following from $k\cdot p$ is orders of magnitude more efficient to work with than tht microscopic model, which is why we most often work with these.<br>Of course, there is always a danger of missing certain lattice level phenomena in such a coarse-grained model.<br>Practically, we often do not start with an atomistic lattice model, but rather with a continuum $k\cdot p$ model and then discretize it.<br>This is because, the latter models can often be constrained quite well by a combination symmetry arguments as well as experimental measurements.<br>For example the $k\cdot p$ model for the conduction band minimum state of a GaAs quantum well is<br>$$H(k)=\hbar^2 k^2/2m^<em>+\alpha_R (\sigma_x k_y-\sigma_y k_x),$$<br>where $m^</em>$ is the electron effective mass, $\sigma_{x,y}$ are Pauli matrices and $\alpha_R$ is the Rashba spin-orbit coupling. This model is rather complicated to derive from the atomistic level (though it can be done). On the hand, it has also been checked experimentally through transport.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The main goal of this section was to review the simplest models for how electrons in crystals can be described quantum mechanically.</p>
<p>Let us summarize this review of bandstructures: </p>
<ul>
<li>Quantum mechanics views electrons as waves described by the Schrodinger equation.</li>
<li>The Schrodinger equation written in a basis of orbitals becomes a matrix eigenvalue problem from linear algebra.</li>
<li>The Schrodinger equation for electrons in crystals can be solved using Bloch’s theorem, where crystal momentum $k$ is a good quantum number.</li>
<li>The crystal momentum $k$ is periodic within the Brillouin zone.</li>
<li>We can treat the crystal momentum $k$ as a derivative when $k$ is small - called the $k\cdot p$ approximation.</li>
<li>We solve this Hamiltonian numerically by discretizing the derivative $k$.</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w9_disorder/w9_assignments"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w9_disorder/w9_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.885Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h1><h2 id="1D-localization"><a href="#1D-localization" class="headerlink" title="1D localization"></a>1D localization</h2><p>As usual, start by grabbing the notebooks of this week (<code>w9_disorder</code>). They are once again over <a target="_blank" rel="noopener" href="http://tiny.cc/topocm_smc">here</a>.</p>
<p>Our aim now is to verify that Anderson localization works in one-dimensional systems.</p>
<p>Simulate the Anderson model of a ribbon of appropriate and large width $W$  as a function of length $L$.</p>
<p>Anderson model is just the simpest <a target="_blank" rel="noopener" href="http://kwant-project.org/doc/1.0/tutorial/tutorial1">tight binding model on a square lattice</a> with random onsite potential.</p>
<p>Tune your model in the clean limit such that it has a relatively large number of modes (at least 3). Then calculate conductance as a function of $L$ at a finite disorder, while keeping $W$ constant.</p>
<p>The weak disorder regime should look ohmic or classical i.e $g \sim N_{ch}\lambda_{MFP}/L$. Here $\lambda_{MFP}$ is the mean free path, and $N_{ch}$ is the number of channels.</p>
<p>First, verify that when $g \gtrsim 1$ you observe the classical behavior and evaluate the mean free path.</p>
<p>Verify that the scaling also holds for different disorder strengths and different widths.</p>
<p>Examine the plot for larger $L$, but this time plot $\textrm{ln}(g)$ to verify that at large $L$ the conductance $g$ goes as $g \sim \exp(-L/\xi)$. Try to guess how $\xi$ is related to $\lambda_{MFP}$ by comparing the numbers you get from the plot in this part and the previous.</p>
<p>Check what happens when you reduce the disorder? Is there sign of a insulator- metal transition at lower disorder?</p>
<h2 id="Griffiths-phase"><a href="#Griffiths-phase" class="headerlink" title="Griffiths phase"></a>Griffiths phase</h2><p>A disordered Kitaev chain has a peculiar property. Close to the transition point it can have infinite density of states even despite it is insulating.</p>
<p>Calculate the energies of all the states in a finite Kitaev chain with disorder. You’ll need to get the Hamiltonian of the chain by using <code>syst.hamiltonian_submatrix</code> method, and diagonalize it (check the very beginning of the course if you don’t remember how to diagonalize matrices).</p>
<p>Do so for many disorder realizations, and build a histograph of the density of states for different values of average $m$ and of disorder strengh around the critical point $m=0$.</p>
<p>If all goes well, you should observe different behaviors: the density of states in a finite region around $m=0$ has a weak power law divergence, that eventually turns into an actual gap. Check out this paper for details:</p>
<ul>
<li>arXiv:cond-mat/0011200</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Disorder&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-0908-0881"><a href="#arXiv-0908-0881" class="headerlink" title="arXiv:0908.0881"></a>arXiv:0908.0881</h3><p><strong>Hint:</strong> The topological Anderson insulator.</p>
<h3 id="arXiv-0705-0886"><a href="#arXiv-0705-0886" class="headerlink" title="arXiv:0705.0886"></a>arXiv:0705.0886</h3><p><strong>Hint:</strong> One-parameter scaling in graphene.</p>
<h3 id="arXiv-0705-1607"><a href="#arXiv-0705-1607" class="headerlink" title="arXiv:0705.1607"></a>arXiv:0705.1607</h3><p><strong>Hint:</strong> Scaling with Dirac fermions.</p>
<h3 id="arXiv-1208-3442"><a href="#arXiv-1208-3442" class="headerlink" title="arXiv:1208.3442"></a>arXiv:1208.3442</h3><p><strong>Hint:</strong> The average symmetry and weak transitions.</p>
<h3 id="arXiv-1411-5992"><a href="#arXiv-1411-5992" class="headerlink" title="arXiv:1411.5992"></a>arXiv:1411.5992</h3><p><strong>Hint:</strong> A technical paper about localization in 1D, but you don’t need to follow the calculations.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Disorder&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w9_disorder/topoflow"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w9_disorder/topoflow/" class="article-date">
  <time datetime="2021-01-07T09:11:06.885Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> LineCollection</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap, BoundaryNorm</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> la</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the path to a folder containing data files, to work with filters as well.</span></span><br><span class="line">data_folder = (</span><br><span class="line">    <span class="string">&quot;data/&quot;</span> <span class="keyword">if</span> os.path.exists(<span class="string">&quot;data&quot;</span>) <span class="keyword">and</span> os.path.isdir(<span class="string">&quot;data&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;../../data/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_kitaev_chain</span>(<span class="params">L=<span class="number">10</span></span>):</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.disorder:</span><br><span class="line">            <span class="keyword">return</span> (p.m + <span class="number">2</span> * p.t) * pauli.sz</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rand = p.disorder * kwant.digest.gauss(<span class="built_in">str</span>(site.tag), p.salt)</span><br><span class="line">            <span class="keyword">return</span> (p.m + rand + <span class="number">2</span> * p.t) * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz - <span class="number">1j</span> * p.delta * pauli.sy</span><br><span class="line"></span><br><span class="line">    syst[(lat(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>,))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The leads are precalculated.</span></span><br><span class="line">    lead[lat(<span class="number">0</span>)] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    syst = syst.precalculate(</span><br><span class="line">        params=<span class="built_in">dict</span>(p=SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phase_diagram</span>(<span class="params">L, ms, p, num_average=<span class="number">100</span></span>):</span></span><br><span class="line">    syst = make_kitaev_chain(L)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adjust the reflection phase such that it&#x27;s 0 for trivial system.</span></span><br><span class="line">    trivial = SimpleNamespace(m=<span class="number">10.0</span>, t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0</span>, salt=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    phase = kwant.smatrix(syst, params=<span class="built_in">dict</span>(p=trivial)).data[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    phase /= <span class="built_in">abs</span>(phase)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> p.m <span class="keyword">in</span> ms:</span><br><span class="line">        qt = []</span><br><span class="line">        <span class="keyword">for</span> p.salt <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(num_average)):</span><br><span class="line">            s = kwant.smatrix(syst, params=<span class="built_in">dict</span>(p=p)).data</span><br><span class="line">            qt.append(((s[<span class="number">0</span>, <span class="number">0</span>] / phase).real, <span class="built_in">abs</span>(s[<span class="number">0</span>, <span class="number">1</span>]) ** <span class="number">2</span>))</span><br><span class="line">        qt = np.mean(qt, axis=<span class="number">0</span>)</span><br><span class="line">        data.append(qt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(data).T</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The scaling flow of topological insulators is introduced by Alexander Altland from the University of Cologne</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;8gkERY6hXTU&quot;</span>, src_location=<span class="string">&quot;9.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="A-toy-model-for-two-parameter-scaling-the-disordered-Kitaev-chain"><a href="#A-toy-model-for-two-parameter-scaling-the-disordered-Kitaev-chain" class="headerlink" title="A toy model for two-parameter scaling: the disordered Kitaev chain"></a>A toy model for two-parameter scaling: the disordered Kitaev chain</h1><p>Before we learn what happens to topological insulators in the presence of disorder, let’s decide on a specific example for concreteness.</p>
<p>Topology makes the behavior of disordered systems richer, however a careful simulation of properties of disordered topological insulators may take weeks, since we need not only to take large system sizes (we need to consider the lengths much larger than mean free path), but also we need to average over disorder.</p>
<p>Luckily, unlike in the non-topological case, a one-dimensional system can already show interesting properties in the presence of disorder, so we can just reuse the familiar Kitaev chain and add disorder to it.</p>
<p>It is nothing but the same 1D tight-binding model that we saw in week one,</p>
<p>$$<br>H = \sum_n (\mu_n + 2t + m) \tau_z\left|n\right\rangle\left\langle n\right|-\sum_n \left[(t\tau_z+i\Delta\tau_y),\left|n\right\rangle\left\langle n!+!!1 \right| + \textrm{h.c.}\right].<br>$$</p>
<p>For convenience, we introduced a mass $m$ that corresponds to the gap in the Dirac equation. The phase transition happens at $m=0$, and $m&lt;0$ corresponds to the topological phase with Majorana modes at the end.</p>
<p>The only difference from what we used before is that now the chemical potential $\mu_n$ varies randomly from site to site. For example, we can sample the values $\mu_n$ from a Gaussian distribution with mean value $\mu_0 $ and standard deviation $U$.</p>
<h1 id="The-simpler-effect-of-disorder"><a href="#The-simpler-effect-of-disorder" class="headerlink" title="The simpler effect of disorder"></a>The simpler effect of disorder</h1><p>In addition to transmission through a finite chain we can now compute its topological invariant $\mathcal{Q}$.</p>
<p>Just as a reminder: $\mathcal{Q} = \det r$, with $r$ is the reflection matrix from one end of a finite Kitaev chain.</p>
<p>We know that $\mathcal{Q}=-1$ in the topological phase and $\mathcal{Q}=+1$ in the trivial phase. Now, in the presence of disorder, the value of $\mathcal{Q}$ in a finite size system can in principle depend on the particular disorder realization. So just like calculating average conductance, we can average the topological invariant over disorder to describe how topological properties depend on it.</p>
<p>Whenever $\langle Q\rangle = \pm 1$, we know that the system is in one of the two insulating phases and there is no reflection whatsoever.</p>
<p>Let’s try the most obvious thing and see what happens to  $\langle Q\rangle$, as we increase disorder strength.</p>
<p>So below we see $\mathcal{Q}$ averaged over 100 different realizations in a disordered Kitaev chain with 30 sites as we gradually increase $U$:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>) <span class="keyword">and</span> os.path.exists(</span><br><span class="line">    data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span></span><br><span class="line">):</span><br><span class="line">    ms = np.loadtxt(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>)</span><br><span class="line">    qs = np.loadtxt(data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># This cell generates data</span></span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>)</span><br><span class="line">    ms = np.linspace(-<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">50</span>)</span><br><span class="line">    qs = [phase_diagram(<span class="number">30</span>, ms, p)[<span class="number">0</span>] <span class="keyword">for</span> p.disorder <span class="keyword">in</span> np.linspace(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">10</span>)]</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>, ms)</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span>, qs)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">ax.set_prop_cycle(<span class="string">&quot;alpha&quot;</span>, np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(qs)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> qs:</span><br><span class="line">    ax.plot(ms, q)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;$m$&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">r&quot;$\langle Q \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">0.4</span>, <span class="number">0</span>, <span class="number">0.4</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">ax.set_xlim(-<span class="number">0.4</span>, <span class="number">0.4</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.1</span>, <span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line">ax.hlines(<span class="number">0</span>, ax.get_xlim()[<span class="number">0</span>], ax.get_xlim()[<span class="number">1</span>], linestyles=<span class="string">&quot;dashed&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>(Darker color corresponds to larger $U$.)</p>
<p>What you see is that far away from the transition, when the gap in the clean limit is very large, disorder does not matter. Around the transition, the average value of $\mathcal{Q}$ changes from $-1$ and $+1$.</p>
<p>Increasing disorder changes two things: </p>
<ul>
<li>It makes the width of the region where the transition happens larger. This we can understand relatively well, in a finite system adding fluctuations just means we can be (un)lucky and get an opposite value of the topological invariant.</li>
<li>It shifts the separation point between trivial and topological phases towards positive $m$. This looks much more curious: if we start with a trivial and insulating system and add disorder, it appears we can make this system topological!</li>
</ul>
<p>The second effect, despite looking mysterious, appears just because the disorder changes the effective values of the Hamiltonian parameters. For small $U$, this can be understood in terms of the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Born_approximation">Born approximation</a>, which allows to compute <em>effective</em> disorder-averaged band structure parameters, given the properties of disorder. The lowest order correction to $m$ for the disorder Kitaev chain is simply $m_\textrm{eff} - m \sim -U^2$, and weak disorder indeed drives the system to a topologically nontrivial state by lowering the effective value of the mass.</p>
<p>Since this phenomenon appears with disorder, it was initially dubbed “topological Anderson insulator”. This name is certainly not accurate: the band structure parameters approach the effective ones on the length scale of mean free path, and before the Anderson scaling flow begins.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">r&quot;What would happen if instead of $\det r$ we use $sign \det r$ for invariant?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;We would get a step function instead of a smooth curve.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;Not well-defined because $\det r$ becomes complex.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The $Q=\pm 1$ plateaus cancel and give $Q=0$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The curve is qualitatively the same.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">r&quot;Each disorder realization get $\textrm&#123;det&#125; r\sim \pm 1$ except near the transition. So adding sign doesn&#x27;t affect &quot;</span></span><br><span class="line">    <span class="string">&quot;the invariant for most disorder realizations. The intermediate values result from averaging over different &quot;</span></span><br><span class="line">    <span class="string">&quot;realizations.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Two-parameter-scaling-in-one-dimension"><a href="#Two-parameter-scaling-in-one-dimension" class="headerlink" title="Two parameter scaling in one dimension"></a>Two parameter scaling in one dimension</h1><p>Speaking of the scaling flow: the scaling hypothesis appears to be very powerful, does the topology have any impact on it?</p>
<p>We can understand some limits. First of all, if $g\gg 1$, the system is a metal, and there can hardly be any trace of topology left. However when $g \lesssim 1$, the system can become one out of several topologically distinct types of insulators, and we can expect some sort of transition between different insulating phases.</p>
<p>The rational assumption at this point is to assume that the scaling hypothesis still holds, but in addition to $g$ it depends on the average topological invariant of the disordered ensemble $\langle \mathcal{Q} \rangle$.</p>
<p>Just like in the case of the non-topological phases, there is no universal proof that this form of scaling flow is correct. Instead, there is a vast amount of mixed numerical and analytical evidence that this is correct.</p>
<p>Let’s try and verify our hypothesis by constructing the scaling flow of the disordered Kitaev chain. We can do it in the following way:</p>
<ul>
<li><p>Choose a given disorder strength $U$, a given length $L$, and a set of values ${\mu}$ for the chemical potential. For each of these values, we compute $\langle \mathcal{Q} \rangle$ and the average transmission $\langle T \rangle$ over a large number of disorder realizations (as large as possible, in our case 1000). This gives us a set of starting points on the $(\langle \mathcal{Q} \rangle, \langle T \rangle)$ plane.</p>
</li>
<li><p>Increase the chain length $L$, and compute $\langle \mathcal{Q} \rangle, \langle T \rangle$ again for all the values ${\mu}$. We obtain a second set of points on the plane.</p>
</li>
<li><p>Join the points corresponding to the same value of $\mu$.</p>
</li>
<li><p>Increase again the length $L$, and so on…</p>
</li>
</ul>
<p>Here’s what we get:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>) <span class="keyword">and</span> os.path.exists(</span><br><span class="line">    data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span></span><br><span class="line">):</span><br><span class="line">    qs = np.loadtxt(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>)</span><br><span class="line">    ts = np.loadtxt(data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0.8</span>)</span><br><span class="line">    Ls = np.array(np.logspace(np.log10(<span class="number">10</span>), np.log10(<span class="number">180</span>), <span class="number">6</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">    ms = [np.sign(x) * x ** <span class="number">2</span> + <span class="number">0.2</span> <span class="keyword">for</span> x <span class="keyword">in</span> np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">40</span>)]</span><br><span class="line">    qs, ts = <span class="built_in">zip</span>(*[phase_diagram(<span class="built_in">int</span>(L), ms, p, num_average=<span class="number">1000</span>) <span class="keyword">for</span> L <span class="keyword">in</span> Ls])</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>, qs)</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span>, ts)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">npoints = qs.shape[<span class="number">0</span>]</span><br><span class="line">X, Y = qs.T, ts.T</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y):</span><br><span class="line">    points = np.array([x, y]).T.reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    segments = np.concatenate([points[:-<span class="number">1</span>], points[<span class="number">1</span>:]], axis=<span class="number">1</span>)</span><br><span class="line">    lc = LineCollection(</span><br><span class="line">        segments, cmap=<span class="string">&quot;gist_heat_r&quot;</span>, norm=matplotlib.colors.Normalize(<span class="number">0</span>, npoints + <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    lc.set_array(np.array(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, npoints + <span class="number">1</span>))))</span><br><span class="line">    ax.add_collection(lc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.set_xlim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">r&quot;$\langle Q \rangle$&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">r&quot;$\langle T \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">1</span>, -<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">0.0</span>, <span class="number">0.25</span>, <span class="number">0.50</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals]);</span><br></pre></td></tr></table></figure>

<p>The lines have a direction, which tells us how $\langle Q \rangle$ and $\langle T \rangle$ change as we increase $L$. In the plot above, $L$ is increasing in going from bright to dark colors.</p>
<p>The first and the most important observation we can make is that the lines do not intersect, which confirms the scaling hypothesis.</p>
<p>Most of the lines tend to one of the two points $(\langle \mathcal{Q} \rangle, \langle T \rangle) = (-1, 0)$ or $(1, 0)$. These correspond to two insulating systems with different topological invariants. We can say that quantized values of $\langle \mathcal{Q} \rangle$ are insulating, and they correspond to <em>attractive fixed points</em> of the flow.</p>
<p>You can also see that the flow is roughly separated around a vertical <em>critical line</em> at $\langle \mathcal{Q} \rangle=0$. All lines which start from a negative value of $\langle \mathcal{Q} \rangle$ end up at $(-1, 0)$, and all the lines which start from a positive value end up at $(1,0)$.</p>
<p>Finally, the point $(0, 0)$ is a saddle point: the flow goes towards it along the vertical axis, and away from it along the horizontal axis.</p>
<p>We now understand better why two parameter scaling is necessary in the presence of a topological invariant. Even in the presence of disorder, there can be topologically distinct insulating phases. Therefore, saying that every system flows to an insulator is not enough anymore. Including the average topological invariant as a second scaling parameter allows to predict towards <em>which</em> insulating phase the system will flow.</p>
<p>The flow, we just calculated is in fact valid for all one-dimensional topological insulators and superconductors. In the case of a $\mathbb{Z}$ invariant, the saddle points are located at $(\langle \mathcal{Q} \rangle, \langle T\rangle) = (n+1/2, 0)$.</p>
<p>It is important to notice that one important result of the standard scaling theory regarding one dimensional system remains true: in the plot above all lines flow to no transmission, or in other words there are no metallic phases in the flow diagram.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What does the 2 parameter flow diagram predict about the infinite size limit?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Always topological for all parameters.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There&#x27;s a localized topological and non-topological phase separated by a transition point.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Always localized for every parameter.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Almost always conducting except at a transition point.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The phase is determined by the long length (i.e. dark part of the figure) which is almost always in small T&quot;</span></span><br><span class="line">    <span class="string">&quot;i.e. supporting localized states. Here the states either flow to $Q=+1$ or $Q=-1$ (non-top or top respectively) &quot;</span></span><br><span class="line">    <span class="string">&quot;except near $Q=0$ has a slower decay.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Critical-point"><a href="#Critical-point" class="headerlink" title="Critical point"></a>Critical point</h1><p>The scaling flow of 1D topological insulators can be solved exactly, and especially for our system we can very easily derive some of its properties.</p>
<p>The behavior of the disordered Kitaev chain close to the phase transition can be understood within an effective Dirac Hamiltonian in the continuum limit. The Hamiltonian is similar to the one, we studied in week one when we were concerned with a domain wall</p>
<p>$$<br>H_\textrm{Dirac} = v,p,\tau_z + m(x),\tau_y,,<br>$$</p>
<p>with $p$ the momentum along the chain, $v$ the velocity of the modes, and $m(x)$ the position dependent gap which couples left-movers and right-movers.</p>
<p>To model the disordered chain, we take $m(x)$ to be a random function of $x$, just like $\mu_n$ was random in the lattice version. The chain is disordered in a segment of finite size $L$, while for $x&lt;0$ and $x&gt;L$ we set $m=0$ so that in this region we have propagating modes and thus a well-defined scattering problem.</p>
<p>We want to compute the transmission probability through the chain at zero energy. As we saw in week one, an eigenstate at zero energy satisfies the relation</p>
<p>$$<br>\Psi(L) =,\exp,(-\tau_x,\alpha),,\Psi(0),,<br>$$</p>
<p>with a parameter</p>
<p>$$\alpha = \frac{1}{v},\int_0^L, m(x), dx,$$</p>
<p>proportional to the average value of the random mass in the chain.</p>
<p>An incoming wave from the left (negative $x$) entering the scattering region is partially transmitted through it and partially reflected. We can find the reflection and transmission amplitudes $r, t$ by substituting $\Psi(0)=(1,r)^T$ and $\Psi(L) = (t,0)^T$ in the equation above. By solving the simple linear system that comes out of the substitution, we get immediately </p>
<p>$$<br>r = \tanh (\alpha),,;;t = \cosh^{-1} (\alpha).<br>$$</p>
<p>The scattering topological invariant $Q$ for the Kitaev chain is the sign of the determinant of $r$. In our case, since $r$ is just a number, we immediately get</p>
<p>$$Q=r = \tanh\alpha,.$$</p>
<p>We see that the topological transition happens when $\alpha=0$. That is, to model the transition, we think of $m(x)$ as a random function of $x$ which can take positive and negative values with equal probabilities. </p>
<p>The details of the probability distribution for $m(x)$ are not very important as long as the distribution is characterized by a finite correlation length $\xi \ll L$ - that is, values of $m$ at points more distant than $\xi$ are statistically uncorrelated. </p>
<p>If this is the case, $\alpha$ is the sum of an order $\sim L/\xi$ of uncorrelated values of $m$. By using the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Central_limit_theorem">central limit theorem</a>, we can say that $\alpha$ is a normally distributed variable with zero mean and a variance growing linearly in $L$. Since $\alpha$ is a random variable, so is the transmission probability $T=|t^2|=\cosh^{-2}(\alpha)$. From the probability distribution of $\alpha$, we can obtain the scaling behavior of $T$ as</p>
<p>$$<br>\left\langle T \right \rangle \propto 1/\sqrt{L},.<br>$$</p>
<h1 id="Two-parameter-scaling-in-higher-dimensions"><a href="#Two-parameter-scaling-in-higher-dimensions" class="headerlink" title="Two parameter scaling in higher dimensions"></a>Two parameter scaling in higher dimensions</h1><p>Just like the regular scaling flow, the topological one is also richer in $d&gt;1$.</p>
<p>The oldest known example of the two parameter flow is unsurprisingly the quantum Hall effect. The flow looks similar to what we just calculated in 1D, here:</p>
<p><img src="/2021/01/07/src/w9_disorder/topoflow/Three_Dimensional_RG_Flowdiagram_of_the_QHE.png" alt></p>
<p>By Wout Neutkens (Own work) <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, via Wikimedia Commons</p>
<p>The axes are the same as before - the horizontal one is the topological invariant given by $\sigma_H$, and the vertical axis the longitudinal conductance. The saddle point separating the different topological phases is now elevated to a finite critical conductance, which is known to be around $0.5-0.6$ conductance quanta.</p>
<p>Metallic phases are the final part that we need to consider. The appearance of those at high conductance is governed by the same rules as without the topological invariant. The reason for this is that the topological effects are all $\mathcal{O}(1)$ corrections to conductance, and are therefore only important at $g\sim 1$.</p>
<p>An extra attractive metallic fixed point can make the flow diagram more complicated. For example, the metallic phase can completely separate the two insulating phases and eliminate the fixed point. What happens in each particular case is not always certain, and is still an open research topic.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;NY6wPiH0E9E&quot;</span>, src_location=<span class="string">&quot;9.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topological scaling&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w9_disorder/scaling"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w9_disorder/scaling/" class="article-date">
  <time datetime="2021-01-07T09:11:06.884Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the path to a folder containing data files, to work with filters as well.</span></span><br><span class="line">data_folder = (</span><br><span class="line">    <span class="string">&quot;data/&quot;</span> <span class="keyword">if</span> os.path.exists(<span class="string">&quot;data&quot;</span>) <span class="keyword">and</span> os.path.isdir(<span class="string">&quot;data&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;../../data/&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Anderson localization is introduced by Piet Brouwer from the Free University of Berlin.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;sbbyL0RDH-o&quot;</span>, src_location=<span class="string">&quot;9.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>At this point, you might be wondering how we got from talking about topological insulators to disordered metals. Well, we told you several times that topological states are supposed to be robust to disorder, and that this is one of the main reasons why they are so interesting.</p>
<p>Based on the arguments we made in previous weeks, you could convince yourselves that certain properties, such as the bulk boundary correspondence, are robust as long as disorder isn’t enough to close the gap. However, many topological properties that we measure could in principle be susceptible to disorder.</p>
<p>For example, we told you that at the edge of a two-dimensional topological insulator, there is a perfectly conducting state that is robust to disorder. Remember however that we made no such claims about the surface states of a three-dimensional topological insulator! In fact, while in three dimensions the conductance is certainly susceptible to disorder, topology forbids it from becoming zero. Such subtle properties require a more detailed understanding of disorder.</p>
<h1 id="Simple-limits-localized-and-extended-states"><a href="#Simple-limits-localized-and-extended-states" class="headerlink" title="Simple limits: localized and extended states"></a>Simple limits: localized and extended states</h1><p>When we speak of disorder in electronic systems, the main distinction we need to keep in mind is that between extended and localized states.</p>
<p>Let’s start by thinking of a three dimensional metal with a low density of impurities, and hence weak disorder. In this limit, electrons moving through the system are only scattered by impurities every now and then, but otherwise they move ballistically between collisions. This picture is known as the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Drude_model">Drude model</a>, and yields a conductivity given by</p>
<p>$$\sigma=n e^2\tau/m,$$</p>
<p>where $n$ is the electron density, $m$ is the electron mass and $\tau$ the mean free time between collisions. In this limit, the electron wave functions are extended throughout the bulk of the system, much like the plane waves of a clean crystal.</p>
<p>The other extreme is the strong disorder limit, in which there is a strongly fluctuating random potential in the material, for instance due to a high density of impurities. This potential has minima at random positions in the material, where electrons can become trapped. The corresponding wave functions are localized exponentially close to the minima. If the density of impurities is high in the material, all electronic states are of this type. In this situation, the only mechanism for conduction in the material is tunneling between different potential minima. However, the minima may be far apart from each other, which leads to a suppression of conductance and to an insulating state.</p>
<p>Let’s discuss qualitatively the simplest effect of strong disorder on topological states, which are gapped. If we imagine a disorder potential with a Gaussian distribution, there are always “rare regions” where the disorder potential is very deep. Such potentials may thus yield energy levels in the middle of the gap. If disorder is strong, there might even be no energy gap at all! However, the electrons trapped in these rare regions are localized, and do not participate in any of the transport properties of the material.</p>
<blockquote>
<p>Thus, even weak disorder can close the energy gap, which is what protects topology, as discussed so far. However, since these localized states are isolated from each other, and most importantly from the edges, they do not affect any of the topological properties.</p>
</blockquote>
<p>The considerations above make it clear that the presence or absence of an energy gap is not a good criterion to tell whether a system is insulating or not in the presence of strong disorder, and that we need to understand the nature of the electronic states in the system. Our definition of an insulating state must obey a new criterion. As will see next, this criterion can be obtained by studying conductance as a function of the system size.</p>
<h1 id="Conductance-scaling"><a href="#Conductance-scaling" class="headerlink" title="Conductance scaling"></a>Conductance scaling</h1><p>How can we really get away with understanding electrons in disordered potentials without doing any real quantum mechanical calculations? We can only do this in the two aforementioned extreme limits, and actually only in certain dimensions. In principle, to see how the “transition” from extended to localized electrons happens as disorder is increased, one must solve the full quantum mechanical problem. So far, it seems impossible to solve this problem exactly in any dimension other than 1D, so we won’t bother and instead discuss an educated guess, which gives us most of the answer.</p>
<p>To start with, let us be more specific and consider the conductance $G(L)$ of a $d$-dimensional block with sides $L$. The conductance represents the ease with which electrons can propagate through the block, and is has the natural unit $G_0=e^2/h$. Therefore, we can think of the dimensionless conductance $g(L)=G(L)/G_0$ as sort of a higher dimensional analog of the average transmission of electrons between the ends of the system, multiplied by the number of channels. If we take the analogy with transmission seriously, we can guess that the conductance of a combination of blocks, each with conductance $g(L)$, has conductance $g’$ which depends on $g(L)$. This is not very different from what we expect classically. For example, consider a connected pair of metallic blocks of conductivity $g(L)$ each, such that the total conductivity of the connected blocks is $g’$. If the blocks are connected in series, then $g’=g(L)/2$. If they are connected in parallel, then $g’=2 g(L)$. </p>
<p>We can extend the above guess due to Thouless to relate the conductance $g(L)$ of a block of size $L$ to that of a block of size $2L$ i.e. </p>
<p>$$g(2L)=f(g(L)),$$</p>
<p>where $f$ is some function. We can use this equation to relate the conductances at a bunch of different length scales, but not quite at all continuous lengths. We could create a larger set of similar relations by increasing the block size by a factor of $b$ instead of $2$. By choosing $b=1+\delta{\lambda}$, we can write the equation</p>
<p>$$g(b L)=g(L(1+\delta\lambda))=g(L)+g(L)\beta(g(L))\delta\lambda,$$</p>
<p>where $\beta$ is a function called the scaling function or often simply the <em>beta function</em>. Taking the limit $\delta\lambda\rightarrow 0$ we obtain the <em>scaling equation</em></p>
<p>$$\frac{d\textrm{ln}g}{d\textrm{ln}L}=\beta(g).$$</p>
<blockquote>
<p>This is the educated guess known as <em>single parameter scaling</em> that was adopted by  the “Gang of Four” (Abrahams, Anderson, Licciardello and Ramakrishnan) and is essentially an application of the idea of the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Renormalization_group">renormalization group</a> to the conductance problem. Of course, we don’t quite know the function $\beta$, but as we will see in the next unit, it is possible to guess the form in various limits and this is enough to guess the qualitative behavior of the conductance.</p>
</blockquote>
<p>While the above representation will be useful for understanding the “flow diagram”, the above scaling hypothesis has a simple general solution </p>
<p>$$g(L)=\Phi(L/\xi),$$</p>
<p>where $\Phi$ is a function that is determined entirely by $\beta$, and $\xi$ is a decay length.</p>
<h1 id="Scaling-flow-diagram"><a href="#Scaling-flow-diagram" class="headerlink" title="Scaling flow diagram"></a>Scaling flow diagram</h1><p>Now we are in a position to make use of the scaling hypothesis. We don’t really know $\beta(g)$ in general, but we can compute it for large $g$ i.e. in the metallic/delocalized limit and also in the small $g$ or strongly localized limit. In the strongly localized limit $g\sim g_c e^{-L/\xi}$ so that $\beta(g)=\textrm{ln}(g/g_c)$, while in the weak scattering limit, we can estimate $g$ from the classical Drude formula so that $g\sim L^{(d-2)}$ and $\beta(g)\sim d-2$. In addition, one can calculate “quantum corrections” to the $\beta-$function at large $g$, which turn out to depend on other details such as the symmetry class of the disorder.</p>
<p>The simplest next step is to plot the function $\beta(g)$ using the simplest interpolation between the two limits. The amazing thing is that even the simplest interpolation allows us to guess the physics of the phase diagram. As a side note, this phase diagram is lost in the exact solution we wrote at the end of the last unit in terms of $\Phi$, which may seem counterintuitive to you. But let’s move on to understanding the phase diagram. Below, we plot $\beta(g)$ as a function of $g$:</p>
<p><img src="/2021/01/07/src/w9_disorder/scaling/conductance_scaling.svg" alt></p>
<p>What we see is that for dimensions $d=1,2$ the curve stays below $\beta\leq 0$, while the curve for $d=3$ intersects $\beta=0$. To make it easier to understand the diagram, we’ve turned it into a “flow diagram” by adding arrows along the curve representing how $g$ changes with system size $L$. If $\beta&lt;0$ then the arrow points towards smaller values of $g$, but if $\beta&gt;0$ the arrow points towards larger values of $g$. Thus, the flow diagram tells us that in $d=1,2$ dimensions, $g$ reduces with increasing system size, and therefore the system is insulating.</p>
<p>The situation is different in $d=3$ dimensions. If the conductance $g$ is large enough to begin with, then $\beta &gt; 0$ and the arrow points to larger values of $g$. This means that the conductance grows with increasing system size. On the other hand, if disorder is large enough such that $\beta &lt; 0$ initially, $g$ decreases as the system size increases. The separation point $\beta = 0$ between these two behaviours is the <em>metal-insulator transition</em>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;How is the flow in the diagram above altered if we stack 10 1D systems next to each other and weakly couple them?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Nothing changes.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;$\beta$ is multiplied by 10.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The scaling hypothesis doesn&#x27;t apply since we don&#x27;t have a 1D system anymore.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;$\beta$ is altered in some way, since we have a different disordered system now.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;The scaling hypothesis tells us that the details of the Hamiltonian don&#x27;t matter, so the scaling flow stays the same.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">0</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The 2D case is special: in the classical limit $g \gg 1$, the scaling flow disappears, $\beta \approx 0$. However, there remain <em>quantum corrections</em> to it. These are effects that get weaker with increasing conductance, and they depend on the symmetry class of the Hamiltonian.</p>
<p>Let’s see what happens in the three simplest symmetry classes, those without sublattice or particle-hole symmetry. As we learned last week, these are class A (no symmetries, also called unitary since the matrix of Hamiltonian eigenvalues is unitary), AI ($\mathcal{T}^2 = 1$, orthogonal), and AII ($\mathcal{T} = -1$, symplectic).</p>
<p>A lengthy and technical calculation leads to the following corrections to the scaling flow at $g \gg 1$:</p>
<p><img src="/2021/01/07/src/w9_disorder/scaling/conductance_scaling_2D.svg" alt></p>
<p>So we see that in symmetry classes A and AI the conductance always drops, even though it does so very slowly in the class A, eventually leading to an insulating phase.</p>
<p>The class AII has a critical metal-insulator transition point, and a metallic phase at $g &gt; g_c$, just like a disordered 3D system. The growth of conductance in this system is much slower however: instead of $g \sim L$, in 2D AII we have $g \sim \log L$.</p>
<h1 id="Metal-insulator-transition"><a href="#Metal-insulator-transition" class="headerlink" title="Metal-insulator transition"></a>Metal-insulator transition</h1><p>The most interesting feature of the scaling theory of conductance that we have learned about so far is the existence of a universal critical point at which the behavior of the system changes from insulating (negative $\beta$ function) to metallic (positive $\beta$ function). This is the point $\beta=0$ which appears in 3D and in 2D in class AII. Let’s study such a critical point in more detail.</p>
<p>The first thing to observe is that at the critical point, we have $d\ln g/ d\ln L = 0$, so the conductance takes a <em>scale-invariant</em> value $g=g_c$ which is independent of $L$.</p>
<p>In practice, this behavior can be observed at a fixed $L$ by varying one parameter $\alpha$ appearing in the model under study, typically the disorder strength or the chemical potential. The average conductance $\langle g \rangle$ is then computed as a function of $\alpha$ for different values of $L$. One then obtains a plot like the following:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">data = np.loadtxt(data_folder + <span class="string">&quot;data_from_doru.dat&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">cmap = plt.get_cmap(<span class="string">&quot;gist_heat&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    x, y = data[i::<span class="number">3</span>, <span class="number">0</span>], data[i::<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    error = data[i::<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">    L = data[i, <span class="number">1</span>]</span><br><span class="line">    color = cmap(np.log(L - <span class="number">26</span>) / np.log(<span class="number">243</span> - <span class="number">26</span>) * <span class="number">0.7</span>)</span><br><span class="line">    ax.errorbar(x, y, yerr=error, label=<span class="string">&quot;$L=%i$&quot;</span> % L, color=color)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;$V$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">r&quot;$\langle G \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">5.5</span>, <span class="number">5.75</span>, <span class="number">6</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">ax.set_xlim(<span class="number">5.5</span>, <span class="number">6.0</span>)</span><br><span class="line">ax.set_ylim(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>(We thank Doru Sticlet for providing the data for this plot)</p>
<p>The plot above was computed for a 2D tight-binding model in class AII, essentially electrons hopping on a square lattice in the presence of a strong Rashba spin-orbit coupling. In this case, the average conductance was computed as a function of onsite disorder strength $V$.</p>
<p>We see that there is a point $V = V_c\simeq 5.8$ which distiguishes two different behaviors. For $V &lt; V_c$, conductance increases with system size: the system is metallic. For $V &gt; V_c$, conductance decreases with system size: the system is insulating. Hence by comparing different curves at fixed $V$ we can easily ‘see’ the sign of the $\beta$ function in our numerical calculations.</p>
<p>At $V = V_c$, all the curves overlap in the same point: we find that $g$ is basically independent of $L$. This is the critical point. In the plot above, the critical value of conductance is $g_c \simeq 1.3$. (Note that in a typical numerical calculations the curves will not cross precisely at the same point because the systems under consideration are too small. This leads to an entire field of study regarding the finite-size corrections to the scaling theory).</p>
<p>Let us study the conductance scaling around this point. The beta function changes sign at $g_c$, and in its vicinity we can consider it to be a linear function of $g$:</p>
<p>$$\beta(g) = \frac{1}{\nu},\frac{g-g_c}{g_c},,$$</p>
<p>where $\nu$ is just a coefficient and $g-g_c\ll g_c$. On the insulating side of the transition, it is convenient to write down $g  = g_c - \delta g$. Using the fact that $\ln g \simeq - \delta g/ g_c + \ln g_c$, and that $g_c$ does not depend on $L$, one obtains the following scaling equation for $\delta g$,</p>
<p>$$ \frac{d \delta g}{d \ln L} = \frac{\delta g}{\nu},.$$</p>
<p>Integrating this equation gives a power law,</p>
<p>$$ \frac{\delta g(L)}{\delta g(L_0)} = \left(\frac{L}{L_0}\right)^{1/\nu},. $$</p>
<p>At a fixed $L_0$, the behavior close to the transition is given by $\delta g(L_0) \simeq a(L_0) (V-V_c)$. So we get</p>
<p>$$ g(L) =  g_c - a(L_0),(V-V_c) , (L/L_0)^{1/\nu} = g_c - a(L_0),(L/\xi)^{1/\nu},.$$</p>
<p>The length $\xi = L_0,(V-V_c)^{-\nu},$ is the localization length, which diverges at the transition point $V=V_c$. The number $\nu$ is known as the <em>critical exponent</em>, and determines the scaling behavior of the conductance close to the critical point.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">r&quot;What would we see if $\beta$ crossed from positive to negative values?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Small conductances would have a metallic phase, where $g$ grows indefinitely, &quot;</span></span><br><span class="line">    <span class="string">&quot;while large $g$ would lead to an insulator.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;We would see a critical phase, where all conductances converge to the same value.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;This is just the same metal-insulator transition since $\beta(g_c) = 0$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;This is an impossible scaling function.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Both larger conductances and smaller conductances flow towards the critical value, &quot;</span></span><br><span class="line">    <span class="string">&quot;so all systems get the same conductance when their size becomes large enough. &quot;</span></span><br><span class="line">    <span class="string">&quot;This is an attractive critical point.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Absence-of-localization-for-topological-insulators"><a href="#Absence-of-localization-for-topological-insulators" class="headerlink" title="Absence of localization for topological insulators"></a>Absence of localization for topological insulators</h1><p>Finally let’s remark on how the conductance scaling flow is modified on the protected surfaces of topological insulators.</p>
<p>At large conductances we know that the classical scaling must still hold, since this is just Ohm’s law. On the other hand, if we were able to make conductance exactly zero, we would break the bulk-edge correspondence, so $\beta$ cannot be negative at $g \ll 1$.</p>
<p>It turns out, the scaling flow on the surface of a topological insulator is modified by the appearance of an extra term, that vanishes at large conductance, but ensures that there is no localization.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;JdDeBJEBO0s&quot;</span>, src_location=<span class="string">&quot;9.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Anderson localization&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w8_general/w8_assignments"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w8_general/w8_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.882Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-Gaps-and-invariants"><a href="#Simulations-Gaps-and-invariants" class="headerlink" title="Simulations: Gaps and invariants"></a>Simulations: Gaps and invariants</h1><p>As usual, start by grabbing the notebooks of this week (<code>w8_general</code>). They are once again over <a target="_blank" rel="noopener" href="http://tiny.cc/topocm_smc">here</a>.</p>
<h2 id="A-different-analytic-continuation"><a href="#A-different-analytic-continuation" class="headerlink" title="A different analytic continuation"></a>A different analytic continuation</h2><p>You have learned how to map a winding number onto counting the zeros of an eigenproblem in a complex plane. This can be applied to other symmetry classes as well.</p>
<p>Let’s try to calculate the invariant in the 1D symmetry class DIII. If you look in the table, you’ll see it’s the same invariant as the scattering invariant we’ve used for the quantum spin Hall effect,</p>
<p>$$<br>Q = \frac{\textrm{Pf } h(k=0)}{\textrm{Pf } h(k=\pi)} \sqrt{\frac{\det h(k=\pi)}{\det h(k=0)}}<br>$$</p>
<p>In <a target="_blank" rel="noopener" href="http://arxiv.org/abs/1106.6351">this paper</a> (around Eq. 4.13), have a look at how to use analytic continuation to calculate the analytic continuation of $\sqrt{h}$, and implement the calculation of this invariant without numerical integration, like we did before.</p>
<p>In order to test your invariant, you’ll need a topologically non-trivial system in this symmetry class. You can obtain it by combining a Majorana nanowire with its time-reversed copy.</p>
<p>This is a hard task; if you go for it, try it out, but don’t hesitate to ask for help in the discussion below.</p>
<h2 id="Finding-gaps"><a href="#Finding-gaps" class="headerlink" title="Finding gaps"></a>Finding gaps</h2><p>The analytic continuation from $e^{ik}$ to a complex plane is also useful in telling if a system is gapped.</p>
<p>Using the mapping of a 1D Hamiltonian to the eigenvalue problem, implement a function which checks if there are propagating modes at a given energy.</p>
<p>Then implement an algorithm which uses this check to find the lowest and the highest energy states for a given 1D Hamiltonian $H = h + t e^{ik} + t^\dagger e^{-ik}$ (with $h$, $t$ arbitrary matrices, of course).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Topological invariants&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1006-0690"><a href="#arXiv-1006-0690" class="headerlink" title="arXiv:1006.0690"></a>arXiv:1006.0690</h3><p><strong>Hint:</strong> The most general classification.</p>
<h3 id="arXiv-1310-5281"><a href="#arXiv-1310-5281" class="headerlink" title="arXiv:1310.5281"></a>arXiv:1310.5281</h3><p><strong>Hint:</strong> Beyond classification.</p>
<h3 id="arXiv-1012-1019"><a href="#arXiv-1012-1019" class="headerlink" title="arXiv:1012.1019"></a>arXiv:1012.1019</h3><p><strong>Hint:</strong> The non-commutative invariants.</p>
<h3 id="arXiv-1106-6351"><a href="#arXiv-1106-6351" class="headerlink" title="arXiv:1106.6351"></a>arXiv:1106.6351</h3><p><strong>Hint:</strong> All about scattering.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;General classification&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w8_general/invariants"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w8_general/invariants/" class="article-date">
  <time datetime="2021-01-07T09:11:06.881Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> sla</span><br><span class="line"></span><br><span class="line">randn = np.random.randn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chern_torus</span>(<span class="params">W=<span class="number">5</span>, L=<span class="number">5</span></span>):</span></span><br><span class="line"></span><br><span class="line">    disorder_potential = randn(W, L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; W) * (<span class="number">0</span> &lt;= y &lt; L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        t, mu, dis_amplitude = p.t, p.mu, p.disorder</span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">4</span> * t - mu) * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        t, delta = p.t, p.delta</span><br><span class="line">        <span class="keyword">return</span> -t * pauli.sz + <span class="number">1j</span> * p.delta * pauli.sx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        t, delta = p.t, p.delta</span><br><span class="line">        <span class="keyword">return</span> -t * pauli.sz - <span class="number">1j</span> * p.delta * pauli.sy</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((-W + <span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, -L + <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">projected_operators</span>(<span class="params">syst, p, energy=<span class="number">0</span></span>):</span></span><br><span class="line">    x, y = np.array([i.pos <span class="keyword">for</span> i <span class="keyword">in</span> syst.sites]).T</span><br><span class="line">    <span class="comment"># Double all entries to take orbitals into account.</span></span><br><span class="line">    x = np.resize(x, (<span class="number">2</span>, <span class="built_in">len</span>(x))).T.flatten()</span><br><span class="line">    y = np.resize(y, (<span class="number">2</span>, <span class="built_in">len</span>(y))).T.flatten()</span><br><span class="line">    x *= <span class="number">2</span> * np.pi / (np.<span class="built_in">max</span>(x) + <span class="number">1</span>)</span><br><span class="line">    y *= <span class="number">2</span> * np.pi / (np.<span class="built_in">max</span>(y) + <span class="number">1</span>)</span><br><span class="line">    op_x = np.diag(np.exp(<span class="number">1j</span> * x))</span><br><span class="line">    op_y = np.diag(np.exp(<span class="number">1j</span> * y))</span><br><span class="line"></span><br><span class="line">    ham = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    ham -= <span class="number">0</span> * np.identity(<span class="built_in">len</span>(ham))</span><br><span class="line">    energies, states = np.linalg.eigh(ham)</span><br><span class="line"></span><br><span class="line">    projector = states[:, energies &lt; energy]</span><br><span class="line"></span><br><span class="line">    op_x = projector.T.conj() @ op_x @ projector</span><br><span class="line">    op_y = projector.T.conj() @ op_y @ projector</span><br><span class="line">    <span class="keyword">return</span> op_x, op_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_terminal</span>(<span class="params">L, W</span>):</span></span><br><span class="line">    t = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; W <span class="keyword">and</span> <span class="number">0</span> &lt;= x &lt; L</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; W</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># definition of system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">3</span> * t</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># definition of leads</span></span><br><span class="line">    lead = kwant.Builder(kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">3</span> * t</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># attaching leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diag_time</span>(<span class="params">N</span>):</span></span><br><span class="line">    syst = two_terminal(N, N)</span><br><span class="line"></span><br><span class="line">    start = time()</span><br><span class="line">    ham = syst.hamiltonian_submatrix()</span><br><span class="line">    ev, evec = sla.eigh(ham)</span><br><span class="line">    res = time() - start</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smat_time</span>(<span class="params">N</span>):</span></span><br><span class="line">    syst = two_terminal(N, N)</span><br><span class="line"></span><br><span class="line">    start = time()</span><br><span class="line"></span><br><span class="line">    smat = kwant.smatrix(syst)</span><br><span class="line"></span><br><span class="line">    res = time() - start</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Fabian Hassler from RWTH Aachen will present the topological invariants</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;ceyus0cRBi0&quot;</span>, src_location=<span class="string">&quot;8.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Applications-of-topological-invariants"><a href="#Applications-of-topological-invariants" class="headerlink" title="Applications of topological invariants"></a>Applications of topological invariants</h1><p>Throughout the course we computed several times a topological invariant of different systems. When is calculating a topological invariant useful or necessary?</p>
<p>The toy model Hamiltonians that we considered do not really require a complicated calculation set up to figure out whether they are topological or not. However, there are two types of applications where a heavy duty algorithm is important. These are:</p>
<ul>
<li>Ab-initio band structures calculations</li>
<li>Disordered systems</li>
</ul>
<p>So, we start with a Hamiltonian of some complicated material, and we want to know if it is topological or not. What’s worse is that we don’t even know in advance if it is gapped or not! If the system is disordered (you’ll learn more about those next week), then in addition we can never simulate a truly infinite system. What we can do is to take chunks of finite size  and hope that it behaves correctly like an infinite system once the sample size is large enough.</p>
<p>This Hamiltonian may have many parameters, so it’s a large $N\times N$ matrix. For systems with a complicated band structure, $N$ is fixed to be the number of orbitals we need to faithfully approximate the Hamiltonian, while in disordered systems we would usually simulate a finite system with linear size $L$, and so $N=L^d$, with $d$ the dimensionality of the space.</p>
<p>There’s a simple rule which allows us to guess how large a disordered system should be, in order to correctly reproduce the topology of an infinite system.</p>
<blockquote>
<p>If the typical decay length of the state at the Fermi level of a disordered system is $\xi$, then we need to take a sample with $L \gtrsim \xi$ to correctly calculate its topological properties.</p>
</blockquote>
<p>The reason why this is true is that in a smaller sample the bulk is not ‘insulating enough’.</p>
<p>So now we know that the main problem is that we need to do something with a large matrix.</p>
<h1 id="Computational-costs"><a href="#Computational-costs" class="headerlink" title="Computational costs"></a>Computational costs</h1><p>How expensive are the calculations? If you look in the literature, you’ll see wildly differently looking algorithms bundled together with different claims of performance. There is actually a very simple way to figure out, and it comes down to an almost universally correct empirical rule:</p>
<blockquote>
<p>Whenever you need to do something with a dense matrix of size $M\times M$ in a numerical calculation, the costs of doing it most likely are $\sim M^3$.</p>
</blockquote>
<p>This is true almost no matter what you do: matrix multiplication, inversion, diagonalization, calculation of a determinant, and dozens of other decompositions all cost the same. The specific value of the numerical prefactor does vary.</p>
<p>The things become more complicated when the Hamiltonian becomes sparse, since then one may efficiently use that most entries in the matrix are zero. For example, multiplying two $M\times M$ banded matrices has a cost $~M$, instead of $M^3$.</p>
<p>Part of our intuition stays true. So since after diagonalizing a Hamiltonian we obtain an $M\times M$ matrix of eigenvectors, typically we still need to perform $\sim M^3$ number of operations.</p>
<p>A scattering matrix is smaller than the matrix of all the eigenvectors, and for our sample with a linear size $L$, the size of the scattering matrix is $L^{d-1}$, as opposed to $L^d$, the size of the Hamiltonian. While this fact isn’t <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/LU_decomposition#Sparse_matrix_decomposition">trivial</a> at <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Nested_dissection">all</a>, calculation of a scattering matrix still costs the cube of its size, so $L^{3d-3}$.</p>
<p>This difference is most pronounced in 2D systems, where the cost of diagonalization results in more than an order of magnitude difference in the system size. On most modern computers diagonalization works up to system sizes of $\sim 100$, and scattering matrix calculations work up to system sizes of $\sim 1000$. This can be best seen over here (but you can also test for yourself):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ns_diag = np.logspace(<span class="number">1</span>, np.log10(<span class="number">80</span>), <span class="number">5</span>)[:<span class="number">4</span>]</span><br><span class="line">diag_times = [diag_time(N) <span class="keyword">for</span> N <span class="keyword">in</span> Ns_diag]</span><br><span class="line"></span><br><span class="line">Ns_smat = np.logspace(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>)[:<span class="number">6</span>]</span><br><span class="line">smat_times = [smat_time(N) <span class="keyword">for</span> N <span class="keyword">in</span> Ns_smat]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(Ns_diag, diag_times, <span class="string">&quot;-o&quot;</span>, label=<span class="string">&quot;diagonalization&quot;</span>)</span><br><span class="line">plt.plot(Ns_smat, smat_times, <span class="string">&quot;-o&quot;</span>, label=<span class="string">&quot;scattering matrix&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">plt.yscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;$N$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;$t [s]$&quot;</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span> ** -<span class="number">3</span>, <span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">plt.yticks([<span class="number">1e-3</span>, <span class="number">1</span>, <span class="number">1e3</span>, <span class="number">1e6</span>])</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="Momentum-integration"><a href="#Momentum-integration" class="headerlink" title="Momentum integration"></a>Momentum integration</h2><p>As you saw, unless we’re lucky, a topological invariant is a $d$-dimensional integral of something like winding number density or Berry curvature. If we deal with the scattering matrix, the Brillouin zone is once again reduced by one dimension, and the integral becomes $(d-1)$-dimensional.</p>
<p>How many points in momentum space do we need? If we are integrating Berry curvature, we want the uncertainty of the integral to be $\lesssim .5$, so that we can round it and get the correct answer. That means that if there’s a Dirac point with a small gap, we need to resolve it in momentum space, and the number of points should scale as $\sim(1/\xi)^d$.</p>
<p>If we consider a disordered system, we must consider a finite system of a large enough size $L \gtrsim \xi$, so that every point on the Brillouin zone is representative, and we just need a single point to effectively estimate the value of the integral (you’ll see later how to do this in one of the techniques).</p>
<p>So let’s take a system with $N$ orbitals in a unit cell, and edge state decay length $\xi$. The cost of computing the topological invariant is:</p>
<ul>
<li>$\sim (N/\xi)^{3d}$ for disordered systems using the full spectrum.</li>
<li>$\sim N^3 / \xi^d$ for band structures using the full spectrum.</li>
<li>$\sim (N/\xi)^{3d-3}$ for disordered systems using scattering approach.</li>
<li>$\sim N^3 / \xi^{d-1}$ for band structures using scattering approach.</li>
</ul>
<h1 id="A-special-thing-about-1D"><a href="#A-special-thing-about-1D" class="headerlink" title="A special thing about 1D"></a>A special thing about 1D</h1><p>There is a special feature of topological invariants in 1D, that dramatically speeds up a calculation. It’s a computational trick that is so elegant and universal that we’d like to share it.</p>
<p>You might remember studying the SSH chain back in week one. This is a similar system to the Majorana chain, but it is characterized by chiral symmetry rather than particle-hole symmetry.</p>
<p>A 1D Bloch Hamiltonian $H(k)$ with chiral symmetry has the form</p>
<p>$$<br>H(k) = \begin{pmatrix} 0 &amp; h(k) \<br>h^\dagger(k) &amp; 0\end{pmatrix},<br>$$</p>
<p>with $h(k) = h_0 + t_L e^{ik} + t_R e^{-ik}$ a matrix containing the onsite term $h_0$, the left hopping $t_L$ and the right hopping $t_R$.</p>
<p>If you look up the table, this Hamiltonian is characterized by a $\mathbb{Z}$ topological invariant. This invariant is the  <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Winding_number">winding number</a> that Fabian Hassler discussed in the introductory video. Let’s again describe its meaning.</p>
<p>We need to find an integer quantity which can only change when the gap of $H(k)$ closes. Now, $H(k)$ can only have a zero eigenvalue if $h(k)$ does, that is if $\det [h(k)]=0$. For a gapped Hamiltonian, $\det [h(k)]$ will in general be a complex number other than zero for all values of $k$.</p>
<p>Let us now try to picture the path that $h(k)$ takes in the complex plane as $k$ is varied from $0$ to $2\pi$. This path must be closed, because $\det [h(0)]$ must be equal to $\det [h(2\pi)]$, and avoid the origin. We may therefore ask: how many times does the path go around the origin? This number must be integer, and it cannot change unless we make the path go through zero. It is our $\mathbb{Z}$ topological invariant, because we can distinguish a clockwise path from a counterclockwise path.</p>
<p>The mathematical expression for the winding number is more obscure than its meaning:</p>
<p>$$<br>Q(H) = \frac{1}{2\pi i},\int_0^{2\pi} dk,\frac{d}{dk},\log,\det[h(k)],<br>$$</p>
<p>but it just counts how much the phase of $\det h$ increases as $k$ goes through the Brillouin zone.</p>
<p>How to take this integral? The trick is to use analytic continuation to a complex plane.</p>
<p>As $k$ varies from $0$ to $2\pi$, $e^{ik}$ goes around the unit circle in the complex plane. Let’s now make a substitution $e^{ik},\to,z$, with $z$ a complex number. The determinant $\det[h(k)]$ becomes a polynomial function in $z$, $f(z) = \det[h_0 + z, t_L + z^{-1}, t_R]$. We now need to compute the following integral on the unit circle </p>
<p>$$<br>Q(H) = \frac{1}{2\pi i},\oint dz ,\frac{d}{dz} \log f(z) = \frac{1}{2\pi i},\oint,dz,\frac{f’(z)}{f(z)}.<br>$$</p>
<p>We can now use a nice result from complex analysis, the <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Argument_principle">argument principle</a>. It tells us that each zero of $f(z)$ inside the unit circle contributes $+1$ to the value of $Q(H)$, and each pole contributes $-1$. Hence, by counting the number of zeros and poles of $f(z)$ inside the unit circle we immediately get the winding number. So, we have reduced the calculation of the topological invariant to finding zeros and poles of the expression $\det[h_0 + z, t_L + z^{-1}, t_R]=0$. The poles are trivial to find, and they are all located at $z=0$.</p>
<p>To find the zeros we notice that we need to solve a problem</p>
<p>$$[z h_0 + z^2 t_L + t_R]\psi = 0.$$</p>
<p>This is a <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Nonlinear_eigenproblem">polynomial eigenvalue problem</a>, and it is trivially mapped onto a standard eigenvalue problem.</p>
<p>$$<br>\begin{pmatrix}<br>-t_r &amp; 0\<br>0 &amp; 1<br>\end{pmatrix} \psi’=<br>z\begin{pmatrix}<br>h_0 &amp; t_L \<br>1 &amp; 0<br>\end{pmatrix} \psi’.<br>$$</p>
<p>So by finding all the eigenvalues $z$ we get all the zeros of $h(z)$ inside the unit circle, and immediately obtain the 1D topological invariant:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_sys</span>(<span class="params">N=<span class="number">4</span></span>):</span></span><br><span class="line">    onsite = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    lefthopping = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    righthopping = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> onsite, lefthopping, righthopping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_singularities</span>(<span class="params">onsite, lefthopping, righthopping</span>):</span></span><br><span class="line">    <span class="comment"># We will have a generalized eigenvalue problem. The two matrices alone do not have much of a physical meaning,</span></span><br><span class="line">    <span class="comment"># so their names are also meaningless: A, B.</span></span><br><span class="line">    n = <span class="built_in">len</span>(onsite)</span><br><span class="line"></span><br><span class="line">    A = np.bmat([[-righthopping, np.zeros((n, n))], [np.zeros((n, n)), np.eye(n)]])</span><br><span class="line"></span><br><span class="line">    B = np.bmat([[onsite, lefthopping], [np.eye(n), np.zeros((n, n))]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scipy.linalg.eigvals(A, B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">winding_plot</span>(<span class="params">onsite, lefthopping, righthopping</span>):</span></span><br><span class="line">    singularities = find_singularities(onsite, lefthopping, righthopping)</span><br><span class="line">    winding = <span class="built_in">sum</span>(<span class="built_in">abs</span>(singularities) &lt; <span class="number">1</span>) - <span class="built_in">len</span>(onsite)</span><br><span class="line">    circle = np.exp(<span class="number">1j</span> * np.linspace(-np.pi, np.pi, <span class="number">30</span>))</span><br><span class="line">    title = <span class="string">&quot;Winding number: $&#123;&#125;$&quot;</span>.<span class="built_in">format</span>(winding)</span><br><span class="line">    kdims = [<span class="string">r&quot;$\operatorname&#123;Re&#125;(z)$&quot;</span>, <span class="string">r&quot;$\operatorname&#123;Im&#125;(z)$&quot;</span>]</span><br><span class="line">    pl = holoviews.Path((circle.real, circle.imag), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>, <span class="string">&quot;linestyle&quot;</span>: <span class="string">&quot;--&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    pl *= holoviews.Points((singularities.real, singularities.imag)).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    pl *= holoviews.Points((<span class="number">0</span>, <span class="number">0</span>)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> pl[-<span class="number">2</span>:<span class="number">2</span>, -<span class="number">2</span>:<span class="number">2</span>].relabel(title).opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">3</span>, <span class="string">&quot;yticks&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">30</span>)</span><br><span class="line">onsite, lefthopping, righthopping = random_sys()</span><br><span class="line">winding_scale = <span class="keyword">lambda</span> scale: winding_plot(</span><br><span class="line">    <span class="number">4</span> * onsite * <span class="number">1.2</span> ** -<span class="built_in">abs</span>(scale),</span><br><span class="line">    lefthopping * <span class="number">1.2</span> ** scale,</span><br><span class="line">    righthopping * <span class="number">1.2</span> ** -scale,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;scale: winding_scale(scale) <span class="keyword">for</span> scale <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>, <span class="number">10</span>)&#125;, kdims=[<span class="string">r&quot;$\alpha$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In the graph above, we see the zeros (red) and poles (blue) of $h(z)$ for some randomly generated system, while we tune a parameter $\alpha$ that gradually changes the topology of the system.</p>
<p>The approach of analytic continuation onto a complex plane works whenever we have only one momentum variable, so for any 1D system, or a 2D system where we compute the scattering, and allows to calculate the integral exactly and in one step.</p>
<h1 id="Real-space-methods"><a href="#Real-space-methods" class="headerlink" title="Real space methods"></a>Real space methods</h1><p>There is also a broad class of algorithms that rely on the real space structure of the system, and on the inability to deform the wave functions of the filled state into completely localized orbitals.</p>
<p>The intuition behind these is coming from <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Noncommutative_geometry">non-commutative geometry</a>, and so it is very hard to explain intuitively. Let us try to illustrate the logic behind those.</p>
<p>The real space invariants are known for many different <a target="_blank" rel="noopener" href="http://arxiv.org/abs/1012.1019">symmetry classes</a>, but for concreteness let’s see how they work for the Chern insulators (and accordingly how we can compute the Chern number).</p>
<p>First, let’s make a finite but large system in a way that it is fully gapped. Of course if it’s topologically non-trivial, we need to remove the edge states, and we’ll do this by applying periodic boundary conditions in both $x$- and $y$-directions.</p>
<p>We can now define periodic $x$ and $y$ coordinates $0 &lt; x \leq L$, $0 &lt; y \leq W$. We can make continuous variables out of these by studying phase factors $\varphi_x = \exp(2 \pi i x / L)$, and $\varphi_y = \exp(2 \pi i y / W)$.</p>
<p>The rough idea is as follows. All the filled states in a gapped material can be made localized, but if the system is topological this localization of the states is never exact (since fully localized states would correspond to a trivial Hamiltonian).</p>
<p>Fully localized states would have their $x$ and $y$ coordinates commuting, so we could try to check if we can approximate $x$ and $y$ coordinates of the filled states with commuting matrices.</p>
<p>The $\varphi_x$ and $\varphi_y$ phases of the filled states are operators, and we can calculate them by projecting them onto the space of filled states:</p>
<p>$$<br>\varPhi_x = \sum_{ij} |\psi_i\rangle\langle \psi_i | \varphi_x | \psi_j\rangle \langle \psi_j|,<br>$$</p>
<p>$$<br>\varPhi_y = \sum_{ij} |\psi_i\rangle \langle \psi_i | \varphi_y | \psi_j\rangle \langle \psi_j|.<br>$$</p>
<p>We now need to determine if $\varPhi_x$ and $\varPhi_y$ approximately commute. Let’s consider the expression</p>
<p>$$<br>\textrm{tr}\left(\log\left(\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger\right)\right) = 2\pi i ,m + r,.<br>$$</p>
<p>First of all, $m$ is always an integer, because $\text{tr}(\log(A)) = \log(\det(A)),$ and the $\det\left(\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger\right) = \det(\varPhi_x)\det^<em>(\varPhi_x)\det(\varPhi_y)\det^</em>(\varPhi_y)$, so it is real.</p>
<p>If $\varPhi_x$ and $\varPhi_y$ commute, $m = 0$. It can only change if one of the eigenvalues of $\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger$ goes through 0 on a complex plane, which signals appearance of a delocalized mode.</p>
<p>So the <strong>Bott index</strong> $m$ looks like a Chern number, behaves like a Chern number, and it indeed is a Chern number.</p>
<p>To illustrate its behavior let’s plot the cumulative sum of the eigenvalues of $\log\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger$, taking a disordered Chern insulator as a sample system:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">%%opts Points &#123;+framewise&#125;</span><br><span class="line">%%opts Path &#123;+framewise&#125;</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.1</span>, delta=<span class="number">0.1</span>, disorder=<span class="number">0.5</span>)</span><br><span class="line">syst = chern_torus(<span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_m</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    op_x, op_y = projected_operators(syst, p, energy=<span class="number">0.01</span>)</span><br><span class="line">    temp = op_x @ op_y @ op_x.T.conj() @ op_y.T.conj()</span><br><span class="line">    eigs = np.linalg.eigvals(temp)</span><br><span class="line">    <span class="comment"># get rid of the four zero eigenvalues</span></span><br><span class="line">    res = np.<span class="built_in">sum</span>(np.log(eigs))</span><br><span class="line">    res = res.imag / (<span class="number">2</span> * np.pi)</span><br><span class="line">    <span class="comment"># This calculation is only correct to numerical accuracy.</span></span><br><span class="line">    <span class="comment"># When the Chern number is zero the result might be a very small negative number.</span></span><br><span class="line">    <span class="comment"># We make them positive so that the out put is never -0, because that does not look nice.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(res) &lt; <span class="number">0.5</span>:</span><br><span class="line">        res = <span class="built_in">abs</span>(res)</span><br><span class="line"></span><br><span class="line">    xs = np.cumsum(np.log(eigs)).real</span><br><span class="line">    ys = np.cumsum(np.log(eigs)).imag</span><br><span class="line"></span><br><span class="line">    x = np.append([<span class="number">0</span>], xs)</span><br><span class="line">    y = np.append([<span class="number">0</span>], ys)</span><br><span class="line">    title = <span class="string">&quot;$m=&#123;:.2&#125;$, Chern number $=&#123;:1.0f&#125;$&quot;</span>.<span class="built_in">format</span>(p.mu, res)</span><br><span class="line">    window_widening = (<span class="built_in">max</span>(x) - <span class="built_in">min</span>(x)) * <span class="number">0.05</span></span><br><span class="line">    pl = holoviews.Path((x, y)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    pl *= holoviews.Points((x, y)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    xlim = <span class="built_in">slice</span>(<span class="built_in">min</span>(x) - window_widening, <span class="built_in">max</span>(x) + window_widening)</span><br><span class="line">    ylim = <span class="built_in">slice</span>(-<span class="number">2</span> * np.pi - <span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">2</span>, <span class="string">&quot;yticks&quot;</span>: [(-<span class="number">2</span> * np.pi, <span class="string">r&quot;$-2\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>)]&#125;</span><br><span class="line">    <span class="keyword">return</span> pl[xlim, ylim].relabel(title).opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: evaluate_m(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> np.linspace(-<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">16</span>)&#125;, kdims=[<span class="string">r&quot;$m$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;9qCSXEfSlqE&quot;</span>, src_location=<span class="string">&quot;8.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topological invariants&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w8_general/classification"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w8_general/classification/" class="article-date">
  <time datetime="2021-01-07T09:11:06.879Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> HTML</span><br><span class="line"><span class="keyword">from</span> nbconvert.filters.markdown <span class="keyword">import</span> markdown2html_pandoc</span><br><span class="line"></span><br><span class="line">displaymd = <span class="keyword">lambda</span> markdown: display_html(HTML(markdown2html_pandoc(markdown)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Markdown tables are ugly, and Mathjax doesn&#x27;t support \tabular,</span></span><br><span class="line"><span class="comment"># therefore we use math mode + \array + add a command \T to make</span></span><br><span class="line"><span class="comment"># the \array rows less dense.</span></span><br><span class="line"></span><br><span class="line">table_header = <span class="string">r&quot;&quot;&quot;$$</span></span><br><span class="line"><span class="string">\require&#123;color&#125;</span></span><br><span class="line"><span class="string">colordefs</span></span><br><span class="line"><span class="string">\newcommand\T&#123;\Rule&#123;0pt&#125;&#123;1em&#125;&#123;.3em&#125;&#125;</span></span><br><span class="line"><span class="string">\begin&#123;array&#125;&#123;fmt&#125;</span></span><br><span class="line"><span class="string">\hline</span></span><br><span class="line"><span class="string">body\\</span></span><br><span class="line"><span class="string">\hline</span></span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br><span class="line"><span class="string">$$&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">replacements = [</span><br><span class="line">    (<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#123;&#123;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;&#125;&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;colordefs&quot;</span>, <span class="string">&quot;&#123;colordefs&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;fmt&quot;</span>, <span class="string">&quot;&#123;fmt&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;body&quot;</span>, <span class="string">&quot;&#123;body&#125;&quot;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> replacements:</span><br><span class="line">    table_header = table_header.replace(i, j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Symmetry classes names and their symmetry properties</span></span><br><span class="line">symmetry_classes = (<span class="string">&quot;A&quot;</span>, <span class="string">&quot;AIII&quot;</span>, <span class="string">&quot;AI&quot;</span>, <span class="string">&quot;BDI&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DIII&quot;</span>, <span class="string">&quot;AII&quot;</span>, <span class="string">&quot;CII&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CI&quot;</span>)</span><br><span class="line">chiralsym = <span class="number">5</span> * (<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">phs = <span class="number">3</span> * (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;1&quot;</span>,) + (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;-1&quot;</span>,)</span><br><span class="line">trs = <span class="number">2</span> * (<span class="string">&quot;&quot;</span>,) + <span class="number">2</span> * (<span class="string">&quot;1&quot;</span>,) + (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;-1&quot;</span>,) + (<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Locations of non-empty entries in the periodic table</span></span><br><span class="line">primary_seq = <span class="keyword">lambda</span> n: np.arange(n) % <span class="number">2</span></span><br><span class="line">z_descendant = <span class="keyword">lambda</span> n: np.arange(n) % <span class="number">8</span></span><br><span class="line">z2_descendant = <span class="keyword">lambda</span> n: np.arange(<span class="number">1</span>, n + <span class="number">1</span>) % <span class="number">8</span></span><br><span class="line">z2_descendant2 = <span class="keyword">lambda</span> n: np.arange(<span class="number">2</span>, n + <span class="number">2</span>) % <span class="number">8</span></span><br><span class="line">twoz_descendant = <span class="keyword">lambda</span> n: np.arange(<span class="number">4</span>, n + <span class="number">4</span>) % <span class="number">8</span></span><br><span class="line"></span><br><span class="line">line_end = <span class="string">&quot;\\T\\\\\n&quot;</span></span><br><span class="line">sep = <span class="string">&quot; &amp; &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_table</span>(<span class="params">n=<span class="number">4</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create an array of entries forming the periodic table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    n : int</span></span><br><span class="line"><span class="string">        Number of dimensions to show.</span></span><br><span class="line"><span class="string">    show_symmetries : bool</span></span><br><span class="line"><span class="string">        Show symmetry information for each symmetry class.</span></span><br><span class="line"><span class="string">    sort_order : int array or None</span></span><br><span class="line"><span class="string">        Ordering to apply to the symmetry classes </span></span><br><span class="line"><span class="string">        (can be trivially used to discard entries).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    data : np.ndarray</span></span><br><span class="line"><span class="string">        A string array with the entries of the periodic table.</span></span><br><span class="line"><span class="string">    format_string : str</span></span><br><span class="line"><span class="string">        An alignment string that can be used to feed the resulting</span></span><br><span class="line"><span class="string">        table to a Latex \array environment. </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    dimensions = np.array([[<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]], dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> dimensions.shape[<span class="number">1</span>]:</span><br><span class="line">        dimensions[<span class="number">0</span>, <span class="number">0</span>] = <span class="string">r&quot;d=&quot;</span> + dimensions[<span class="number">0</span>, <span class="number">0</span>].decode(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    complex_entries = np.zeros((<span class="number">2</span>, n), dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    complex_entries[primary_seq(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    real_entries = np.zeros((<span class="number">8</span>, n), dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    real_entries[z_descendant(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line">    real_entries[z2_descendant(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;_2&quot;</span></span><br><span class="line">    real_entries[z2_descendant2(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;_2&quot;</span></span><br><span class="line">    real_entries[twoz_descendant(n), np.arange(n)] = <span class="string">r&quot;2\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    entries = np.r_[complex_entries, real_entries]</span><br><span class="line"></span><br><span class="line">    sym_classes_rm = <span class="built_in">tuple</span>(<span class="string">r&quot;\textrm&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(cl) <span class="keyword">for</span> cl <span class="keyword">in</span> symmetry_classes)</span><br><span class="line"></span><br><span class="line">    sym = np.array(</span><br><span class="line">        [sym_classes_rm] + show_symmetries * [chiralsym, phs, trs], dtype=<span class="string">&quot;S100&quot;</span></span><br><span class="line">    ).T</span><br><span class="line">    sym_header = np.array(</span><br><span class="line">        [</span><br><span class="line">            [<span class="string">r&quot;\textrm&#123;class&#125;&quot;</span>]</span><br><span class="line">            + show_symmetries * [<span class="string">r&quot;\mathcal&#123;C&#125;&quot;</span>, <span class="string">r&quot;\mathcal&#123;P&#125;&quot;</span>, <span class="string">r&quot;\mathcal&#123;T&#125;&quot;</span>]</span><br><span class="line">        ],</span><br><span class="line">        dtype=<span class="string">&quot;S100&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    header = np.c_[sym_header, dimensions]</span><br><span class="line"></span><br><span class="line">    table = np.c_[sym, entries]</span><br><span class="line">    <span class="keyword">if</span> sort_order <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        table = table[sort_order]</span><br><span class="line"></span><br><span class="line">    format_string = <span class="string">&quot;c|&quot;</span> + show_symmetries * <span class="string">&quot;rrr&quot;</span> + n * show_symmetries * <span class="string">&quot;|&quot;</span> + n * <span class="string">&quot;c&quot;</span></span><br><span class="line">    <span class="keyword">return</span> np.r_[header, table], format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">color_table</span>(<span class="params">table, color_array</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Apply rgb colors to table entries.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `color_array[i, j]` is the rgb color of the entry `(i, j)`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns the string of color definitions required for coloring the table.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    apply_color = <span class="keyword">lambda</span> text, color: <span class="string">r&quot;\color&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(color, text)</span><br><span class="line"></span><br><span class="line">    colors = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> np.indices(table.shape).reshape(<span class="number">2</span>, -<span class="number">1</span>).T:</span><br><span class="line">        idx = <span class="built_in">tuple</span>(idx)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(color_array[idx]):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        color = <span class="string">&quot;,&quot;</span>.join(<span class="string">&quot;&#123;:1.2&#125;&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> color_array[idx])</span><br><span class="line">        val = <span class="built_in">str</span>(<span class="built_in">abs</span>(<span class="built_in">hash</span>(color)))[:<span class="number">8</span>]</span><br><span class="line">        colors[color] = val</span><br><span class="line">        table[idx] = apply_color(table[idx].decode(<span class="string">&quot;utf-8&quot;</span>), val)</span><br><span class="line"></span><br><span class="line">    defs = []</span><br><span class="line">    <span class="keyword">for</span> color, code <span class="keyword">in</span> <span class="built_in">list</span>(colors.items()):</span><br><span class="line">        defs.append(<span class="string">r&quot;\definecolor&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;rgb&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(code, color))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(defs)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Shinsei Ryu from the University of Illinois will introduce the general classification of topological insulators and superconductors.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;cKzUuQyZjFo&quot;</span>, src_location=<span class="string">&quot;8.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="At-a-glance-periodic-table"><a href="#At-a-glance-periodic-table" class="headerlink" title="At a glance: periodic table"></a>At a glance: periodic table</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">full_table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">False</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line"></span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line">colordefs = <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>Let us now look at all the possible symmetry classes in dimensions from $0$ to $3$, and see what kind of topological insulators are possible.</p>
<p>There are quite a few, here is the full list:</p>
<p>This table has a lot of logic in it, but to you it most likely looks no better than this:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">full_table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">False</span>, sort_order=np.random.permutation(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">color_array = np.<span class="built_in">round</span>(np.random.rand(*(full_table.shape + (<span class="number">3</span>,))), <span class="number">2</span>)</span><br><span class="line">colordefs = color_table(full_table, color_array)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>But don’t worry, we are going to learn exactly what these tables mean.</p>
<p>First of all, let’s review the meaning of the entries in the table. Each entry gives the topological classification of a system with a given combination of symmetries and dimensionality. In other words, it gives us the possible values that the topological invariant $Q$ of such a system can take.</p>
<p>An empty entry means that the system does not have a topological phase. In other words, all gapped Hamiltonians with dimension and symmetries corresponding to an empty entry can be deformed into each other, without ever closing the bulk gap and without breaking any existing symmetry.</p>
<p>A $\mathbb{Z}$ entry tells us that the topological invariant is an integer number, $Q=0, \pm 1, \pm 2, \dots$ An example of such a system is the quantum Hall effect, for which the topological invariant is the Chern number. The value of $Q$ specifies the number of chiral edge states and their chirality, which is opposite for opposite signs of $Q$.</p>
<p>A $2\mathbb{Z}$ entry is much like a $\mathbb{Z}$ entry, except that the invariant may only take even numbers, $Q=0,\pm2, \pm4, \dots$, because of some doubling of the degrees of freedom. An example is a quantum dot with spinful time-reversal symmetry, for which the topological invariant is the number of filled energy levels. It may only be an even number because of Kramers degeneracy.</p>
<p>A $\mathbb{Z}_2$ entry means that there are only two distinct topological phases, with $Q=\pm 1$ (or $Q=0, 1$, depending on convention). An example we know is the Majorana chain, with the Pfaffian topological invariant, which distinguishes between the two phases with or without unpaired Majorana modes and the ends. Another example we know are the time-reversal invariant topological insulators in two and three dimensions.</p>
<p>Now that we have attached a meaning to each entry in the table, let’s try to understand the table as a whole. The first thing to do is to understand why it has ten and only ten rows.</p>
<h1 id="Symmetry-classes"><a href="#Symmetry-classes" class="headerlink" title="Symmetry classes"></a>Symmetry classes</h1><p>Each row in the table corresponds to a certain <em>symmetry class</em>, that is to a given combination of the presence or absence of three fundamental discrete symmetries.</p>
<p>You already encountered these three symmetries all the way back in week one. They are time-reversal symmetry ($\mathcal{T}$), particle-hole symmetry ($\mathcal{P}$) and chiral symmetry ($\mathcal{C}$). We previously referred to chiral symmetry $\mathcal{C}$ as sublattice symmetry. This is because in condensed matter physics, a natural realization of chiral symmetry is a system composed of two sublattices, such that sites in one lattice only couple to sites in the other.</p>
<p>Why do we consider these symmetries fundamental, and restrict the periodic table to them only?</p>
<p>As you may recall from week one, and as Shinsei Ryu explained in the introductory video, normal unitary symmetries of a Hamiltonian do not have particularly interesting consequences for topological classification. One may always make the Hamiltonian block-diagonal, reducing the problem to the study of a single block. This procedure can be repeated until one runs out of unitary symmetries and is left with an <em>irreducible</em> block of the Hamiltonian, i.e. one which cannot be block diagonalized.</p>
<p>Time-reversal, particle-hole and chiral symmetries act in a different way. They impose certain constraints on an irreducible Hamiltonian - for instance, by forcing it to be a real matrix, or to be block off-diagonal.</p>
<p>Note, however, that it is possible to extend the periodic table to study the interplay between these three discrete symmetries and other unitary symmetries. For instance, we have already touched upon crystalline symmetries in week seven, and we will return to them in week ten.</p>
<p>But for now, let’s focus on the three fundamental discrete symmetries: $\mathcal{P}$, $\mathcal{T}$ and $\mathcal{C}$. Their basic properties are:</p>
<ul>
<li>$\mathcal{T}$ is an anti-unitary operator which commutes with the Hamiltonian.</li>
<li>$\mathcal{P}$ is an anti-unitary operator which anti-commutes with the Hamiltonian.</li>
<li>$\mathcal{C}$ is a unitary operator which anti-commutes with the Hamiltonian.</li>
</ul>
<p>Recall that an anti-unitary operator can be written as the product of a unitary operator and the complex conjugation operator $\mathcal{K}$. The next important thing to know is that time-reversal and particle-hole symmetry may come in two separate flavors, depending on whether they square to plus or minus one.</p>
<p>For instance, you will recall that for the time-reversal operator acting on electronic states, $\mathcal{T}^2=-1$. This was the crux of Kramers theorem, which in turn was the key to topological insulators. If you go back to week one, you will also remember that we discussed real matrices, which were symmetric under a time-reversal operator $\mathcal{T}=\mathcal{K}$. This operator satisfies $\mathcal{T}^2=1$.</p>
<p>Thus, a system can behave in three ways under time-reversal symmetry $\mathcal{T}$: (1) it does not have time-reversal symmetry, (2) it has it and $\mathcal{T}$ squares to $+1$, (3) it has it and $\mathcal{T}$ squares to $-1$. The same holds for particle-hole symmetry, which can also have $\mathcal{P}^2=\pm 1$. On the other hand, the chiral symmetry only comes in one flavor, $\mathcal{C}^2=1$.</p>
<h2 id="Combining-symmetries"><a href="#Combining-symmetries" class="headerlink" title="Combining symmetries"></a>Combining symmetries</h2><p>How do we arrive to having ten symmetry classes? Let’s count all the possible cases carefully. By combining the three cases for $\mathcal{P}$ and the three cases for $\mathcal{T}$ we arrive at nine possible combinations. </p>
<p>The important thing to notice now is that $\mathcal{C}$ is not completely independent from $\mathcal{T}$ and $\mathcal{P}$. Whenever a system has both $\mathcal{T}$ and $\mathcal{P}$, there is also a chiral symmetry $\mathcal{C}=\mathcal{P\cdot T}$.</p>
<p>This also means that if a system only has either $\mathcal{T}$ or $\mathcal{P}$ but not both, it cannot have a chiral symmetry $\mathcal{C}$. In other words, the presence of any two out of the three symmetries implies that the third is also present.</p>
<p>On the other hand, if both $\mathcal{P}$ and $\mathcal{T}$ are absent, then $\mathcal{C}$ may or may not be present. This gives us two distinct cases.</p>
<p>Adding all the possibilities, we indeed find 10 symmetry classes:</p>
<p>$$(3\times 3 - 1) + 2 = 8 + 2 = 10,.$$</p>
<p>The first term in the sum corresponds to the eight cases where there is at least one anti-unitary symmetry: either $\mathcal{P}$, or $\mathcal{T}$, or both. These eight symmetry classes are called <em>real</em>, because an anti-unitary symmetry always involves the complex conjugation operator. This does not necessarily mean that the Hamiltonian is a real matrix, but it is a reminder that there is a constraint between its real and imaginary parts.</p>
<p>The second term in the sum covers the two cases when there are no anti-unitary symmetries. These symmetry classes are called <em>complex</em>.</p>
<p>Let’s have another look at the 10 rows in the table, this time specifying which combination of the three fundamental symmetries each row has:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">full_table, format_string = make_table(</span><br><span class="line">    n=<span class="number">0</span>, show_symmetries=<span class="literal">True</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>The somewhat cryptic notations in the leftmost column are just the names of the different symmetry classes. (Also the ‘I’s appearing there are Roman cardinal numbers, so for instance BDI is ‘B D one’, and AIII is “A three”.)</p>
<p>Their names come from an elegant mathematical classification of <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Symmetric_space">symmetric spaces</a> worked out by <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/%C3%89lie_Cartan">Elie Cartan</a> in 1926. While it is definitely intriguing that a group theory result from 1926 reappears in a totally different context almost 80 years later, the origin of this nomenclature is not directly relevant to most of the theory done in the field.<br>The two complex classes are A and AIII.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;Which symmetry class do we get if we break Kramers degeneracy in class BDI?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [<span class="string">&quot;D&quot;</span>, <span class="string">&quot;AIII&quot;</span>, <span class="string">&quot;DIII&quot;</span>, <span class="string">&quot;None, class BDI has no Kramers degeneracy&quot;</span>]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;Kramers degeneracy requires that time reversal squares to -1, while it squares to 1 in class BDI.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Finally, let us make an extra observation:</p>
<blockquote>
<p>While the particle-hole symmetry appears in any superconductor, it must satisfy $\mathcal{P}^2 = -\mathcal{T}^2$ due to the way the Bogoliubov quasiparticles are related to the original electrons. This makes the symmetry classes BDI, and CII rely on a fine-tuned Hamiltonian, just like the symmetry class AIII.</p>
</blockquote>
<h1 id="What-we-learned-so-far"><a href="#What-we-learned-so-far" class="headerlink" title="What we learned so far"></a>What we learned so far</h1><p>To get some confidence with the table and these obscure names, it is useful to see where the topological systems that we have studied so far fit into the table.</p>
<p>Every red entry in the table below corresponds to something which we already know and studied in the previous weeks of the course, as you can discover by moving the mouse over it.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">tooltips = &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">6</span>): <span class="string">&quot;Chern insulator: no symmetries, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">5</span>): <span class="string">&quot;Majorana wire: spinful particle-hole, d=1&quot;</span>,</span><br><span class="line">    (<span class="number">4</span>, <span class="number">5</span>): <span class="string">&quot;Polyacetilene/SSH chain: sublattice symmetry, d=1&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">6</span>): <span class="string">&quot;QSHE: spinful TRS, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">7</span>): <span class="string">&quot;3D strong TI: spinful TRS, d=3&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">6</span>): <span class="string">&quot;p-wave superconductor: PHS, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">4</span>): <span class="string">&quot;Superconducting quantum dot: d=0, PHS&quot;</span>,</span><br><span class="line">    (<span class="number">2</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, spinless TRS&quot;</span>,</span><br><span class="line">    (<span class="number">1</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, no symmetries&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, spinful TRS and Kramers degeneracy&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">True</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">colors = np.zeros(shape=table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos <span class="keyword">in</span> tooltips:</span><br><span class="line">    colors[pos] = [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line"></span><br><span class="line">colordefs = color_table(table, colors)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos, val <span class="keyword">in</span> <span class="built_in">list</span>(tooltips.items()):</span><br><span class="line">    table[pos] = <span class="string">r&quot;\texttip&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(table[pos].decode(<span class="string">&quot;utf-8&quot;</span>), val)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">HTML(</span><br><span class="line">    markdown2html_pandoc(</span><br><span class="line">        table_header.<span class="built_in">format</span>(</span><br><span class="line">            colordefs=(<span class="string">&quot;\\require&#123;action&#125;\n&quot;</span> + colordefs), fmt=format_string, body=block</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>As you can see, the Majorana wire and the $p$-wave superconductor are in class D, the Chern insulators in class A, and the time-reversal invariant topological insulators in class AII. These names occur quite often in the literature.</p>
<h1 id="Finding-a-periodic-structure"><a href="#Finding-a-periodic-structure" class="headerlink" title="Finding a periodic structure"></a>Finding a periodic structure</h1><p>We have now explained why there are ten rows and the meaning of the symmetry classes, but the table as a whole still does not have a coherent structure. Is there a way that we can connect systems between different symmetry classes and different dimensions?</p>
<p>Given a gapped Bloch Hamiltonian $H_d$ in a certain symmetry class and dimension $d$, there is a systematic procedure by which we can increase its dimensionality. This changes its symmetry class, but makes sure that the topological classification is unvaried. This procedure thus allows us to connect different rows of the table.</p>
<p>The basic idea is to add a new momentum $k_{d+1}$ to the Bloch Hamiltonian in such a way that the gap does not close for any value of $k_{d+1}$ in the Brillouin zone. This means that the new Hamiltonian must have the same value of the topological invariant as the initial one. The tricky (but also beautiful) part is that adding a momentum can change the symmetries of the Hamiltonian, and one has to keep track of that carefully.</p>
<p>This procedure is slightly different depending on whether the initial $H_d$ has chiral symmetry or not. In one case the procedure removes symmetries, in the other it adds them. Let’s start with the first.</p>
<h2 id="Removing-symmetries"><a href="#Removing-symmetries" class="headerlink" title="Removing symmetries"></a>Removing symmetries</h2><p>Let’s first suppose that $H_d$ has chiral symmetry $\mathcal{C}$. The Hamiltonian then has $n$ pairs of energy bands symmetric around zero, which we can denote as $\pm \epsilon_{n,d}$, hiding their dependence on the different momenta appearing in $H_d$.</p>
<p>Then consider the following higher-dimensional Hamiltonian:</p>
<p>$$<br>H_{d+1} = H_d,\cos k_{d+1} + \mathcal{C} \sin k_{d+1}.<br>$$</p>
<p>This Hamiltonian has the same number of bands as $H_d$, even though the bands are higher-dimensional. Given its simple form, every band $\epsilon_{n,d+1}^n$ is directly related to a band $\epsilon_{n,d}$ of $H_d$, </p>
<p>$$<br>\epsilon_{n,d+1} = \pm \sqrt{\epsilon_{n, d}^2,\cos^2 k_{d+1} + \sin^2 k_{d+1}}.<br>$$</p>
<p>This expression guarantees that the gap of $H_{d+1}$ only closes if that of $H_d$ closes. In other words, whatever value of the topological invariant $H_d$ has, $H_{d+1}$ will have the same value.</p>
<p>What are the discrete symmetries of $H_{d+1}$? First of all, note that $H_{d+1}$ has no chiral symmetry since the second term by construction commutes with $\mathcal{C}$, while the chiral symmetry would require anti-commutation. So $H_{d+1}$ and $H_d$ belong to a different symmetry classes. Which symmetry class does $H_d$ belong to?</p>
<p>If $\mathcal{C}$ is the only discrete symmetry of $H_d$, i.e. if $H_d$ belongs to class AIII, then $H_{d+1}$ has no symmetries at all, so it is in class A. We can express this by writing AIII $\to$ A, meaning that the topological classification is the same to the left of the arrow in $d$ dimensions, and to the right of the arrow in $d+1$ dimensions.</p>
<p>If instead $\mathcal{C}$ is not the only discrete symmetry of $H_d$, then $H_d$ must have both $\mathcal{P}$ and $\mathcal{T}$, because we know that two of the symmetries imply the third. Hence $H_d$ must be in one of the symmetry classes BDI, CI, CII, DIII. Because $H_{d+1}$ has no chiral symmetry, it can only have one remaining symmetry, either $\mathcal{P}$ or $\mathcal{T}$. It is therefore in one of the four classes AI, AII, C, D. With some patience, it is possible to work out exactly the symmetry class of $H_{d+1}$ given that of $H_d$ in all four cases.</p>
<p>We won’t do that, but state that the result is that by removing chiral symmetry and adding one dimension, one obtains that BDI $\to$ D, DIII $\to$ AII, CII $\to$ C and CI $\to$ AI.</p>
<h2 id="Adding-symmetries"><a href="#Adding-symmetries" class="headerlink" title="Adding symmetries"></a>Adding symmetries</h2><p>Let’s now start from a Hamiltonian without chiral symmetry. Our procedure this time involves a doubling of the number of bands of $H_d$. That is, we introduce a new set of Pauli matrices $\tau$, not present in $H_d$, and write $H_{d+1}$ as</p>
<p>$$<br>H_{d+1} = H_d,\cos k_{d+1},\tau_x + \sin k_{d+1},\tau_y.<br>$$</p>
<p>Note that just like in our previous argument, the topological invariant of $H_{d+1}$ must be the same as that of $H_d$. Also, by construction, $H_{d+1}$ has a chiral symmetry given by $\mathcal{C}=\tau_z$, which anticommutes with all the terms in the Hamiltonian. </p>
<p>What are the symmetries of $H_{d+1}$ in this case? To begin with, $H_d$ cannot have both anti-unitary symmetries, because then it would have $\mathcal{C}$ as well. It either has none (class A) or just one of them (classes AI, AII, C, or D). We thus have two cases:</p>
<ul>
<li>if $H_d$ has no symmetries at all, meaning that it was in class A, then $H_{d+1}$ only has chiral symmetry, meaning that it is in class AIII. So we obtain A $\to$ AIII.</li>
<li>if $H_d$ has one anti-unitary symmetry, then $H_{d+1}$ must have all three discrete symmetries. Again, we will not work out the details for each case, but one obtains that AI $\to$ BDI, D $\to$ DIII, AII $\to$ CII, and C $\to$ CI.</li>
</ul>
<p>Now that we have learned how to extend the topological classification by adding one dimension to the Hamiltonian and changing its symmetry in an appropriate way, nothing forbids us to repeat the procedure, by going two dimensions higher, three dimensions higher, etc…</p>
<p>So we have made the procedure of finding topological phases systematic.</p>
<h1 id="The-Bott-clock"><a href="#The-Bott-clock" class="headerlink" title="The Bott clock"></a>The Bott clock</h1><p>If you repeat the procedure many times, you will find that it has a period, i.e. at some point you end up in the same symmetry class you started with.</p>
<p>This is easy to see for the two complex classes, which are just interchanged:</p>
<ul>
<li>A $\to$ AIII $\to$ A.</li>
</ul>
<p>But it is also the case for the eight real classes:</p>
<ul>
<li>AI $\to$ BDI $\to$ D $\to$ DIII $\to$ AII $\to$ CII $\to$ C $\to$ CI $\to$ AI.</li>
</ul>
<p>This property is called <strong>Bott periodicity</strong>, and it can be nicely represented in the following table, similar to a clock:</p>
<p><img src="/2021/01/07/src/w8_general/classification/bott_clock.svg" alt></p>
<p>The grey entries in the table are the chiral classes, and the arrows show which classes have the same topological classification when you shift $d\to d+1$. The complex classes are in the centre of the table, and only talk to each other. The eight real classes are disposed around the clock.</p>
<p>Finally, let’s see what the table looks like when we order the rows according to the Bott clock above:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">5</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=<span class="number">8</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.linspace(<span class="number">0.6</span>, <span class="number">1.2</span>, n).reshape(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>) * np.random.rand(<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">palette = np.minimum(palette, <span class="number">1</span>)</span><br><span class="line">colors[primary_seq(n) + <span class="number">1</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">0</span>]</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">1</span>]</span><br><span class="line">colors[z2_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">2</span>]</span><br><span class="line">colors[z2_descendant2(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">3</span>]</span><br><span class="line">colors[twoz_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">4</span>]</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>Finally some order appears!</p>
<p>We have colored the different entries to show how all the topological invariants repeat themselves along the diagonals, as a consequence of the procedure outlined above. The table has overall a period equal to 8, meaning that for instance in $d=8$ the topological classification in all symmetry classes is equal to that in $d=0$, and so on.</p>
<p>In fact, we know another way to change the dimensionality while preserving the topology. It is to go from a Hamiltonian $H$ in $d$ dimensions to the reflection matrix $r$ in $d-1$ dimensions. Whenever $H$ is gapped, $r$ has no zeroes, so both have the same topology. On the other hand, $r$ is a $d-1$-dimensional object, so in going from $H$ to $r$, we go against the Bott clock.</p>
<p>For example, this means that in the SSH chain, which is a $d=1$ dimensional system in symmetry class AIII, the scattering invariant is the same as the Hamiltonian invariant in the $d=0$ symmetry class A, i.e. the number of negative eigenvalues. On the other hand, the scattering invariant of the quantum Hall effect, the winding number of $r$, is the same expression as the Hamiltonian topological invariant of the SSH chain.</p>
<h1 id="Reading-the-table-in-different-ways"><a href="#Reading-the-table-in-different-ways" class="headerlink" title="Reading the table in different ways"></a>Reading the table in different ways</h1><h2 id="Complex-classes-Chern-and-winding-numbers"><a href="#Complex-classes-Chern-and-winding-numbers" class="headerlink" title="Complex classes: Chern and winding numbers"></a>Complex classes: Chern and winding numbers</h2><p>The first thing to observe is that the complex classes only have $\mathbb{Z}$ invariant. We already know what these invariants are in low dimensions: the Chern number, which we encountered in quantum Hall systems (class A, $d=2$), and the winding number of the reflection matrix, which we encountered when we studied reflection from the Thouless pump.</p>
<p>The higher dimensional invariants are simple generalizations of these two. Their mathematical expression can be found in several papers, for instance <a target="_blank" rel="noopener" href="http://arxiv.org/abs/1104.1602">this one</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=n, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:<span class="number">3</span>, <span class="number">4</span>:] = [<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>]</span><br><span class="line">colors[<span class="number">1</span>, <span class="number">4</span>:] = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">colors[<span class="number">2</span>, <span class="number">4</span>:] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<h2 id="Reading-the-table-by-columns"><a href="#Reading-the-table-by-columns" class="headerlink" title="Reading the table by columns"></a>Reading the table by columns</h2><p>Another useful feature of the table is that in a given column, all $\mathbb{Z}$ or $2\mathbb{Z}$ entries, which are grouped by the color gradients below, have the same topological invariant.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">15</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=n, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.random.rand(n, <span class="number">3</span>) ** <span class="number">2</span></span><br><span class="line">colors[primary_seq(n) + <span class="number">1</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">0.8</span> * palette</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.6</span> * (<span class="number">1</span> - palette)</span><br><span class="line">colors[twoz_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.6</span> * (<span class="number">1</span> - palette)</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>We can check this statement for some cases we know. For instance, in $d=0$ the $\mathbb{Z}$ topological invariant is the number of filled energy levels, which applies to quantum dots with broken time-reversal symmetry (class A), spinless time-reversal symmetry (class AI) and spinful time-reversal symmetry (class AII, which has $2\mathbb{Z}$ because of Kramers degeneracy). In $d=2$, the $\mathbb{Z}$ topological invariant is the Chern number, and we saw how it applies to both the Chern insulators in class A and the $p$-wave superconductor in class D.</p>
<h2 id="Dimensional-reduction"><a href="#Dimensional-reduction" class="headerlink" title="Dimensional reduction"></a>Dimensional reduction</h2><p>An important pattern visible in the table is the descending sequence $\mathbb{Z} ,\to,\mathbb{Z}_2,\to,\mathbb{Z}_2$ that appears in every symmetry class. That is, starting from the $\mathbb{Z}$ invariant, reducing the dimensionaility twice by one we encounter two $\mathbb{Z}_2$ invariants in a row:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">4</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=<span class="number">8</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.random.rand(n, <span class="number">3</span>)</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">0.8</span> * palette</span><br><span class="line">colors[z2_descendant(n - <span class="number">1</span>) + <span class="number">3</span>, np.arange(n - <span class="number">1</span>) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.8</span> * (<span class="number">1</span> - palette[<span class="number">1</span>:])</span><br><span class="line">colors[z2_descendant2(n - <span class="number">2</span>) + <span class="number">3</span>, np.arange(n - <span class="number">2</span>) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.5</span> * (<span class="number">1</span> - palette[<span class="number">2</span>:])</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>Again, this dimensional reduction can best be understood with an example we already know. Consider the symmetry class $D$. In $d=2$ it has a $\mathbb{Z}$ topological phase, the $p$-wave superconductor.</p>
<p>If you take a finite ribbon of a $p$-wave superconductor, it will have an integer number of edge states, as determined by the Chern number. Let’s now imagine that you take a ribbon and roll it up into a thin, long cylinder, by pasting two of its edges together. The two remaining edges at this point form a circle.</p>
<p>You can now view this cylinder as a one-dimensional system whose ends are the two rolled-up edges, and ask: how many zero-energy Majorana modes can there be at the ends? We know the answer from last week’s material: the number of zero-modes can be zero or one, depending on whether the boundary conditions are periodic or anti-periodic. The topological invariant is thus reduced to $\mathbb{Z}_2$. This is no surprise, since the system is topologically in the same class as the Kitaev chain.</p>
<p>We can proceed further with our dimensional reduction. If we take our one dimensional system and make it into a ring, we obtain a zero-dimensional system. Depending on how the two ends are coupled, the two Majorana modes can favour the even or odd fermion parity state, and this quantity cannot change without a Fermi level crossing. This is the $\mathbb{Z}_2$ invariant of zero-dimensional systems in class D.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What sort of topological invariant do we get if we take a 3D TI, and try to make a 4D system with strong invariant, &quot;</span></span><br><span class="line">    <span class="string">&quot;like we did when making a 3D TI out of QSHE?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;We get another $Z_2$ topological invariant&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A 4D system with the Chern number as invariant.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;This construction cannot be repeated anymore.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The topological invariant stays the same.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;A quick check with the table shows that symmetry class AII in 4D has a $Z$ invariant, &quot;</span></span><br><span class="line">    <span class="string">&quot;and it should be the second Chern number.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;nnzPiJ3Q3_8&quot;</span>, src_location=<span class="string">&quot;8.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Periodic table&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-src/w7_defects/w7_assignments"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/01/07/src/w7_defects/w7_assignments/" class="article-date">
  <time datetime="2021-01-07T09:11:06.878Z" itemprop="datePublished">2021-01-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-Majorana-defects"><a href="#Simulations-Majorana-defects" class="headerlink" title="Simulations: Majorana defects"></a>Simulations: Majorana defects</h1><p>As usual, start by grabbing the notebooks of this week (<code>w7_defects</code>). They are once again over <a target="_blank" rel="noopener" href="http://tiny.cc/topocm_smc">here</a>.</p>
<h2 id="Quantum-spin-Hall-junction"><a href="#Quantum-spin-Hall-junction" class="headerlink" title="Quantum spin Hall junction"></a>Quantum spin Hall junction</h2><p>Let us study the spectrum of a Josephson junction on a quantum spin Hall edge in more detail. As in the lecture, we can add a magnet in the middle of the junction, which adds a Zeeman energy term to the Hamiltonian.</p>
<p>First, make such a junction. The code from week 2 for making a Josephson junction may be useful.</p>
<p>We are interested in the spectrum below the gap. There are two interesting parameters to vary: the Zeeman energy and the length of the junction. What happens to the energy levels as you increase the length of the junction. In particular, what happens when the junction is very long? What if you turn off the magnet?</p>
<p>Compare your results to the following paper, particularly Fig. 2.</p>
<ul>
<li>arXiv:0804.4469</li>
</ul>
<h2 id="Majorana-in-a-crystalline-defect"><a href="#Majorana-in-a-crystalline-defect" class="headerlink" title="Majorana in a crystalline defect"></a>Majorana in a crystalline defect</h2><p>Following Taylor Hughes suggestion from the summary of the lecture about crystalline defects, create an edge dislocation carrying a Majorana mode in an array of weakly coupled Kitaev chains.</p>
<p>Then try to split the dislocation into two disclinations. What happens to the Majorana mode?</p>
<p>Note that Kwant only supports regular lattices, so crystallographic defects can be implemented by altering some hoppings, as was done in the simulations in the lecture.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Topological defects&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-0707-1692"><a href="#arXiv-0707-1692" class="headerlink" title="arXiv:0707.1692"></a>arXiv:0707.1692</h3><p><strong>Hint:</strong> In detail, how to create and manipulate Majoranas on the 3D TI surface.</p>
<h3 id="arXiv-1112-3527"><a href="#arXiv-1112-3527" class="headerlink" title="arXiv:1112.3527"></a>arXiv:1112.3527</h3><p><strong>Hint:</strong> The Josephson effect on a 3D TI, in real life.</p>
<h3 id="arXiv-1208-6303"><a href="#arXiv-1208-6303" class="headerlink" title="arXiv:1208.6303"></a>arXiv:1208.6303</h3><p><strong>Hint:</strong> Disclinations.</p>
<h3 id="arXiv-1105-4351"><a href="#arXiv-1105-4351" class="headerlink" title="arXiv:1105.4351"></a>arXiv:1105.4351</h3><p><strong>Hint:</strong> How weak is weak?</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Topological defects&quot;</span>)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> huyi
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="O"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/about">关于我</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/logs/">日志</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://pan.ihuyi.xyz">网盘</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://aria.ihuyi.xyz">aria2</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
            <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css">
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>