<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>O</title>
  
  <subtitle>HUYI_blog</subtitle>
  <link href="http://ihuyi.xyz/atom.xml" rel="self"/>
  
  <link href="http://ihuyi.xyz/"/>
  <updated>2021-01-16T01:46:40.902Z</updated>
  <id>http://ihuyi.xyz/</id>
  
  <author>
    <name>huyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/16/hexo%E9%83%A8%E7%BD%B2/"/>
    <id>http://ihuyi.xyz/2021/01/16/hexo%E9%83%A8%E7%BD%B2/</id>
    <published>2021-01-16T01:46:40.902Z</published>
    <updated>2021-01-16T01:46:40.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用Hexo部署博客到Ubuntu服务器"><a href="#用Hexo部署博客到Ubuntu服务器" class="headerlink" title="用Hexo部署博客到Ubuntu服务器"></a>用Hexo部署博客到Ubuntu服务器</h1><h1 id="本地安装Hexo-node-js-git"><a href="#本地安装Hexo-node-js-git" class="headerlink" title="本地安装Hexo,node.js,git"></a>本地安装Hexo,node.js,git</h1><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>首先需要一台Ubuntu服务器，并且可以用<code>ubuntu</code>用户身份正常登陆.</p><h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>配置服务器的登陆选项，添加SSH，SSH公钥就用之前安装git时生成的公钥即可.</p><p>在本地下载Xshell等工具，登陆方式也可以选为本地的私钥.</p><blockquote><p>注意在使用Xshell等终端时，若不小心键入了<code>ctrl+s</code>, 则这个命令为暂时挂起终端，只需要按<code>ctrl+q</code>即可继续输入</p></blockquote><h2 id="安装Git和Nginx"><a href="#安装Git和Nginx" class="headerlink" title="安装Git和Nginx"></a>安装Git和Nginx</h2><p>Git 用于版本管理和部署，Nginx 用于静态博客托管。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git nginx -y</span><br></pre></td></tr></table></figure><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><p>在<code>/var/repo/</code>下创建名为<code>hexo_static</code>的裸仓库。用如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /var/repo/</span><br><span class="line">sudo chown -R $USER:$USER /var/repo/</span><br><span class="line">sudo chmod -R 755 /var/repo/</span><br><span class="line"></span><br><span class="line">cd /var/repo/</span><br><span class="line">git init --bare hexo_static.git</span><br></pre></td></tr></table></figure><h2 id="配置Nginx托管文件目录"><a href="#配置Nginx托管文件目录" class="headerlink" title="配置Nginx托管文件目录"></a>配置Nginx托管文件目录</h2><p>创建<code>/var/www/hexo</code>目录，用于Nginx托管，修改目录所有权和权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /var/www/hexo</span><br><span class="line"></span><br><span class="line">sudo chown -R $USER:$USER /var/www/hexo</span><br><span class="line">sudo chmod -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure><p>随后修改Nginx的<code>default</code>设置，使<code>root</code>指向<code>hexo</code>目录.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-available/<span class="keyword">default</span></span><br></pre></td></tr></table></figure><p>注意一定要加<code>sudo</code>,否则会提醒<code>default</code>是只读文件.</p><p>修改文件中对应的项</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span> default_server;</span><br><span class="line">    listen [::]:<span class="number">80</span> default_server ipv6only=<span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line">    root /<span class="keyword">var</span>/www/hexo; # 需要修改的部分</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>Vim的操作方法比较特殊，可以在网上查查</p></blockquote><p>重启Nginx服务，使得改动生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure><h2 id="创建Git钩子"><a href="#创建Git钩子" class="headerlink" title="创建Git钩子"></a>创建Git钩子</h2><blockquote><p>不清楚钩子是什么</p></blockquote><p>在自动生成的 hooks 目录下创建一个新的钩子文件：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>在该文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f</span><br></pre></td></tr></table></figure><p>保存并退出文件，并让该文件变为可执行文件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h1 id="回到本地配置"><a href="#回到本地配置" class="headerlink" title="回到本地配置"></a>回到本地配置</h1><h2 id="修改Hexo的默认配置"><a href="#修改Hexo的默认配置" class="headerlink" title="修改Hexo的默认配置"></a>修改Hexo的默认配置</h2><p>在站点config.yml中修改博客的地址<code>url</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site <span class="keyword">is</span> put <span class="keyword">in</span> a subdirectory, <span class="keyword">set</span> url <span class="keyword">as</span> <span class="string">&#x27;http://yoursite.com/child&#x27;</span> and root <span class="keyword">as</span> <span class="string">&#x27;/child/&#x27;</span></span><br><span class="line"></span><br><span class="line">url: http:<span class="comment">//server-ip # 没有绑定域名时填写服务器的实际 IP 地址。</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><h2 id="通过Git部署"><a href="#通过Git部署" class="headerlink" title="通过Git部署"></a>通过Git部署</h2><p>先在任意位置处打开powershell, 从服务器上把<code>hexo_static</code>仓库克隆下来, 以此来将服务器地址添加到受信任的站点中。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ubuntu<span class="variable">@server_ip</span><span class="symbol">:/var/repo/hexo_static</span>.git</span><br></pre></td></tr></table></figure><p>注意在第一次进行这一步时会提示是否继续，选yes即可。</p><p>再编辑Hexo的<code>config.yml</code>文件，找到Deployment, 修改为</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line">  <span class="symbol">type:</span> git</span><br><span class="line">   <span class="symbol">repo:</span> ubuntu<span class="variable">@server_ip</span><span class="symbol">:/var/repo/hexo_static</span>.git</span><br><span class="line">  <span class="symbol">branch:</span> master</span><br></pre></td></tr></table></figure><p>最后记得安装Hexo部署到Git仓库的包.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>于是就可用<code>hexo d</code>命令来部署了。大功告成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用Hexo部署博客到Ubuntu服务器&quot;&gt;&lt;a href=&quot;#用Hexo部署博客到Ubuntu服务器&quot; class=&quot;headerlink&quot; title=&quot;用Hexo部署博客到Ubuntu服务器&quot;&gt;&lt;/a&gt;用Hexo部署博客到Ubuntu服务器&lt;/h1&gt;&lt;h1 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w1_topointro/0d/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w1_topointro/0d/</id>
    <published>2021-01-07T09:19:47.980Z</published>
    <updated>2021-01-07T09:11:06.811Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line">%opts Layout [sublabel_format=<span class="string">&#x27;&#x27;</span> aspect_weight=<span class="number">1</span> figure_size=(<span class="number">100</span>) vspace=<span class="number">0.4</span>]</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">randn = np.random.randn</span><br><span class="line"></span><br><span class="line">alphas = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">dims = SimpleNamespace(</span><br><span class="line">    E=holoviews.Dimension(<span class="string">r&quot;$E$&quot;</span>),</span><br><span class="line">    alpha=holoviews.Dimension(<span class="string">r&quot;$\alpha$&quot;</span>),</span><br><span class="line">    Q=holoviews.Dimension(<span class="string">r&quot;$Q$&quot;</span>),</span><br><span class="line">    Q_BdG=holoviews.Dimension(<span class="string">r&quot;$Q_&#123;BdG&#125;$&quot;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_real_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = randn(N, N)</span><br><span class="line">    H += H.T</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cons_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = np.kron(pauli.s0, randn(N, N)) + np.kron(pauli.sz, randn(N, N))</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_symplectic_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="keyword">if</span> N % <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Matrix dimension should be a multiple of 2&quot;</span>)</span><br><span class="line">    sy = np.kron(np.eye(N // <span class="number">2</span>), np.array([[<span class="number">0</span>, -<span class="number">1j</span>], [<span class="number">1j</span>, <span class="number">0</span>]]))</span><br><span class="line">    h = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    h += h.T.conj()</span><br><span class="line">    Th = sy @ h.conj() @ sy</span><br><span class="line">    <span class="keyword">return</span> (h + Th) / <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_chiral_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    temp1 = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    temp2 = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    H = np.kron(pauli.sx, temp1) + np.kron(pauli.sy, temp2)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_BdG_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="comment"># This is antisymmetric basis</span></span><br><span class="line">    H = <span class="number">1j</span> * randn(<span class="number">2</span> * N, <span class="number">2</span> * N)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">energies</span>(<span class="params">alpha, H0, H1</span>):</span></span><br><span class="line">    H = (<span class="number">1</span> - alpha) * H0 + alpha * H1</span><br><span class="line">    <span class="keyword">return</span> np.linalg.eigvalsh(H)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_spectrum</span>(<span class="params">alphas, H0, H1</span>):</span></span><br><span class="line">    spectrum = [energies(a, H0, H1) <span class="keyword">for</span> a <span class="keyword">in</span> alphas]</span><br><span class="line">    <span class="keyword">return</span> np.array(spectrum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_Q</span>(<span class="params">spectrum</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds the number of bands that are under zero energy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    spectrum : numpy array</span></span><br><span class="line"><span class="string">        Array that contains the energies levels for every alpha.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    Q : list</span></span><br><span class="line"><span class="string">        Number of bands under zero energy.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">len</span>(s[s &lt; <span class="number">0</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> spectrum]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_hamiltonian_spectrum</span>(<span class="params">alphas, spectrum, E_range=(<span class="params">-<span class="number">4</span>, <span class="number">4</span></span>)</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function that plots a spectrum for a range of alphas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    spectrum : numpy array</span></span><br><span class="line"><span class="string">        Array that contains the energies levels for every alpha.</span></span><br><span class="line"><span class="string">    E_range : tuple</span></span><br><span class="line"><span class="string">        The upper and lower limit of the y-dimension.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    plot : holoviews.Path object</span></span><br><span class="line"><span class="string">        Plot of alphas vs. spectrum.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    E_min, E_max = E_range</span><br><span class="line">    energy = dims.E.clone()</span><br><span class="line">    energy.<span class="built_in">range</span> = <span class="built_in">tuple</span>(E_range)</span><br><span class="line">    plot = (holoviews.Path((alphas, spectrum), kdims=[dims.alpha, energy]) * holoviews.HLine(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [E_min, <span class="number">0</span>, E_max]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_Q</span>(<span class="params">alphas, Q, Q_range, Q_dim=dims.Q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function that plots value of Q for a range of alphas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    Q : numpy array</span></span><br><span class="line"><span class="string">        Vector that contains the value of Q for every alpha.</span></span><br><span class="line"><span class="string">    Q_range : tuple</span></span><br><span class="line"><span class="string">        The upper and lower limit of the y-dimension.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    plot : holoviews.Path object</span></span><br><span class="line"><span class="string">        Plot of alphas vs. Q.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    Q_min, Q_max = Q_range</span><br><span class="line">    Q_mid = (Q_max + Q_min) / <span class="number">2</span></span><br><span class="line">    Q_dim = Q_dim.clone()</span><br><span class="line">    Q_dim.<span class="built_in">range</span> = <span class="built_in">tuple</span>(Q_range)</span><br><span class="line">    plot = holoviews.Area((alphas, Q), kdims=[dims.alpha], vdims=[Q_dim]).opts(style=&#123;<span class="string">&quot;alpha&quot;</span>: <span class="number">0.4</span>&#125;)</span><br><span class="line">    plot *= holoviews.Curve((alphas, Q), kdims=[dims.alpha], vdims=[Q_dim])</span><br><span class="line">    <span class="keyword">return</span> plot.opts(</span><br><span class="line">        plot=&#123;</span><br><span class="line">            <span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</span><br><span class="line">            <span class="string">&quot;yticks&quot;</span>: [<span class="built_in">int</span>(Q_min), <span class="built_in">int</span>(Q_mid), <span class="built_in">int</span>(Q_max)],</span><br><span class="line">            <span class="string">&quot;aspect&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h1 id="Topology-and-symmetry"><a href="#Topology-and-symmetry" class="headerlink" title="Topology and symmetry"></a>Topology and symmetry</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;5ysdSoorJz4&quot;</span>, src_location=<span class="string">&quot;1.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Zero-dimensional-quantum-systems"><a href="#Zero-dimensional-quantum-systems" class="headerlink" title="Zero-dimensional quantum systems"></a>Zero-dimensional quantum systems</h1><p>Imagine a quantum system with a finite number of states $N$. The Hamiltonian of such a system is represented by a matrix $H$ of dimension $N\times N$.<br>This matrix is Hermitian, $H=H^\dagger$. Its real eigenvalues $E_n$ correspond to the allowed energies of the system,</p><p>$$H,\left|n\right\rangle = E_n,\left|n\right\rangle,,$$</p><p>with $\left|n\right\rangle$ the corresponding eigenstate. Let’s say that $H$ describes a small quantum dot with a few levels. We can imagine that the quantum dot is in weak contact with a metallic lead, as in the following sketch:</p><p><img src="/2021/01/07/src/w1_topointro/0d/dot.svg" alt></p><p>The presence of a metallic lead allows us to measure all the energies $E_n$ of the electronic states in the dot with respect to the Fermi level $E_F$ of the electrons in the metallic lead. In the following we will set $E_F=0$. Hence, all negative energies $E_n&lt;0$ correspond to filled states in the dot, and all positive energies $E_n&gt;0$ to empty states. In the sketch, the lead and the dot are separated by a potential barrier, such that they are only coupled very weakly. Thus, we can still consider the dot as an isolated system, to a good approximation.</p><p>We are now ready to start on the main theme of this course, topology.</p><h2 id="Topology-and-gapped-quantum-systems"><a href="#Topology-and-gapped-quantum-systems" class="headerlink" title="Topology and gapped quantum systems"></a>Topology and gapped quantum systems</h2><p>Topology studies whether objects can be transformed continuously into each other. In condensed matter physics we can ask whether the Hamiltonians of two quantum systems can be continuously transformed into each other. If that is the case, then we can say that two systems are ‘topologically equivalent’.</p><p>If we considered all Hamiltonians without any constraint, every Hamiltonian could be continuously deformed into every other Hamiltonian, and all quantum systems would be topologically equivalent. This changes drastically if we restrict ourselves to systems with an energy gap. This means that there is a finite energy cost to excite the system above its ground state.<br>If an energy gap is present, then the Hamiltonian of the system has no eigenvalues in a finite interval around zero energy.</p><p>We can now use the following criterion: we say that two gapped quantum systems are topologically equivalent if their Hamiltonians can be continuously deformed into each other <em>without ever closing the energy gap</em>.</p><p>In the following, we will see that often one is interested in some more specific criterion: for instance, that some symmetry may be preserved throughout the continuous path which connects two Hamiltonians.</p><p>However, for the moment let’s just see these ideas at play using our quantum dot as a simple test case. Imagine our dot is initially described by a random $H$, such as:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">30</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure><p>For simplicity, we have taken $H$ to be real. Let’s now deform this Hamiltonian into another Hamiltonian $H’$, also real. We can imagine that this deformation describes the changes that occur to the dot as an external parameter, such as a gate voltage, is varied. We can parameterize the deformation by</p><p>$H(\alpha) = \alpha H’ + (1-\alpha) H,$</p><p>so that at $\alpha=0$ we are at the initial Hamiltonian and at $\alpha=1$ we are at the final Hamiltonian. Let’s see what the energy levels do as a function of $\alpha$ (we use more levels here than in the matrix above so that the spectrum looks more interesting).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">69</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum)</span><br></pre></td></tr></table></figure><p>You may notice from the plot that as $\alpha$ varies, it can happen that an energy level crosses zero energy. When this happens, we break the condition that there should be an energy gap in the system. Notice, however, that this does not necessarily mean that there is no continuous transformation between $H$ and $H’$ such that the gap does not close. It simply means that this particular path has gap closings. Perhaps it is possible to find another path which does not.</p><p>So are $H$ and $H’$ topologically equivalent or not? Let’s look at this situation:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">6</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum)</span><br></pre></td></tr></table></figure><p>We see that one level does cross zero (even twice), but it seems obvious that we can just push it down a little bit and we find a continuous path between two Hamiltonians. So we need to come up with an easier way to figure out if Hamiltonians can be transformed into each other or not.</p><h1 id="The-concept-of-a-topological-invariant"><a href="#The-concept-of-a-topological-invariant" class="headerlink" title="The concept of a topological invariant"></a>The concept of a topological invariant</h1><p>In order to know whether there is any path which connects $H$ and $H’$ without closing the gap, we can count the number of levels below zero energy, i.e. the number of filled energy levels. This is possible because the eigenvalues of gapped Hamiltonians can move freely as long as they don’t cross zero energy. Therefore continuous transformations exist exactly between Hamiltonians with the same number of energy levels below zero.</p><p>Since this number can not change under continuous transformations inside the set of gapped Hamiltonians, we call it a <em>topological invariant</em> $Q$.</p><p>Below, we plot the energy levels along our path from $H$ to $H’$ again, together with our topological invariant, the number of filled energy levels. You can see that this number changes between 3, 4 and 5. Hence we can say that $H$ and $H’$ are not topologically equivalent.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">69</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum)</span><br><span class="line">    + plot_Q(alphas, Q, [<span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line">).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>The plot makes it clear that we do not actually have to count the number of filled energy levels for both $H$ and $H’$, so it is enough to keep track of <em>zero energy crossings</em>. Whenever an energy level crosses zero energy, the number of levels below zero energy changes. Such a crossing therefore changes the topological invariant. We call that a <em>topological phase transition</em>.</p><p>If two Hamiltonians have a different topological invariant, they must be separated by such a transition. In other words, it is impossible to go from one to the other without closing the gap.</p><p>On the other hand, if there are equally many levels crossing from below to above zero energy as the other way around, the number of levels below zero energy does not change. The topological invariant is therefore the same for the initial and final Hamiltonian. In this case, there must be a continuous transformation between the initial and final Hamiltonian which does not close the gap.</p><p>Once we have identified a topological invariant, we can <em>classify</em> all quantum Hamiltonians according to its value. In this way we create classes of Hamiltonians which are all topologically equivalent, and we can keep track of all the different <em>topological phases</em> that these Hamiltonians can support.</p><h2 id="Role-of-conservation-laws"><a href="#Role-of-conservation-laws" class="headerlink" title="Role of conservation laws"></a>Role of conservation laws</h2><p>Let’s now consider the case that the Hamiltonian of the quantum dot satisfies a symmetry constraint. This means that there is a unitary matrix, for example $U = \sigma_z \otimes 1!!1$ where $\sigma_z$ is the third Pauli matrix, such that the Hamiltonian commutes with this matrix:</p><p>$$U^\dagger H U = H.$$</p><p>This means that the system has a conservation law, and that the Hamiltonian can be brought to a block-diagonal form:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">modes = <span class="number">5</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">H0 = make_cons_ham(<span class="number">2</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure><p>We can now look at the spectrum and the topological invariant of each subblock individually,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%%opts Layout [aspect_weight=<span class="number">1</span> fig_inches=(<span class="number">8</span>, <span class="number">6</span>) fig_size=<span class="number">100</span> ]</span><br><span class="line">np.random.seed(<span class="number">13</span>)</span><br><span class="line">H0 = make_cons_ham(modes)</span><br><span class="line">H1 = make_cons_ham(modes)</span><br><span class="line">spectrum1 = find_spectrum(alphas, H0[:modes, :modes], H1[:modes, :modes])</span><br><span class="line">spectrum2 = find_spectrum(alphas, H0[modes:, modes:], H1[modes:, modes:])</span><br><span class="line">Q1 = find_Q(spectrum1)</span><br><span class="line">Q2 = find_Q(spectrum2)</span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum1, [-<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    + plot_hamiltonian_spectrum(alphas, spectrum2, [-<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    + plot_Q(alphas, Q1, [<span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">    + plot_Q(alphas, Q2, [<span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">).cols(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>and combine them to get the spectrum and the topological invariant of the whole system:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>As you can see, unitary symmetries play a rather boring role. As usual, they allow to reduce the dimension of the problem at hand, but nothing more. There are however other symmetries which can have a rich influence on topology. An important example is time-reversal symmetry, as we will see next.</p><h1 id="Time-reversal-symmetry"><a href="#Time-reversal-symmetry" class="headerlink" title="Time-reversal symmetry"></a>Time-reversal symmetry</h1><p>In our previous examples, you might have wondered, whether there was anything special with choosing real matrices? Indeed there was something special. A real Hamiltonian is a manifestation of time-reversal symmetry. Time-reversal symmetry is represented by an anti-unitary operator, and as such it can always be written as the product $\mathcal{T}=U\mathcal{K}$ of a unitary matrix times complex conjugation. In the case above, we had simply $\mathcal{T}\equiv\mathcal{K}$. Our real Hamiltonians clearly obeyed time-reversal symmetry since $H=H^*$.</p><p>Let’s now break time-reversal symmetry, create random Hamiltonians with complex entries and see what happens.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">91</span>)</span><br><span class="line">H0 = make_random_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">92</span>)</span><br><span class="line">H0 = make_random_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>As you can see, there aren’t really many differences with the previous case. The different energy levels move, and the topological invariant changes when one of them crosses zero.</p><p>There is, however, a very important case where time-reversal symmetry makes a real difference. For systems with spin $1/2$, time-reversal symmetry has the operator</p><p>$$<br>\mathcal{T}=i\sigma_y \mathcal{K},<br>$$</p><p>with $\sigma_y$ the second Pauli matrix acting on the spin degree of freedom. In that case $\mathcal{T}^2=-1$. A Hamiltonian with this type of time-reversal symmetry obeys the equation</p><p>$$<br>H = \sigma_y, H^* \sigma_y.<br>$$</p><p>The following matrix is an example of such Hamiltonian:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">49</span>)</span><br><span class="line">H0 = make_random_symplectic_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure><p>Hamiltonians of this type have the following property: every energy eigenvalue $E_n$ is doubly degenerate (Kramers’ degeneracy). We can see the consequences of Kramers’ degeneracy on our game of deforming one random Hamiltonian into another.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">2285</span>)</span><br><span class="line">H0 = make_random_symplectic_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_symplectic_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>While the spectrum looks quite similar to the previous ones, whenever a line crosses zero energy, our topological invariant makes a jump of two, and not one! In this case, time-reversal symmetry constrains the topological invariant to only take even values. This is an example of how topological properties can be influenced by discrete symmetries.</p><h1 id="Sublattice-symmetry"><a href="#Sublattice-symmetry" class="headerlink" title="Sublattice symmetry"></a>Sublattice symmetry</h1><p>We just saw that time-reversal symmetry can forbid the topological invariant to take a certain set of values. We now study another case where a symmetry changes the topological properties dramatically.</p><p>Let’s now take a system where we can split all the degrees of freedom into two groups (say group $A$ and group $B$) such that the Hamiltonian only has nonzero matrix elements between two groups, and not inside each group. This situation arises naturally when the lattice has two sublattices, as in the hexagonal carbon lattice of graphene. So let’s imagine our quantum dot is now a graphene dot:</p><p><img src="/2021/01/07/src/w1_topointro/0d/graphene_dot.svg" alt></p><p>As a consequence of sublattice symmetry, the Hamiltonian of the graphene dot looks like this:</p><p>$$<br>H =<br>\begin{pmatrix}<br>0 &amp; H_{AB} \<br>H_{AB}^\dagger &amp; 0<br>\end{pmatrix}.<br>$$</p><p>We can once again generate a random Hamiltonian with sublattice symmetry, here:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">98</span>)</span><br><span class="line">pprint_matrix(make_chiral_ham(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>If we introduce a diagonal matrix $\sigma_z$ that equals $+1$ for sites on sublattice $A$, and $-1$ for sites on sublattice $B$, we can write the sublattice symmetry of the Hamiltonian as</p><p>$$<br>\sigma_z H \sigma_z = -H.<br>$$</p><p>This immediately means that if $(\psi_A, \psi_B)^T$ is an eigenvector of the Hamiltonian with energy $\varepsilon$, then<br>$(\psi_A, -\psi_B)^T$ is an eigenvector with energy $-\varepsilon$. A symmetric spectrum is the consequence of sublattice symmetry.</p><p>What does this mean for the topological classification?<br>Clearly, the number of states with negative energy is the same as the number of states with positive energy, and that means we don’t ever expect a single level to cross zero energy.</p><p>Let’s once again see if this is correct by transforming a random Hamiltonian with sublattice symmetry into another one.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modes = <span class="number">10</span></span><br><span class="line">np.random.seed(<span class="number">99</span>)</span><br><span class="line">H0 = make_chiral_ham(modes)</span><br><span class="line">H1 = make_chiral_ham(modes)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">3</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>Indeed, we can deform all the Hamiltonians with sublattice symmetry into one another without closing the gap.<br>This means that an extra symmetry may render topological classification trivial.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;OK, let&#x27;s see what we have so far. Which symmetry certainly &quot;</span></span><br><span class="line">    <span class="string">&quot;does not restrict the values that the topological invariant can take?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Spinless time-reversal symmetry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sublattice symmetry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Conservation law&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Spinful time-reversal symmetry&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;We cannot be sure about the conservation law, since the blocks may have different remaining symmetries. &quot;</span></span><br><span class="line">    <span class="string">&quot;And we just saw that sublattice symmetry makes every system trivial, while spinful time-reversal &quot;</span></span><br><span class="line">    <span class="string">&quot;makes the numbers of levels even.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">0</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Particle-hole-symmetry"><a href="#Particle-hole-symmetry" class="headerlink" title="Particle-hole symmetry"></a>Particle-hole symmetry</h1><p>There is another symmetry that has a strong influence on topology: particle-hole symmetry. It shows up in superconducting systems. As an example, imagine bringing our quantum dot in contact with a superconductor, like this:</p><p><img src="/2021/01/07/src/w1_topointro/0d/SCdot.svg" alt></p><p>A superconductor will create and annihilate pairs of electrons by breaking apart <a href="https://en.wikipedia.org/wiki/Cooper_pair">Cooper pairs</a> and forming them.<br>This results in a Hamiltonian:</p><p>$$<br>\mathcal{H} = \sum_{nm} H_{nm} c^\dagger_nc_m + \tfrac{1}{2} (\Delta_{nm} c^\dagger_n c^\dagger_m + \Delta^*_{nm} c_m c_n),<br>$$</p><p>where $c^\dagger_n, c_n$ are the creation and annihilation operators of the electrons. We recall that these operators anticommute, obeying the relations $c_nc_m+c_mc_n=0$ and $c^\dagger_n c_m + c_m c^\dagger_n = \delta_{mn}$, where $\delta_{mn}=0$ if $m\neq n$ and $1$ if $m=n$.</p><p>The $H$-term is the dynamics of the electrons in the dot, while $\Delta$ describes the pair creation and annihilation. The matrix $\Delta$ is antisymmetric because the fermion operators anticommute. Now $\mathcal{H}$ does not conserve the number of electrons, but still conserves the parity of the number of electrons, that is whether the number of electrons is even or odd. We can now group all the creation and annihilation operators in a vector, $C = (c_1, \dots, c_n, c^\dagger_1, \dots, c^\dagger_n)^T$. Then we write $\mathcal{H}$ in the form ‘row multiplies matrix multiplies column’:</p><p>$$<br>\mathcal{H} = \frac{1}{2} C^\dagger H_\textrm{BdG},C,.<br>$$</p><p>The matrix $H_\textrm{BdG}$ is known as the Bogoliubov-de Gennes Hamiltonian, and it has the following structure:</p><p>$$<br>H_\textrm{BdG} = \begin{pmatrix} H &amp; \Delta \ -\Delta^* &amp; -H^* \end{pmatrix}.<br>$$</p><p>The Bogoliubov-de Gennes Hamiltonian acts on wave functions whose first half is composed out of annihilation operators of electrons, and the second half out of creations operators of the same electrons.<br>We can think of them as annihilation operators of an extra set of holes, so that we double the amount of degrees of freedom in the system.</p><p>Since holes are related to the electrons, $H_{BdG}$ automatically has an extra symmetry.<br>This symmetry exchanges electrons with holes, and has an antiunitary operator $\mathcal{P}=\tau_x \mathcal{K}$, where the Pauli matrix $\tau_x$ acts on the particle and hole blocks. We have that:</p><p>$$<br>\mathcal{P} H_\textrm{BdG} \mathcal{P}^{-1} = -H_\textrm{BdG}.<br>$$</p><p>Particle-hole symmetry is represented by an anti-unitary operator which anti-commutes with the Hamiltonian (compare this situation with that of time-reversal and sublattice symmetries). Because of the minus sign in the particle-hole symmetry, the spectrum of $H_\textrm{BdG}$ must be symmetric around zero energy (that is, the Fermi level). Indeed, for every eigenvector $\psi = (u, v)^T$ of $H_\textrm{BdG}$ with energy $E$, there will be a particle-hole symmetric eigenvector $\mathcal{P}\psi=(v^<em>, u^</em>)^T$ with energy $-E$.</p><h2 id="Fermi-level-crossings-in-a-random-Bogoliubov-de-Gennes-Hamiltonian"><a href="#Fermi-level-crossings-in-a-random-Bogoliubov-de-Gennes-Hamiltonian" class="headerlink" title="Fermi level crossings in a random Bogoliubov-de Gennes Hamiltonian"></a>Fermi level crossings in a random Bogoliubov-de Gennes Hamiltonian</h2><p>Let’s generate a random Bogoliubov-de Gennes Hamiltonian $H_\textrm{BdG}$:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modes = <span class="number">2</span></span><br><span class="line">np.random.seed(<span class="number">101</span>)</span><br><span class="line">H0 = make_BdG_ham(modes)</span><br><span class="line">H1 = make_BdG_ham(modes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print in &#x27;normal&#x27; basis</span></span><br><span class="line">H0_normal = np.kron(np.array([[<span class="number">1</span>, -<span class="number">1j</span>], [<span class="number">1</span>, <span class="number">1j</span>]]), np.identity(modes)) @ H0</span><br><span class="line">H0_normal = H0_normal @ np.kron(np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1j</span>, -<span class="number">1j</span>]]), np.identity(modes))</span><br><span class="line">pprint_matrix(H0_normal)</span><br></pre></td></tr></table></figure><p>We can now see what happens when we deform it into a second one. You can indeed see clearly that the spectrum is mirrored around the line $E=0$, just like it was in the presence of sublattice symmetry.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modes = <span class="number">10</span></span><br><span class="line">np.random.seed(<span class="number">5</span>)</span><br><span class="line">H0 = make_BdG_ham(modes)</span><br><span class="line">H1 = make_BdG_ham(modes)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">3</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>You can however notice that, unlike in the case of sublattice symmetry, energy levels do not repel around zero energy, so that crossings at zero energy appear.</p><h2 id="Fermion-parity-switches"><a href="#Fermion-parity-switches" class="headerlink" title="Fermion parity switches"></a>Fermion parity switches</h2><p>Let’s think a bit more about these crossings. At first, they might look a bit mysterious. In general a crossing between energy levels happens in the presence of a conserved quantity, and our random Bogoliubov-de Gennes Hamiltonian does not seem to have an obvious one. Let’s however recall what we said earlier: While the mean-field Hamiltonian of a superconductor does not conserve the number of particles, it conserves the parity of this number. In other words, forming and breaking Cooper pairs does not affect whether the superconducting quantum dots contains an even or odd number of electrons. In short, fermion parity is a conserved quantity (provided that isolated electrons do not enter or leave the dot, a possibility which we will disregard).</p><p>The above observation reveals that the existence of crossings is due to the fermion parity conservation. Fermion parity, however, is a many-body quantity, which cannot be directly described in terms of the single particle picture of the Bogoliubov-de Gennes Hamiltonian.<br>To understand the existence of the crossings, recall that to obtain a Bogoliubov-de Gennes description of the superconductor we had to double the number of degrees of freedom by introducing holes.<br>Hence, unlike in the case of sublattice symmetry, a pair of $\pm E$ energy levels does not corresponds to two distinct quantum states, but to a <em>single</em> quantum state.<br>This quantum state is a coherent superposition of electrons and holes - a <em>Bogoliubov quasiparticle</em>: it has an excitation energy $E$, and it is created by an operator $a^\dagger = u c^\dagger + v c$.<br>Populating the partner state at energy $-E$ is the same as emptying the positive energy state.</p><p>When a pair of levels crosses zero energy, the excitation energy $E$ of the Bogoliubov quasiparticle changes sign and it becomes favorable to add a Bogoliubov quasiparticle to, or remove it from the superconducting quantum dot. In other words, at each crossing the fermion parity in the ground state of the dot changes from even to odd, or vice versa. Hence these crossings are <em>fermion parity switches</em>.</p><p>Since the ground state fermion parity is preserved by the superconducting Hamiltonian if there are no Bogoliubov quasiparticles crossing zero energy, the ground state fermion parity is the topological invariant of this system. It is clear however that this invariant is of a different nature than the one of the non-superconducting systems, which is given by the number of negative eigenvalues of the Hamiltonian. The latter cannot change for a Bogoliubov-de Gennes Hamiltonian, which has a symmetric energy spectrum, and hence it is not suitable to describe changes in fermion parity. Is there a way to compute this new invariant directly from the Bogoliubov-de Gennes Hamiltonian?</p><h2 id="The-Pfaffian-invariant"><a href="#The-Pfaffian-invariant" class="headerlink" title="The Pfaffian invariant"></a>The Pfaffian invariant</h2><p>In order to introduce the new invariant, we have to start with a basis transformation, that makes the Hamiltonian an antisymmetric matrix. We use the following unitary transformation in particle-hole space,</p><p>$$<br>\tilde{H}<em>{BdG}=\frac{1}{2}\left( \begin{array}{cc}<br>1 &amp; 1 \<br>i &amp; -i \end{array} \right)<br>H</em>{BdG}<br>\left( \begin{array}{cc}<br>1 &amp; -i \<br>1 &amp; i \end{array} \right),.<br>$$</p><p>We then have</p><p>$$<br>\tilde{H}_\textrm{BdG} = \frac{1}{2}\begin{pmatrix} H-H^<em>+\Delta-\Delta^</em> &amp; -iH-iH^<em>+i\Delta+i\Delta^</em> \ +iH+iH^<em>+i\Delta+i\Delta^</em> &amp; H-H^<em>-\Delta+\Delta^</em> \end{pmatrix}.<br>$$</p><p>We already know that the pairing matrix $\Delta$ is antisymmetric. Since $H$ is Hermitian $H-H^<em>$ is also antisymmetric and $H+H^</em>$ is symmetric. Then we can see that $\tilde{H}_\textrm{BdG}$ is antisymmetric.</p><p>There is a special number that we can compute for antisymmetric matrices, the <a href="http://en.wikipedia.org/wiki/Pfaffian">Pfaffian</a>. Its rigorous definition is not important for our course. The basic idea is simple: The eigenvalues of antisymmetric matrices always come in pairs. In the case of our $\tilde{H}_{BdG}$, these are the energy eigenvalues $\pm E_n$. By taking their product we obtain the determinant of the matrix, equal to $\prod_n (-E_n^2)$. The key property of the Pfaffian is that it allows to take a square root of the determinant, equal to $\pm \prod_n iE_n$, in such a way that the sign of the product is uniquely defined. At a fermion parity switch a single $E_n$ changes sign, so the Pfaffian changes sign as well (while the determinant stays the same).</p><p>This feature of the Pfaffian really makes it what we are looking for. Let’s try out the sign of the Pfaffian as our topological invariant $Q_\textrm{BdG}$:</p><p>$$ Q_\textrm{BdG} = \textrm{sign}\left[,\textrm{Pf} (i H_\textrm{BdG}),\right],.$$</p><p>We have included a factor of $i$ just for convenience, so that the Pfaffian is a real number.</p><p>Whenever we need to compute a Pfaffian we just use the <a href="http://arxiv.org/abs/1102.3440">Pfapack</a> package that calculates Pfaffians for numerical matrices. Let’s use that package and check that the Pfaffian indeed allows us to calculate the fermion parity of the ground state of $H_\textrm{BdG}$.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_pfaffian</span>(<span class="params">alphas, H0, H1</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function caculates the Pfaffian for a Hamiltonian.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    H0 : numpy array</span></span><br><span class="line"><span class="string">        Hamiltonian, same size as H1.</span></span><br><span class="line"><span class="string">    H1 : numpy array</span></span><br><span class="line"><span class="string">        Hamiltonian, same size as H0.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    pfaffians : numpy array</span></span><br><span class="line"><span class="string">        Pfaffians for each alpha.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">H</span>(<span class="params">alpha</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> - alpha) * H0 + alpha * H1</span><br><span class="line"></span><br><span class="line">    pfaffians = [np.sign(np.real(pf.pfaffian(<span class="number">1j</span> * H(a)))) <span class="keyword">for</span> a <span class="keyword">in</span> alphas]</span><br><span class="line">    <span class="keyword">return</span> np.array(pfaffians)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pfaffian = find_pfaffian(alphas, H0, H1)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">1.5</span>, <span class="number">1.5</span>])</span><br><span class="line">    + plot_Q(alphas, pfaffian, [-<span class="number">1.2</span>, <span class="number">1.2</span>], dims.Q_BdG)</span><br><span class="line">).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>You can see how the Pfaffian invariant $Q_\textrm{BdG}$ changes its value from $+1$ to $-1$ at every zero-energy crossing.<br>This means that it is the correct expression for the ground state fermion parity and for the topological invariant.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens to the topological invariant if we take the superconducting&quot;</span></span><br><span class="line">    + <span class="string">&quot; Hamiltonian and set $\Delta=0$?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The Pfaffian invariant still captures all of the topological properties.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hamiltonian loses particle-hole symmetry and becomes topologically trivial.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hamiltonian now has a new conservation law so there are two blocks, each with its own invariant.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It isn&#x27;t allowed to set $\Delta=0$&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;If $\Delta=0$ the numbers of filled electron and hole states is conserved, and so the invariant once again&quot;</span></span><br><span class="line">    <span class="string">&quot; becomes just the number of filled states.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;C7HoXjVbpoM&quot;</span>, src_location=<span class="string">&quot;1.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>Questions about what you learned? Ask them below</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Hamiltonians, Topology and Symmetry&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w0_background/band_structures/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w0_background/band_structures/</id>
    <published>2021-01-07T09:15:40.285Z</published>
    <updated>2021-01-07T09:11:06.782Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure><h1 id="A-quick-review-of-band-structures"><a href="#A-quick-review-of-band-structures" class="headerlink" title="A quick review of band structures"></a>A quick review of band structures</h1><p>For the material of this course we assume familiarity with basic linear algebra, quantum mechanics and solid state physics.<br>In this chapter, we briefly review the concepts most relevant to this course.<br>If you think you know how you would proceed if you are given to compute the bandstructure of graphene then you can likely skip this chapter.</p><h2 id="Quantum-mechanics-electrons-as-waves"><a href="#Quantum-mechanics-electrons-as-waves" class="headerlink" title="Quantum mechanics: electrons as waves"></a>Quantum mechanics: electrons as waves</h2><p>Quantum mechanics begins with stating that particles such as electrons should really be treated<br>as waves. These waves are described by the famous Schrodinger equation<br>$$i\hbar\partial_t \Psi = H\Psi,$$<br>where at this point $\Psi$ is the “wave-function” and $H$ is the Hamiltonian.<br>The problem of analyzing this Schrodinger equation can be reduced to the eigenvalue problem in linear algebra, though in many cases the vector space might be infinite dimensional.<br>In the following, we assume familiarity with basic finite dimensional linear (matrix) algebra.</p><h3 id="Schrodinger-equation-besides-electrons"><a href="#Schrodinger-equation-besides-electrons" class="headerlink" title="Schrodinger equation besides electrons"></a>Schrodinger equation besides electrons</h3><p>Our main focus is quantum-mechanical systems, however, as we will see, many ideas apply also in completely classical context of sound propagation and elasticity.<br>To see this, let us  convert a familiar wave-equation for a string in to a Schrodinger-like form.<br>You must have seen a wave-equation for a string that looks like<br>$$\partial_t^2 h-c^2\partial_x^2 h=0,$$<br>where $h(x,t)$ is the vertical displacement of the string.<br>This wave-equation is second order in time.<br>Let’s try to make it first order like the Schrodinger equation by defining $h_1(x,t)=c^{-1} \partial_t h(x,t)$ and $h_2(x,t)=\partial_x h(x,t)$.<br>After doing this we see that our wave-equation turns into a pair of equations that are linear order in time:<br>$$\partial_t h_2 = c\partial_x h_1$$<br>and<br>$$\partial_t h_1=-c\partial_x h_2.$$</p><p>We can turn this into the Schrodinger equation if we define:<br>$$\Psi(x,t)=\left(\begin{array}{c}h_1(x,t)\h_2(x,t)\end{array}\right)\quad H=c\left(\begin{array}{cc}0&amp; i\-i &amp; 0\end{array}\right)(-i\partial_x).$$<br>Now those of you who know basic quantum mechanics might say this is a very strange Schrodinger equation.<br>But this indeed is the wave-function for helical Majorana particles that we encounter later on.</p><h3 id="Applying-the-Schrodinger-equation"><a href="#Applying-the-Schrodinger-equation" class="headerlink" title="Applying the Schrodinger equation"></a>Applying the Schrodinger equation</h3><p>The wave-function $\Psi$ in the Schrodinger equation that describes electrons is typically a complex though the Hamiltonian is not a matrix (thankfully):<br>$$H=-\frac{\hbar^2}{2m}\partial_x^2 + V(x),$$<br>where $m$ is the mass of the electron and $V(x)$ is the background potential energy over which the electron is moving.</p><p>The main things that you should remember about wave equations for electrons are:  </p><ul><li>$\Psi(x,t)$ is complex, </li><li>$H$ is a Hermitian  matrix or operator </li><li>density of electrons are related to $|\Psi(x,t)|^2$.</li><li>If $N$ is the number of electrons, one must occupy $N$ orthogonal wave-functions.</li></ul><p>The last point is more subtle and is called the <strong>Pauli exclusion principle</strong>. We elaborate on orthogonality later.</p><p>Since we are interested in static properties of electrons in materials for much of our course, it helps to make the simplifying ansatz: $\Psi=e^{-i E t/\hbar}\psi$.<br>This ansatz simplifies the Schrodinger equation to a time-independent form:<br>$$H\psi=E\psi,$$<br>which is an eigenvalue problem in linear algebra.</p><p>We can often model electrons in materials within the  <strong>tight-binding</strong> approximation where electrons are assumed to occupy a discrete set of orbitals.<br>We then take $\psi_a$ to be the wave-function of the electron on orbital $a$.<br>The wave-functions $\psi_a$ can be combined into $\psi$, which is then a vector.<br>In this case, the Hamiltonian $H$ becomes a matrix with components $H_{ab}$.<br>These definitions transform the time-independent Schrodinger equation into a matrix eigenvalue problem from linear algebra.<br>Once we know how to set-up the matrix $H_{ab}$ to model a particular material, we can extract the properties of the material from the wave-function components $\psi_a$ and energy (eigenvalue) $E$.<br>A few key properties of the Schrodinger equation $H\psi^{(n)}=E^{(n)}\psi^{(n)}$ are: </p><ul><li>if $H$ is an $N\times N$ matrix, the eigenvalue index $n$ goes from $n=1,\dots,N$. </li><li>$H$ is Hermitian i.e. $H_{ab}=H_{ba}^*$. </li><li>Eigenstates are orthogonal i.e. $\psi^{(n)\dagger} \psi^{(m)}=0$ for $m\neq n$.</li></ul><p>Physicists have a convenient notation for doing linear algebra called the Dirac <strong>bra-ket</strong> notation.<br>In this notation, wave-functions such as $\psi$ are represented by <strong>kets</strong> i.e. $\psi\rightarrow |\psi\rangle$.<br>We construct the ket $|\psi\rangle$ from the components of the wave-function $\psi_a$ using the equation: $$|\psi\rangle=\sum_a \psi_a |a\rangle.$$<br>Similarly, we turn the Hamiltonian $H$ in to  an <strong>operator</strong> using the equation :$$H=\sum_{ab}H_{ab}|a\rangle \langle b|,$$<br>where $H_{ab}$ are the elements of the matrix $H$ from the last paragraph.<br>We call the object $\langle b|$ a <strong>bra</strong> and together with the ket it forms a bra-ket with the property $\langle b| a\rangle=\delta_{ab}$.<br>The Schrodinger equation now looks like $$H|\psi\rangle = E|\psi\rangle,$$<br>which can be checked to be the same equation as the linear algebra form. </p><h3 id="Example-Atomic-triangle"><a href="#Example-Atomic-triangle" class="headerlink" title="Example: Atomic triangle"></a>Example: Atomic triangle</h3><p>Let’s now work out the simple example of electrons moving in a triangle of atoms, where each atom has one orbital. We label the orbitals as $|0\rangle,|1\rangle,|2\rangle$.<br>With this labeling, the <strong>hopping</strong> amplitude $t$ of electrons between orbitals has the Hamiltonian<br>$$H=-t(|0\rangle \langle 1|+|1\rangle \langle 2|+|2\rangle \langle 0|)+h.c,$$<br>where $h.c.$ stands for Hermitian conjugate, which means that you reverse the ordering of the labels and take a complex conjugate.<br>We can also write the Hamiltonian in matrix form<br>$$H_{ab}=-\left(\begin{array}{ccc}0&amp;t&amp;t^<em>\t^</em>&amp;0&amp;t\t&amp;t^*&amp;0\end{array}\right).$$<br>Diagonalizing this matrix is a straightforward exercise that results in three eigenvectors $\psi^{(n)}_a$ (with $n=1,2,3$)<br>corresponding to energy eigenvalues<br>$$E^{(n)}=-2 |t| \cos{\theta},|t|\cos{\theta}\pm |t|\sqrt{3}\sin{\theta}$$<br>(where $t=|t|e^{i\theta}$).<br>The corresponding eigenvectors<br>$$\psi^{(n)}_a=3^{-1/2}(1,1,1),3^{-1/2}(1,\omega,\omega^2),3^{-1/2}(1,\omega^2,\omega)$$<br>where $\omega$ is the cube-root of unity (i.e. $\omega^3=1$).</p><h2 id="Bloch’s-theorem-for-bulk-electrons"><a href="#Bloch’s-theorem-for-bulk-electrons" class="headerlink" title="Bloch’s theorem for bulk electrons"></a>Bloch’s theorem for bulk electrons</h2><p>Actually, we can even solve the problem of an electron in an N site ring (triangle being $N=3$).<br>The trick to doing this is a neat theorem called Bloch’s theorem.<br>Bloch’s theorem is the key to understanding electrons in a crystal.<br>The defining property of a crystal is that the atomic positions repeat in a periodic manner in space.<br>We account for ALL the atoms in the crystal by first identifying a finite group of orbitals called the <strong>unit-cell</strong>.<br>We choose the unit-cell so that we can construct the crystal by translating the unit cell by a discrete set of vectors called lattice vectors to $n$.<br>We label the orbitals in the unit-cell by the index $l$, which takes a finite set of values.<br>By combining the unit cell and the lattice vectors, we  construct positions $a=(l,n)$<br>of all the orbitals in the crystal.<br>For our example of an atomic ring of size $N$, the index $l$ wouldn’t be needed since there is only one orbital per unit-cell and $n$ would take values $1$ to $N$.<br>In a three-dimensional crystal, $n=(n_x,n_y,n_z)$ would be a vector of integers.<br>The Hamiltonian for a crystal has matrix elements that satisfy $H_{(l,n),(l’,m)}=H_{(l,n-m),(l’,0)}$ for all pairs of unit-cell $n$ and $m$. </p><blockquote><p>Bloch’s theorem states that the Schrodinger equation for such Hamiltonians in crystals can be solved by the ansatz: $$\psi_{(l,n)}=e^{i k n}u_l,$$<br>where $u_l$ is the periodic part of the Bloch function which is identical in each unit-cell.</p></blockquote><p>The parameter $k$ is called crystal momentum and is quite analogous to momentum (apart from a factor of $\hbar$)<br>except that it is confined in the range $k\in [-\pi,\pi]$ which is referred to as the <strong>Brillouin Zone</strong>.<br>You can now substitute this ansatz into the Schrodinger equation: $\sum_{l’m}H_{(l,n),(l’,m)}u_{l’}e^{i k m}=E(k) e^{i k n}u_{l}(k)$.<br> Thus the Bloch functions $u(k)$ and energies $E(k)$ are obtained from the eigenvalue equation (so-called Bloch equation) $$H(k)u(k)=E(k)u(k),$$<br>where $$H(k)<em>{ll’}=\sum</em>{m}H_{(l,-m),(l’,0)}e^{-i k m}.$$<br>The Bloch equation written above is an eigenvalue problem at any momentum $k$.<br>The resulting eigenvalues $E^{(n)}(k)$ consitute the bandstructure of a material, where the eigenvalue label $n$ is also called a band index. </p><h3 id="Example-Su-Schrieffer-Heeger-model"><a href="#Example-Su-Schrieffer-Heeger-model" class="headerlink" title="Example: Su-Schrieffer-Heeger model"></a>Example: Su-Schrieffer-Heeger model</h3><p>Let us now work through an example.<br>The Su-Schrieffer-Heeger (SSH) model is the simplest model for polyacetylene, which to a physicist can be thought of as a chain of atoms with one orbital per atom.<br>However, the hopping strength alternates (corresponding to the alternating bond-length ) between $t_1$ and $t_2$.<br>Ususally you could assume that since each orbital has one atom there is only one atom per unit cell.<br>But this would mean all the atoms are identical.<br>On the other hand, in polyacetylene, half the atoms are on the right end of a short bond and half of them are on the left.<br>Thus there are two kinds of atoms - the former kind we label $R$ and the latter $L$. Thus there are two orbitals per unit cell that we label $|L,n\rangle$ and $|R,n\rangle$ with $n$ being the unit-cell label.</p><p><img src="/2021/01/07/src/w0_background/band_structures/Trans-_CH_n.svg" alt></p><p>The Hamiltonian for the SSH model is<br>$$H=\sum_n {t_1(|L,n\rangle\langle R,n|+|R,n\rangle\langle L,n|)+t_2(|L,n\rangle\langle R,n-1|+|R,n-1\rangle\langle L,n|)}.$$<br>This Hamiltonian is clearly periodic with shift of $n$ and the non-zero matrix elements of the Hamiltonian can be written as $H_{(L,0),(R,0)}=H_{(R,0),(L,0)}=t_1$ and $H_{(L,1),(R,0)}=H_{(R,-1),(L,0)}=t_2$.<br>The $2\times 2$ Bloch Hamiltonian is calculated to be: $$H(k)_{ll’=1,2}=\left(\begin{array}{cc}0&amp; t_1+t_2 e^{i k}\t_1+t_2 e^{-ik}&amp;0\end{array}\right).$$</p><p>We can calculate the eigenvalues of this Hamiltonian by taking determinants and we find that the eigenvalues are<br>$$E^{(\pm)}(k)=\pm \sqrt{t_1^2+t_2^2+2 t_1 t_2\cos{k}}.$$<br>Since $L$ and $R$ on a given unit-cell surrounded one of the shorter bonds (i.e. with larger hopping ) we expect $t_1&gt;t_2$. As $k$ varies across $[-\pi,\pi]$, $E^{(+)}(k)$ goes from $t_1-t_2$ to $t_1+t_2$. Note that the other energy eigenvalue is just the negative $E^{(-)}(k)=-E^{(+)}(k)$. </p><blockquote><p>As $k$ varies no energy eigenvalue $E^{(\pm)}(k)$ ever enters the range $-|t_1-t_2|$ to $|t_1-t_2|$. This range is called an <strong>band gap</strong>, which is the first seminal prediction of Bloch theory that explains insulators.</p></blockquote><p>This notion of an insulator is rather important in our course.<br>So let us dwell on this a bit further. Assuming we have a periodic ring with $2N$ atoms so that $n$ takes $N$ values, single valuedness of the wave-function $\psi_{(l,n)}$ requires that $e^{i k N}=1$.<br>This means that $k$ is allowed $N$ discrete values separated by $2\pi/N$ spanning the range $[-\pi,\pi]$.<br>Next to describe the lower-energy state of the electrons we can fill only the lower eigenvalue $E^{(-)}(k)$ with ane electron at each $k$ leaving the upper state empty.<br>This describes a state with $N$ electrons. Furthermore, we can see that to excite the system one would need to transfer an electron from a negative energy state to a positive energy state that would cost at least $2(t_1-t_2)$ in energy.<br> Such a gapped state with a fixed number of electrons cannot respond to an applied voltage and as such must be an insulator. </p><p>This insulator is rather easy to understand in the $t_2=0$ limit and corresponds to the double bonds in the polyacetylene chain being occupied by localized electrons. </p><h2 id="k-cdot-p-perturbation-theory"><a href="#k-cdot-p-perturbation-theory" class="headerlink" title="$k\cdot p$ perturbation theory"></a>$k\cdot p$ perturbation theory</h2><p>Let us now think about how we can use the smoothness of $H(k)$ to predict energies and wave-functions at finite $k$ from $H(k=0)$ and its derivatives.<br>We start by expanding the Bloch Hamiltonian<br>$$H(k)\approx H(k=0)+k H^{‘}(k=0)+(k^2/2)H^{‘’}(k=0)$$.<br>Using standard perturbation theory we can conclude that:<br>  the velocity and mass of a non-degenerate band near $k\sim 0$ is written as<br>  $$v_n =\partial_k E^{(n)}(k)= u^{(n)\dagger} H^{‘}(k=0) u^{(n)}$$<br>  and<br>  $$m_n^{-1}=\partial^2_k E^{(n)}(k)=u^{(n)\dagger} H^{‘’}(k=0) u^{(n)}+\sum_{m\neq n}\frac{|u^{(n)\dagger} H^{‘}(k=0) u^{(m)}|^2}{E^{(n)}(k=0)-E^{(m)}(k=0)},$$<br>where $E^{(n)}(k=0)$ and $u^{(n)}(k=0)$ are energy eigenvalues and eigenfunctions of $H(k=0)$. One of the immediate consequences of this is that the effective mass $m_n $ vanishes as the energy denominator $E^{(n)}(k=0)-E^{(m)}(k=0)$ (i.e. gap ) becomes small. This can be checked to be the case by expanding<br>$$E^{(-)}(k)\simeq -(t_1-t_2)-\frac{t_2^2}{(t_1-t_2)}k^2$$. </p><h3 id="Discretizing-continuum-models-for-materials"><a href="#Discretizing-continuum-models-for-materials" class="headerlink" title="Discretizing continuum models for materials"></a>Discretizing continuum models for materials</h3><p>The series expansion of $H(k)$ that we discussed in the previous paragraph is a continuum description of a material.<br>This is because the series expansion is valid for small $k$ that is much smaller than the Brillouin zone.<br>The continuum Hamiltonian is obtained by replacing $k$ in the series expasion by $\hbar^{-1}p$, where $p=-i\hbar\partial_x$ is the momentum operator. </p><p>A continuum Hamiltonian is sometimes easier to work with analytically then the crystal lattice of orbitals.<br>On the other hand, we need to discretize the continuum Hamiltonian to simulate it numerically. We can do this representing $k$ as a discrete derivative operator: $$k=-i\partial_x\approx -i(2\Lambda)^{-1}\sum_n (|n+1\rangle\langle n|-|n\rangle\langle n+1|).$$<br>The label $n$ is discrete-analogous to the unit-cell label, where the unit cell has size $\Lambda$.<br>To check that this is a representation of the derivative, apply $i k=\partial_x$ to $|\psi\rangle$ as $i k|\psi\rangle\approx \sum_n \frac{\psi_{n+1}-\psi_{n-1}}{2\Lambda}|n\rangle$.<br>In addition, we need to represent the $N\times N$ matrix structure of $H(k=0)$.<br>This is done by introducing label $a=1,\dots N$ so that the Hamiltonian is defined on a space labeled by $|a,n\rangle$.<br>Applying these steps to the the $k\cdot p$ Hamiltonian takes the discrete form:<br>$$H(k)\approx \sum_{n,a,b} H(k=0)<em>{ab}|a,n\rangle \langle b,n| +i H^{‘}(k=0)</em>{ab}(|a,n+1\rangle\langle b,n|-|a,n\rangle\langle b,n+1|),$$<br>where we have dropped the $k^2$ term for compactness.<br>For future reference, $k^2$ would discretize into $k^2=-\sum_n (|n\rangle \langle n+2|+|n+2\rangle\langle n|-2|n\rangle \langle n|)$.</p><p>But wait! Didn’t we just go in a circle by starting in a lattice Hamiltonian and coming back to a discrete Hamiltonian?<br>Well, actually, the lattice in the newly discretized model has almost nothing to do with the microscopic lattice we started with.<br>More often than not, the lattice constant $\Lambda$ (i.e. effective size of the unit-cell) in the latter representation is orders of magnitude larger than the microscopic lattice constant.<br>So the discrete model following from $k\cdot p$ is orders of magnitude more efficient to work with than tht microscopic model, which is why we most often work with these.<br>Of course, there is always a danger of missing certain lattice level phenomena in such a coarse-grained model.<br>Practically, we often do not start with an atomistic lattice model, but rather with a continuum $k\cdot p$ model and then discretize it.<br>This is because, the latter models can often be constrained quite well by a combination symmetry arguments as well as experimental measurements.<br>For example the $k\cdot p$ model for the conduction band minimum state of a GaAs quantum well is<br>$$H(k)=\hbar^2 k^2/2m^<em>+\alpha_R (\sigma_x k_y-\sigma_y k_x),$$<br>where $m^</em>$ is the electron effective mass, $\sigma_{x,y}$ are Pauli matrices and $\alpha_R$ is the Rashba spin-orbit coupling. This model is rather complicated to derive from the atomistic level (though it can be done). On the hand, it has also been checked experimentally through transport.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The main goal of this section was to review the simplest models for how electrons in crystals can be described quantum mechanically.</p><p>Let us summarize this review of bandstructures: </p><ul><li>Quantum mechanics views electrons as waves described by the Schrodinger equation.</li><li>The Schrodinger equation written in a basis of orbitals becomes a matrix eigenvalue problem from linear algebra.</li><li>The Schrodinger equation for electrons in crystals can be solved using Bloch’s theorem, where crystal momentum $k$ is a good quantum number.</li><li>The crystal momentum $k$ is periodic within the Brillouin zone.</li><li>We can treat the crystal momentum $k$ as a derivative when $k$ is small - called the $k\cdot p$ approximation.</li><li>We solve this Hamiltonian numerically by discretizing the derivative $k$.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w9_disorder/w9_assignments/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w9_disorder/w9_assignments/</id>
    <published>2021-01-07T09:11:06.885Z</published>
    <updated>2021-01-07T09:11:06.885Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure><h1 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h1><h2 id="1D-localization"><a href="#1D-localization" class="headerlink" title="1D localization"></a>1D localization</h2><p>As usual, start by grabbing the notebooks of this week (<code>w9_disorder</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p><p>Our aim now is to verify that Anderson localization works in one-dimensional systems.</p><p>Simulate the Anderson model of a ribbon of appropriate and large width $W$  as a function of length $L$.</p><p>Anderson model is just the simpest <a href="http://kwant-project.org/doc/1.0/tutorial/tutorial1">tight binding model on a square lattice</a> with random onsite potential.</p><p>Tune your model in the clean limit such that it has a relatively large number of modes (at least 3). Then calculate conductance as a function of $L$ at a finite disorder, while keeping $W$ constant.</p><p>The weak disorder regime should look ohmic or classical i.e $g \sim N_{ch}\lambda_{MFP}/L$. Here $\lambda_{MFP}$ is the mean free path, and $N_{ch}$ is the number of channels.</p><p>First, verify that when $g \gtrsim 1$ you observe the classical behavior and evaluate the mean free path.</p><p>Verify that the scaling also holds for different disorder strengths and different widths.</p><p>Examine the plot for larger $L$, but this time plot $\textrm{ln}(g)$ to verify that at large $L$ the conductance $g$ goes as $g \sim \exp(-L/\xi)$. Try to guess how $\xi$ is related to $\lambda_{MFP}$ by comparing the numbers you get from the plot in this part and the previous.</p><p>Check what happens when you reduce the disorder? Is there sign of a insulator- metal transition at lower disorder?</p><h2 id="Griffiths-phase"><a href="#Griffiths-phase" class="headerlink" title="Griffiths phase"></a>Griffiths phase</h2><p>A disordered Kitaev chain has a peculiar property. Close to the transition point it can have infinite density of states even despite it is insulating.</p><p>Calculate the energies of all the states in a finite Kitaev chain with disorder. You’ll need to get the Hamiltonian of the chain by using <code>syst.hamiltonian_submatrix</code> method, and diagonalize it (check the very beginning of the course if you don’t remember how to diagonalize matrices).</p><p>Do so for many disorder realizations, and build a histograph of the density of states for different values of average $m$ and of disorder strengh around the critical point $m=0$.</p><p>If all goes well, you should observe different behaviors: the density of states in a finite region around $m=0$ has a weak power law divergence, that eventually turns into an actual gap. Check out this paper for details:</p><ul><li>arXiv:cond-mat/0011200</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Now share your results:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Disorder&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-0908-0881"><a href="#arXiv-0908-0881" class="headerlink" title="arXiv:0908.0881"></a>arXiv:0908.0881</h3><p><strong>Hint:</strong> The topological Anderson insulator.</p><h3 id="arXiv-0705-0886"><a href="#arXiv-0705-0886" class="headerlink" title="arXiv:0705.0886"></a>arXiv:0705.0886</h3><p><strong>Hint:</strong> One-parameter scaling in graphene.</p><h3 id="arXiv-0705-1607"><a href="#arXiv-0705-1607" class="headerlink" title="arXiv:0705.1607"></a>arXiv:0705.1607</h3><p><strong>Hint:</strong> Scaling with Dirac fermions.</p><h3 id="arXiv-1208-3442"><a href="#arXiv-1208-3442" class="headerlink" title="arXiv:1208.3442"></a>arXiv:1208.3442</h3><p><strong>Hint:</strong> The average symmetry and weak transitions.</p><h3 id="arXiv-1411-5992"><a href="#arXiv-1411-5992" class="headerlink" title="arXiv:1411.5992"></a>arXiv:1411.5992</h3><p><strong>Hint:</strong> A technical paper about localization in 1D, but you don’t need to follow the calculations.</p><h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Disorder&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w9_disorder/topoflow/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w9_disorder/topoflow/</id>
    <published>2021-01-07T09:11:06.885Z</published>
    <updated>2021-01-07T09:11:06.885Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> LineCollection</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap, BoundaryNorm</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> la</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the path to a folder containing data files, to work with filters as well.</span></span><br><span class="line">data_folder = (</span><br><span class="line">    <span class="string">&quot;data/&quot;</span> <span class="keyword">if</span> os.path.exists(<span class="string">&quot;data&quot;</span>) <span class="keyword">and</span> os.path.isdir(<span class="string">&quot;data&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;../../data/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_kitaev_chain</span>(<span class="params">L=<span class="number">10</span></span>):</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.disorder:</span><br><span class="line">            <span class="keyword">return</span> (p.m + <span class="number">2</span> * p.t) * pauli.sz</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rand = p.disorder * kwant.digest.gauss(<span class="built_in">str</span>(site.tag), p.salt)</span><br><span class="line">            <span class="keyword">return</span> (p.m + rand + <span class="number">2</span> * p.t) * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz - <span class="number">1j</span> * p.delta * pauli.sy</span><br><span class="line"></span><br><span class="line">    syst[(lat(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>,))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The leads are precalculated.</span></span><br><span class="line">    lead[lat(<span class="number">0</span>)] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    syst = syst.precalculate(</span><br><span class="line">        params=<span class="built_in">dict</span>(p=SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phase_diagram</span>(<span class="params">L, ms, p, num_average=<span class="number">100</span></span>):</span></span><br><span class="line">    syst = make_kitaev_chain(L)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adjust the reflection phase such that it&#x27;s 0 for trivial system.</span></span><br><span class="line">    trivial = SimpleNamespace(m=<span class="number">10.0</span>, t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0</span>, salt=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    phase = kwant.smatrix(syst, params=<span class="built_in">dict</span>(p=trivial)).data[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    phase /= <span class="built_in">abs</span>(phase)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> p.m <span class="keyword">in</span> ms:</span><br><span class="line">        qt = []</span><br><span class="line">        <span class="keyword">for</span> p.salt <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(num_average)):</span><br><span class="line">            s = kwant.smatrix(syst, params=<span class="built_in">dict</span>(p=p)).data</span><br><span class="line">            qt.append(((s[<span class="number">0</span>, <span class="number">0</span>] / phase).real, <span class="built_in">abs</span>(s[<span class="number">0</span>, <span class="number">1</span>]) ** <span class="number">2</span>))</span><br><span class="line">        qt = np.mean(qt, axis=<span class="number">0</span>)</span><br><span class="line">        data.append(qt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(data).T</span><br></pre></td></tr></table></figure><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The scaling flow of topological insulators is introduced by Alexander Altland from the University of Cologne</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;8gkERY6hXTU&quot;</span>, src_location=<span class="string">&quot;9.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="A-toy-model-for-two-parameter-scaling-the-disordered-Kitaev-chain"><a href="#A-toy-model-for-two-parameter-scaling-the-disordered-Kitaev-chain" class="headerlink" title="A toy model for two-parameter scaling: the disordered Kitaev chain"></a>A toy model for two-parameter scaling: the disordered Kitaev chain</h1><p>Before we learn what happens to topological insulators in the presence of disorder, let’s decide on a specific example for concreteness.</p><p>Topology makes the behavior of disordered systems richer, however a careful simulation of properties of disordered topological insulators may take weeks, since we need not only to take large system sizes (we need to consider the lengths much larger than mean free path), but also we need to average over disorder.</p><p>Luckily, unlike in the non-topological case, a one-dimensional system can already show interesting properties in the presence of disorder, so we can just reuse the familiar Kitaev chain and add disorder to it.</p><p>It is nothing but the same 1D tight-binding model that we saw in week one,</p><p>$$<br>H = \sum_n (\mu_n + 2t + m) \tau_z\left|n\right\rangle\left\langle n\right|-\sum_n \left[(t\tau_z+i\Delta\tau_y),\left|n\right\rangle\left\langle n!+!!1 \right| + \textrm{h.c.}\right].<br>$$</p><p>For convenience, we introduced a mass $m$ that corresponds to the gap in the Dirac equation. The phase transition happens at $m=0$, and $m&lt;0$ corresponds to the topological phase with Majorana modes at the end.</p><p>The only difference from what we used before is that now the chemical potential $\mu_n$ varies randomly from site to site. For example, we can sample the values $\mu_n$ from a Gaussian distribution with mean value $\mu_0 $ and standard deviation $U$.</p><h1 id="The-simpler-effect-of-disorder"><a href="#The-simpler-effect-of-disorder" class="headerlink" title="The simpler effect of disorder"></a>The simpler effect of disorder</h1><p>In addition to transmission through a finite chain we can now compute its topological invariant $\mathcal{Q}$.</p><p>Just as a reminder: $\mathcal{Q} = \det r$, with $r$ is the reflection matrix from one end of a finite Kitaev chain.</p><p>We know that $\mathcal{Q}=-1$ in the topological phase and $\mathcal{Q}=+1$ in the trivial phase. Now, in the presence of disorder, the value of $\mathcal{Q}$ in a finite size system can in principle depend on the particular disorder realization. So just like calculating average conductance, we can average the topological invariant over disorder to describe how topological properties depend on it.</p><p>Whenever $\langle Q\rangle = \pm 1$, we know that the system is in one of the two insulating phases and there is no reflection whatsoever.</p><p>Let’s try the most obvious thing and see what happens to  $\langle Q\rangle$, as we increase disorder strength.</p><p>So below we see $\mathcal{Q}$ averaged over 100 different realizations in a disordered Kitaev chain with 30 sites as we gradually increase $U$:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>) <span class="keyword">and</span> os.path.exists(</span><br><span class="line">    data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span></span><br><span class="line">):</span><br><span class="line">    ms = np.loadtxt(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>)</span><br><span class="line">    qs = np.loadtxt(data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># This cell generates data</span></span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>)</span><br><span class="line">    ms = np.linspace(-<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">50</span>)</span><br><span class="line">    qs = [phase_diagram(<span class="number">30</span>, ms, p)[<span class="number">0</span>] <span class="keyword">for</span> p.disorder <span class="keyword">in</span> np.linspace(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">10</span>)]</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>, ms)</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span>, qs)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">ax.set_prop_cycle(<span class="string">&quot;alpha&quot;</span>, np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(qs)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> qs:</span><br><span class="line">    ax.plot(ms, q)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;$m$&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">r&quot;$\langle Q \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">0.4</span>, <span class="number">0</span>, <span class="number">0.4</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">ax.set_xlim(-<span class="number">0.4</span>, <span class="number">0.4</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.1</span>, <span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line">ax.hlines(<span class="number">0</span>, ax.get_xlim()[<span class="number">0</span>], ax.get_xlim()[<span class="number">1</span>], linestyles=<span class="string">&quot;dashed&quot;</span>);</span><br></pre></td></tr></table></figure><p>(Darker color corresponds to larger $U$.)</p><p>What you see is that far away from the transition, when the gap in the clean limit is very large, disorder does not matter. Around the transition, the average value of $\mathcal{Q}$ changes from $-1$ and $+1$.</p><p>Increasing disorder changes two things: </p><ul><li>It makes the width of the region where the transition happens larger. This we can understand relatively well, in a finite system adding fluctuations just means we can be (un)lucky and get an opposite value of the topological invariant.</li><li>It shifts the separation point between trivial and topological phases towards positive $m$. This looks much more curious: if we start with a trivial and insulating system and add disorder, it appears we can make this system topological!</li></ul><p>The second effect, despite looking mysterious, appears just because the disorder changes the effective values of the Hamiltonian parameters. For small $U$, this can be understood in terms of the <a href="https://en.wikipedia.org/wiki/Born_approximation">Born approximation</a>, which allows to compute <em>effective</em> disorder-averaged band structure parameters, given the properties of disorder. The lowest order correction to $m$ for the disorder Kitaev chain is simply $m_\textrm{eff} - m \sim -U^2$, and weak disorder indeed drives the system to a topologically nontrivial state by lowering the effective value of the mass.</p><p>Since this phenomenon appears with disorder, it was initially dubbed “topological Anderson insulator”. This name is certainly not accurate: the band structure parameters approach the effective ones on the length scale of mean free path, and before the Anderson scaling flow begins.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">r&quot;What would happen if instead of $\det r$ we use $sign \det r$ for invariant?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;We would get a step function instead of a smooth curve.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;Not well-defined because $\det r$ becomes complex.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The $Q=\pm 1$ plateaus cancel and give $Q=0$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The curve is qualitatively the same.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">r&quot;Each disorder realization get $\textrm&#123;det&#125; r\sim \pm 1$ except near the transition. So adding sign doesn&#x27;t affect &quot;</span></span><br><span class="line">    <span class="string">&quot;the invariant for most disorder realizations. The intermediate values result from averaging over different &quot;</span></span><br><span class="line">    <span class="string">&quot;realizations.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Two-parameter-scaling-in-one-dimension"><a href="#Two-parameter-scaling-in-one-dimension" class="headerlink" title="Two parameter scaling in one dimension"></a>Two parameter scaling in one dimension</h1><p>Speaking of the scaling flow: the scaling hypothesis appears to be very powerful, does the topology have any impact on it?</p><p>We can understand some limits. First of all, if $g\gg 1$, the system is a metal, and there can hardly be any trace of topology left. However when $g \lesssim 1$, the system can become one out of several topologically distinct types of insulators, and we can expect some sort of transition between different insulating phases.</p><p>The rational assumption at this point is to assume that the scaling hypothesis still holds, but in addition to $g$ it depends on the average topological invariant of the disordered ensemble $\langle \mathcal{Q} \rangle$.</p><p>Just like in the case of the non-topological phases, there is no universal proof that this form of scaling flow is correct. Instead, there is a vast amount of mixed numerical and analytical evidence that this is correct.</p><p>Let’s try and verify our hypothesis by constructing the scaling flow of the disordered Kitaev chain. We can do it in the following way:</p><ul><li><p>Choose a given disorder strength $U$, a given length $L$, and a set of values ${\mu}$ for the chemical potential. For each of these values, we compute $\langle \mathcal{Q} \rangle$ and the average transmission $\langle T \rangle$ over a large number of disorder realizations (as large as possible, in our case 1000). This gives us a set of starting points on the $(\langle \mathcal{Q} \rangle, \langle T \rangle)$ plane.</p></li><li><p>Increase the chain length $L$, and compute $\langle \mathcal{Q} \rangle, \langle T \rangle$ again for all the values ${\mu}$. We obtain a second set of points on the plane.</p></li><li><p>Join the points corresponding to the same value of $\mu$.</p></li><li><p>Increase again the length $L$, and so on…</p></li></ul><p>Here’s what we get:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>) <span class="keyword">and</span> os.path.exists(</span><br><span class="line">    data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span></span><br><span class="line">):</span><br><span class="line">    qs = np.loadtxt(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>)</span><br><span class="line">    ts = np.loadtxt(data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0.8</span>)</span><br><span class="line">    Ls = np.array(np.logspace(np.log10(<span class="number">10</span>), np.log10(<span class="number">180</span>), <span class="number">6</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">    ms = [np.sign(x) * x ** <span class="number">2</span> + <span class="number">0.2</span> <span class="keyword">for</span> x <span class="keyword">in</span> np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">40</span>)]</span><br><span class="line">    qs, ts = <span class="built_in">zip</span>(*[phase_diagram(<span class="built_in">int</span>(L), ms, p, num_average=<span class="number">1000</span>) <span class="keyword">for</span> L <span class="keyword">in</span> Ls])</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>, qs)</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span>, ts)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">npoints = qs.shape[<span class="number">0</span>]</span><br><span class="line">X, Y = qs.T, ts.T</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y):</span><br><span class="line">    points = np.array([x, y]).T.reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    segments = np.concatenate([points[:-<span class="number">1</span>], points[<span class="number">1</span>:]], axis=<span class="number">1</span>)</span><br><span class="line">    lc = LineCollection(</span><br><span class="line">        segments, cmap=<span class="string">&quot;gist_heat_r&quot;</span>, norm=matplotlib.colors.Normalize(<span class="number">0</span>, npoints + <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    lc.set_array(np.array(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, npoints + <span class="number">1</span>))))</span><br><span class="line">    ax.add_collection(lc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.set_xlim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">r&quot;$\langle Q \rangle$&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">r&quot;$\langle T \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">1</span>, -<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">0.0</span>, <span class="number">0.25</span>, <span class="number">0.50</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals]);</span><br></pre></td></tr></table></figure><p>The lines have a direction, which tells us how $\langle Q \rangle$ and $\langle T \rangle$ change as we increase $L$. In the plot above, $L$ is increasing in going from bright to dark colors.</p><p>The first and the most important observation we can make is that the lines do not intersect, which confirms the scaling hypothesis.</p><p>Most of the lines tend to one of the two points $(\langle \mathcal{Q} \rangle, \langle T \rangle) = (-1, 0)$ or $(1, 0)$. These correspond to two insulating systems with different topological invariants. We can say that quantized values of $\langle \mathcal{Q} \rangle$ are insulating, and they correspond to <em>attractive fixed points</em> of the flow.</p><p>You can also see that the flow is roughly separated around a vertical <em>critical line</em> at $\langle \mathcal{Q} \rangle=0$. All lines which start from a negative value of $\langle \mathcal{Q} \rangle$ end up at $(-1, 0)$, and all the lines which start from a positive value end up at $(1,0)$.</p><p>Finally, the point $(0, 0)$ is a saddle point: the flow goes towards it along the vertical axis, and away from it along the horizontal axis.</p><p>We now understand better why two parameter scaling is necessary in the presence of a topological invariant. Even in the presence of disorder, there can be topologically distinct insulating phases. Therefore, saying that every system flows to an insulator is not enough anymore. Including the average topological invariant as a second scaling parameter allows to predict towards <em>which</em> insulating phase the system will flow.</p><p>The flow, we just calculated is in fact valid for all one-dimensional topological insulators and superconductors. In the case of a $\mathbb{Z}$ invariant, the saddle points are located at $(\langle \mathcal{Q} \rangle, \langle T\rangle) = (n+1/2, 0)$.</p><p>It is important to notice that one important result of the standard scaling theory regarding one dimensional system remains true: in the plot above all lines flow to no transmission, or in other words there are no metallic phases in the flow diagram.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What does the 2 parameter flow diagram predict about the infinite size limit?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Always topological for all parameters.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There&#x27;s a localized topological and non-topological phase separated by a transition point.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Always localized for every parameter.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Almost always conducting except at a transition point.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The phase is determined by the long length (i.e. dark part of the figure) which is almost always in small T&quot;</span></span><br><span class="line">    <span class="string">&quot;i.e. supporting localized states. Here the states either flow to $Q=+1$ or $Q=-1$ (non-top or top respectively) &quot;</span></span><br><span class="line">    <span class="string">&quot;except near $Q=0$ has a slower decay.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Critical-point"><a href="#Critical-point" class="headerlink" title="Critical point"></a>Critical point</h1><p>The scaling flow of 1D topological insulators can be solved exactly, and especially for our system we can very easily derive some of its properties.</p><p>The behavior of the disordered Kitaev chain close to the phase transition can be understood within an effective Dirac Hamiltonian in the continuum limit. The Hamiltonian is similar to the one, we studied in week one when we were concerned with a domain wall</p><p>$$<br>H_\textrm{Dirac} = v,p,\tau_z + m(x),\tau_y,,<br>$$</p><p>with $p$ the momentum along the chain, $v$ the velocity of the modes, and $m(x)$ the position dependent gap which couples left-movers and right-movers.</p><p>To model the disordered chain, we take $m(x)$ to be a random function of $x$, just like $\mu_n$ was random in the lattice version. The chain is disordered in a segment of finite size $L$, while for $x&lt;0$ and $x&gt;L$ we set $m=0$ so that in this region we have propagating modes and thus a well-defined scattering problem.</p><p>We want to compute the transmission probability through the chain at zero energy. As we saw in week one, an eigenstate at zero energy satisfies the relation</p><p>$$<br>\Psi(L) =,\exp,(-\tau_x,\alpha),,\Psi(0),,<br>$$</p><p>with a parameter</p><p>$$\alpha = \frac{1}{v},\int_0^L, m(x), dx,$$</p><p>proportional to the average value of the random mass in the chain.</p><p>An incoming wave from the left (negative $x$) entering the scattering region is partially transmitted through it and partially reflected. We can find the reflection and transmission amplitudes $r, t$ by substituting $\Psi(0)=(1,r)^T$ and $\Psi(L) = (t,0)^T$ in the equation above. By solving the simple linear system that comes out of the substitution, we get immediately </p><p>$$<br>r = \tanh (\alpha),,;;t = \cosh^{-1} (\alpha).<br>$$</p><p>The scattering topological invariant $Q$ for the Kitaev chain is the sign of the determinant of $r$. In our case, since $r$ is just a number, we immediately get</p><p>$$Q=r = \tanh\alpha,.$$</p><p>We see that the topological transition happens when $\alpha=0$. That is, to model the transition, we think of $m(x)$ as a random function of $x$ which can take positive and negative values with equal probabilities. </p><p>The details of the probability distribution for $m(x)$ are not very important as long as the distribution is characterized by a finite correlation length $\xi \ll L$ - that is, values of $m$ at points more distant than $\xi$ are statistically uncorrelated. </p><p>If this is the case, $\alpha$ is the sum of an order $\sim L/\xi$ of uncorrelated values of $m$. By using the <a href="http://en.wikipedia.org/wiki/Central_limit_theorem">central limit theorem</a>, we can say that $\alpha$ is a normally distributed variable with zero mean and a variance growing linearly in $L$. Since $\alpha$ is a random variable, so is the transmission probability $T=|t^2|=\cosh^{-2}(\alpha)$. From the probability distribution of $\alpha$, we can obtain the scaling behavior of $T$ as</p><p>$$<br>\left\langle T \right \rangle \propto 1/\sqrt{L},.<br>$$</p><h1 id="Two-parameter-scaling-in-higher-dimensions"><a href="#Two-parameter-scaling-in-higher-dimensions" class="headerlink" title="Two parameter scaling in higher dimensions"></a>Two parameter scaling in higher dimensions</h1><p>Just like the regular scaling flow, the topological one is also richer in $d&gt;1$.</p><p>The oldest known example of the two parameter flow is unsurprisingly the quantum Hall effect. The flow looks similar to what we just calculated in 1D, here:</p><p><img src="/2021/01/07/src/w9_disorder/topoflow/Three_Dimensional_RG_Flowdiagram_of_the_QHE.png" alt></p><p>By Wout Neutkens (Own work) <a href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, via Wikimedia Commons</p><p>The axes are the same as before - the horizontal one is the topological invariant given by $\sigma_H$, and the vertical axis the longitudinal conductance. The saddle point separating the different topological phases is now elevated to a finite critical conductance, which is known to be around $0.5-0.6$ conductance quanta.</p><p>Metallic phases are the final part that we need to consider. The appearance of those at high conductance is governed by the same rules as without the topological invariant. The reason for this is that the topological effects are all $\mathcal{O}(1)$ corrections to conductance, and are therefore only important at $g\sim 1$.</p><p>An extra attractive metallic fixed point can make the flow diagram more complicated. For example, the metallic phase can completely separate the two insulating phases and eliminate the fixed point. What happens in each particular case is not always certain, and is still an open research topic.</p><h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;NY6wPiH0E9E&quot;</span>, src_location=<span class="string">&quot;9.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p>Questions about what you just learned? Ask them below!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topological scaling&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w9_disorder/scaling/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w9_disorder/scaling/</id>
    <published>2021-01-07T09:11:06.884Z</published>
    <updated>2021-01-07T09:11:06.884Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the path to a folder containing data files, to work with filters as well.</span></span><br><span class="line">data_folder = (</span><br><span class="line">    <span class="string">&quot;data/&quot;</span> <span class="keyword">if</span> os.path.exists(<span class="string">&quot;data&quot;</span>) <span class="keyword">and</span> os.path.isdir(<span class="string">&quot;data&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;../../data/&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Anderson localization is introduced by Piet Brouwer from the Free University of Berlin.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;sbbyL0RDH-o&quot;</span>, src_location=<span class="string">&quot;9.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>At this point, you might be wondering how we got from talking about topological insulators to disordered metals. Well, we told you several times that topological states are supposed to be robust to disorder, and that this is one of the main reasons why they are so interesting.</p><p>Based on the arguments we made in previous weeks, you could convince yourselves that certain properties, such as the bulk boundary correspondence, are robust as long as disorder isn’t enough to close the gap. However, many topological properties that we measure could in principle be susceptible to disorder.</p><p>For example, we told you that at the edge of a two-dimensional topological insulator, there is a perfectly conducting state that is robust to disorder. Remember however that we made no such claims about the surface states of a three-dimensional topological insulator! In fact, while in three dimensions the conductance is certainly susceptible to disorder, topology forbids it from becoming zero. Such subtle properties require a more detailed understanding of disorder.</p><h1 id="Simple-limits-localized-and-extended-states"><a href="#Simple-limits-localized-and-extended-states" class="headerlink" title="Simple limits: localized and extended states"></a>Simple limits: localized and extended states</h1><p>When we speak of disorder in electronic systems, the main distinction we need to keep in mind is that between extended and localized states.</p><p>Let’s start by thinking of a three dimensional metal with a low density of impurities, and hence weak disorder. In this limit, electrons moving through the system are only scattered by impurities every now and then, but otherwise they move ballistically between collisions. This picture is known as the <a href="http://en.wikipedia.org/wiki/Drude_model">Drude model</a>, and yields a conductivity given by</p><p>$$\sigma=n e^2\tau/m,$$</p><p>where $n$ is the electron density, $m$ is the electron mass and $\tau$ the mean free time between collisions. In this limit, the electron wave functions are extended throughout the bulk of the system, much like the plane waves of a clean crystal.</p><p>The other extreme is the strong disorder limit, in which there is a strongly fluctuating random potential in the material, for instance due to a high density of impurities. This potential has minima at random positions in the material, where electrons can become trapped. The corresponding wave functions are localized exponentially close to the minima. If the density of impurities is high in the material, all electronic states are of this type. In this situation, the only mechanism for conduction in the material is tunneling between different potential minima. However, the minima may be far apart from each other, which leads to a suppression of conductance and to an insulating state.</p><p>Let’s discuss qualitatively the simplest effect of strong disorder on topological states, which are gapped. If we imagine a disorder potential with a Gaussian distribution, there are always “rare regions” where the disorder potential is very deep. Such potentials may thus yield energy levels in the middle of the gap. If disorder is strong, there might even be no energy gap at all! However, the electrons trapped in these rare regions are localized, and do not participate in any of the transport properties of the material.</p><blockquote><p>Thus, even weak disorder can close the energy gap, which is what protects topology, as discussed so far. However, since these localized states are isolated from each other, and most importantly from the edges, they do not affect any of the topological properties.</p></blockquote><p>The considerations above make it clear that the presence or absence of an energy gap is not a good criterion to tell whether a system is insulating or not in the presence of strong disorder, and that we need to understand the nature of the electronic states in the system. Our definition of an insulating state must obey a new criterion. As will see next, this criterion can be obtained by studying conductance as a function of the system size.</p><h1 id="Conductance-scaling"><a href="#Conductance-scaling" class="headerlink" title="Conductance scaling"></a>Conductance scaling</h1><p>How can we really get away with understanding electrons in disordered potentials without doing any real quantum mechanical calculations? We can only do this in the two aforementioned extreme limits, and actually only in certain dimensions. In principle, to see how the “transition” from extended to localized electrons happens as disorder is increased, one must solve the full quantum mechanical problem. So far, it seems impossible to solve this problem exactly in any dimension other than 1D, so we won’t bother and instead discuss an educated guess, which gives us most of the answer.</p><p>To start with, let us be more specific and consider the conductance $G(L)$ of a $d$-dimensional block with sides $L$. The conductance represents the ease with which electrons can propagate through the block, and is has the natural unit $G_0=e^2/h$. Therefore, we can think of the dimensionless conductance $g(L)=G(L)/G_0$ as sort of a higher dimensional analog of the average transmission of electrons between the ends of the system, multiplied by the number of channels. If we take the analogy with transmission seriously, we can guess that the conductance of a combination of blocks, each with conductance $g(L)$, has conductance $g’$ which depends on $g(L)$. This is not very different from what we expect classically. For example, consider a connected pair of metallic blocks of conductivity $g(L)$ each, such that the total conductivity of the connected blocks is $g’$. If the blocks are connected in series, then $g’=g(L)/2$. If they are connected in parallel, then $g’=2 g(L)$. </p><p>We can extend the above guess due to Thouless to relate the conductance $g(L)$ of a block of size $L$ to that of a block of size $2L$ i.e. </p><p>$$g(2L)=f(g(L)),$$</p><p>where $f$ is some function. We can use this equation to relate the conductances at a bunch of different length scales, but not quite at all continuous lengths. We could create a larger set of similar relations by increasing the block size by a factor of $b$ instead of $2$. By choosing $b=1+\delta{\lambda}$, we can write the equation</p><p>$$g(b L)=g(L(1+\delta\lambda))=g(L)+g(L)\beta(g(L))\delta\lambda,$$</p><p>where $\beta$ is a function called the scaling function or often simply the <em>beta function</em>. Taking the limit $\delta\lambda\rightarrow 0$ we obtain the <em>scaling equation</em></p><p>$$\frac{d\textrm{ln}g}{d\textrm{ln}L}=\beta(g).$$</p><blockquote><p>This is the educated guess known as <em>single parameter scaling</em> that was adopted by  the “Gang of Four” (Abrahams, Anderson, Licciardello and Ramakrishnan) and is essentially an application of the idea of the <a href="http://en.wikipedia.org/wiki/Renormalization_group">renormalization group</a> to the conductance problem. Of course, we don’t quite know the function $\beta$, but as we will see in the next unit, it is possible to guess the form in various limits and this is enough to guess the qualitative behavior of the conductance.</p></blockquote><p>While the above representation will be useful for understanding the “flow diagram”, the above scaling hypothesis has a simple general solution </p><p>$$g(L)=\Phi(L/\xi),$$</p><p>where $\Phi$ is a function that is determined entirely by $\beta$, and $\xi$ is a decay length.</p><h1 id="Scaling-flow-diagram"><a href="#Scaling-flow-diagram" class="headerlink" title="Scaling flow diagram"></a>Scaling flow diagram</h1><p>Now we are in a position to make use of the scaling hypothesis. We don’t really know $\beta(g)$ in general, but we can compute it for large $g$ i.e. in the metallic/delocalized limit and also in the small $g$ or strongly localized limit. In the strongly localized limit $g\sim g_c e^{-L/\xi}$ so that $\beta(g)=\textrm{ln}(g/g_c)$, while in the weak scattering limit, we can estimate $g$ from the classical Drude formula so that $g\sim L^{(d-2)}$ and $\beta(g)\sim d-2$. In addition, one can calculate “quantum corrections” to the $\beta-$function at large $g$, which turn out to depend on other details such as the symmetry class of the disorder.</p><p>The simplest next step is to plot the function $\beta(g)$ using the simplest interpolation between the two limits. The amazing thing is that even the simplest interpolation allows us to guess the physics of the phase diagram. As a side note, this phase diagram is lost in the exact solution we wrote at the end of the last unit in terms of $\Phi$, which may seem counterintuitive to you. But let’s move on to understanding the phase diagram. Below, we plot $\beta(g)$ as a function of $g$:</p><p><img src="/2021/01/07/src/w9_disorder/scaling/conductance_scaling.svg" alt></p><p>What we see is that for dimensions $d=1,2$ the curve stays below $\beta\leq 0$, while the curve for $d=3$ intersects $\beta=0$. To make it easier to understand the diagram, we’ve turned it into a “flow diagram” by adding arrows along the curve representing how $g$ changes with system size $L$. If $\beta&lt;0$ then the arrow points towards smaller values of $g$, but if $\beta&gt;0$ the arrow points towards larger values of $g$. Thus, the flow diagram tells us that in $d=1,2$ dimensions, $g$ reduces with increasing system size, and therefore the system is insulating.</p><p>The situation is different in $d=3$ dimensions. If the conductance $g$ is large enough to begin with, then $\beta &gt; 0$ and the arrow points to larger values of $g$. This means that the conductance grows with increasing system size. On the other hand, if disorder is large enough such that $\beta &lt; 0$ initially, $g$ decreases as the system size increases. The separation point $\beta = 0$ between these two behaviours is the <em>metal-insulator transition</em>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;How is the flow in the diagram above altered if we stack 10 1D systems next to each other and weakly couple them?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Nothing changes.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;$\beta$ is multiplied by 10.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The scaling hypothesis doesn&#x27;t apply since we don&#x27;t have a 1D system anymore.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;$\beta$ is altered in some way, since we have a different disordered system now.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;The scaling hypothesis tells us that the details of the Hamiltonian don&#x27;t matter, so the scaling flow stays the same.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">0</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>The 2D case is special: in the classical limit $g \gg 1$, the scaling flow disappears, $\beta \approx 0$. However, there remain <em>quantum corrections</em> to it. These are effects that get weaker with increasing conductance, and they depend on the symmetry class of the Hamiltonian.</p><p>Let’s see what happens in the three simplest symmetry classes, those without sublattice or particle-hole symmetry. As we learned last week, these are class A (no symmetries, also called unitary since the matrix of Hamiltonian eigenvalues is unitary), AI ($\mathcal{T}^2 = 1$, orthogonal), and AII ($\mathcal{T} = -1$, symplectic).</p><p>A lengthy and technical calculation leads to the following corrections to the scaling flow at $g \gg 1$:</p><p><img src="/2021/01/07/src/w9_disorder/scaling/conductance_scaling_2D.svg" alt></p><p>So we see that in symmetry classes A and AI the conductance always drops, even though it does so very slowly in the class A, eventually leading to an insulating phase.</p><p>The class AII has a critical metal-insulator transition point, and a metallic phase at $g &gt; g_c$, just like a disordered 3D system. The growth of conductance in this system is much slower however: instead of $g \sim L$, in 2D AII we have $g \sim \log L$.</p><h1 id="Metal-insulator-transition"><a href="#Metal-insulator-transition" class="headerlink" title="Metal-insulator transition"></a>Metal-insulator transition</h1><p>The most interesting feature of the scaling theory of conductance that we have learned about so far is the existence of a universal critical point at which the behavior of the system changes from insulating (negative $\beta$ function) to metallic (positive $\beta$ function). This is the point $\beta=0$ which appears in 3D and in 2D in class AII. Let’s study such a critical point in more detail.</p><p>The first thing to observe is that at the critical point, we have $d\ln g/ d\ln L = 0$, so the conductance takes a <em>scale-invariant</em> value $g=g_c$ which is independent of $L$.</p><p>In practice, this behavior can be observed at a fixed $L$ by varying one parameter $\alpha$ appearing in the model under study, typically the disorder strength or the chemical potential. The average conductance $\langle g \rangle$ is then computed as a function of $\alpha$ for different values of $L$. One then obtains a plot like the following:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">data = np.loadtxt(data_folder + <span class="string">&quot;data_from_doru.dat&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">cmap = plt.get_cmap(<span class="string">&quot;gist_heat&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    x, y = data[i::<span class="number">3</span>, <span class="number">0</span>], data[i::<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    error = data[i::<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">    L = data[i, <span class="number">1</span>]</span><br><span class="line">    color = cmap(np.log(L - <span class="number">26</span>) / np.log(<span class="number">243</span> - <span class="number">26</span>) * <span class="number">0.7</span>)</span><br><span class="line">    ax.errorbar(x, y, yerr=error, label=<span class="string">&quot;$L=%i$&quot;</span> % L, color=color)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;$V$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">r&quot;$\langle G \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">5.5</span>, <span class="number">5.75</span>, <span class="number">6</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">ax.set_xlim(<span class="number">5.5</span>, <span class="number">6.0</span>)</span><br><span class="line">ax.set_ylim(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>(We thank Doru Sticlet for providing the data for this plot)</p><p>The plot above was computed for a 2D tight-binding model in class AII, essentially electrons hopping on a square lattice in the presence of a strong Rashba spin-orbit coupling. In this case, the average conductance was computed as a function of onsite disorder strength $V$.</p><p>We see that there is a point $V = V_c\simeq 5.8$ which distiguishes two different behaviors. For $V &lt; V_c$, conductance increases with system size: the system is metallic. For $V &gt; V_c$, conductance decreases with system size: the system is insulating. Hence by comparing different curves at fixed $V$ we can easily ‘see’ the sign of the $\beta$ function in our numerical calculations.</p><p>At $V = V_c$, all the curves overlap in the same point: we find that $g$ is basically independent of $L$. This is the critical point. In the plot above, the critical value of conductance is $g_c \simeq 1.3$. (Note that in a typical numerical calculations the curves will not cross precisely at the same point because the systems under consideration are too small. This leads to an entire field of study regarding the finite-size corrections to the scaling theory).</p><p>Let us study the conductance scaling around this point. The beta function changes sign at $g_c$, and in its vicinity we can consider it to be a linear function of $g$:</p><p>$$\beta(g) = \frac{1}{\nu},\frac{g-g_c}{g_c},,$$</p><p>where $\nu$ is just a coefficient and $g-g_c\ll g_c$. On the insulating side of the transition, it is convenient to write down $g  = g_c - \delta g$. Using the fact that $\ln g \simeq - \delta g/ g_c + \ln g_c$, and that $g_c$ does not depend on $L$, one obtains the following scaling equation for $\delta g$,</p><p>$$ \frac{d \delta g}{d \ln L} = \frac{\delta g}{\nu},.$$</p><p>Integrating this equation gives a power law,</p><p>$$ \frac{\delta g(L)}{\delta g(L_0)} = \left(\frac{L}{L_0}\right)^{1/\nu},. $$</p><p>At a fixed $L_0$, the behavior close to the transition is given by $\delta g(L_0) \simeq a(L_0) (V-V_c)$. So we get</p><p>$$ g(L) =  g_c - a(L_0),(V-V_c) , (L/L_0)^{1/\nu} = g_c - a(L_0),(L/\xi)^{1/\nu},.$$</p><p>The length $\xi = L_0,(V-V_c)^{-\nu},$ is the localization length, which diverges at the transition point $V=V_c$. The number $\nu$ is known as the <em>critical exponent</em>, and determines the scaling behavior of the conductance close to the critical point.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">r&quot;What would we see if $\beta$ crossed from positive to negative values?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Small conductances would have a metallic phase, where $g$ grows indefinitely, &quot;</span></span><br><span class="line">    <span class="string">&quot;while large $g$ would lead to an insulator.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;We would see a critical phase, where all conductances converge to the same value.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;This is just the same metal-insulator transition since $\beta(g_c) = 0$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;This is an impossible scaling function.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Both larger conductances and smaller conductances flow towards the critical value, &quot;</span></span><br><span class="line">    <span class="string">&quot;so all systems get the same conductance when their size becomes large enough. &quot;</span></span><br><span class="line">    <span class="string">&quot;This is an attractive critical point.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Absence-of-localization-for-topological-insulators"><a href="#Absence-of-localization-for-topological-insulators" class="headerlink" title="Absence of localization for topological insulators"></a>Absence of localization for topological insulators</h1><p>Finally let’s remark on how the conductance scaling flow is modified on the protected surfaces of topological insulators.</p><p>At large conductances we know that the classical scaling must still hold, since this is just Ohm’s law. On the other hand, if we were able to make conductance exactly zero, we would break the bulk-edge correspondence, so $\beta$ cannot be negative at $g \ll 1$.</p><p>It turns out, the scaling flow on the surface of a topological insulator is modified by the appearance of an extra term, that vanishes at large conductance, but ensures that there is no localization.</p><h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;JdDeBJEBO0s&quot;</span>, src_location=<span class="string">&quot;9.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p>Questions about what you just learned? Ask them below!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Anderson localization&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w8_general/w8_assignments/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w8_general/w8_assignments/</id>
    <published>2021-01-07T09:11:06.882Z</published>
    <updated>2021-01-07T09:11:06.882Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure><h1 id="Simulations-Gaps-and-invariants"><a href="#Simulations-Gaps-and-invariants" class="headerlink" title="Simulations: Gaps and invariants"></a>Simulations: Gaps and invariants</h1><p>As usual, start by grabbing the notebooks of this week (<code>w8_general</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p><h2 id="A-different-analytic-continuation"><a href="#A-different-analytic-continuation" class="headerlink" title="A different analytic continuation"></a>A different analytic continuation</h2><p>You have learned how to map a winding number onto counting the zeros of an eigenproblem in a complex plane. This can be applied to other symmetry classes as well.</p><p>Let’s try to calculate the invariant in the 1D symmetry class DIII. If you look in the table, you’ll see it’s the same invariant as the scattering invariant we’ve used for the quantum spin Hall effect,</p><p>$$<br>Q = \frac{\textrm{Pf } h(k=0)}{\textrm{Pf } h(k=\pi)} \sqrt{\frac{\det h(k=\pi)}{\det h(k=0)}}<br>$$</p><p>In <a href="http://arxiv.org/abs/1106.6351">this paper</a> (around Eq. 4.13), have a look at how to use analytic continuation to calculate the analytic continuation of $\sqrt{h}$, and implement the calculation of this invariant without numerical integration, like we did before.</p><p>In order to test your invariant, you’ll need a topologically non-trivial system in this symmetry class. You can obtain it by combining a Majorana nanowire with its time-reversed copy.</p><p>This is a hard task; if you go for it, try it out, but don’t hesitate to ask for help in the discussion below.</p><h2 id="Finding-gaps"><a href="#Finding-gaps" class="headerlink" title="Finding gaps"></a>Finding gaps</h2><p>The analytic continuation from $e^{ik}$ to a complex plane is also useful in telling if a system is gapped.</p><p>Using the mapping of a 1D Hamiltonian to the eigenvalue problem, implement a function which checks if there are propagating modes at a given energy.</p><p>Then implement an algorithm which uses this check to find the lowest and the highest energy states for a given 1D Hamiltonian $H = h + t e^{ik} + t^\dagger e^{-ik}$ (with $h$, $t$ arbitrary matrices, of course).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Now share your results:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Topological invariants&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1006-0690"><a href="#arXiv-1006-0690" class="headerlink" title="arXiv:1006.0690"></a>arXiv:1006.0690</h3><p><strong>Hint:</strong> The most general classification.</p><h3 id="arXiv-1310-5281"><a href="#arXiv-1310-5281" class="headerlink" title="arXiv:1310.5281"></a>arXiv:1310.5281</h3><p><strong>Hint:</strong> Beyond classification.</p><h3 id="arXiv-1012-1019"><a href="#arXiv-1012-1019" class="headerlink" title="arXiv:1012.1019"></a>arXiv:1012.1019</h3><p><strong>Hint:</strong> The non-commutative invariants.</p><h3 id="arXiv-1106-6351"><a href="#arXiv-1106-6351" class="headerlink" title="arXiv:1106.6351"></a>arXiv:1106.6351</h3><p><strong>Hint:</strong> All about scattering.</p><h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;General classification&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w8_general/invariants/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w8_general/invariants/</id>
    <published>2021-01-07T09:11:06.881Z</published>
    <updated>2021-01-07T09:11:06.881Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> sla</span><br><span class="line"></span><br><span class="line">randn = np.random.randn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chern_torus</span>(<span class="params">W=<span class="number">5</span>, L=<span class="number">5</span></span>):</span></span><br><span class="line"></span><br><span class="line">    disorder_potential = randn(W, L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; W) * (<span class="number">0</span> &lt;= y &lt; L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        t, mu, dis_amplitude = p.t, p.mu, p.disorder</span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">4</span> * t - mu) * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        t, delta = p.t, p.delta</span><br><span class="line">        <span class="keyword">return</span> -t * pauli.sz + <span class="number">1j</span> * p.delta * pauli.sx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        t, delta = p.t, p.delta</span><br><span class="line">        <span class="keyword">return</span> -t * pauli.sz - <span class="number">1j</span> * p.delta * pauli.sy</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((-W + <span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, -L + <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">projected_operators</span>(<span class="params">syst, p, energy=<span class="number">0</span></span>):</span></span><br><span class="line">    x, y = np.array([i.pos <span class="keyword">for</span> i <span class="keyword">in</span> syst.sites]).T</span><br><span class="line">    <span class="comment"># Double all entries to take orbitals into account.</span></span><br><span class="line">    x = np.resize(x, (<span class="number">2</span>, <span class="built_in">len</span>(x))).T.flatten()</span><br><span class="line">    y = np.resize(y, (<span class="number">2</span>, <span class="built_in">len</span>(y))).T.flatten()</span><br><span class="line">    x *= <span class="number">2</span> * np.pi / (np.<span class="built_in">max</span>(x) + <span class="number">1</span>)</span><br><span class="line">    y *= <span class="number">2</span> * np.pi / (np.<span class="built_in">max</span>(y) + <span class="number">1</span>)</span><br><span class="line">    op_x = np.diag(np.exp(<span class="number">1j</span> * x))</span><br><span class="line">    op_y = np.diag(np.exp(<span class="number">1j</span> * y))</span><br><span class="line"></span><br><span class="line">    ham = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    ham -= <span class="number">0</span> * np.identity(<span class="built_in">len</span>(ham))</span><br><span class="line">    energies, states = np.linalg.eigh(ham)</span><br><span class="line"></span><br><span class="line">    projector = states[:, energies &lt; energy]</span><br><span class="line"></span><br><span class="line">    op_x = projector.T.conj() @ op_x @ projector</span><br><span class="line">    op_y = projector.T.conj() @ op_y @ projector</span><br><span class="line">    <span class="keyword">return</span> op_x, op_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_terminal</span>(<span class="params">L, W</span>):</span></span><br><span class="line">    t = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; W <span class="keyword">and</span> <span class="number">0</span> &lt;= x &lt; L</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; W</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># definition of system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">3</span> * t</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># definition of leads</span></span><br><span class="line">    lead = kwant.Builder(kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">3</span> * t</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># attaching leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diag_time</span>(<span class="params">N</span>):</span></span><br><span class="line">    syst = two_terminal(N, N)</span><br><span class="line"></span><br><span class="line">    start = time()</span><br><span class="line">    ham = syst.hamiltonian_submatrix()</span><br><span class="line">    ev, evec = sla.eigh(ham)</span><br><span class="line">    res = time() - start</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smat_time</span>(<span class="params">N</span>):</span></span><br><span class="line">    syst = two_terminal(N, N)</span><br><span class="line"></span><br><span class="line">    start = time()</span><br><span class="line"></span><br><span class="line">    smat = kwant.smatrix(syst)</span><br><span class="line"></span><br><span class="line">    res = time() - start</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Fabian Hassler from RWTH Aachen will present the topological invariants</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;ceyus0cRBi0&quot;</span>, src_location=<span class="string">&quot;8.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Applications-of-topological-invariants"><a href="#Applications-of-topological-invariants" class="headerlink" title="Applications of topological invariants"></a>Applications of topological invariants</h1><p>Throughout the course we computed several times a topological invariant of different systems. When is calculating a topological invariant useful or necessary?</p><p>The toy model Hamiltonians that we considered do not really require a complicated calculation set up to figure out whether they are topological or not. However, there are two types of applications where a heavy duty algorithm is important. These are:</p><ul><li>Ab-initio band structures calculations</li><li>Disordered systems</li></ul><p>So, we start with a Hamiltonian of some complicated material, and we want to know if it is topological or not. What’s worse is that we don’t even know in advance if it is gapped or not! If the system is disordered (you’ll learn more about those next week), then in addition we can never simulate a truly infinite system. What we can do is to take chunks of finite size  and hope that it behaves correctly like an infinite system once the sample size is large enough.</p><p>This Hamiltonian may have many parameters, so it’s a large $N\times N$ matrix. For systems with a complicated band structure, $N$ is fixed to be the number of orbitals we need to faithfully approximate the Hamiltonian, while in disordered systems we would usually simulate a finite system with linear size $L$, and so $N=L^d$, with $d$ the dimensionality of the space.</p><p>There’s a simple rule which allows us to guess how large a disordered system should be, in order to correctly reproduce the topology of an infinite system.</p><blockquote><p>If the typical decay length of the state at the Fermi level of a disordered system is $\xi$, then we need to take a sample with $L \gtrsim \xi$ to correctly calculate its topological properties.</p></blockquote><p>The reason why this is true is that in a smaller sample the bulk is not ‘insulating enough’.</p><p>So now we know that the main problem is that we need to do something with a large matrix.</p><h1 id="Computational-costs"><a href="#Computational-costs" class="headerlink" title="Computational costs"></a>Computational costs</h1><p>How expensive are the calculations? If you look in the literature, you’ll see wildly differently looking algorithms bundled together with different claims of performance. There is actually a very simple way to figure out, and it comes down to an almost universally correct empirical rule:</p><blockquote><p>Whenever you need to do something with a dense matrix of size $M\times M$ in a numerical calculation, the costs of doing it most likely are $\sim M^3$.</p></blockquote><p>This is true almost no matter what you do: matrix multiplication, inversion, diagonalization, calculation of a determinant, and dozens of other decompositions all cost the same. The specific value of the numerical prefactor does vary.</p><p>The things become more complicated when the Hamiltonian becomes sparse, since then one may efficiently use that most entries in the matrix are zero. For example, multiplying two $M\times M$ banded matrices has a cost $~M$, instead of $M^3$.</p><p>Part of our intuition stays true. So since after diagonalizing a Hamiltonian we obtain an $M\times M$ matrix of eigenvectors, typically we still need to perform $\sim M^3$ number of operations.</p><p>A scattering matrix is smaller than the matrix of all the eigenvectors, and for our sample with a linear size $L$, the size of the scattering matrix is $L^{d-1}$, as opposed to $L^d$, the size of the Hamiltonian. While this fact isn’t <a href="http://en.wikipedia.org/wiki/LU_decomposition#Sparse_matrix_decomposition">trivial</a> at <a href="http://en.wikipedia.org/wiki/Nested_dissection">all</a>, calculation of a scattering matrix still costs the cube of its size, so $L^{3d-3}$.</p><p>This difference is most pronounced in 2D systems, where the cost of diagonalization results in more than an order of magnitude difference in the system size. On most modern computers diagonalization works up to system sizes of $\sim 100$, and scattering matrix calculations work up to system sizes of $\sim 1000$. This can be best seen over here (but you can also test for yourself):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ns_diag = np.logspace(<span class="number">1</span>, np.log10(<span class="number">80</span>), <span class="number">5</span>)[:<span class="number">4</span>]</span><br><span class="line">diag_times = [diag_time(N) <span class="keyword">for</span> N <span class="keyword">in</span> Ns_diag]</span><br><span class="line"></span><br><span class="line">Ns_smat = np.logspace(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>)[:<span class="number">6</span>]</span><br><span class="line">smat_times = [smat_time(N) <span class="keyword">for</span> N <span class="keyword">in</span> Ns_smat]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(Ns_diag, diag_times, <span class="string">&quot;-o&quot;</span>, label=<span class="string">&quot;diagonalization&quot;</span>)</span><br><span class="line">plt.plot(Ns_smat, smat_times, <span class="string">&quot;-o&quot;</span>, label=<span class="string">&quot;scattering matrix&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">plt.yscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;$N$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;$t [s]$&quot;</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span> ** -<span class="number">3</span>, <span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">plt.yticks([<span class="number">1e-3</span>, <span class="number">1</span>, <span class="number">1e3</span>, <span class="number">1e6</span>])</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="Momentum-integration"><a href="#Momentum-integration" class="headerlink" title="Momentum integration"></a>Momentum integration</h2><p>As you saw, unless we’re lucky, a topological invariant is a $d$-dimensional integral of something like winding number density or Berry curvature. If we deal with the scattering matrix, the Brillouin zone is once again reduced by one dimension, and the integral becomes $(d-1)$-dimensional.</p><p>How many points in momentum space do we need? If we are integrating Berry curvature, we want the uncertainty of the integral to be $\lesssim .5$, so that we can round it and get the correct answer. That means that if there’s a Dirac point with a small gap, we need to resolve it in momentum space, and the number of points should scale as $\sim(1/\xi)^d$.</p><p>If we consider a disordered system, we must consider a finite system of a large enough size $L \gtrsim \xi$, so that every point on the Brillouin zone is representative, and we just need a single point to effectively estimate the value of the integral (you’ll see later how to do this in one of the techniques).</p><p>So let’s take a system with $N$ orbitals in a unit cell, and edge state decay length $\xi$. The cost of computing the topological invariant is:</p><ul><li>$\sim (N/\xi)^{3d}$ for disordered systems using the full spectrum.</li><li>$\sim N^3 / \xi^d$ for band structures using the full spectrum.</li><li>$\sim (N/\xi)^{3d-3}$ for disordered systems using scattering approach.</li><li>$\sim N^3 / \xi^{d-1}$ for band structures using scattering approach.</li></ul><h1 id="A-special-thing-about-1D"><a href="#A-special-thing-about-1D" class="headerlink" title="A special thing about 1D"></a>A special thing about 1D</h1><p>There is a special feature of topological invariants in 1D, that dramatically speeds up a calculation. It’s a computational trick that is so elegant and universal that we’d like to share it.</p><p>You might remember studying the SSH chain back in week one. This is a similar system to the Majorana chain, but it is characterized by chiral symmetry rather than particle-hole symmetry.</p><p>A 1D Bloch Hamiltonian $H(k)$ with chiral symmetry has the form</p><p>$$<br>H(k) = \begin{pmatrix} 0 &amp; h(k) \<br>h^\dagger(k) &amp; 0\end{pmatrix},<br>$$</p><p>with $h(k) = h_0 + t_L e^{ik} + t_R e^{-ik}$ a matrix containing the onsite term $h_0$, the left hopping $t_L$ and the right hopping $t_R$.</p><p>If you look up the table, this Hamiltonian is characterized by a $\mathbb{Z}$ topological invariant. This invariant is the  <a href="http://en.wikipedia.org/wiki/Winding_number">winding number</a> that Fabian Hassler discussed in the introductory video. Let’s again describe its meaning.</p><p>We need to find an integer quantity which can only change when the gap of $H(k)$ closes. Now, $H(k)$ can only have a zero eigenvalue if $h(k)$ does, that is if $\det [h(k)]=0$. For a gapped Hamiltonian, $\det [h(k)]$ will in general be a complex number other than zero for all values of $k$.</p><p>Let us now try to picture the path that $h(k)$ takes in the complex plane as $k$ is varied from $0$ to $2\pi$. This path must be closed, because $\det [h(0)]$ must be equal to $\det [h(2\pi)]$, and avoid the origin. We may therefore ask: how many times does the path go around the origin? This number must be integer, and it cannot change unless we make the path go through zero. It is our $\mathbb{Z}$ topological invariant, because we can distinguish a clockwise path from a counterclockwise path.</p><p>The mathematical expression for the winding number is more obscure than its meaning:</p><p>$$<br>Q(H) = \frac{1}{2\pi i},\int_0^{2\pi} dk,\frac{d}{dk},\log,\det[h(k)],<br>$$</p><p>but it just counts how much the phase of $\det h$ increases as $k$ goes through the Brillouin zone.</p><p>How to take this integral? The trick is to use analytic continuation to a complex plane.</p><p>As $k$ varies from $0$ to $2\pi$, $e^{ik}$ goes around the unit circle in the complex plane. Let’s now make a substitution $e^{ik},\to,z$, with $z$ a complex number. The determinant $\det[h(k)]$ becomes a polynomial function in $z$, $f(z) = \det[h_0 + z, t_L + z^{-1}, t_R]$. We now need to compute the following integral on the unit circle </p><p>$$<br>Q(H) = \frac{1}{2\pi i},\oint dz ,\frac{d}{dz} \log f(z) = \frac{1}{2\pi i},\oint,dz,\frac{f’(z)}{f(z)}.<br>$$</p><p>We can now use a nice result from complex analysis, the <a href="http://en.wikipedia.org/wiki/Argument_principle">argument principle</a>. It tells us that each zero of $f(z)$ inside the unit circle contributes $+1$ to the value of $Q(H)$, and each pole contributes $-1$. Hence, by counting the number of zeros and poles of $f(z)$ inside the unit circle we immediately get the winding number. So, we have reduced the calculation of the topological invariant to finding zeros and poles of the expression $\det[h_0 + z, t_L + z^{-1}, t_R]=0$. The poles are trivial to find, and they are all located at $z=0$.</p><p>To find the zeros we notice that we need to solve a problem</p><p>$$[z h_0 + z^2 t_L + t_R]\psi = 0.$$</p><p>This is a <a href="http://en.wikipedia.org/wiki/Nonlinear_eigenproblem">polynomial eigenvalue problem</a>, and it is trivially mapped onto a standard eigenvalue problem.</p><p>$$<br>\begin{pmatrix}<br>-t_r &amp; 0\<br>0 &amp; 1<br>\end{pmatrix} \psi’=<br>z\begin{pmatrix}<br>h_0 &amp; t_L \<br>1 &amp; 0<br>\end{pmatrix} \psi’.<br>$$</p><p>So by finding all the eigenvalues $z$ we get all the zeros of $h(z)$ inside the unit circle, and immediately obtain the 1D topological invariant:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_sys</span>(<span class="params">N=<span class="number">4</span></span>):</span></span><br><span class="line">    onsite = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    lefthopping = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    righthopping = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> onsite, lefthopping, righthopping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_singularities</span>(<span class="params">onsite, lefthopping, righthopping</span>):</span></span><br><span class="line">    <span class="comment"># We will have a generalized eigenvalue problem. The two matrices alone do not have much of a physical meaning,</span></span><br><span class="line">    <span class="comment"># so their names are also meaningless: A, B.</span></span><br><span class="line">    n = <span class="built_in">len</span>(onsite)</span><br><span class="line"></span><br><span class="line">    A = np.bmat([[-righthopping, np.zeros((n, n))], [np.zeros((n, n)), np.eye(n)]])</span><br><span class="line"></span><br><span class="line">    B = np.bmat([[onsite, lefthopping], [np.eye(n), np.zeros((n, n))]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scipy.linalg.eigvals(A, B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">winding_plot</span>(<span class="params">onsite, lefthopping, righthopping</span>):</span></span><br><span class="line">    singularities = find_singularities(onsite, lefthopping, righthopping)</span><br><span class="line">    winding = <span class="built_in">sum</span>(<span class="built_in">abs</span>(singularities) &lt; <span class="number">1</span>) - <span class="built_in">len</span>(onsite)</span><br><span class="line">    circle = np.exp(<span class="number">1j</span> * np.linspace(-np.pi, np.pi, <span class="number">30</span>))</span><br><span class="line">    title = <span class="string">&quot;Winding number: $&#123;&#125;$&quot;</span>.<span class="built_in">format</span>(winding)</span><br><span class="line">    kdims = [<span class="string">r&quot;$\operatorname&#123;Re&#125;(z)$&quot;</span>, <span class="string">r&quot;$\operatorname&#123;Im&#125;(z)$&quot;</span>]</span><br><span class="line">    pl = holoviews.Path((circle.real, circle.imag), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>, <span class="string">&quot;linestyle&quot;</span>: <span class="string">&quot;--&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    pl *= holoviews.Points((singularities.real, singularities.imag)).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    pl *= holoviews.Points((<span class="number">0</span>, <span class="number">0</span>)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> pl[-<span class="number">2</span>:<span class="number">2</span>, -<span class="number">2</span>:<span class="number">2</span>].relabel(title).opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">3</span>, <span class="string">&quot;yticks&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">30</span>)</span><br><span class="line">onsite, lefthopping, righthopping = random_sys()</span><br><span class="line">winding_scale = <span class="keyword">lambda</span> scale: winding_plot(</span><br><span class="line">    <span class="number">4</span> * onsite * <span class="number">1.2</span> ** -<span class="built_in">abs</span>(scale),</span><br><span class="line">    lefthopping * <span class="number">1.2</span> ** scale,</span><br><span class="line">    righthopping * <span class="number">1.2</span> ** -scale,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;scale: winding_scale(scale) <span class="keyword">for</span> scale <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>, <span class="number">10</span>)&#125;, kdims=[<span class="string">r&quot;$\alpha$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>In the graph above, we see the zeros (red) and poles (blue) of $h(z)$ for some randomly generated system, while we tune a parameter $\alpha$ that gradually changes the topology of the system.</p><p>The approach of analytic continuation onto a complex plane works whenever we have only one momentum variable, so for any 1D system, or a 2D system where we compute the scattering, and allows to calculate the integral exactly and in one step.</p><h1 id="Real-space-methods"><a href="#Real-space-methods" class="headerlink" title="Real space methods"></a>Real space methods</h1><p>There is also a broad class of algorithms that rely on the real space structure of the system, and on the inability to deform the wave functions of the filled state into completely localized orbitals.</p><p>The intuition behind these is coming from <a href="http://en.wikipedia.org/wiki/Noncommutative_geometry">non-commutative geometry</a>, and so it is very hard to explain intuitively. Let us try to illustrate the logic behind those.</p><p>The real space invariants are known for many different <a href="http://arxiv.org/abs/1012.1019">symmetry classes</a>, but for concreteness let’s see how they work for the Chern insulators (and accordingly how we can compute the Chern number).</p><p>First, let’s make a finite but large system in a way that it is fully gapped. Of course if it’s topologically non-trivial, we need to remove the edge states, and we’ll do this by applying periodic boundary conditions in both $x$- and $y$-directions.</p><p>We can now define periodic $x$ and $y$ coordinates $0 &lt; x \leq L$, $0 &lt; y \leq W$. We can make continuous variables out of these by studying phase factors $\varphi_x = \exp(2 \pi i x / L)$, and $\varphi_y = \exp(2 \pi i y / W)$.</p><p>The rough idea is as follows. All the filled states in a gapped material can be made localized, but if the system is topological this localization of the states is never exact (since fully localized states would correspond to a trivial Hamiltonian).</p><p>Fully localized states would have their $x$ and $y$ coordinates commuting, so we could try to check if we can approximate $x$ and $y$ coordinates of the filled states with commuting matrices.</p><p>The $\varphi_x$ and $\varphi_y$ phases of the filled states are operators, and we can calculate them by projecting them onto the space of filled states:</p><p>$$<br>\varPhi_x = \sum_{ij} |\psi_i\rangle\langle \psi_i | \varphi_x | \psi_j\rangle \langle \psi_j|,<br>$$</p><p>$$<br>\varPhi_y = \sum_{ij} |\psi_i\rangle \langle \psi_i | \varphi_y | \psi_j\rangle \langle \psi_j|.<br>$$</p><p>We now need to determine if $\varPhi_x$ and $\varPhi_y$ approximately commute. Let’s consider the expression</p><p>$$<br>\textrm{tr}\left(\log\left(\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger\right)\right) = 2\pi i ,m + r,.<br>$$</p><p>First of all, $m$ is always an integer, because $\text{tr}(\log(A)) = \log(\det(A)),$ and the $\det\left(\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger\right) = \det(\varPhi_x)\det^<em>(\varPhi_x)\det(\varPhi_y)\det^</em>(\varPhi_y)$, so it is real.</p><p>If $\varPhi_x$ and $\varPhi_y$ commute, $m = 0$. It can only change if one of the eigenvalues of $\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger$ goes through 0 on a complex plane, which signals appearance of a delocalized mode.</p><p>So the <strong>Bott index</strong> $m$ looks like a Chern number, behaves like a Chern number, and it indeed is a Chern number.</p><p>To illustrate its behavior let’s plot the cumulative sum of the eigenvalues of $\log\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger$, taking a disordered Chern insulator as a sample system:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">%%opts Points &#123;+framewise&#125;</span><br><span class="line">%%opts Path &#123;+framewise&#125;</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.1</span>, delta=<span class="number">0.1</span>, disorder=<span class="number">0.5</span>)</span><br><span class="line">syst = chern_torus(<span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_m</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    op_x, op_y = projected_operators(syst, p, energy=<span class="number">0.01</span>)</span><br><span class="line">    temp = op_x @ op_y @ op_x.T.conj() @ op_y.T.conj()</span><br><span class="line">    eigs = np.linalg.eigvals(temp)</span><br><span class="line">    <span class="comment"># get rid of the four zero eigenvalues</span></span><br><span class="line">    res = np.<span class="built_in">sum</span>(np.log(eigs))</span><br><span class="line">    res = res.imag / (<span class="number">2</span> * np.pi)</span><br><span class="line">    <span class="comment"># This calculation is only correct to numerical accuracy.</span></span><br><span class="line">    <span class="comment"># When the Chern number is zero the result might be a very small negative number.</span></span><br><span class="line">    <span class="comment"># We make them positive so that the out put is never -0, because that does not look nice.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(res) &lt; <span class="number">0.5</span>:</span><br><span class="line">        res = <span class="built_in">abs</span>(res)</span><br><span class="line"></span><br><span class="line">    xs = np.cumsum(np.log(eigs)).real</span><br><span class="line">    ys = np.cumsum(np.log(eigs)).imag</span><br><span class="line"></span><br><span class="line">    x = np.append([<span class="number">0</span>], xs)</span><br><span class="line">    y = np.append([<span class="number">0</span>], ys)</span><br><span class="line">    title = <span class="string">&quot;$m=&#123;:.2&#125;$, Chern number $=&#123;:1.0f&#125;$&quot;</span>.<span class="built_in">format</span>(p.mu, res)</span><br><span class="line">    window_widening = (<span class="built_in">max</span>(x) - <span class="built_in">min</span>(x)) * <span class="number">0.05</span></span><br><span class="line">    pl = holoviews.Path((x, y)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    pl *= holoviews.Points((x, y)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    xlim = <span class="built_in">slice</span>(<span class="built_in">min</span>(x) - window_widening, <span class="built_in">max</span>(x) + window_widening)</span><br><span class="line">    ylim = <span class="built_in">slice</span>(-<span class="number">2</span> * np.pi - <span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">2</span>, <span class="string">&quot;yticks&quot;</span>: [(-<span class="number">2</span> * np.pi, <span class="string">r&quot;$-2\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>)]&#125;</span><br><span class="line">    <span class="keyword">return</span> pl[xlim, ylim].relabel(title).opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: evaluate_m(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> np.linspace(-<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">16</span>)&#125;, kdims=[<span class="string">r&quot;$m$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;9qCSXEfSlqE&quot;</span>, src_location=<span class="string">&quot;8.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p>Questions about what you just learned? Ask them below!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topological invariants&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w8_general/classification/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w8_general/classification/</id>
    <published>2021-01-07T09:11:06.879Z</published>
    <updated>2021-01-07T09:11:06.879Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> HTML</span><br><span class="line"><span class="keyword">from</span> nbconvert.filters.markdown <span class="keyword">import</span> markdown2html_pandoc</span><br><span class="line"></span><br><span class="line">displaymd = <span class="keyword">lambda</span> markdown: display_html(HTML(markdown2html_pandoc(markdown)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Markdown tables are ugly, and Mathjax doesn&#x27;t support \tabular,</span></span><br><span class="line"><span class="comment"># therefore we use math mode + \array + add a command \T to make</span></span><br><span class="line"><span class="comment"># the \array rows less dense.</span></span><br><span class="line"></span><br><span class="line">table_header = <span class="string">r&quot;&quot;&quot;$$</span></span><br><span class="line"><span class="string">\require&#123;color&#125;</span></span><br><span class="line"><span class="string">colordefs</span></span><br><span class="line"><span class="string">\newcommand\T&#123;\Rule&#123;0pt&#125;&#123;1em&#125;&#123;.3em&#125;&#125;</span></span><br><span class="line"><span class="string">\begin&#123;array&#125;&#123;fmt&#125;</span></span><br><span class="line"><span class="string">\hline</span></span><br><span class="line"><span class="string">body\\</span></span><br><span class="line"><span class="string">\hline</span></span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br><span class="line"><span class="string">$$&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">replacements = [</span><br><span class="line">    (<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#123;&#123;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;&#125;&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;colordefs&quot;</span>, <span class="string">&quot;&#123;colordefs&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;fmt&quot;</span>, <span class="string">&quot;&#123;fmt&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;body&quot;</span>, <span class="string">&quot;&#123;body&#125;&quot;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> replacements:</span><br><span class="line">    table_header = table_header.replace(i, j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Symmetry classes names and their symmetry properties</span></span><br><span class="line">symmetry_classes = (<span class="string">&quot;A&quot;</span>, <span class="string">&quot;AIII&quot;</span>, <span class="string">&quot;AI&quot;</span>, <span class="string">&quot;BDI&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DIII&quot;</span>, <span class="string">&quot;AII&quot;</span>, <span class="string">&quot;CII&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CI&quot;</span>)</span><br><span class="line">chiralsym = <span class="number">5</span> * (<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">phs = <span class="number">3</span> * (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;1&quot;</span>,) + (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;-1&quot;</span>,)</span><br><span class="line">trs = <span class="number">2</span> * (<span class="string">&quot;&quot;</span>,) + <span class="number">2</span> * (<span class="string">&quot;1&quot;</span>,) + (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;-1&quot;</span>,) + (<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Locations of non-empty entries in the periodic table</span></span><br><span class="line">primary_seq = <span class="keyword">lambda</span> n: np.arange(n) % <span class="number">2</span></span><br><span class="line">z_descendant = <span class="keyword">lambda</span> n: np.arange(n) % <span class="number">8</span></span><br><span class="line">z2_descendant = <span class="keyword">lambda</span> n: np.arange(<span class="number">1</span>, n + <span class="number">1</span>) % <span class="number">8</span></span><br><span class="line">z2_descendant2 = <span class="keyword">lambda</span> n: np.arange(<span class="number">2</span>, n + <span class="number">2</span>) % <span class="number">8</span></span><br><span class="line">twoz_descendant = <span class="keyword">lambda</span> n: np.arange(<span class="number">4</span>, n + <span class="number">4</span>) % <span class="number">8</span></span><br><span class="line"></span><br><span class="line">line_end = <span class="string">&quot;\\T\\\\\n&quot;</span></span><br><span class="line">sep = <span class="string">&quot; &amp; &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_table</span>(<span class="params">n=<span class="number">4</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create an array of entries forming the periodic table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    n : int</span></span><br><span class="line"><span class="string">        Number of dimensions to show.</span></span><br><span class="line"><span class="string">    show_symmetries : bool</span></span><br><span class="line"><span class="string">        Show symmetry information for each symmetry class.</span></span><br><span class="line"><span class="string">    sort_order : int array or None</span></span><br><span class="line"><span class="string">        Ordering to apply to the symmetry classes </span></span><br><span class="line"><span class="string">        (can be trivially used to discard entries).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    data : np.ndarray</span></span><br><span class="line"><span class="string">        A string array with the entries of the periodic table.</span></span><br><span class="line"><span class="string">    format_string : str</span></span><br><span class="line"><span class="string">        An alignment string that can be used to feed the resulting</span></span><br><span class="line"><span class="string">        table to a Latex \array environment. </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    dimensions = np.array([[<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]], dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> dimensions.shape[<span class="number">1</span>]:</span><br><span class="line">        dimensions[<span class="number">0</span>, <span class="number">0</span>] = <span class="string">r&quot;d=&quot;</span> + dimensions[<span class="number">0</span>, <span class="number">0</span>].decode(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    complex_entries = np.zeros((<span class="number">2</span>, n), dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    complex_entries[primary_seq(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    real_entries = np.zeros((<span class="number">8</span>, n), dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    real_entries[z_descendant(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line">    real_entries[z2_descendant(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;_2&quot;</span></span><br><span class="line">    real_entries[z2_descendant2(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;_2&quot;</span></span><br><span class="line">    real_entries[twoz_descendant(n), np.arange(n)] = <span class="string">r&quot;2\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    entries = np.r_[complex_entries, real_entries]</span><br><span class="line"></span><br><span class="line">    sym_classes_rm = <span class="built_in">tuple</span>(<span class="string">r&quot;\textrm&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(cl) <span class="keyword">for</span> cl <span class="keyword">in</span> symmetry_classes)</span><br><span class="line"></span><br><span class="line">    sym = np.array(</span><br><span class="line">        [sym_classes_rm] + show_symmetries * [chiralsym, phs, trs], dtype=<span class="string">&quot;S100&quot;</span></span><br><span class="line">    ).T</span><br><span class="line">    sym_header = np.array(</span><br><span class="line">        [</span><br><span class="line">            [<span class="string">r&quot;\textrm&#123;class&#125;&quot;</span>]</span><br><span class="line">            + show_symmetries * [<span class="string">r&quot;\mathcal&#123;C&#125;&quot;</span>, <span class="string">r&quot;\mathcal&#123;P&#125;&quot;</span>, <span class="string">r&quot;\mathcal&#123;T&#125;&quot;</span>]</span><br><span class="line">        ],</span><br><span class="line">        dtype=<span class="string">&quot;S100&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    header = np.c_[sym_header, dimensions]</span><br><span class="line"></span><br><span class="line">    table = np.c_[sym, entries]</span><br><span class="line">    <span class="keyword">if</span> sort_order <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        table = table[sort_order]</span><br><span class="line"></span><br><span class="line">    format_string = <span class="string">&quot;c|&quot;</span> + show_symmetries * <span class="string">&quot;rrr&quot;</span> + n * show_symmetries * <span class="string">&quot;|&quot;</span> + n * <span class="string">&quot;c&quot;</span></span><br><span class="line">    <span class="keyword">return</span> np.r_[header, table], format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">color_table</span>(<span class="params">table, color_array</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Apply rgb colors to table entries.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `color_array[i, j]` is the rgb color of the entry `(i, j)`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns the string of color definitions required for coloring the table.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    apply_color = <span class="keyword">lambda</span> text, color: <span class="string">r&quot;\color&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(color, text)</span><br><span class="line"></span><br><span class="line">    colors = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> np.indices(table.shape).reshape(<span class="number">2</span>, -<span class="number">1</span>).T:</span><br><span class="line">        idx = <span class="built_in">tuple</span>(idx)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(color_array[idx]):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        color = <span class="string">&quot;,&quot;</span>.join(<span class="string">&quot;&#123;:1.2&#125;&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> color_array[idx])</span><br><span class="line">        val = <span class="built_in">str</span>(<span class="built_in">abs</span>(<span class="built_in">hash</span>(color)))[:<span class="number">8</span>]</span><br><span class="line">        colors[color] = val</span><br><span class="line">        table[idx] = apply_color(table[idx].decode(<span class="string">&quot;utf-8&quot;</span>), val)</span><br><span class="line"></span><br><span class="line">    defs = []</span><br><span class="line">    <span class="keyword">for</span> color, code <span class="keyword">in</span> <span class="built_in">list</span>(colors.items()):</span><br><span class="line">        defs.append(<span class="string">r&quot;\definecolor&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;rgb&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(code, color))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(defs)</span><br></pre></td></tr></table></figure><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Shinsei Ryu from the University of Illinois will introduce the general classification of topological insulators and superconductors.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;cKzUuQyZjFo&quot;</span>, src_location=<span class="string">&quot;8.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="At-a-glance-periodic-table"><a href="#At-a-glance-periodic-table" class="headerlink" title="At a glance: periodic table"></a>At a glance: periodic table</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">full_table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">False</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line"></span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line">colordefs = <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure><p>Let us now look at all the possible symmetry classes in dimensions from $0$ to $3$, and see what kind of topological insulators are possible.</p><p>There are quite a few, here is the full list:</p><p>This table has a lot of logic in it, but to you it most likely looks no better than this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">full_table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">False</span>, sort_order=np.random.permutation(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">color_array = np.<span class="built_in">round</span>(np.random.rand(*(full_table.shape + (<span class="number">3</span>,))), <span class="number">2</span>)</span><br><span class="line">colordefs = color_table(full_table, color_array)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure><p>But don’t worry, we are going to learn exactly what these tables mean.</p><p>First of all, let’s review the meaning of the entries in the table. Each entry gives the topological classification of a system with a given combination of symmetries and dimensionality. In other words, it gives us the possible values that the topological invariant $Q$ of such a system can take.</p><p>An empty entry means that the system does not have a topological phase. In other words, all gapped Hamiltonians with dimension and symmetries corresponding to an empty entry can be deformed into each other, without ever closing the bulk gap and without breaking any existing symmetry.</p><p>A $\mathbb{Z}$ entry tells us that the topological invariant is an integer number, $Q=0, \pm 1, \pm 2, \dots$ An example of such a system is the quantum Hall effect, for which the topological invariant is the Chern number. The value of $Q$ specifies the number of chiral edge states and their chirality, which is opposite for opposite signs of $Q$.</p><p>A $2\mathbb{Z}$ entry is much like a $\mathbb{Z}$ entry, except that the invariant may only take even numbers, $Q=0,\pm2, \pm4, \dots$, because of some doubling of the degrees of freedom. An example is a quantum dot with spinful time-reversal symmetry, for which the topological invariant is the number of filled energy levels. It may only be an even number because of Kramers degeneracy.</p><p>A $\mathbb{Z}_2$ entry means that there are only two distinct topological phases, with $Q=\pm 1$ (or $Q=0, 1$, depending on convention). An example we know is the Majorana chain, with the Pfaffian topological invariant, which distinguishes between the two phases with or without unpaired Majorana modes and the ends. Another example we know are the time-reversal invariant topological insulators in two and three dimensions.</p><p>Now that we have attached a meaning to each entry in the table, let’s try to understand the table as a whole. The first thing to do is to understand why it has ten and only ten rows.</p><h1 id="Symmetry-classes"><a href="#Symmetry-classes" class="headerlink" title="Symmetry classes"></a>Symmetry classes</h1><p>Each row in the table corresponds to a certain <em>symmetry class</em>, that is to a given combination of the presence or absence of three fundamental discrete symmetries.</p><p>You already encountered these three symmetries all the way back in week one. They are time-reversal symmetry ($\mathcal{T}$), particle-hole symmetry ($\mathcal{P}$) and chiral symmetry ($\mathcal{C}$). We previously referred to chiral symmetry $\mathcal{C}$ as sublattice symmetry. This is because in condensed matter physics, a natural realization of chiral symmetry is a system composed of two sublattices, such that sites in one lattice only couple to sites in the other.</p><p>Why do we consider these symmetries fundamental, and restrict the periodic table to them only?</p><p>As you may recall from week one, and as Shinsei Ryu explained in the introductory video, normal unitary symmetries of a Hamiltonian do not have particularly interesting consequences for topological classification. One may always make the Hamiltonian block-diagonal, reducing the problem to the study of a single block. This procedure can be repeated until one runs out of unitary symmetries and is left with an <em>irreducible</em> block of the Hamiltonian, i.e. one which cannot be block diagonalized.</p><p>Time-reversal, particle-hole and chiral symmetries act in a different way. They impose certain constraints on an irreducible Hamiltonian - for instance, by forcing it to be a real matrix, or to be block off-diagonal.</p><p>Note, however, that it is possible to extend the periodic table to study the interplay between these three discrete symmetries and other unitary symmetries. For instance, we have already touched upon crystalline symmetries in week seven, and we will return to them in week ten.</p><p>But for now, let’s focus on the three fundamental discrete symmetries: $\mathcal{P}$, $\mathcal{T}$ and $\mathcal{C}$. Their basic properties are:</p><ul><li>$\mathcal{T}$ is an anti-unitary operator which commutes with the Hamiltonian.</li><li>$\mathcal{P}$ is an anti-unitary operator which anti-commutes with the Hamiltonian.</li><li>$\mathcal{C}$ is a unitary operator which anti-commutes with the Hamiltonian.</li></ul><p>Recall that an anti-unitary operator can be written as the product of a unitary operator and the complex conjugation operator $\mathcal{K}$. The next important thing to know is that time-reversal and particle-hole symmetry may come in two separate flavors, depending on whether they square to plus or minus one.</p><p>For instance, you will recall that for the time-reversal operator acting on electronic states, $\mathcal{T}^2=-1$. This was the crux of Kramers theorem, which in turn was the key to topological insulators. If you go back to week one, you will also remember that we discussed real matrices, which were symmetric under a time-reversal operator $\mathcal{T}=\mathcal{K}$. This operator satisfies $\mathcal{T}^2=1$.</p><p>Thus, a system can behave in three ways under time-reversal symmetry $\mathcal{T}$: (1) it does not have time-reversal symmetry, (2) it has it and $\mathcal{T}$ squares to $+1$, (3) it has it and $\mathcal{T}$ squares to $-1$. The same holds for particle-hole symmetry, which can also have $\mathcal{P}^2=\pm 1$. On the other hand, the chiral symmetry only comes in one flavor, $\mathcal{C}^2=1$.</p><h2 id="Combining-symmetries"><a href="#Combining-symmetries" class="headerlink" title="Combining symmetries"></a>Combining symmetries</h2><p>How do we arrive to having ten symmetry classes? Let’s count all the possible cases carefully. By combining the three cases for $\mathcal{P}$ and the three cases for $\mathcal{T}$ we arrive at nine possible combinations. </p><p>The important thing to notice now is that $\mathcal{C}$ is not completely independent from $\mathcal{T}$ and $\mathcal{P}$. Whenever a system has both $\mathcal{T}$ and $\mathcal{P}$, there is also a chiral symmetry $\mathcal{C}=\mathcal{P\cdot T}$.</p><p>This also means that if a system only has either $\mathcal{T}$ or $\mathcal{P}$ but not both, it cannot have a chiral symmetry $\mathcal{C}$. In other words, the presence of any two out of the three symmetries implies that the third is also present.</p><p>On the other hand, if both $\mathcal{P}$ and $\mathcal{T}$ are absent, then $\mathcal{C}$ may or may not be present. This gives us two distinct cases.</p><p>Adding all the possibilities, we indeed find 10 symmetry classes:</p><p>$$(3\times 3 - 1) + 2 = 8 + 2 = 10,.$$</p><p>The first term in the sum corresponds to the eight cases where there is at least one anti-unitary symmetry: either $\mathcal{P}$, or $\mathcal{T}$, or both. These eight symmetry classes are called <em>real</em>, because an anti-unitary symmetry always involves the complex conjugation operator. This does not necessarily mean that the Hamiltonian is a real matrix, but it is a reminder that there is a constraint between its real and imaginary parts.</p><p>The second term in the sum covers the two cases when there are no anti-unitary symmetries. These symmetry classes are called <em>complex</em>.</p><p>Let’s have another look at the 10 rows in the table, this time specifying which combination of the three fundamental symmetries each row has:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">full_table, format_string = make_table(</span><br><span class="line">    n=<span class="number">0</span>, show_symmetries=<span class="literal">True</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure><p>The somewhat cryptic notations in the leftmost column are just the names of the different symmetry classes. (Also the ‘I’s appearing there are Roman cardinal numbers, so for instance BDI is ‘B D one’, and AIII is “A three”.)</p><p>Their names come from an elegant mathematical classification of <a href="http://en.wikipedia.org/wiki/Symmetric_space">symmetric spaces</a> worked out by <a href="http://en.wikipedia.org/wiki/%C3%89lie_Cartan">Elie Cartan</a> in 1926. While it is definitely intriguing that a group theory result from 1926 reappears in a totally different context almost 80 years later, the origin of this nomenclature is not directly relevant to most of the theory done in the field.<br>The two complex classes are A and AIII.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;Which symmetry class do we get if we break Kramers degeneracy in class BDI?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [<span class="string">&quot;D&quot;</span>, <span class="string">&quot;AIII&quot;</span>, <span class="string">&quot;DIII&quot;</span>, <span class="string">&quot;None, class BDI has no Kramers degeneracy&quot;</span>]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;Kramers degeneracy requires that time reversal squares to -1, while it squares to 1 in class BDI.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Finally, let us make an extra observation:</p><blockquote><p>While the particle-hole symmetry appears in any superconductor, it must satisfy $\mathcal{P}^2 = -\mathcal{T}^2$ due to the way the Bogoliubov quasiparticles are related to the original electrons. This makes the symmetry classes BDI, and CII rely on a fine-tuned Hamiltonian, just like the symmetry class AIII.</p></blockquote><h1 id="What-we-learned-so-far"><a href="#What-we-learned-so-far" class="headerlink" title="What we learned so far"></a>What we learned so far</h1><p>To get some confidence with the table and these obscure names, it is useful to see where the topological systems that we have studied so far fit into the table.</p><p>Every red entry in the table below corresponds to something which we already know and studied in the previous weeks of the course, as you can discover by moving the mouse over it.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">tooltips = &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">6</span>): <span class="string">&quot;Chern insulator: no symmetries, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">5</span>): <span class="string">&quot;Majorana wire: spinful particle-hole, d=1&quot;</span>,</span><br><span class="line">    (<span class="number">4</span>, <span class="number">5</span>): <span class="string">&quot;Polyacetilene/SSH chain: sublattice symmetry, d=1&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">6</span>): <span class="string">&quot;QSHE: spinful TRS, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">7</span>): <span class="string">&quot;3D strong TI: spinful TRS, d=3&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">6</span>): <span class="string">&quot;p-wave superconductor: PHS, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">4</span>): <span class="string">&quot;Superconducting quantum dot: d=0, PHS&quot;</span>,</span><br><span class="line">    (<span class="number">2</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, spinless TRS&quot;</span>,</span><br><span class="line">    (<span class="number">1</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, no symmetries&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, spinful TRS and Kramers degeneracy&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">True</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">colors = np.zeros(shape=table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos <span class="keyword">in</span> tooltips:</span><br><span class="line">    colors[pos] = [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line"></span><br><span class="line">colordefs = color_table(table, colors)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos, val <span class="keyword">in</span> <span class="built_in">list</span>(tooltips.items()):</span><br><span class="line">    table[pos] = <span class="string">r&quot;\texttip&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(table[pos].decode(<span class="string">&quot;utf-8&quot;</span>), val)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">HTML(</span><br><span class="line">    markdown2html_pandoc(</span><br><span class="line">        table_header.<span class="built_in">format</span>(</span><br><span class="line">            colordefs=(<span class="string">&quot;\\require&#123;action&#125;\n&quot;</span> + colordefs), fmt=format_string, body=block</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>As you can see, the Majorana wire and the $p$-wave superconductor are in class D, the Chern insulators in class A, and the time-reversal invariant topological insulators in class AII. These names occur quite often in the literature.</p><h1 id="Finding-a-periodic-structure"><a href="#Finding-a-periodic-structure" class="headerlink" title="Finding a periodic structure"></a>Finding a periodic structure</h1><p>We have now explained why there are ten rows and the meaning of the symmetry classes, but the table as a whole still does not have a coherent structure. Is there a way that we can connect systems between different symmetry classes and different dimensions?</p><p>Given a gapped Bloch Hamiltonian $H_d$ in a certain symmetry class and dimension $d$, there is a systematic procedure by which we can increase its dimensionality. This changes its symmetry class, but makes sure that the topological classification is unvaried. This procedure thus allows us to connect different rows of the table.</p><p>The basic idea is to add a new momentum $k_{d+1}$ to the Bloch Hamiltonian in such a way that the gap does not close for any value of $k_{d+1}$ in the Brillouin zone. This means that the new Hamiltonian must have the same value of the topological invariant as the initial one. The tricky (but also beautiful) part is that adding a momentum can change the symmetries of the Hamiltonian, and one has to keep track of that carefully.</p><p>This procedure is slightly different depending on whether the initial $H_d$ has chiral symmetry or not. In one case the procedure removes symmetries, in the other it adds them. Let’s start with the first.</p><h2 id="Removing-symmetries"><a href="#Removing-symmetries" class="headerlink" title="Removing symmetries"></a>Removing symmetries</h2><p>Let’s first suppose that $H_d$ has chiral symmetry $\mathcal{C}$. The Hamiltonian then has $n$ pairs of energy bands symmetric around zero, which we can denote as $\pm \epsilon_{n,d}$, hiding their dependence on the different momenta appearing in $H_d$.</p><p>Then consider the following higher-dimensional Hamiltonian:</p><p>$$<br>H_{d+1} = H_d,\cos k_{d+1} + \mathcal{C} \sin k_{d+1}.<br>$$</p><p>This Hamiltonian has the same number of bands as $H_d$, even though the bands are higher-dimensional. Given its simple form, every band $\epsilon_{n,d+1}^n$ is directly related to a band $\epsilon_{n,d}$ of $H_d$, </p><p>$$<br>\epsilon_{n,d+1} = \pm \sqrt{\epsilon_{n, d}^2,\cos^2 k_{d+1} + \sin^2 k_{d+1}}.<br>$$</p><p>This expression guarantees that the gap of $H_{d+1}$ only closes if that of $H_d$ closes. In other words, whatever value of the topological invariant $H_d$ has, $H_{d+1}$ will have the same value.</p><p>What are the discrete symmetries of $H_{d+1}$? First of all, note that $H_{d+1}$ has no chiral symmetry since the second term by construction commutes with $\mathcal{C}$, while the chiral symmetry would require anti-commutation. So $H_{d+1}$ and $H_d$ belong to a different symmetry classes. Which symmetry class does $H_d$ belong to?</p><p>If $\mathcal{C}$ is the only discrete symmetry of $H_d$, i.e. if $H_d$ belongs to class AIII, then $H_{d+1}$ has no symmetries at all, so it is in class A. We can express this by writing AIII $\to$ A, meaning that the topological classification is the same to the left of the arrow in $d$ dimensions, and to the right of the arrow in $d+1$ dimensions.</p><p>If instead $\mathcal{C}$ is not the only discrete symmetry of $H_d$, then $H_d$ must have both $\mathcal{P}$ and $\mathcal{T}$, because we know that two of the symmetries imply the third. Hence $H_d$ must be in one of the symmetry classes BDI, CI, CII, DIII. Because $H_{d+1}$ has no chiral symmetry, it can only have one remaining symmetry, either $\mathcal{P}$ or $\mathcal{T}$. It is therefore in one of the four classes AI, AII, C, D. With some patience, it is possible to work out exactly the symmetry class of $H_{d+1}$ given that of $H_d$ in all four cases.</p><p>We won’t do that, but state that the result is that by removing chiral symmetry and adding one dimension, one obtains that BDI $\to$ D, DIII $\to$ AII, CII $\to$ C and CI $\to$ AI.</p><h2 id="Adding-symmetries"><a href="#Adding-symmetries" class="headerlink" title="Adding symmetries"></a>Adding symmetries</h2><p>Let’s now start from a Hamiltonian without chiral symmetry. Our procedure this time involves a doubling of the number of bands of $H_d$. That is, we introduce a new set of Pauli matrices $\tau$, not present in $H_d$, and write $H_{d+1}$ as</p><p>$$<br>H_{d+1} = H_d,\cos k_{d+1},\tau_x + \sin k_{d+1},\tau_y.<br>$$</p><p>Note that just like in our previous argument, the topological invariant of $H_{d+1}$ must be the same as that of $H_d$. Also, by construction, $H_{d+1}$ has a chiral symmetry given by $\mathcal{C}=\tau_z$, which anticommutes with all the terms in the Hamiltonian. </p><p>What are the symmetries of $H_{d+1}$ in this case? To begin with, $H_d$ cannot have both anti-unitary symmetries, because then it would have $\mathcal{C}$ as well. It either has none (class A) or just one of them (classes AI, AII, C, or D). We thus have two cases:</p><ul><li>if $H_d$ has no symmetries at all, meaning that it was in class A, then $H_{d+1}$ only has chiral symmetry, meaning that it is in class AIII. So we obtain A $\to$ AIII.</li><li>if $H_d$ has one anti-unitary symmetry, then $H_{d+1}$ must have all three discrete symmetries. Again, we will not work out the details for each case, but one obtains that AI $\to$ BDI, D $\to$ DIII, AII $\to$ CII, and C $\to$ CI.</li></ul><p>Now that we have learned how to extend the topological classification by adding one dimension to the Hamiltonian and changing its symmetry in an appropriate way, nothing forbids us to repeat the procedure, by going two dimensions higher, three dimensions higher, etc…</p><p>So we have made the procedure of finding topological phases systematic.</p><h1 id="The-Bott-clock"><a href="#The-Bott-clock" class="headerlink" title="The Bott clock"></a>The Bott clock</h1><p>If you repeat the procedure many times, you will find that it has a period, i.e. at some point you end up in the same symmetry class you started with.</p><p>This is easy to see for the two complex classes, which are just interchanged:</p><ul><li>A $\to$ AIII $\to$ A.</li></ul><p>But it is also the case for the eight real classes:</p><ul><li>AI $\to$ BDI $\to$ D $\to$ DIII $\to$ AII $\to$ CII $\to$ C $\to$ CI $\to$ AI.</li></ul><p>This property is called <strong>Bott periodicity</strong>, and it can be nicely represented in the following table, similar to a clock:</p><p><img src="/2021/01/07/src/w8_general/classification/bott_clock.svg" alt></p><p>The grey entries in the table are the chiral classes, and the arrows show which classes have the same topological classification when you shift $d\to d+1$. The complex classes are in the centre of the table, and only talk to each other. The eight real classes are disposed around the clock.</p><p>Finally, let’s see what the table looks like when we order the rows according to the Bott clock above:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">5</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=<span class="number">8</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.linspace(<span class="number">0.6</span>, <span class="number">1.2</span>, n).reshape(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>) * np.random.rand(<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">palette = np.minimum(palette, <span class="number">1</span>)</span><br><span class="line">colors[primary_seq(n) + <span class="number">1</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">0</span>]</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">1</span>]</span><br><span class="line">colors[z2_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">2</span>]</span><br><span class="line">colors[z2_descendant2(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">3</span>]</span><br><span class="line">colors[twoz_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">4</span>]</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure><p>Finally some order appears!</p><p>We have colored the different entries to show how all the topological invariants repeat themselves along the diagonals, as a consequence of the procedure outlined above. The table has overall a period equal to 8, meaning that for instance in $d=8$ the topological classification in all symmetry classes is equal to that in $d=0$, and so on.</p><p>In fact, we know another way to change the dimensionality while preserving the topology. It is to go from a Hamiltonian $H$ in $d$ dimensions to the reflection matrix $r$ in $d-1$ dimensions. Whenever $H$ is gapped, $r$ has no zeroes, so both have the same topology. On the other hand, $r$ is a $d-1$-dimensional object, so in going from $H$ to $r$, we go against the Bott clock.</p><p>For example, this means that in the SSH chain, which is a $d=1$ dimensional system in symmetry class AIII, the scattering invariant is the same as the Hamiltonian invariant in the $d=0$ symmetry class A, i.e. the number of negative eigenvalues. On the other hand, the scattering invariant of the quantum Hall effect, the winding number of $r$, is the same expression as the Hamiltonian topological invariant of the SSH chain.</p><h1 id="Reading-the-table-in-different-ways"><a href="#Reading-the-table-in-different-ways" class="headerlink" title="Reading the table in different ways"></a>Reading the table in different ways</h1><h2 id="Complex-classes-Chern-and-winding-numbers"><a href="#Complex-classes-Chern-and-winding-numbers" class="headerlink" title="Complex classes: Chern and winding numbers"></a>Complex classes: Chern and winding numbers</h2><p>The first thing to observe is that the complex classes only have $\mathbb{Z}$ invariant. We already know what these invariants are in low dimensions: the Chern number, which we encountered in quantum Hall systems (class A, $d=2$), and the winding number of the reflection matrix, which we encountered when we studied reflection from the Thouless pump.</p><p>The higher dimensional invariants are simple generalizations of these two. Their mathematical expression can be found in several papers, for instance <a href="http://arxiv.org/abs/1104.1602">this one</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=n, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:<span class="number">3</span>, <span class="number">4</span>:] = [<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>]</span><br><span class="line">colors[<span class="number">1</span>, <span class="number">4</span>:] = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">colors[<span class="number">2</span>, <span class="number">4</span>:] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure><h2 id="Reading-the-table-by-columns"><a href="#Reading-the-table-by-columns" class="headerlink" title="Reading the table by columns"></a>Reading the table by columns</h2><p>Another useful feature of the table is that in a given column, all $\mathbb{Z}$ or $2\mathbb{Z}$ entries, which are grouped by the color gradients below, have the same topological invariant.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">15</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=n, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.random.rand(n, <span class="number">3</span>) ** <span class="number">2</span></span><br><span class="line">colors[primary_seq(n) + <span class="number">1</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">0.8</span> * palette</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.6</span> * (<span class="number">1</span> - palette)</span><br><span class="line">colors[twoz_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.6</span> * (<span class="number">1</span> - palette)</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure><p>We can check this statement for some cases we know. For instance, in $d=0$ the $\mathbb{Z}$ topological invariant is the number of filled energy levels, which applies to quantum dots with broken time-reversal symmetry (class A), spinless time-reversal symmetry (class AI) and spinful time-reversal symmetry (class AII, which has $2\mathbb{Z}$ because of Kramers degeneracy). In $d=2$, the $\mathbb{Z}$ topological invariant is the Chern number, and we saw how it applies to both the Chern insulators in class A and the $p$-wave superconductor in class D.</p><h2 id="Dimensional-reduction"><a href="#Dimensional-reduction" class="headerlink" title="Dimensional reduction"></a>Dimensional reduction</h2><p>An important pattern visible in the table is the descending sequence $\mathbb{Z} ,\to,\mathbb{Z}_2,\to,\mathbb{Z}_2$ that appears in every symmetry class. That is, starting from the $\mathbb{Z}$ invariant, reducing the dimensionaility twice by one we encounter two $\mathbb{Z}_2$ invariants in a row:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">4</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=<span class="number">8</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.random.rand(n, <span class="number">3</span>)</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">0.8</span> * palette</span><br><span class="line">colors[z2_descendant(n - <span class="number">1</span>) + <span class="number">3</span>, np.arange(n - <span class="number">1</span>) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.8</span> * (<span class="number">1</span> - palette[<span class="number">1</span>:])</span><br><span class="line">colors[z2_descendant2(n - <span class="number">2</span>) + <span class="number">3</span>, np.arange(n - <span class="number">2</span>) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.5</span> * (<span class="number">1</span> - palette[<span class="number">2</span>:])</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure><p>Again, this dimensional reduction can best be understood with an example we already know. Consider the symmetry class $D$. In $d=2$ it has a $\mathbb{Z}$ topological phase, the $p$-wave superconductor.</p><p>If you take a finite ribbon of a $p$-wave superconductor, it will have an integer number of edge states, as determined by the Chern number. Let’s now imagine that you take a ribbon and roll it up into a thin, long cylinder, by pasting two of its edges together. The two remaining edges at this point form a circle.</p><p>You can now view this cylinder as a one-dimensional system whose ends are the two rolled-up edges, and ask: how many zero-energy Majorana modes can there be at the ends? We know the answer from last week’s material: the number of zero-modes can be zero or one, depending on whether the boundary conditions are periodic or anti-periodic. The topological invariant is thus reduced to $\mathbb{Z}_2$. This is no surprise, since the system is topologically in the same class as the Kitaev chain.</p><p>We can proceed further with our dimensional reduction. If we take our one dimensional system and make it into a ring, we obtain a zero-dimensional system. Depending on how the two ends are coupled, the two Majorana modes can favour the even or odd fermion parity state, and this quantity cannot change without a Fermi level crossing. This is the $\mathbb{Z}_2$ invariant of zero-dimensional systems in class D.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What sort of topological invariant do we get if we take a 3D TI, and try to make a 4D system with strong invariant, &quot;</span></span><br><span class="line">    <span class="string">&quot;like we did when making a 3D TI out of QSHE?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;We get another $Z_2$ topological invariant&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A 4D system with the Chern number as invariant.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;This construction cannot be repeated anymore.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The topological invariant stays the same.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;A quick check with the table shows that symmetry class AII in 4D has a $Z$ invariant, &quot;</span></span><br><span class="line">    <span class="string">&quot;and it should be the second Chern number.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;nnzPiJ3Q3_8&quot;</span>, src_location=<span class="string">&quot;8.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p>Questions about what you just learned? Ask them below!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Periodic table&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w7_defects/w7_assignments/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w7_defects/w7_assignments/</id>
    <published>2021-01-07T09:11:06.878Z</published>
    <updated>2021-01-07T09:11:06.878Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure><h1 id="Simulations-Majorana-defects"><a href="#Simulations-Majorana-defects" class="headerlink" title="Simulations: Majorana defects"></a>Simulations: Majorana defects</h1><p>As usual, start by grabbing the notebooks of this week (<code>w7_defects</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p><h2 id="Quantum-spin-Hall-junction"><a href="#Quantum-spin-Hall-junction" class="headerlink" title="Quantum spin Hall junction"></a>Quantum spin Hall junction</h2><p>Let us study the spectrum of a Josephson junction on a quantum spin Hall edge in more detail. As in the lecture, we can add a magnet in the middle of the junction, which adds a Zeeman energy term to the Hamiltonian.</p><p>First, make such a junction. The code from week 2 for making a Josephson junction may be useful.</p><p>We are interested in the spectrum below the gap. There are two interesting parameters to vary: the Zeeman energy and the length of the junction. What happens to the energy levels as you increase the length of the junction. In particular, what happens when the junction is very long? What if you turn off the magnet?</p><p>Compare your results to the following paper, particularly Fig. 2.</p><ul><li>arXiv:0804.4469</li></ul><h2 id="Majorana-in-a-crystalline-defect"><a href="#Majorana-in-a-crystalline-defect" class="headerlink" title="Majorana in a crystalline defect"></a>Majorana in a crystalline defect</h2><p>Following Taylor Hughes suggestion from the summary of the lecture about crystalline defects, create an edge dislocation carrying a Majorana mode in an array of weakly coupled Kitaev chains.</p><p>Then try to split the dislocation into two disclinations. What happens to the Majorana mode?</p><p>Note that Kwant only supports regular lattices, so crystallographic defects can be implemented by altering some hoppings, as was done in the simulations in the lecture.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Now share your results:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Topological defects&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-0707-1692"><a href="#arXiv-0707-1692" class="headerlink" title="arXiv:0707.1692"></a>arXiv:0707.1692</h3><p><strong>Hint:</strong> In detail, how to create and manipulate Majoranas on the 3D TI surface.</p><h3 id="arXiv-1112-3527"><a href="#arXiv-1112-3527" class="headerlink" title="arXiv:1112.3527"></a>arXiv:1112.3527</h3><p><strong>Hint:</strong> The Josephson effect on a 3D TI, in real life.</p><h3 id="arXiv-1208-6303"><a href="#arXiv-1208-6303" class="headerlink" title="arXiv:1208.6303"></a>arXiv:1208.6303</h3><p><strong>Hint:</strong> Disclinations.</p><h3 id="arXiv-1105-4351"><a href="#arXiv-1105-4351" class="headerlink" title="arXiv:1105.4351"></a>arXiv:1105.4351</h3><p><strong>Hint:</strong> How weak is weak?</p><h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Topological defects&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w7_defects/ti_majoranas/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w7_defects/ti_majoranas/</id>
    <published>2021-01-07T09:11:06.878Z</published>
    <updated>2021-01-07T09:11:06.878Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> sl</span><br><span class="line"></span><br><span class="line">my = <span class="number">0.5</span> * (pauli.sys0 + pauli.sysz)</span><br><span class="line">s0s0sz = np.kron(pauli.s0s0, pauli.sz)</span><br><span class="line">s0szsz = np.kron(pauli.s0sz, pauli.sz)</span><br><span class="line">mys0 = np.kron(my, pauli.s0)</span><br><span class="line">s0s0sx = np.kron(pauli.s0s0, pauli.sx)</span><br><span class="line">s0s0sy = np.kron(pauli.s0s0, pauli.sy)</span><br><span class="line">szsxsz = np.kron(pauli.szsx, pauli.sz)</span><br><span class="line">s0sysz = np.kron(pauli.s0sy, pauli.sz)</span><br><span class="line">sxsxsz = np.kron(pauli.sxsx, pauli.sz)</span><br><span class="line">sysxsz = np.kron(pauli.sysx, pauli.sz)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qshe_sc</span>(<span class="params">l=<span class="number">40</span>, w=<span class="number">10</span>, lead=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.M - <span class="number">4</span> * p.B) * s0szsz</span><br><span class="line">            - <span class="number">4</span> * p.D * s0s0sz</span><br><span class="line">            + p.gaps(x, y)[<span class="number">1</span>] * mys0</span><br><span class="line">            + p.gaps(x, y)[<span class="number">0</span>] * s0s0sx</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz + <span class="number">0.5j</span> * p.A * szsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz - <span class="number">0.5j</span> * p.A * s0sysz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lead:</span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        lead = kwant.Builder(sym)</span><br><span class="line">        lead[lat(<span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1.5</span> * p.B * s0szsz</span><br><span class="line">        lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -p.B * s0szsz</span><br><span class="line">        syst.attach_lead(lead)</span><br><span class="line">        syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qshe_sc_ribbon</span>(<span class="params">w=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= x &lt; w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.M - <span class="number">4</span> * p.B) * s0szsz</span><br><span class="line">            - <span class="number">4</span> * p.D * s0s0sz</span><br><span class="line">            + p.gaps(x, y)[<span class="number">1</span>] * mys0</span><br><span class="line">            + p.gaps(x, y)[<span class="number">0</span>] * s0s0sx</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz + <span class="number">0.5j</span> * p.A * szsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz - <span class="number">0.5j</span> * p.A * s0sysz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_2d_pwave</span>(<span class="params">w, l</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        (x1, y1) = site1.pos</span><br><span class="line">        (x2, y2) = site2.pos</span><br><span class="line">        phi = p.phase(<span class="number">0.5</span> * (x1 + x2), <span class="number">0.5</span> * (y1 + y2))</span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz + <span class="number">1j</span> * p.delta * (</span><br><span class="line">            np.cos(phi) * pauli.sx + np.sin(phi) * pauli.sy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        (x1, y1) = site1.pos</span><br><span class="line">        (x2, y2) = site2.pos</span><br><span class="line">        phi = p.phase(<span class="number">0.5</span> * (x1 + x2), <span class="number">0.5</span> * (y1 + y2))</span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz - <span class="number">1j</span> * p.delta * (</span><br><span class="line">            np.cos(np.pi / <span class="number">2</span> + phi) * pauli.sx + np.sin(np.pi / <span class="number">2</span> + phi) * pauli.sy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site1, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">4</span> * p.t - p.mu) * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (w / <span class="number">2</span> - <span class="number">1</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_slab</span>(<span class="params">l, w, h</span>):</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; h) <span class="keyword">and</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y, z) = site.pos</span><br><span class="line">        phi = p.phase(x, y)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * s0s0sz</span><br><span class="line">            + (p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2) * s0szsz</span><br><span class="line">            + p.delta * (np.cos(phi) * s0s0sx + np.sin(phi) * s0s0sy)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * s0s0sz - p.B2 * s0szsz + p.A2 * <span class="number">0.5j</span> * sxsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * s0s0sz - p.B2 * s0szsz + p.A2 * <span class="number">0.5j</span> * sysxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * s0s0sz - p.B1 * s0szsz + p.A1 * <span class="number">0.5j</span> * szsxsz</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_energies</span>(<span class="params">syst, p, num_orbitals, num_states</span>):</span></span><br><span class="line">    ham = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p), sparse=<span class="literal">True</span>).tocsc()</span><br><span class="line">    energies, states = sl.eigsh(ham, sigma=<span class="number">0</span>, k=num_states)</span><br><span class="line">    densities = (</span><br><span class="line">        np.linalg.norm(states.reshape(-<span class="number">1</span>, num_orbitals, num_states), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> energies, states, densities</span><br></pre></td></tr></table></figure><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>We have a returning lecturer for the first chapter of this week’s lectures: Carlo Beenakker from Leiden University, who will tell us more about different ways to create Majoranas in superconducting vortices.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;YVGlfejNH90&quot;</span>, src_location=<span class="string">&quot;7.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Different-types-of-bulk-edge-correspondence"><a href="#Different-types-of-bulk-edge-correspondence" class="headerlink" title="Different types of bulk-edge correspondence"></a>Different types of bulk-edge correspondence</h1><p>By now, we have seen examples of how the topological properties of the bulk of a material can give birth to new physical properties at its edges, and how these edge properties cannot exist without a bulk. This is the essence of bulk-edge correspondence. For example, the unpaired Majorana bound states at the edges of a Kitaev chain exist because they are separated by the bulk of the chain.</p><p>Observe that the systems we have studied so far all had something in common: the topologically protected edge states were separated by a bulk that is one dimension higher than the dimension of the edge states. For example, the 0D Majorana bound states are separated by the 1D bulk of a Kitaev chain, and 1D chiral edge modes are separated by a 2D Chern insulator.</p><p>In this week, we will see that this does not need to be the case.</p><blockquote><p>The dimension of the bulk does not need to be one higher than the dimension of the topologically protected edge. Any dimension higher than the dimension of the edge works equally well.</p></blockquote><p>We will see how this simple insight opens new avenues in the hunt for topological protection.</p><h1 id="Turning-the-helical-edge-into-a-topological-superconductor"><a href="#Turning-the-helical-edge-into-a-topological-superconductor" class="headerlink" title="Turning the helical edge into a topological superconductor"></a>Turning the helical edge into a topological superconductor</h1><p>In the past weeks, we have studied two systems that appear very different, but where topology showed up in a very similar way.</p><p>First, let’s consider the quantum spin-Hall insulator. As we saw two weeks ago, it is characterized by a fermion parity pump: if you take a Corbino disk made out of a quantum spin-Hall insulator and change the flux by half a normal flux quantum, that is by $h/2e$, one unit of fermion parity is transferred from one edge of the sample to the other.</p><p>Secondly, let us consider a one-dimensional topological superconductor, like we studied in weeks two and three. If such a system is closed into a Josephson ring, and the flux through the ring is advanced by one superconducting flux quantum $h/2e$, the fermion parity at the Josephson junction connecting the two ends changes from even to odd, or viceversa. This is the $4π$ Josephson effect, one of the main signatures of topological superconductivity.</p><p>Note that the change in flux is equal to $h/2e$ in both cases, since a superconducting flux quantum $h/2e$ is half of the normal flux quantum $h/e$.</p><p>This suggest that once you have a quantum-spin Hall insulator, you are only one small step away from topological superconductivity and Majoranas. The only ingredient that is missing is to introduce superconducting pairing on the quantum spin-Hall edge.</p><p>But this is easy to add, for instance by putting a superconductor on top of the outer edge of our quantum spin-Hall Corbino disk:</p><p><img src="/2021/01/07/src/w7_defects/ti_majoranas/qsh_josephson_ring.svg" alt></p><p>The superconductor covers the entire quantum spin-Hall edge except for a small segment, which acts as a Josephson junction with a phase difference given by $\phi = 2e\Phi/\hbar$, where $\Phi$ is the magnetic flux through the center of the disk. We imagine that the superconductor gaps out the helical edge by proximity, which means that Cooper pairs can tunnel in and out from the superconductor into the edge. In order for this to happen, a conventional $s$-wave superconductor is enough.</p><p>We will not repeat our pumping experiment, that is increasing the flux $\Phi$ by $h/2e$. We know that one unit of fermion parity must be transferred from the inner edge of the disk to the outer edge. However, the only place where we can now find a zero-energy state is the Josephson junction, because the rest of the edge is gapped.</p><p>From the point of view of the superconducting junction, this means that advancing the phase difference $\phi$ by $2\pi$, the ground state fermion parity of the junction changes. Recalling what we learned in the second and third weeks, we can say that the Josephson effect is $4\pi$-periodic.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;What happens to the Josephson current in the setup shown above if you remove the inner edge of the Corbino disk?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The pumping argument fails and the Josephson effect becomes $2\pi$ periodic.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Then you can no longer apply a flux through the disk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Josephson effect remains $4\pi$ periodic, but the fermion parity becomes fixed.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Nothing changes if the inner edge of the Corbino disk is removed.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Josephson current is a local effect, so it cannot be affected by a removal of the inner edge. &quot;</span></span><br><span class="line">    <span class="string">&quot;When you insert a superconducting flux quantum into the ring, the fermion parity of the edge becomes odd. &quot;</span></span><br><span class="line">    <span class="string">&quot;The extra fermion comes from the gapped bulk of QSHE, which now acquires one broken &quot;</span></span><br><span class="line">    <span class="string">&quot;Kramers pair. That is allowed since there is half a normal flux quantum penetrating the bulk, &quot;</span></span><br><span class="line">    <span class="string">&quot;and Kramers theorem doesn&#x27;t apply anymore.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Majoranas-on-the-quantum-spin-Hall-edge"><a href="#Majoranas-on-the-quantum-spin-Hall-edge" class="headerlink" title="Majoranas on the quantum spin-Hall edge"></a>Majoranas on the quantum spin-Hall edge</h2><p>We know that the $4\pi$-periodicity of the Josephson effect can always be associated with the presence of Majorana zero modes at the two superconducting interfaces of the Josephson junction.</p><p>However, if you compare the system above with the Josephson ring studied in week three, you will notice an important difference. In that case, the Josephson junction was formed by an insulating barrier. Now on the other hand, the two superconducting interfaces are connected by the quantum spin-Hall edge.</p><p>This means that our Majoranas are connected by a gapless system, and therefore always strongly coupled. In order to see unpaired Majoranas, or at least weakly coupled ones, we need to gap out the segment of the edge forming the Josephson junction.</p><p>To gap it out, we can try to place another superconductor in the gap. Unfortunately, this doesn’t really help us, because it results in the formation of two Josephson junctions connected in series, and we only want one.</p><p>However, we know that the edge modes of the quantum spin-Hall insulator are protected from backscattering by time-reversal symmetry. To gap them out, we need to break time-reversal symmetry. Since a magnetic field breaks time-reversal symmetry, we can gap out the edge modes by placing a magnet on the segment of the edge between the two superconductors:</p><p><img src="/2021/01/07/src/w7_defects/ti_majoranas/qsh_majoranas.svg" alt></p><p>In the sketch above, you see two Majoranas drawn, one at each interface between the magnet and the superconductor. Their wavefunctions decay as we move away from the interfaces. As Carlo Beenakker mentioned in the introductory video, these Majoranas are quite similar to those we found at the ends of quantum wires.</p><p>To understand them in more detail, note that the magnet and the superconductor both introduce a gap in the helical edge, but through a completely different physical mechanism. The magnet flips the spin of an incoming electron, or hole, while the superconductor turns an incoming electron with spin up into an outgoing hole with spin down. These two different types of reflection processes combine together to form a Majorana bound state.</p><p>We can capture this behavior with the following Bogoliubov-de Gennes Hamiltonian for the edge:</p><p>$$H_\textrm{BdG}=(-iv\sigma_x \partial_x-\mu)\tau_z+m(x),\sigma_z+\Delta(x),\tau_x.$$</p><p>The first term is the edge Hamiltonian of the quantum spin-Hall effect, describing spin up and down electrons moving in opposite direction, together with a chemical potential $\mu$. The matrix $\tau_z$ acts on the particle-hole degrees of freedom, doubling the normal state Hamiltonian as usual. The second term is the Zeeman term due to the presence of the magnet. Finally, the last term is the superconducting pairing.</p><p>The strength of the Zeeman field $m(x)$ and the pairing $\Delta(x)$ both depend on position. At a domain wall between the superconductor and the magnet, when the relevant gap for the edge changes between $m$ and $\Delta$, the Hamiltonian above yields a Majorana mode.</p><p>This is shown below in a numerical simulation of a quantum spin-Hall disk. The left panel shows the edge state of the disk without any superconductor or magnet. In the right panel we cover one half of the disk by a superconductor and the other by a magnet, and obtain two well-separated Majoranas:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="number">60</span></span><br><span class="line">w = <span class="number">60</span></span><br><span class="line">sys2 = make_qshe_sc(l, w)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(A=<span class="number">0.5</span>, B=<span class="number">1.00</span>, D=<span class="number">0.1</span>, M=<span class="number">0.5</span>)</span><br><span class="line">p.gaps = <span class="keyword">lambda</span> x, y: [(y &lt; <span class="number">0</span>) * <span class="number">0.0</span>, (y &gt;= <span class="number">0</span>) * <span class="number">0.0</span>]</span><br><span class="line">energies0, states0, densities0 = calc_energies(sys2, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line">p.gaps = <span class="keyword">lambda</span> x, y: [(y &lt; <span class="number">0</span>) * <span class="number">0.2</span>, (y &gt;= <span class="number">0</span>) * <span class="number">0.3</span>]</span><br><span class="line">energies, states, densities = calc_energies(sys2, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">phi = np.linspace(-np.pi, np.pi, <span class="number">51</span>)</span><br><span class="line">x = (w + <span class="number">0.5</span>) / <span class="number">2</span> * np.cos(phi)</span><br><span class="line">y = (l + <span class="number">0.5</span>) / <span class="number">2</span> * np.sin(phi)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">9</span>, <span class="number">3.5</span>))</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">122</span>)</span><br><span class="line">gap_B = ax1.fill_between(x[:<span class="number">26</span>], <span class="number">0</span>, y[:<span class="number">26</span>], facecolor=<span class="string">&quot;gold&quot;</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">gap_Sc = ax1.fill_between(x[<span class="number">26</span>:], <span class="number">0</span>, y[<span class="number">26</span>:], facecolor=<span class="string">&quot;blue&quot;</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(sys2, densities[:, <span class="number">0</span>], colorbar=<span class="literal">False</span>, ax=ax1, cmap=<span class="string">&quot;gist_heat_r&quot;</span>)</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;k-&quot;</span>, lw=<span class="number">2</span>)</span><br><span class="line">text_style = <span class="built_in">dict</span>(fontsize=<span class="number">16</span>, arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">&quot;-&quot;</span>, facecolor=<span class="string">&quot;black&quot;</span>, lw=<span class="number">0</span>))</span><br><span class="line">plt.annotate(<span class="string">&quot;$E_Z$&quot;</span>, xytext=(-w / <span class="number">20</span>, l / <span class="number">5</span>), xy=(<span class="number">0</span>, l / <span class="number">3</span>), **text_style)</span><br><span class="line">plt.annotate(<span class="string">&quot;$\Delta$&quot;</span>, xytext=(-w / <span class="number">20</span>, -l / <span class="number">4</span>), xy=(<span class="number">0</span>, -l / <span class="number">3</span>), **text_style)</span><br><span class="line">ax1.set_yticks([])</span><br><span class="line">ax1.set_xticks([])</span><br><span class="line">ax1.set_ylim(-l / <span class="number">2</span> - <span class="number">3</span>, l / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax1.set_xlim(-w / <span class="number">2</span> - <span class="number">3</span>, w / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">pot = np.log(<span class="built_in">abs</span>(energies0[<span class="number">0</span>])) // np.log(<span class="number">10.0</span>) - <span class="number">1</span></span><br><span class="line">fac = <span class="built_in">abs</span>(energies0[<span class="number">0</span>]) * <span class="number">10</span> ** (-pot)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Majoranas, $E = $&quot;</span> + scientific_number(<span class="built_in">abs</span>(energies[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line">ax0 = fig.add_subplot(<span class="number">121</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(sys2, densities0[:, <span class="number">0</span>], colorbar=<span class="literal">False</span>, ax=ax0, cmap=<span class="string">&quot;gist_heat_r&quot;</span>)</span><br><span class="line">ax0.set_yticks([])</span><br><span class="line">ax0.set_xticks([])</span><br><span class="line">ax0.set_ylim(-l / <span class="number">2</span> - <span class="number">3</span>, l / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax0.set_xlim(-w / <span class="number">2</span> - <span class="number">3</span>, w / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax0.set_title(<span class="string">&quot;Edge state, $E = $&quot;</span> + scientific_number(<span class="built_in">abs</span>(energies0[<span class="number">0</span>])))</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;k-&quot;</span>, lw=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>The density of states plot of the lowest energy state reveals one Majorana mode at each of the two interfaces between the magnet and the superconductor.</p><p>This clearly shows how is it possible to obtain 0D topologically protected states (the Majorana modes) from a $2D$ bulk topological phase (the quantum spin Hall insulator). All we had to do was to add the appropriate ingredients (the superconductor and the magnet).</p><h1 id="Two-dimensional-p-wave-superconductors"><a href="#Two-dimensional-p-wave-superconductors" class="headerlink" title="Two-dimensional $p$-wave superconductors"></a>Two-dimensional $p$-wave superconductors</h1><p>Let us now move on to Majoranas in vortices, as discussed by Carlo Beenakker in the introductory video. We will need a model for a 2D topological superconductor. How do we obtain it?</p><p>It turns out that the method we used to construct 2D Chern insulators in week 4, namely stacking 1D Kitaev chains and coupling them, can also be used to construct 2D topological superconductors.</p><p>That isn’t very surprising though, is it? Remember that back then, we told you to forget that the Kitaev model was really a superconductor. Bearing that in mind, it comes as no surprise that stacking 1D superconductors gives us a 2D superconductor.</p><p>So let’s look back at the Hamiltonian we obtained for a Chern insulator by coupling a stack of Kitaev chains: </p><p>$$H_\textrm{2D}(\mathbf{k})=-(2t\cos{k_x}+\mu),\tau_z+\Delta\sin{k_x}\tau_y-2\gamma,(\cos{k_y}\tau_z+\sin{k_y},\tau_x).$$ </p><p>Those of us who are careful would want to check that the above Hamiltonian is indeed a superconductor, in particular that the terms coupling different chains do not spoil particle-hole symmetry.</p><p>And indeed if we consider the operator $\mathcal{P}=\tau_x \mathcal{K}$ with $\mathcal{K}$ the complex conjugation operator, we find that the Bloch Hamiltonian obeys $H_\textrm{2D}(\mathbf{k}) = -\tau_x H^*_\textrm{2D}(-\mathbf{k}) \tau_x$, precisely the symmetry obeyed by the Kitaev chain, extended to two dimensions (if you do not remember how to apply an anti-unitary symmetry in momentum space, you can go back to week 1 and look at the original derivation).</p><p>The Hamiltonian above is quite anisotropic - it looks different in the $x$ and $y$ directions, a consequence of the way we derived it in week four. For our purposes, however, it is convenient to make it look isotropic. Thus, we tweak the coefficients in $H$ to make it look similar in the $x$ and $y$ directions. This is fine as long as we do not close the gap, because the topological properties of $H$ remain unchanged.</p><p>In this way we arrive at the canonical Hamiltonian of a so-called $p$-wave superconductor:</p><p>$$H(k_x,k_y)=-[2t,(\cos{k_x}+\cos{k_y})+\mu],\tau_z+\Delta,(\sin{k_x}\tau_y-\sin{k_y}\tau_x).$$</p><p>Apart from looking more symmetric between the $x$ and $y$ directions, the Hamiltonian clearly separates normal hopping, which is proportional to $t$, and superconducting pairing, which is proportional to $\Delta$. This superconductor is $p$-wave because the pairing is linear in momentum, just like in the Kitaev chain. This can be seen explicitly by expanding $H$ around $\mathbf{k}=\mathbf{0}$, which gives</p><p>$$H(k_x,k_y)\approx [t,(k_x^2+k_y^2)-\mu+4 t]\tau_z+[i \Delta(k_x+i k_y)\tau_++\textrm{h.c.}],$$</p><p>where $\tau_+=(\tau_x+i\tau_y)/2$. Note that the pairing is proportional to $k_x+ik_y$, and it breaks both time-reversal and inversion symmetries.</p><p>Even though we have reinterpreted the Hamiltonian $H$ as a superconductor, it is still originally a Chern insulator. This means that the system is still characterized by a bulk Chern number, which determines the presence of chiral edge states.<br>A chiral edge state can be described by a simple effective Hamiltonian, equivalent to that of a quantum Hall edge:</p><p>$$H_\textrm{edge}=\hbar v k$$</p><p>with $v$ the velocity and $k$ the momentum along the edge. Note that the edge Hamiltonian maintains the particle-hole symmetry of the bulk: for every state with energy $E$ and momentum $k$ there is a state with energy $-E$ and momentum $-k$.</p><p>We are now ready to see how unpaired Majoranas can appear in a 2D $p$-wave superconductor.</p><h1 id="Vortices-in-2D-p-wave-superconductors"><a href="#Vortices-in-2D-p-wave-superconductors" class="headerlink" title="Vortices in 2D p-wave superconductors"></a>Vortices in 2D p-wave superconductors</h1><p>So far we have considered a uniform superconducting pairing $\Delta$, with constant amplitude and phase. This is an idealized situation, which corresponds to a perfect superconductor with no defects.</p><p>If you apply a small magnetic field to a superconducting film, or if there are defects in the material, a <a href="http://en.wikipedia.org/wiki/Abrikosov_vortex"><strong>vortex</strong></a> of supercurrent can form to lower the free energy of the system.<br>In a vortex, there is a supercurrent circulating in a small area around the defect or the magnetic field lines penetrating the superconductor. The magnetic flux enclosed by the vortex supercurrent is equal to a superconducting flux quantum $h/2e$.</p><p>The amplitude $\Delta$ of the superconducting pairing is suppressed in the core of the vortex, going to zero in its center, and the superconducting phase winds by $2\pi$ around a closed path surrounding it. The situation is sketched below:</p><p><img src="/2021/01/07/src/w7_defects/ti_majoranas/vortex.svg" alt></p><p>Because the pairing $\Delta$ goes to zero in the middle of the vortex, there can be states with an energy smaller than $\Delta$ which are localized at the vortex core. We now want to see whether it is possible to have a non-degenerate zero energy solution in the vortex - because of particle-hole symmetry, this would be an unpaired Majorana mode!</p><p>To compute the spectrum of the vortex we could introduce a position dependent-phase for $\Delta$ in the Hamiltonian of the superconductor, and solve it for the energy spectrum by going through quite some algebra. But as usual in this course, we will take a shortcut.</p><p>Our shortcut comes from answering the following question: how is the spectrum of the chiral edge states affected by introducing a vortex in the middle of the superconductor?</p><p>From week one, we know that changing the flux through a superconducting ring by a flux quantum changes the boundary condition from periodic to antiperiodic, or viceversa.</p><p>A vortex has precisely the same effect on the chiral edge states. Therefore, in the presence of a vortex, the allowed values $k_n$ of momentum in a disk shift by $\pi/L$, with $L$ the length of the edge. The energy levels depend linearly on momentum and are shifted accordingly,</p><p>$$<br>E_n,\to, E_n + \hbar v \pi / L.<br>$$</p><p>Now, with or without the vortex, the spectrum must be symmetric around $E=0$ because of particle-hole symmetry. The energy levels $E_n$ correspond to standing waves and are equally spaced, with spacing given by $2\hbar v \pi / L$. There are only two such spectra consistent with particle-hole symmetry, $E_n = 2\pi,n, \hbar v / L$ and $E_n = 2\pi,(n+1/2), \hbar v / L$.</p><p>Which one of the two spectra correspond to the presence of a vortex?</p><p>To answer this question, observe that the energy spectrum $E_n = 2 \pi,n,\hbar v / L$ includes a zero-energy solution, which is an unpaired Majorana mode at the edge! This is impossible unless there is somewhere a place to have a second zero-energy solution. And the only other possible place where we could have a zero-energy solution is the core of the vortex.</p><blockquote><p>Just by looking at the edge state momentum quantization, we have thus demonstrated that a vortex in a $p$-wave superconductor must come with a Majorana.</p></blockquote><p>Below, we plot the wave function of the lowest energy state in a $p$-wave disk with a vortex in the middle. The lowest energy wavefunction is an equal superposition of the two Majorana modes. Here you can see that half of it is localized close to the vortex core and half of it close to the edge.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.cm</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"></span><br><span class="line">colors = matplotlib.cm.gist_heat_r(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>) ** <span class="number">0.25</span>)</span><br><span class="line">gist_heat_r_rescaled = mcolors.LinearSegmentedColormap.from_list(</span><br><span class="line">    <span class="string">&quot;gist_heat_r_rescaled&quot;</span>, colors</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.4</span>, delta=<span class="number">0.5</span>, phase=<span class="keyword">lambda</span> x, y: np.angle(x + <span class="number">1j</span> * y))</span><br><span class="line">l = <span class="number">60</span></span><br><span class="line">w = <span class="number">60</span></span><br><span class="line">syst = make_2d_pwave(w, l)</span><br><span class="line">energies, states, densities = calc_energies(syst, p, num_orbitals=<span class="number">2</span>, num_states=<span class="number">10</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(</span><br><span class="line">    syst, densities[:, <span class="number">0</span>], cmap=gist_heat_r_rescaled, show=<span class="literal">False</span>, colorbar=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>The wave function is not zero in the bulk between the edge and the vortex because of the relatively small size of the system. The separation between edge and vortex, or between different vortices, plays the same role as the finite length of a Kitaev chain, i.e. it splits the Majorana modes away from zero energy by an exponentially small amount.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens if you add a second vortex to the superconductor? &quot;</span></span><br><span class="line">    <span class="string">&quot;Imagine that the vortices and edge are all very far away from each other&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The second vortex has no Majorana.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Both vortices have a Majorana, and the edge has two Majoranas.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Majorana mode at the edge goes away, and each vortex has its own Majorana.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Vortices can only be added in pairs because Majoranas only come in pairs.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The energy spectrum of the edge is shifted by $\hbar v \pi/L$ by the addition of a second vortex, &quot;</span></span><br><span class="line">    <span class="string">&quot;so the edge has no Majoranas now. The first vortex is not affected, and we know that it has a Majorana. &quot;</span></span><br><span class="line">    <span class="string">&quot;And so, of course, the second vortex must have a Majorana as well.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Vortices-in-3D-topological-insulator"><a href="#Vortices-in-3D-topological-insulator" class="headerlink" title="Vortices in 3D topological insulator"></a>Vortices in 3D topological insulator</h1><p>Unfortunately, superconductors with $p$-wave pairing are very rare, with mainly <a href="http://en.wikipedia.org/wiki/Strontium_ruthenate">one material</a> being a good candidate. But instead waiting for nature to help us, we can try to be ingenious.</p><p>As Carlo mentioned, Fu and Kane <a href="http://arxiv.org/abs/0707.1692">realized</a> that one could obtain an effective $p$-wave superconductor and Majoranas on the surface of a 3D TI.</p><p>We already know how to make Majoranas with a 2D topological insulator. Let us now consider an interface between a magnet and a superconductor on the surface of a 3D topological insulator. Since the surface of the 3D TI is two dimensional, such an interface will be a one dimensional structure and not a point defect as in the quantum spin-Hall case.</p><p>The Hamiltonian of the surface is a very simple extension of the edge Hamiltonian,  $\sigma_x k_x + \sigma_y k_y$ instead of just $\sigma_x k_x$. We can imagine that $k_y$ is the momentum along the interface between the magnet and the superconductor, and it is conserved. The effective Bogoliubov-de Gennes Hamiltonian is</p><p>$$H_\textrm{BdG}=(-i\sigma_x \partial_x+ \sigma_y k_y-\mu)\tau_z+m(x),\sigma_z+\Delta(x) \tau_x.$$</p><p>What is the dispersion $E(k_y)$ of states along the interface resulting from this Hamiltonian? Well, for $k_y=0$ we have exactly the Hamiltonian of the magnet/superconductor interface in the quantum spin-Hall case, which had a zero mode. So we know that the interface is gapless. The magnet breaks time-reversal symmetry, so we will have a chiral edge state, with energy $E$ proportional to $k_y$. Just like in the $p$-wave superconductor case!</p><p>At this point, analyzing the case of a vortex is very simple. We just have to reproduce the geometry we analyzed before. That is, we imagine an $s$-wave superconductor disk with a vortex in the middle, surrounded by a magnetic insulator, all on the surface of a 3D topological insulator:</p><p><img src="/2021/01/07/src/w7_defects/ti_majoranas/3d_ti_vortex.svg" alt></p><p>The introduction of a vortex changes the boundary conditions for the momentum at the edge, like in the $p$-wave case, and thus affects the spectrum of the chiral edge states going around the disk.</p><blockquote><p>Following the same argument as in the $p$-wave case, particle-hole symmetry dictates that there is a Majorana mode in the vortex core on a 3D TI. Interestingly, the vortex core is spatially separated from the magnet - so the vortex should contain a Majorana mode irrespective of the magnet that was used to create the chiral edge mode.</p></blockquote><p>In fact, the magnet was only a crutch that we used to make our argument. We can now throw it away and consider a vortex in a superconductor which covers the entire surface of the topological insulator.</p><p>To confirm this conclusion, below we show the result of a simulation of a 3D BHZ model in a cube geometry, with a vortex line passing through the middle of the cube. To make things simple, we have added superconductivity everywhere in the cube, and not just on the surface (nothing prevents us from doing this, even though in real life materials like Bi$_2$Te$_3$ are not naturally superconducting).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.cm</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"></span><br><span class="line">colors = matplotlib.cm.gist_heat_r(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>))</span><br><span class="line">colors[:, <span class="number">3</span>] = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>)</span><br><span class="line">gist_heat_r_transparent = mcolors.LinearSegmentedColormap.from_list(</span><br><span class="line">    <span class="string">&quot;gist_heat_r_transparent&quot;</span>, colors</span><br><span class="line">)</span><br><span class="line">l, w, h = <span class="number">10</span>, <span class="number">10</span>, <span class="number">25</span></span><br><span class="line">syst = bhz_slab(l, w, h)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(</span><br><span class="line">    A1=<span class="number">0.5</span>,</span><br><span class="line">    A2=<span class="number">0.5</span>,</span><br><span class="line">    B1=<span class="number">0.5</span>,</span><br><span class="line">    B2=<span class="number">0.5</span>,</span><br><span class="line">    C=-<span class="number">0.2</span>,</span><br><span class="line">    D1=<span class="number">0.1</span>,</span><br><span class="line">    D2=<span class="number">0.0</span>,</span><br><span class="line">    M=-<span class="number">0.2</span>,</span><br><span class="line">    delta=<span class="number">0.15</span>,</span><br><span class="line">    phase=<span class="keyword">lambda</span> x, y: np.angle(x + <span class="number">1j</span> * y),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">energies, states, densities = calc_energies(syst, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">9</span>, <span class="number">3.5</span>))</span><br><span class="line"></span><br><span class="line">ax0 = fig.add_subplot(<span class="number">121</span>, projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line">kwant.plot(syst, ax=ax0, site_size=<span class="number">0.3</span>)</span><br><span class="line">ax0.set_xlim(-w / <span class="number">2</span> - <span class="number">2</span>, w / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax0.set_ylim(-l / <span class="number">2</span> - <span class="number">2</span>, l / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax0.set_yticks([])</span><br><span class="line">ax0.set_xticks([])</span><br><span class="line">ax0.set_zlim3d([<span class="number">0</span>, h])</span><br><span class="line">ax0.set_zticks([<span class="number">0</span>, h])</span><br><span class="line">ax0.set_zticklabels([<span class="string">&quot;$0$&quot;</span>, <span class="string">&quot;$%d$&quot;</span> % h])</span><br><span class="line">densities /= np.<span class="built_in">max</span>(densities, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">122</span>, projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line">kwant.plotter.plot(</span><br><span class="line">    syst,</span><br><span class="line">    site_color=densities[:, <span class="number">0</span>],</span><br><span class="line">    ax=ax1,</span><br><span class="line">    cmap=gist_heat_r_transparent,</span><br><span class="line">    colorbar=<span class="literal">False</span>,</span><br><span class="line">    site_lw=<span class="number">0</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ax1.set_xlim(-w / <span class="number">2</span> - <span class="number">2</span>, w / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax1.set_ylim(-l / <span class="number">2</span> - <span class="number">2</span>, l / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax1.set_yticks([])</span><br><span class="line">ax1.set_xticks([])</span><br><span class="line">ax1.set_zlim3d([<span class="number">0</span>, h])</span><br><span class="line">ax1.set_zticks([<span class="number">0</span>, h])</span><br><span class="line">ax1.set_zticklabels([<span class="string">&quot;$0$&quot;</span>, <span class="string">&quot;$%d$&quot;</span> % h])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>In the right panel, you can see a plot of the wavefunction of the lowest energy state. You see that it is very well localized at the end points of the vortex line passing through the cube. These are precisely the two Majorana modes that Carlo Beenakker explained at the end of his introductory video.</p><h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;B7lMz-NrKec&quot;</span>, src_location=<span class="string">&quot;7.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p>Questions about what you just learned? Ask them below!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Majoranas in topological insulators&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w7_defects/crystalline_defects/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w7_defects/crystalline_defects/</id>
    <published>2021-01-07T09:11:06.871Z</published>
    <updated>2021-01-07T09:11:06.871Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">&quot;ignore&quot;</span>, UserWarning)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hoppings terms for BHZ and QAH model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_BHZ</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (p.M - <span class="number">4</span> * p.B) * pauli.s0sz</span><br><span class="line">        - <span class="number">4</span> * p.D * pauli.s0s0</span><br><span class="line">        + p.field * site.pos[<span class="number">1</span>] * pauli.s0s0</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_BHZ</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 + <span class="number">0.5j</span> * p.A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_BHZ</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 - <span class="number">0.5j</span> * p.A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weak_hopping_BHZ</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.t_inter * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_QAH</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (p.mu - <span class="number">4</span> * p.B) * pauli.sz + p.field * site.pos[<span class="number">1</span>] * pauli.s0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_QAH</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.sz + <span class="number">0.5j</span> * p.A * pauli.sx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_QAH</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.sz + <span class="number">0.5j</span> * p.A * pauli.sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weak_hopping_QAH</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.t_inter * np.eye(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Systems</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_screw_system</span>(<span class="params">L, W, H, xs=<span class="literal">None</span>, ys=<span class="literal">None</span>, ye=<span class="literal">None</span>, pbc=<span class="literal">True</span>, model=<span class="string">&quot;BHZ&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create system with screw dislocation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Function creates system with a screw dislocation. </span></span><br><span class="line"><span class="string">    L, W, H are dimension of scattering region.</span></span><br><span class="line"><span class="string">    L, W are dimension of cross section. </span></span><br><span class="line"><span class="string">    Leads are attached from top and bottom (0,0,1) direction.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xs, ys, ye describes where disloaction is placed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">&quot;BHZ&quot;</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_BHZ,</span><br><span class="line">            hopx_BHZ,</span><br><span class="line">            hopy_BHZ,</span><br><span class="line">            weak_hopping_BHZ,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">&quot;QAH&quot;</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_QAH,</span><br><span class="line">            hopx_QAH,</span><br><span class="line">            hopy_QAH,</span><br><span class="line">            weak_hopping_QAH,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; H)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calling kwant</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># scattering system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lead system</span></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># defining dislocation</span></span><br><span class="line">    <span class="keyword">if</span> xs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(ys, ye):</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                <span class="keyword">del</span> syst[lat(xs + <span class="number">1</span>, y, z), lat(xs, y, z)]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">del</span> lead[lat(xs + <span class="number">1</span>, y, <span class="number">0</span>), lat(xs, y, <span class="number">0</span>)]</span><br><span class="line">            lead[lat(xs + <span class="number">1</span>, y, z + <span class="number">1</span>), lat(xs, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y, z <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(ys, ye), <span class="built_in">range</span>(H - <span class="number">1</span>)):</span><br><span class="line">            syst[lat(xs + <span class="number">1</span>, y, z + <span class="number">1</span>), lat(xs, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding periodic boundary conditions</span></span><br><span class="line">    <span class="keyword">if</span> pbc:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            lead[lat(x, <span class="number">0</span>, <span class="number">0</span>), lat(x, W - <span class="number">1</span>, <span class="number">0</span>)] = hopy</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                syst[lat(x, <span class="number">0</span>, z), lat(x, W - <span class="number">1</span>, z)] = hopy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(W):</span><br><span class="line">            lead[lat(<span class="number">0</span>, y, <span class="number">0</span>), lat(L - <span class="number">1</span>, y, <span class="number">0</span>)] = hopx</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                syst[lat(<span class="number">0</span>, y, z), lat(L - <span class="number">1</span>, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized(), lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_edge_dislocation_system</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    L, W, H, xs=<span class="literal">None</span>, ys=<span class="literal">None</span>, ye=<span class="literal">None</span>, pbc=<span class="literal">True</span>, model=<span class="string">&quot;BHZ&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create system with edge dislocation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Function creates system with an edge dislocation. </span></span><br><span class="line"><span class="string">    L, W, H are dimension of scattering region.</span></span><br><span class="line"><span class="string">    L, W are dimension of cross section. </span></span><br><span class="line"><span class="string">    Leads are attached from top and bottom (0,0,1) direction.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xs, ys, ye describes where disloaction is placed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">&quot;BHZ&quot;</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_BHZ,</span><br><span class="line">            hopx_BHZ,</span><br><span class="line">            hopy_BHZ,</span><br><span class="line">            weak_hopping_BHZ,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">&quot;QAH&quot;</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_QAH,</span><br><span class="line">            hopx_QAH,</span><br><span class="line">            hopy_QAH,</span><br><span class="line">            weak_hopping_QAH,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; H)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calling kwant</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># scattering system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = weak_hopping</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lead system</span></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = weak_hopping</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># defining disclocation</span></span><br><span class="line">    <span class="keyword">if</span> xs != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(ys, ye):</span><br><span class="line">            <span class="keyword">del</span> lead[lat(xs, y, <span class="number">0</span>)]</span><br><span class="line">            lead[lat(xs + <span class="number">1</span>, y, <span class="number">0</span>), lat(xs - <span class="number">1</span>, y, <span class="number">0</span>)] = weak_hopping</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                <span class="keyword">del</span> syst[lat(xs, y, z)]</span><br><span class="line">                syst[lat(xs + <span class="number">1</span>, y, z), lat(xs - <span class="number">1</span>, y, z)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># periodic boundary conditions</span></span><br><span class="line">    <span class="keyword">if</span> pbc:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            lead[lat(x, <span class="number">0</span>, <span class="number">0</span>), lat(x, W - <span class="number">1</span>, <span class="number">0</span>)] = hopy</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                syst[lat(x, <span class="number">0</span>, z), lat(x, W - <span class="number">1</span>, z)] = hopy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(W):</span><br><span class="line">            lead[lat(<span class="number">0</span>, y, <span class="number">0</span>), lat(L - <span class="number">1</span>, y, <span class="number">0</span>)] = weak_hopping</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                syst[lat(<span class="number">0</span>, y, z), lat(L - <span class="number">1</span>, y, z)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># attaching leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized(), lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_densities</span>(<span class="params">lead, momentum, p, model, sorting_mid=<span class="number">0.0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Calculate density of states in the lead at a given momentum. &quot;&quot;&quot;</span></span><br><span class="line">    coord = np.array([i.pos <span class="keyword">for</span> i <span class="keyword">in</span> lead.sites])</span><br><span class="line">    xy = coord[coord[:, <span class="number">2</span>] == <span class="number">0</span>][:, :-<span class="number">1</span>]</span><br><span class="line">    indxs_xy = np.lexsort(xy.T)</span><br><span class="line">    xy = xy[indxs_xy, :]</span><br><span class="line"></span><br><span class="line">    h, t = lead.cell_hamiltonian(params=<span class="built_in">dict</span>(p=p)), lead.inter_cell_hopping(params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    h_k = <span class="keyword">lambda</span> k: h + t * np.exp(-<span class="number">1j</span> * k) + t.T.conj() * np.exp(<span class="number">1j</span> * k)</span><br><span class="line"></span><br><span class="line">    vals, vecs = np.linalg.eigh(h_k(momentum))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">&quot;BHZ&quot;</span>:</span><br><span class="line">        num_orbital = <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">&quot;QAH&quot;</span>:</span><br><span class="line">        num_orbital = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    densities = np.linalg.norm(vecs.reshape(-<span class="number">1</span>, num_orbital, <span class="built_in">len</span>(vecs)), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    indxs = np.argsort(<span class="built_in">abs</span>(vals - sorting_mid))</span><br><span class="line">    vals = vals[indxs]</span><br><span class="line">    densities = densities[:, indxs]</span><br><span class="line">    densities = densities[indxs_xy, :]</span><br><span class="line"></span><br><span class="line">    L, W = <span class="built_in">int</span>(np.<span class="built_in">max</span>(xy[:, <span class="number">0</span>]) + <span class="number">1</span>), <span class="built_in">int</span>(np.<span class="built_in">max</span>(xy[:, <span class="number">1</span>]) + <span class="number">1</span>)</span><br><span class="line">    twod_densities = np.zeros((W, L, densities.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> coord, val <span class="keyword">in</span> <span class="built_in">zip</span>(xy, densities):</span><br><span class="line">        i, j = np.array(coord, dtype=<span class="built_in">int</span>)</span><br><span class="line">        twod_densities[j, i, :] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> twod_densities, vals</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_spectrum_and_densities</span>(<span class="params">sys_func, p, model, momentum, kwargs</span>):</span></span><br><span class="line">    syst, lead = sys_func(L=<span class="number">11</span>, W=<span class="number">21</span>, H=<span class="number">5</span>, xs=<span class="number">4</span>, ys=<span class="number">5</span>, ye=<span class="number">16</span>, model=model)</span><br><span class="line">    spect = spectrum(lead, p, **kwargs)</span><br><span class="line">    densities = get_densities(syst.leads[<span class="number">0</span>], momentum, p, model)</span><br><span class="line">    <span class="keyword">return</span> spect, densities</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_hm</span>(<span class="params">sys_func, momentum, kwargs</span>):</span></span><br><span class="line">    parameters = &#123;</span><br><span class="line">        <span class="string">&quot;BHZ&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">0.8</span>&#125;,</span><br><span class="line">        <span class="string">&quot;QAH&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;mu&quot;</span>: <span class="number">0.8</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p_BHZ = SimpleNamespace(field=<span class="number">0.005</span>, t_inter=-<span class="number">0.1</span>, **parameters[<span class="string">&quot;BHZ&quot;</span>])</span><br><span class="line">    p_QAH = SimpleNamespace(field=<span class="number">0.01</span>, t_inter=-<span class="number">0.1</span>, **parameters[<span class="string">&quot;QAH&quot;</span>])</span><br><span class="line"></span><br><span class="line">    spectrum_QAH, densities_QAH = get_spectrum_and_densities(</span><br><span class="line">        sys_func, p_QAH, <span class="string">&quot;QAH&quot;</span>, momentum, kwargs</span><br><span class="line">    )</span><br><span class="line">    spectrum_BHZ, densities_BHZ = get_spectrum_and_densities(</span><br><span class="line">        sys_func, p_BHZ, <span class="string">&quot;BHZ&quot;</span>, momentum, kwargs</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    hm_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> model, density, spect <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">            [<span class="string">&quot;BHZ&quot;</span>, <span class="string">&quot;QAH&quot;</span>], [densities_BHZ, densities_QAH], [spectrum_BHZ, spectrum_QAH]</span><br><span class="line">        ):</span><br><span class="line">            hm_dict[n, model] = (</span><br><span class="line">                spect</span><br><span class="line">                * holoviews.Points((momentum, density[<span class="number">1</span>][n]))</span><br><span class="line">                * holoviews.VLine(momentum)</span><br><span class="line">            ).relabel(<span class="string">&quot;Bandstructure&quot;</span>) + holoviews.Raster(</span><br><span class="line">                density[<span class="number">0</span>][:, :, n], label=<span class="string">r&quot;$\left|\psi\right|^2$&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> holoviews.HoloMap(hm_dict, kdims=[<span class="string">&quot;n&quot;</span>, <span class="string">&quot;model&quot;</span>])</span><br></pre></td></tr></table></figure><h1 id="Introduction-weak-topological-phases"><a href="#Introduction-weak-topological-phases" class="headerlink" title="Introduction: weak topological phases"></a>Introduction: weak topological phases</h1><p>Taylor Hughes from the University of Illinois at Urbana-Champaign will describe the interplay between defects in crystals and weak topological insulators.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;k3ZKCg7jtTs&quot;</span>, src_location=<span class="string">&quot;7.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure><p>As you can see, there is a simple and universal connection between weak topological phases and the ability of defects to carry topologically protected states. The topological invariant $\mathcal{Q}$ of a dislocation is the number of protected states that it carries. It can be determined from the vector of weak topological invariants, $\mathbf{\mathcal{Q}}_\textrm{weak}$, and the Burgers vector of the dislocation $\mathbf{B}$:</p><p>$$\mathcal{Q} = \mathbf{\mathcal{Q}}_\textrm{weak}\cdot\mathbf{B}$$</p><p>Let us now go through the main points that lead to this conclusion, and argue for why it has to be that way.</p><h1 id="Crystallographic-defects-and-topology"><a href="#Crystallographic-defects-and-topology" class="headerlink" title="Crystallographic defects and topology"></a>Crystallographic defects and topology</h1><p>There are many different types of <a href="http://en.wikipedia.org/wiki/Crystallographic_defect">defects in crystals</a>: vacancies, substitutions, grain boundaries, dislocations, and many more.</p><p>What kinds of defects are important for topology? Consider a vacancy for example:<br><img src="/2021/01/07/src/w7_defects/crystalline_defects/Formation_Point_Defect.png" alt><br>(By Safe cracker (Own work) [CC BY 3.0 (<a href="http://creativecommons.org/licenses/by/3.0)]">http://creativecommons.org/licenses/by/3.0)]</a>, via Wikimedia Commons)</p><p>To create a vacancy, we need to remove a single atom (or all the atoms following one line). Can this type of defect carry a topologically protected state?</p><p>We already know that topological protection requires a Hamiltonian that cannot be created locally. For example, in order to create a single Majorana bound state at a phase boundary, another Majorana must appear elsewhere. Removing an atom or a line of atoms only changes the system locally, so the <em>other</em> topologically protected state cannot appear anywhere.</p><p>A simple vacancy is therefore not interesting from a topological point of view. What kinds of topological defects would work then? Crystallographic defects leave nothing different since they leave the bulk Hamiltonian unchanged far away from the defect core. This means we need to do something nontrivial to the crystal so that it cannot be removed locally.</p><p>Examples of such defects are dislocations:</p><p><img src="/2021/01/07/src/w7_defects/crystalline_defects/burgers_vectors.png" alt><br>(By David Gabriel García Andrade (Own work) [Public domain], via Wikimedia Commons)</p><p>In order to create a dislocation we need to cut a crystal along one plane and displace all the atoms along that plane by the <em>Burgers vector</em>. This has to be done all the way to the crystal boundary (or infinity in an infinite crystal), so the dislocation affects the entire system. This means that a dislocation cannot be removed locally.</p><p>As Taylor Hughes explained, a dislocation can be detected infinitely far from its core by going around it and verifying that we don’t return to the point of origin. We cannot simply remove a dislocation by locally replacing some atoms. Therefore, it may carry a topologically protected mode.</p><p>Unsurprisingly, crystallographic defects that cannot be removed locally are called “topological”, which brings us to the first important conclusion:</p><blockquote><p><em>Topological</em> crystallographic defects are the ones that may carry topologically protected modes.</p></blockquote><p>This is a non-trivial observation, even though it sounds tautological. There are two different types of topology involved: the topology of the electronic modes and the topology of the crystal.</p><h1 id="The-role-of-defect-dimensionality"><a href="#The-role-of-defect-dimensionality" class="headerlink" title="The role of defect dimensionality"></a>The role of defect dimensionality</h1><p>When do topological defects carry protected edge states?</p><p>Far away from the defect, the bulk is homogeneous. Hence, the appearance of an edge state must be encoded both in the properties of the defect and in the bulk Hamiltonian. Of course, the appearance of this state must also be controlled by a topological invariant, since the protected state cannot disappear without the closing of the bulk gap.</p><p>What kind of topological invariant can this be? Can a strong topological invariant create a protected edge state at a defect?</p><p>In a sense we already know that it does. We can think of the crystal surface as a defect that breaks translational symmetry, and so it is a crystallographic defect. The strong topological invariant is the quantity that tells us whether or not the bulk can be continuously deformed into vacuum, or equivalently, whether or not the surface can be smoothly removed without closing the bulk gap.</p><p>In a $d$-dimensional bulk, the strong invariant is responsible for the appearance of a $d-1$-dimensional topologically protected state. This state can only be bound to a surface, which is the only $d-1$-dimensional topological defect. Defects of lower dimensionality can not be impacted by the strong invariant. An example of such a defect of lower dimensionality is precisely a dislocation, as in the previous figure. It is a one-dimensional defect in a three-dimensional crystal.</p><p>This is where the weak invariants come into play.</p><p>First of all, we know that the dimensionality $d_\textrm{egde}$ of a protected state at a defect must match the dimensionality of the defect. Secondly, we know the dimensionality of the topological invariant that controls this protected state: it is the topological invariant in the dimension $d_\textrm{edge}+1$.</p><p>The topological invariants with dimensionality $d_{edge}+1$ form a vector or a tensor of the weak indices. The last thing we need to figure out is how to extract information about what happens at the defect from the weak indices.</p><h1 id="The-defect-topological-invariant"><a href="#The-defect-topological-invariant" class="headerlink" title="The defect topological invariant"></a>The defect topological invariant</h1><p>We have almost arrived at the criterion for the appearance of protected states in dislocations.</p><p>To see how the weak topological invariant relates to the number of states in the dislocation, we start by deforming a weak topological insulator into a set of disconnected planes, each carrying protected states. If there is a single state approaching the dislocation, as is shown in the figure below, it cannot backscatter and must therefore continue through the dislocation core.</p><p><img src="/2021/01/07/src/w7_defects/crystalline_defects/dislocation_helical.svg" alt></p><p>(adapted from Cdang (Own work), via Wikimedia Commons, <a href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>.)</p><p>Counting the number and the orientation of the crystal planes approaching the core of the dislocation is just the Burgers vector. Hence, the number of edge states entering the dislocation core is the Burgers vector times the number of states per crystal plane. This brings us to the conclusion:</p><p>$$\mathcal{Q} = \mathbf{\mathcal{Q}}_\textrm{weak}\cdot\mathbf{B}.$$</p><p>Let’s now test this idea and see if we can observe the protected dislocation states.</p><h1 id="Electronic-states-in-dislocations"><a href="#Electronic-states-in-dislocations" class="headerlink" title="Electronic states in dislocations"></a>Electronic states in dislocations</h1><p>Now that we know the main concepts, let’s apply them to concrete examples. Let’s take two models for topological insulators that we already know and apply them to lattice systems with dislocations.</p><p>We will create a 3D weak topological insulators by stacking many layers of 2D topological insulators along the $z$ direction. For the individual layers, we will use the BHZ model (by the way, note that the lecture today was given by the H of BHZ!) for a time-reversal invariant topological insulator, and the square lattice model for the quantum Hall effect that we used in week 4. In this way, we can study dislocations both with and without time reversal symmetry. In both cases, we take the hoppings between different layers to be relatively weak compared to those within the same layer.</p><p>Let’s start with a screw dislocation connecting two layers. The system looks like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># System parameters</span></span><br><span class="line">L = <span class="number">6</span></span><br><span class="line">W = <span class="number">7</span></span><br><span class="line">ws = <span class="number">3</span></span><br><span class="line">xs = <span class="number">2</span></span><br><span class="line">syst, lead = create_screw_system(</span><br><span class="line">    L, W, <span class="number">2</span>, xs=xs, ys=<span class="number">0</span>, ye=W - ws, pbc=<span class="literal">False</span>, model=<span class="string">&quot;BHZ&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line">kwant.plot(syst, site_size=<span class="number">0.0</span>, site_lw=<span class="number">0.01</span>, hop_lw=<span class="number">0.025</span>, ax=ax, num_lead_cells=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">ax.set_zticks(())</span><br><span class="line">ax.view_init(<span class="number">50</span>, -<span class="number">110</span>)</span><br></pre></td></tr></table></figure><p>The Burgers’ vector is parallel to $z$ and has unit length - the dislocation connects neighboring layers.</p><p>The figure above only shows two layers, but we imagine that the system is repeated identically along the $z$ direction. Along the $x$ and $y$ directions it has periodic boundary conditions. Above we only show half of the dislocation.</p><p>Let’s look at the band structure along the $z$ direction, and the wave functions of the corresponding states.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%opts Raster(cmap=<span class="string">&#x27;gist_heat_r&#x27;</span> interpolation=<span class="literal">None</span>) &#123;+framewise&#125;</span><br><span class="line">%opts Points(s=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(np.pi - np.pi / <span class="number">4</span>, np.pi + np.pi / <span class="number">4</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.6</span>, <span class="number">0.95</span>],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [</span><br><span class="line">        (np.pi - np.pi / <span class="number">4</span>, <span class="string">r&quot;$\pi-\pi/4$&quot;</span>),</span><br><span class="line">        (np.pi, <span class="string">r&quot;$\pi$&quot;</span>),</span><br><span class="line">        (np.pi + np.pi / <span class="number">4</span>, <span class="string">r&quot;$\pi+\pi/4$&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create_hm(create_screw_system, momentum=np.pi + <span class="number">0.1</span>, kwargs=kwargs).collate()</span><br></pre></td></tr></table></figure><p>You see that the band structure is gapless: because of the presence of the dislocation, there are states dispersing below the bulk gap along the $z$ direction.</p><p>A look at their wave functions in the right panel shows that in the $x$-$y$ plane, these low-energy states are localized around the end points of the dislocation (we show the wave function corresponding to the blue dot in the band structure plot). On the other hand, when you look at the wave function of states above the gap, you see that they are spread out the whole $x$-$y$ plane.</p><p>Here, the fundamental difference between the BHZ model and the quantum anomalous Hall case is that in the former, the gapless states at the dislocation are helical, while in the latter they are chiral.</p><p>We can also look at an edge dislocation:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># System parameters</span></span><br><span class="line">L = <span class="number">7</span></span><br><span class="line">W = <span class="number">7</span></span><br><span class="line">ws = <span class="number">3</span></span><br><span class="line">xs = <span class="number">3</span></span><br><span class="line">syst, lead = create_edge_dislocation_system(</span><br><span class="line">    L, W, <span class="number">2</span>, xs=xs, ys=<span class="number">0</span>, ye=W - ws, pbc=<span class="literal">False</span>, model=<span class="string">&quot;BHZ&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line"></span><br><span class="line">kwant.plot(syst, site_size=<span class="number">0.0</span>, site_lw=<span class="number">0.01</span>, hop_lw=<span class="number">0.025</span>, ax=ax, num_lead_cells=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">ax.set_zticks(())</span><br><span class="line">ax.view_init(<span class="number">50</span>, -<span class="number">110</span>)</span><br></pre></td></tr></table></figure><p>The Burgers vector is now along the $y$ direction, and it still has unit length. The band structure and the wave function plots show similar behavior.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%opts Raster(cmap=<span class="string">&#x27;gist_heat_r&#x27;</span> interpolation=<span class="literal">None</span>) &#123;+framewise&#125;</span><br><span class="line">%opts Points(s=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi / <span class="number">4</span>, np.pi / <span class="number">4</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.6</span>, <span class="number">0.95</span>],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [(-np.pi / <span class="number">4</span>, <span class="string">r&quot;$-\pi/4$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>), (np.pi / <span class="number">4</span>, <span class="string">r&quot;$\pi/4$&quot;</span>)],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create_hm(create_edge_dislocation_system, momentum=<span class="number">0.1</span>, kwargs=kwargs).collate()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What would happen in both simulations above if we changed the dislocation, &quot;</span></span><br><span class="line">    <span class="string">&quot;making the Burgers vector twice as long?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The wave function would just spread out a bit more because the dislocation is larger.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The number of gapless states would double for both models.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The gapless states would be gapped out for both models.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The dislocation would only have gapless states in the quantum anomalous Hall case, not for the BHZ model.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Doubling the Burgers vector doubles the topological invariant in the $\mathbb&#123;Z&#125;$ case, &quot;</span></span><br><span class="line">    <span class="string">&quot;and changes it from non-trivial to trivial in the $\mathbb&#123;Z&#125;_2$ case.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;MvcvJiZYSSk&quot;</span>, src_location=<span class="string">&quot;7.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p>Questions about what you just learned? Ask them below!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Crystalline defects&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w6_3dti/w6_assignments/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w6_3dti/w6_assignments/</id>
    <published>2021-01-07T09:11:06.870Z</published>
    <updated>2021-01-07T09:11:06.870Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure><h1 id="Simulations-more-Chern-insulators"><a href="#Simulations-more-Chern-insulators" class="headerlink" title="Simulations: more Chern insulators"></a>Simulations: more Chern insulators</h1><p>As usual, start by grabbing the notebooks of this week (<code>w6_3dti</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p><p>Simulations of the three-dimensional systems are hard, mostly because they take a lot of computational power. That’s why we’ll do something relatively simple this time.</p><h3 id="Breaking-time-reversal"><a href="#Breaking-time-reversal" class="headerlink" title="Breaking time-reversal"></a>Breaking time-reversal</h3><p>One mechanism of opening the gap on the surface of a topological insulator is to bring it into contact with a ferromagnet, which creates an effective Zeeman field.</p><ul><li>By calculating dispersion of a slab of 3D TI, observe the effect of Zeeman field pointing in different directions on the surface state dispersion. Find out which direction of the Zeeman field opens the gap in the surface state.</li><li>Make a domain wall between different orientations of Zeeman field. Are there any modes in this domain wall?</li></ul><h3 id="Many-invariants"><a href="#Many-invariants" class="headerlink" title="Many invariants"></a>Many invariants</h3><p>The BHZ model is rather rich and allows to produce every possible topological invariant. Can you find the parameter values that produce all the desired values of the invariants? (Hint: you need to make the model anisotropic).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Now share your results:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;3DTI&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1410-0655"><a href="#arXiv-1410-0655" class="headerlink" title="arXiv:1410.0655"></a>arXiv:1410.0655</h3><p><strong>Hint:</strong> What enters the measurement of a Dirac point conductance.</p><h3 id="arXiv-0811-1303"><a href="#arXiv-0811-1303" class="headerlink" title="arXiv:0811.1303"></a>arXiv:0811.1303</h3><p><strong>Hint:</strong> Consequences of magneto-electric effect.</p><h3 id="arXiv-1401-7461"><a href="#arXiv-1401-7461" class="headerlink" title="arXiv:1401.7461"></a>arXiv:1401.7461</h3><p><strong>Hint:</strong> Weak and strong topological insulators with disorder.</p><h3 id="arXiv-1311-1758"><a href="#arXiv-1311-1758" class="headerlink" title="arXiv:1311.1758"></a>arXiv:1311.1758</h3><p><strong>Hint:</strong> Topological, but not insulator.</p><h3 id="arXiv-1005-3762"><a href="#arXiv-1005-3762" class="headerlink" title="arXiv:1005.3762"></a>arXiv:1005.3762</h3><p><strong>Hint:</strong> Threading flux through a topological insulator.</p><h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;3DTI&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w6_3dti/bhz/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w6_3dti/bhz/</id>
    <published>2021-01-07T09:11:06.856Z</published>
    <updated>2021-01-07T09:11:06.856Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">X=<span class="literal">None</span>, Y=<span class="literal">None</span>, Z=<span class="literal">None</span>, system_type=<span class="string">&quot;infinite&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A cuboid region of BZZ material with two leads attached.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    parameters for leads and scattering region can be defined separately</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Onsite and hoppings matrices used for building BZZ model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * pauli.s0s0 + (</span><br><span class="line">            p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2</span><br><span class="line">        ) * pauli.s0sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sxsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sysx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * pauli.s0s0 - p.B1 * pauli.s0sz + p.A1 * <span class="number">0.5j</span> * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx_phase</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1, z1 = site1.pos</span><br><span class="line">        x2, y2, z2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_slab</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= z &lt; Z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_lead</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= y &lt; Y) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; Z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_cube</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; X) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; Y) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; Z)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>), norbs=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">&quot;slab&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]))</span><br><span class="line">        syst[lat.shape(shape_slab, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">&quot;lead&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[lat.shape(shape_lead, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">&quot;cuboid&quot;</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line">        syst[lat.shape(shape_cube, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">&quot;infinite&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx_phase</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">r&quot;$M=&#123;:.3&#125;$&quot;</span>.<span class="built_in">format</span>(p.M)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lead</span>():</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>), norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder(</span><br><span class="line">        kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)), time_reversal=<span class="number">1j</span> * pauli.sys0</span><br><span class="line">    )</span><br><span class="line">    syst[lat(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1.5</span> * pauli.s0sz</span><br><span class="line">    syst[kwant.HoppingKind((-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = -<span class="number">1</span> * pauli.s0sz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_scatter_sys</span>():</span></span><br><span class="line">    syst = kwant.wraparound.wraparound(bhz(Z=<span class="number">1</span>, system_type=<span class="string">&quot;slab&quot;</span>))</span><br><span class="line">    syst.attach_lead(make_lead())</span><br><span class="line">    syst.attach_lead(kwant.wraparound.wraparound(bhz(), keep=<span class="number">0</span>))</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scattering_det_pfaff</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pfaffian</span>(<span class="params">syst, p, k_x, k_y</span>):</span></span><br><span class="line">        smat = kwant.smatrix(</span><br><span class="line">            syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p, k_x=k_x, k_y=k_y, k_z=<span class="number">0</span>)</span><br><span class="line">        ).data</span><br><span class="line">        <span class="comment"># since we get relatively large numerical errors we project the matrix on</span></span><br><span class="line">        <span class="comment"># the space of antisymmetric matrices</span></span><br><span class="line">        smat = <span class="number">0.5</span> * (smat - smat.T)</span><br><span class="line">        <span class="keyword">return</span> pf.pfaffian(smat)</span><br><span class="line"></span><br><span class="line">    xdim, ydim = <span class="string">&quot;$k_y$&quot;</span>, <span class="string">&quot;phase&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plot_k_x</span>(<span class="params">syst, p, k_x, label, col</span>):</span></span><br><span class="line">        pfaff = [pfaffian(syst, p, k_x, <span class="number">0</span>), pfaffian(syst, p, k_x, np.pi)]</span><br><span class="line">        ks = np.linspace(<span class="number">0.0</span>, np.pi, <span class="number">50</span>)</span><br><span class="line">        det = [</span><br><span class="line">            np.linalg.det(</span><br><span class="line">                kwant.smatrix(</span><br><span class="line">                    syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p, k_x=k_x, k_y=k_y, k_z=<span class="number">0</span>)</span><br><span class="line">                ).data</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">for</span> k_y <span class="keyword">in</span> ks</span><br><span class="line">        ]</span><br><span class="line">        det = np.array(det)</span><br><span class="line">        phase = np.angle(pfaff[<span class="number">0</span>]) + <span class="number">0.5</span> * np.cumsum(np.angle(det[<span class="number">1</span>:] / det[:-<span class="number">1</span>]))</span><br><span class="line">        kdims = [xdim, ydim]</span><br><span class="line">        plot = holoviews.Path((ks[<span class="number">1</span>:], phase), kdims=kdims, label=label).opts(</span><br><span class="line">            style=&#123;<span class="string">&quot;color&quot;</span>: col&#125;</span><br><span class="line">        )</span><br><span class="line">        plot *= holoviews.Points(([<span class="number">0</span>, np.pi], np.angle(pfaff)), kdims=kdims).opts(</span><br><span class="line">            style=&#123;<span class="string">&quot;color&quot;</span>: col&#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> plot</span><br><span class="line"></span><br><span class="line">    plot = plot_k_x(syst, p, <span class="number">0</span>, <span class="string">r&quot;$k_x=0$&quot;</span>, <span class="string">&quot;g&quot;</span>) * plot_k_x(</span><br><span class="line">        syst, p, np.pi, <span class="string">r&quot;$k_x=\pi$&quot;</span>, <span class="string">&quot;b&quot;</span></span><br><span class="line">    )</span><br><span class="line">    xlims, ylims = (-<span class="number">0.2</span>, np.pi + <span class="number">0.2</span>), (-np.pi - <span class="number">0.2</span>, np.pi + <span class="number">0.2</span>)</span><br><span class="line">    pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">    style_overlay = &#123;</span><br><span class="line">        <span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">&quot;$\pi$&quot;</span>)],</span><br><span class="line">        <span class="string">&quot;yticks&quot;</span>: pi_ticks,</span><br><span class="line">        <span class="string">&quot;show_legend&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;legend_position&quot;</span>: <span class="string">&quot;top&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    style_path = &#123;<span class="string">&quot;show_legend&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;xdim: xlims, ydim: ylims&#125;).opts(</span><br><span class="line">        plot=&#123;<span class="string">&quot;Overlay&quot;</span>: style_overlay, <span class="string">&quot;Path&quot;</span>: style_path&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Joel Moore from the University of California, Berkeley will introduce this week’s topic, by telling us how the idea of a two-dimensional topological insulator was generalized to three dimensions.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;NIhMjm7cyug&quot;</span>, src_location=<span class="string">&quot;6.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Making-3D-topological-invariants-out-of-2D-ones"><a href="#Making-3D-topological-invariants-out-of-2D-ones" class="headerlink" title="Making  3D topological invariants out of 2D ones"></a>Making  3D topological invariants out of 2D ones</h1><p>Let us follow the direction explained by Joel Moore and construct a three-dimensional topological state from the two-dimensional topological state. This time, we’ll do this by studying the system in momentum space rather than in real space as we did before. As with two dimensional systems, time-reversal invariant momenta (TRIMs) play an important role in three dimensions. </p><p>For illustrative purposes, consider the three dimensional irreducible Brillouin Zone (i.e. $k_j\in [0,\pi]$) of a cubic system shown below. Fixing one of the three momenta $k_{x,y,z}$ to a TRIM, say $k_x=0$ without loss of generality, we can think of the Hamiltonian in the $(k_y,k_z)$ plane as a two dimensional Hamiltonian, which may either be topologically trivial ($\mathbb{Z}_2$-index $=0$) or non-trivial ($\mathbb{Z}_2$-index $=1$).</p><p><img src="/2021/01/07/src/w6_3dti/bhz/3dbz.svg" alt></p><p>So for every side of the cube shown above we can compute a QSHE topological invariant, which gives us 6 numbers. However not all of them are independent. Specifically, there is a constraint $Q(k_x=0),Q(k_x=\pi) \equiv Q(k_y=0),Q(k_y=\pi) \equiv Q(k_z=0),Q(k_z=\pi)$.</p><p>This product is called <em>the strong topological invariant</em>. Accordingly, the topological insulators where this invariant is non-trivial are called strong topological insulators. For the remaining three invariants, we can choose  $Q(k_x=\pi),,Q(k_y=\pi),,Q(k_z=\pi)$.</p><p>Very frequently the topological invariants of a compound are written as $(1;010)$, where the first number corresponds to the strong invariant, and the remaining three to the weak invariants along each axis. For example, the first predicted topological insulator, the alloy Bi$<em>x$Sb$</em>{1-x}$ is $(1;111)$, and the second generation topological insulators Bi$_2$Te$_3$ and Bi$_2$Se$_3$ are $(1;000)$.</p><p>Just by using the bulk-edge correspondence for $Q$ we know that the strong topological invariant means that there is an odd number of helical states going in each direction on each facet of the topological insulator. We will see later why this is special, but before that let’s construct a model for a 3D TI.</p><h1 id="BHZ-model-of-a-3D-topological-insulator"><a href="#BHZ-model-of-a-3D-topological-insulator" class="headerlink" title="BHZ model of a 3D topological insulator"></a>BHZ model of a 3D topological insulator</h1><p>Our goal in this unit is to derive an effective three-dimensional Hamiltonian $H(\mathbf{k})$ for a strong topological insulator.</p><p>We follow the same logic that led us to defining the three-dimensional topological invariant in the previous unit, building up on our knowledge of 2D topological insulators. Our first step is therefore to set $k_z=0$ and start from a two-dimensional Bloch Hamiltonian which describes a non-trivial 2D topological insulator. Of course, we choose a model we already know for this 2D Hamiltonian, the Bernevig-Hughes-Zhang (BHZ) model.</p><p>Let’s recapitulate what we said about the BHZ model last week. It is a four band model, which has two electron bands (spin up and spin down) and two hole bands (spin up and down). It has inversion symmetry, with electron and hole bands having opposite parity. We will not need more bands for our 3D topological insulator model.</p><p>Copying the BHZ Hamiltonian of last week, at $k_z=0$ we have </p><p>$$<br>H(k_z=0) = \epsilon(\mathbf{k})\cdot\mathbb{1} +<br>\begin{pmatrix}<br>M_0(\mathbf{k}) &amp; A k_+ &amp; 0 &amp; 0 \<br>A k_- &amp; -M_0(\mathbf{k}) &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; M_0(\mathbf{k}) &amp; -Ak_- \<br>0 &amp; 0 &amp; -Ak_+ &amp; -M_0(\mathbf{k})<br>\end{pmatrix},,<br>$$</p><p>where $k_\pm = k_x \pm i k_y$. This Hamiltonian is written in a basis given by the states $\left|E\uparrow\right\rangle$, $\left|H\uparrow\right\rangle$, $\left|E\downarrow\right\rangle$, $\left|H\downarrow\right\rangle$, in that order. The block structure of the Hamiltonian reminds you that it is a doubled version of a Chern insulator, with two diagonal blocks for up and down spins. The particular form of $\epsilon(\mathbf{k})$ can be important to describe the band structure of a given material, but will not play a role in what follows. The effective mass is given by $M_0(\mathbf{k}) = M - B(k_x^2+k_y^2)$, and the transition between the topological and trivial insulating phases in this 2D model happens when $M$ changes sign.</p><p>To get a strong topological insulator, we would like the two-dimensional $\mathbb{Z}_2$ invariant applied to the $(k_x, k_y)$ plane to take different values at $k_z=0$ and $k_z=\pi$. It is easy to achieve this by adding a $k_z$-dependent term to the effective mass, for instance in the following way</p><p>$$<br>M_0(\mathbf{k}),\to,M(\mathbf{k}) = M - B(k_x^2+k_y^2+k_z^2),.<br>$$</p><p>Compared to the 2D model above, we can make the sign of the ‘new’ mass $M-Bk_z^2$ effectively change at fixed $k_x$ and $k_y$ by choosing $k_z$ large enough.</p><p>There is now a problem, however. Looking at the Hamiltonian at different values of $k_z$, we see that if we fix $k_z$ it still has time-reversal symmetry. Since it is topologically nontrivial at $k_z=0$ and becomes trivial at $k_z = \pi$, it should have a topological phase transition somewhere in between.</p><p>In other words, if we just add the $B k_z^2$ term, the Hamiltonian becomes gapless! Of course, we would like to have a gapped Hamiltonian in the whole 3D Brillouin zone instead.</p><p>How can we avoid the gap closing? We definitely need to couple the two spin blocks in $H(\mathbf{k})$, since otherwise each block is undergoing a Chern insulator transition. Recall that spin is odd under time-reversal, so to couple the spins we need a coupling which is odd in momentum, in order to maintain time-reversal invariance in the system. The simplest thing is to pick a coupling that is linear in $k_z$.</p><p>We then arrive at the following 3D Hamiltonian,</p><p>$$<br>H(\mathbf{k}) = \epsilon(\mathbf{k})\cdot\mathbb{1} +<br>\begin{pmatrix}<br>M(\mathbf{k}) &amp; A k_+ &amp; 0 &amp; \tilde{A}k_z \<br>A k_- &amp; -M(\mathbf{k}) &amp; \tilde{A}k_z &amp; 0 \<br>0 &amp; \tilde{A}k_z &amp; M(\mathbf{k}) &amp; -Ak_- \<br>\tilde{A}k_z &amp; 0 &amp; -Ak_+ &amp; -M(\mathbf{k})<br>\end{pmatrix},.<br>$$</p><p>This Hamiltonian is known as the <strong>3D BHZ model</strong>. It is gapped at finite $M$, and a transition between the trivial and strong topological insulator phases is achieved by changing the sign of $M$. Just like its two-dimensional counterpart, the 3D BHZ model can be used as a prototype for a strong topological insulator, as well as a starting point to model real materials. </p><p>The above derivation makes one important point evident: a necessary ingredient to have a strong topological insulator is to break spin conservation. Above, we achieved this by adding coupling between the spins, to avoid the undesirable gap closing at finite $k_z$</p><h1 id="Dirac-surface-states"><a href="#Dirac-surface-states" class="headerlink" title="Dirac surface states"></a>Dirac surface states</h1><p>What is the dispersion of the surface state of the $3D$ topological insulator?</p><p>We know that if we fix one momentum (say $k_x$) to zero, the Hamiltonian of the remaining system is that of a quantum spin Hall insulator. For this system we know that the Hamiltonian of the edge states is just that of a pair of counter-propagating modes, so</p><p>$$H = v \sigma_y k_y.$$</p><p>Here, the matrix $\sigma_y$ acts on the degrees of freedom of these two surface modes, and doesn’t correspond to particle spin.</p><p>Since time-reversal symmetry changes the sign of $k_y$, it must also change the sign of $\sigma_y$, so the time-reversal operator must be $\mathcal{T} = i \sigma_y K$.</p><p>What if we consider a nonzero $k_x$? Generically, the two modes are then coupled by an extra term in the Hamiltonian. This term should be proportional to $k_x$, and since it couples the modes it must also include a Pauli matrix, which we can just choose to be $\sigma_x$.</p><p>So if the surface of the topological insulator is isotropic, its Hamiltonian is merely</p><p>$$H=v \mathbf{\sigma} \cdot \mathbf{k}.$$</p><p>Let’s have a quick look at it to get a more concrete understanding:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1.5</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=<span class="literal">None</span>, Bz=<span class="number">0</span>)</span><br><span class="line">syst = bhz(Z=<span class="number">5</span>, system_type=<span class="string">&quot;slab&quot;</span>)</span><br><span class="line">k = np.linspace(-np.pi, np.pi)</span><br><span class="line">Ms = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;</span><br><span class="line">        p.M: spectrum(syst, p, k_x=k, k_y=k, k_z=<span class="number">0</span>, title=title, num_bands=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms</span><br><span class="line">    &#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$M$&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>What you see here is the dispersion of the two lowest energy bands of a thin slice of a 3D BHZ model.</p><p>The system is topological when $M&lt;0$. As expected, the lowest energy state then has a Dirac dispersion, and surface states are formed.</p><p>The distinguishing feature of the strong topological insulator is that it has an odd number of Dirac cones in total.<br>In fact, the reason why it is called “strong” is also the reason why an odd number of Dirac cones is special.</p><p>To see what is unique, let us add an infinitesimal magnetic field and compute the Chern number of the surface state. We know that the number of Dirac cones is odd. From our study of Chern insulators, we know that the <em>change</em> in the Chern number between $B = -\varepsilon$ and $B = +\varepsilon$ is just the number of the Dirac cones. This is because we open a gap at each of them.</p><p>Since the Chern number is odd under time reversal, we come to a paradoxical conclusion: if we break time reversal, we end up with a half-integer Hall conductance $\sigma_{xy} = e^2/h (n + 1/2)$ on a surface of a topological insulator.</p><p>This is of course not possible in any purely 2D system, since the Hall conductance must be an integer, and therefore the surface state of a strong topological insulator cannot be created without the topological bulk.</p><blockquote><p>The statement that it is impossible to have a tight-binding Hamiltonian with time-reversal symmetry and a single Dirac cone is known as the “fermion doubling theorem”. There are several tricks that one can perform to work around this limitation in a numerical simulation, but we won’t cover them in the course.</p></blockquote><h1 id="Weak-invariants"><a href="#Weak-invariants" class="headerlink" title="Weak invariants"></a>Weak invariants</h1><p>Now that we understand what is special about the strong invariant, let’s deal with the weak invariants.</p><p>From their definition, we know that the weak invariants don’t change the parity of the number of Dirac cones on any surface.<br>Furthermore, there is a very good reason why the weak invariants are called ‘weak’. Imagine we keep the Hamiltonian the same, but instead we double the unit cell in each direction. This folds the Brillouin zone onto itself such that $k=\pi$ is mapped to $k=0$. This doesn’t impact the strong invariant, but all the weak invariants become 0.</p><p>As a final illustration of the relation between weak and strong invariants, let’s see how the invariants change as a function of $M$ as we vary $M$ on a scale comparable with the band width.</p><p>We determine the topological invariant in the same way as for QSHE: we see if the phase of the reflection matrix connects the Pfaffians of $r(k_y=0)$ and $r(k_y=\pi)$.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">0.2</span>, C=<span class="number">0</span>, D1=<span class="number">0.1</span>, D2=<span class="number">0</span>, M=<span class="literal">None</span>, Bz=<span class="number">0</span>)</span><br><span class="line">syst = bhz(Z=<span class="number">15</span>, system_type=<span class="string">&quot;slab&quot;</span>)</span><br><span class="line">fsyst = make_scatter_sys()</span><br><span class="line">k = np.linspace(-np.pi, np.pi)</span><br><span class="line">Ms = np.linspace(-<span class="number">2.75</span>, <span class="number">0.75</span>, <span class="number">11</span>)</span><br><span class="line">hm1 = holoviews.HoloMap(</span><br><span class="line">    &#123;</span><br><span class="line">        p.M: spectrum(syst, p, k_x=k, k_y=k, k_z=<span class="number">0</span>, title=title, num_bands=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms</span><br><span class="line">    &#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$M$&quot;</span>],</span><br><span class="line">)</span><br><span class="line">hm2 = holoviews.HoloMap(</span><br><span class="line">    &#123;p.M: scattering_det_pfaff(fsyst, p) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>]</span><br><span class="line">)</span><br><span class="line">hm1 + hm2</span><br></pre></td></tr></table></figure><p>We see the values of the invariants change several times:</p><ul><li>Initially, when $M&gt;0$, the system is trivial.</li><li>Then, as $M$ is lowered, the topological invariants become $\mathcal{Q}(k_x=0) = 1$ and $\mathcal{Q}(k_x=\pi) = 0$, and there’s a Dirac cone at $k=0$.</li><li>When $M$ is lowered further, two new Dirac cones appear at $k = (0,\pi)$ and $k = (\pi, 0)$. This changes the invariants to $\mathcal{Q}(k_x=0) = 0$ and $\mathcal{Q}(k_x=\pi) = 1$.</li><li>Finally one more Dirac cone appears at $k = (\pi, \pi)$, accompanied by both invariants becoming trivial.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;Suppose you have a $(0;100)$ weak topological insulator. Which one of the following statements is correct?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;There is an even number of Dirac cones for both $k_x=0$ and $k_x=\pi$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There is an even number of Dirac cones for $k_x=0$ and an odd one for $k_x=\pi$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There is an odd number of Dirac cones for $k_x=0$ and an even one for $k_x=\pi$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There is an odd number of Dirac cones for both $k_x=0$ and $k_x=\pi$.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;We know that the strong invariant $Q(k_x=0)Q(k_x=\pi)=0$, so there must be an even number of Dirac cones in total. &quot;</span></span><br><span class="line">    <span class="string">&quot;The number at $k_x=\pi$ is odd because $Q(k_x=\pi)=1$, so the number at $k_x=0$ must also be odd.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Quantum-Hall-conductance-and-the-magneto-electric-effect"><a href="#Quantum-Hall-conductance-and-the-magneto-electric-effect" class="headerlink" title="Quantum Hall conductance and the magneto-electric effect"></a>Quantum Hall conductance and the magneto-electric effect</h1><p>So, what happens if we measure the Hall conductance of a 3D topological insulator? Will we actually obtain a half-integer? If you followed the course closely, you will know that the answer is negative, and that the Hall conductance is always quantized to an integer. So what is going on when we measure the Hall conductance?</p><p>To answer this question we need to remember that we cannot just consider one surface on its own. Each surface is connected to the sides and other surfaces. Let’s consider a part of a 3D TI in magnetic field:</p><p><img src="/2021/01/07/src/w6_3dti/bhz/3d_ti_slab.svg" alt></p><p>The top surface has the quantum Hall conductance $(n + 1/2)e^2/h$, but it is not the only part of the material. The bottom surface is also subject to a magnetic field and hence contributes a half-integer Hall conductance as well.</p><p>In total we thus get $\sigma_{xy} = (2n + 1) e^2/h$: an integer, which resolves the apparent paradox. While this statement sounds relatively simple, there are entire papers dedicated to the question whether it’s possible to measure a half-integer Hall conductance (the answer is ‘not really’).</p><p>Finally, let’s look at the dispersion of the Landau levels and edge states:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%output size=<span class="number">150</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=-<span class="number">1</span>, Bz=<span class="number">0.125</span>)</span><br><span class="line">lead = bhz(Y=<span class="number">20</span>, Z=<span class="number">10</span>, system_type=<span class="string">&quot;lead&quot;</span>)</span><br><span class="line">k = np.linspace(-<span class="number">3.5</span>, <span class="number">1.5</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.8</span>, <span class="number">0.8</span>], <span class="string">&quot;yticks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">spectrum(lead, p, k_x=k, **kwargs)</span><br></pre></td></tr></table></figure><p>We see that the Landau levels come in pairs. In each such pair, one level comes from the top surface, and one from the bottom surface. The magnetic field is parallel to the side surfaces, so there is no gap there. The edge states propagate freely along the side surfaces and are reflected by the magnetic field as they try to enter either the top or the bottom surfaces.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Suppose that you take the 3D TI slab above, and connect the left and right surfaces, making it into &quot;</span></span><br><span class="line">    <span class="string">&quot;a very thick Corbino disk. &quot;</span></span><br><span class="line">    <span class="string">&quot;You then apply to it a strong perpendicular field in the same direction as in the figure, perpendicular to the top &quot;</span></span><br><span class="line">    <span class="string">&quot;and bottom surfaces. &quot;</span></span><br><span class="line">    <span class="string">&quot;What happens if you throw an additional flux quantum through the inner hole of the disk?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;A half-integer number of electron charges is transferred from the inner to the outer surface of the disk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;An integer number of electron charges is transferred from the inner to the outer surface of the disk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;An integer number of charges is transferred from the top to the bottom surface of the disk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The bulk gap closes.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The top and bottom surfaces combined form an integer quantum Hall state. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence the whole system acts like a Laughlin pump, exactly like in the purely 2D case.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Conclusion-integers-half-integers-and-two-types-of-electromagnetic-response"><a href="#Conclusion-integers-half-integers-and-two-types-of-electromagnetic-response" class="headerlink" title="Conclusion: integers, half-integers, and two types of electromagnetic response"></a>Conclusion: integers, half-integers, and two types of electromagnetic response</h1><p>Before we move on to the next lecture, Joel Moore will tell us more about the origins of the peculiar electromagnetic response of topological insulators, and a fascinating connection to high energy physics.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;s7H6oLighOM&quot;</span>, src_location=<span class="string">&quot;6.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;3DTI invariants&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w6_3dti/3dti_signatures/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w6_3dti/3dti_signatures/</id>
    <published>2021-01-07T09:11:06.855Z</published>
    <updated>2021-01-07T09:11:06.855Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> sla</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">&quot;ignore&quot;</span>, UserWarning)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">L, W, H, system_type</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A cuboid region of BHZ material with two leads attached.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    parameters for leads and scattering region can be defined separately</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Onsite and hoppings matrices used for building BHZ model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * pauli.s0s0 + (</span><br><span class="line">            p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2</span><br><span class="line">        ) * pauli.s0sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sxsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sysx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * pauli.s0s0 - p.B1 * pauli.s0sz + p.A1 * <span class="number">0.5j</span> * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_lead</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; H) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_syst</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; H) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= x &lt; L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx_phase</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1, z1 = site1.pos</span><br><span class="line">        x2, y2, z2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">&quot;sys&quot;</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line">        syst[lat.shape(shape_syst, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_scat * np.eye(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">&quot;lead&quot;</span>:</span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        syst = kwant.Builder(sym)</span><br><span class="line">        syst[lat.shape(shape_lead, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">&quot;infinite&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx_phase</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_scatter</span>(<span class="params">L, W, H</span>):</span></span><br><span class="line">    syst = bhz(L, W, H, <span class="string">&quot;sys&quot;</span>)</span><br><span class="line">    lead = bhz(L, W, H, <span class="string">&quot;lead&quot;</span>)</span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cond_mu</span>(<span class="params">p, L, W, H</span>):</span></span><br><span class="line">    p.mu_lead = <span class="number">0.7</span></span><br><span class="line">    syst = bhz_scatter(L, W, H)</span><br><span class="line">    sys_leads_fixed = syst.finalized().precalculate(energy=<span class="number">0</span>, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    mus = np.linspace(-<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">40</span>)</span><br><span class="line">    cond = [</span><br><span class="line">        kwant.smatrix(</span><br><span class="line">            sys_leads_fixed, energy=<span class="number">0</span>, params=<span class="built_in">dict</span>(p=p.update(mu_scat=mu))</span><br><span class="line">        ).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> mu <span class="keyword">in</span> mus</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> np.array(cond), mus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_cond_mu</span>(<span class="params">cond, mus</span>):</span></span><br><span class="line">    xdim, ydim = [<span class="string">r&quot;$\mu$&quot;</span>, <span class="string">r&quot;$G\,[e^2/h]$&quot;</span>]</span><br><span class="line">    kwargs = &#123;<span class="string">&quot;kdims&quot;</span>: [xdim, ydim]&#125;</span><br><span class="line">    plot = holoviews.Path((mus, cond), **kwargs).opts(</span><br><span class="line">        plot=&#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">3</span>, <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;, style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;xdim: (-<span class="number">0.4</span>, <span class="number">0.4</span>), ydim: (<span class="number">0</span>, <span class="number">8</span>)&#125;).relabel(<span class="string">&quot;Conductance&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_bands</span>(<span class="params">p, L, W, H</span>):</span></span><br><span class="line">    lead = bhz(L, W, H, <span class="string">&quot;lead&quot;</span>)</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">101</span>),</span><br><span class="line">        <span class="string">&quot;ylims&quot;</span>: [-<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        <span class="string">&quot;yticks&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;xticks&quot;</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r&quot;$-\pi/3$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>), (np.pi / <span class="number">3</span>, <span class="string">r&quot;$\pi/3$&quot;</span>)],</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu_lead = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> spectrum(lead, p, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_cond_spect</span>(<span class="params">mu, cond_plot, bands_plot</span>):</span></span><br><span class="line">    <span class="keyword">return</span> cond_plot * holoviews.VLine(mu).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    ) + bands_plot.relabel(<span class="string">&quot;Spectrum&quot;</span>) * holoviews.HLine(mu).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_warping</span>(<span class="params">A=<span class="number">1.2</span>, B=<span class="number">1.8</span>, C=<span class="number">1.5</span>, Kmax=<span class="number">1.0</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate_on_grid</span>(<span class="params">X, Y, func</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; X, Y should be in np.meshgrid form. It&#x27;s enough for func to work on floats. &quot;&quot;&quot;</span></span><br><span class="line">        data = []</span><br><span class="line">        <span class="keyword">for</span> xx, yy <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y):</span><br><span class="line">            data.append([func(i, j) <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(xx, yy)])</span><br><span class="line">        data = np.array(data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_energy_function</span>(<span class="params">A, B, C</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Used for plotting of hexagonal warping. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">kx, ky</span>):</span></span><br><span class="line">            matrix = (</span><br><span class="line">                A * (kx ** <span class="number">2</span> + ky ** <span class="number">2</span>) * pauli.s0</span><br><span class="line">                + B * (kx * pauli.sy - ky * pauli.sx)</span><br><span class="line">                + C * <span class="number">0.5</span> * ((kx + <span class="number">1j</span> * ky) ** <span class="number">3</span> + (kx - <span class="number">1j</span> * ky) ** <span class="number">3</span>) * pauli.sz</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> sla.eigh(matrix)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">    zmin, zmax = -<span class="number">1.0</span>, <span class="number">3.5</span></span><br><span class="line">    xylims = (-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    zlims = (-<span class="number">1.0</span>, <span class="number">3.5</span>)</span><br><span class="line">    kdims = [<span class="string">r&quot;$k_x$&quot;</span>, <span class="string">r&quot;$k_y$&quot;</span>]</span><br><span class="line">    vdims = [<span class="string">r&quot;E&quot;</span>]</span><br><span class="line">    <span class="comment"># Generate a circular mesh</span></span><br><span class="line">    N = <span class="number">100</span></span><br><span class="line">    r = np.linspace(<span class="number">0</span>, Kmax, N)</span><br><span class="line">    p = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, N)</span><br><span class="line">    r, p = np.meshgrid(r, p)</span><br><span class="line">    x, y = r * np.cos(p), r * np.sin(p)</span><br><span class="line">    energies = evaluate_on_grid(x, y, func=get_energy_function(A, B, C))</span><br><span class="line"></span><br><span class="line">    xy_ticks = [-<span class="number">1.2</span>, <span class="number">0</span>, <span class="number">1.2</span>]</span><br><span class="line">    zticks = [-<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">    style = &#123;<span class="string">&quot;xticks&quot;</span>: xy_ticks, <span class="string">&quot;yticks&quot;</span>: xy_ticks, <span class="string">&quot;zticks&quot;</span>: zticks&#125;</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">&quot;extents&quot;</span>: (xylims[<span class="number">0</span>], xylims[<span class="number">0</span>], zlims[<span class="number">0</span>], xylims[<span class="number">1</span>], xylims[<span class="number">1</span>], zlims[<span class="number">1</span>]),</span><br><span class="line">        <span class="string">&quot;kdims&quot;</span>: kdims,</span><br><span class="line">        <span class="string">&quot;vdims&quot;</span>: vdims,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hex_cmap colormap is defined below.</span></span><br><span class="line">    plot = holoviews.Overlay(</span><br><span class="line">        [</span><br><span class="line">            holoviews.TriSurface(</span><br><span class="line">                (x.flat, y.flat, energies[:, :, i].flat), **kwargs</span><br><span class="line">            ).opts(style=<span class="built_in">dict</span>(cmap=hex_cmap, linewidth=<span class="number">0</span>), plot=style)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(energies.shape[-<span class="number">1</span>])</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=&#123;<span class="string">&quot;Overlay&quot;</span>: &#123;<span class="string">&quot;fig_size&quot;</span>: <span class="number">350</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom colormap for the hexagonal warping plot</span></span><br><span class="line">cmap_list = [</span><br><span class="line">    ((value + <span class="number">1</span>) / <span class="number">4.0</span>, colour)</span><br><span class="line">    <span class="keyword">for</span> value, colour <span class="keyword">in</span> <span class="built_in">zip</span>([-<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">3.0</span>], [<span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;White&quot;</span>, <span class="string">&quot;Red&quot;</span>])</span><br><span class="line">]</span><br><span class="line">hex_cmap = matplotlib.colors.LinearSegmentedColormap.from_list(<span class="string">&quot;custom&quot;</span>, cmap_list)</span><br></pre></td></tr></table></figure><h1 id="Introduction-searching-the-periodic-table-for-topological-materials"><a href="#Introduction-searching-the-periodic-table-for-topological-materials" class="headerlink" title="Introduction: searching the periodic table for topological materials"></a>Introduction: searching the periodic table for topological materials</h1><p>How do we find a topological insulator? In the first video of today, David Vanderbilt from Rutgers University will tell us more about the material science aspects of topological insulators research.</p><p>This is an expertise that no one from the course team has, so pay close attention to it: this material stands apart from the rest.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;62ZObitJ4DM&quot;</span>, src_location=<span class="string">&quot;6.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure><p>In the rest of the lecture, we will instead discuss the experimental signatures of 3D topological insulators, similarly to what we did in the previous week for their 2D counterparts.</p><p>All the figures showing the experimental data are copyright of the Zahid Hasan lab, Princeton, 2015. They are available under CC-BY-NC-SA 4.0 International license.</p><h1 id="Conductance-of-a-3D-topological-insulator"><a href="#Conductance-of-a-3D-topological-insulator" class="headerlink" title="Conductance of a 3D topological insulator"></a>Conductance of a 3D topological insulator</h1><p>Both the quantum Hall and quantum spin Hall states have striking conductance quantization properties, thanks to the presence of perfectly transmitting one-dimensional transport channels.</p><p>The 3D topological insulators do not posses similar striking conductance properties. In a slab geometry, the surface states contribute with a finite density of propagating states. This density has a minimum at the Dirac point. The conductance increases roughly with a hyperbolic shape if the chemical potential is tuned away from the Dirac point as shown in the plot below:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=-<span class="number">1</span>, Bz=<span class="number">0</span>, mu_scat=<span class="number">0</span>)</span><br><span class="line">L, W, H = <span class="number">10</span>, <span class="number">30</span>, <span class="number">6</span></span><br><span class="line">cond, mus = cond_mu(p, L, W, H)</span><br><span class="line">cond_plot = plot_cond_mu(cond, mus)</span><br><span class="line">bands_plot = plot_bands(p, L, W, H)</span><br><span class="line">mus = np.linspace(-<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;mu: plot_cond_spect(mu, cond_plot, bands_plot) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>]</span><br><span class="line">).collate()</span><br></pre></td></tr></table></figure><p>It is also the behavior that is observed experimentally. In the figure below, you see that the resistance of a 3D TI slab reaches a maximum and then decreases as the chemical potential difference between its top and bottom surfaces is varied.</p><p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/zero_field_Rxx.png" alt></p><p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p><p>Note that in such a measurement, you cannot separate contributions of states coming from the different surfaces, or potentially also from the sides or the sample, or even from the bulk - we’ll discuss this issue soon in more detail.</p><p>Nevertheless, the observed maximum in resistance corresponds to the minimum in conductance computed just above, and it demonstrates the presence of a Dirac point between the conduction and valence bands.</p><p>This behavior discussed above is not very striking. For instance, the same behavior is observed in graphene. The conductance is not sensitive to degeneracies in the electron spectrum in a qualitative way, so just from it, we cannot demonstrate that the surface of a 3D TI has a single Dirac cone, unlike graphene which has four. Hence, while the measurement above is a signature of a surface state, it is not a particularly striking one.</p><p>Perhaps we will be more lucky with topological signatures of 3D topological insulators, if we look at the Hall conductance?</p><h1 id="Landau-levels"><a href="#Landau-levels" class="headerlink" title="Landau levels"></a>Landau levels</h1><p>In last chapter, we saw that one single surface of a 3D topological insulator is characterized by a Hall conductance of $ (n+1/2), e^2/h$. We also pointed out that there are always two surfaces, say the top and bottom one of a slab, which gives a total Hall conductance of $(2n+1),e^2/h$ and makes it hard to observe the half-integer Hall conductance.</p><p>You may say - OK, we can live with this and be happy with our $(2n+1)$ sequence. After all, it looks almost as unique as the $(n+1/2)$ sequence. Sure, it does not allow us to see directly the half-integer value, but it gives a step between plateaus which is twice the usual one, and no plateau with $n=0$. After all, measuring <em>twice</em> that sequence was a good enough probe for graphene.</p><p>So let’s look at a Hall conductance measurements performed on a slab of a 3D TI, focusing for instance on the blue trace.</p><p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/LL_spectroscopy.png" alt></p><p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p><p>You see a sequence of plateaus with integer steps of a normal height $e^2/h$. Nothing special. Why did our prediction of a $(2n+1)$ sequence fail?</p><p>The reason is that there is no symmetry at all between top and bottom surfaces, they are really independent. For instance, they might have different doping, and hence be characterized by different values $n_\textrm{top}$ and $n_\textrm{bottom}$ of the Chern integer.</p><p>Therefore, rather than observing a sequence $e^2/h,(2n+1)$, we observe a more conventional sequence given by $e^2/h,(n_\textrm{top}+n_\textrm{bottom}+1)$, with the usual $e^2/h$ steps between different plateaus.</p><p>So, even by studying the Landau levels experimentally, we do not get a topological signature. But do not despair, luckily there is a much better thing that we can do rather than just measuring conductance: looking at the energy spectrum of the surface states directly.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;Which control parameter can remove the 0th plateau in the QHE measurement? &quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Increasing the magnetic field.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gate voltage difference (which controls difference in electron density) between the surfaces.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Increasing topological mass.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Adding an in-plane magnetic field.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Gate voltage difference changes the filling of the individual states without shifting the total density of electrons. &quot;</span></span><br><span class="line">    <span class="string">&quot;This can therefore shift the plateaus of each surface. Magnetic field and topological mass are part of generating the &quot;</span></span><br><span class="line">    <span class="string">&quot; $0^&#123;th&#125;$ plateau to begin with so cannot eliminate it. &quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Spectroscopy-of-the-surface-of-a-3D-topological-insulator"><a href="#Spectroscopy-of-the-surface-of-a-3D-topological-insulator" class="headerlink" title="Spectroscopy of the surface of a 3D topological insulator"></a>Spectroscopy of the surface of a 3D topological insulator</h1><p>Amazingly, the surface states of a 3D topological insulator can be directly imaged experimentally using the technique of Angle Resolved Photo Emission Spectroscopy - or, in short, <a href="http://en.wikipedia.org/wiki/Angle-resolved_photoemission_spectroscopy">ARPES</a>.</p><p>In ARPES, X-ray photons are shot vertically into a metal surface in order to eject electrons out of it. Due to energy and momentum conservation, the emitted electrons have the same momentum (parallel to the surface) that they had in the crystal, and an energy which is related to their band energy in the crystal. Hence, ARPES is the ideal tool to measure the energy dispersion of the surface states of a solid, i.e. $E(k_x, k_y)$ as a function of momenta $\hbar k_x$ and $\hbar k_y$.</p><p>Below, we see an example of ARPES spectra for the surface states of a strong topological insulator Bi$_2$ Se$_3$:</p><p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/arpes_fig1.png" alt></p><p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p><p>ARPES can only eject electrons - so only occupied states below the Fermi level are visible in the experiment, but of course one can still map out the Fermi surface at different energies by changing the chemical potential in the crystal. In the ARPES results above we see the results for different dopings of the crystal.</p><p>In the top panel of the figure above, we see that by changing the chemical potential, the Fermi surface shrinks from a circle to a point, exactly what you would expect for electrons with a Dirac-like dispersion.</p><p>While the top panels shows where the occupied states lie in the $(k_x, k_y)$ plane, in the second and third rows we see a cross-section of the energy as a function of momentum, where the Dirac cone is clearly visible, emerging from a bulk valence band filled with electrons.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;Why do you think ARPES observes surface states even if there is conductance through the bulk?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;ARPES can only observe occupied states and therefore bulk conductance is not an issue. &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since ARPES measures the spectrum in a momentum resolved way, it can separate out surface and bulk states.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ARPES does not measure conductance and therefore bulk electronic states are not an issue.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since ARPES measures the spectrum in an energy resolved way, it can selectively choose the surface states in the bulk gap.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The surface states live within the energy gap of the bulk. Since ARPES directly measure $E(k)$, it separates out &quot;</span></span><br><span class="line">    <span class="string">&quot;surface states from bulk states, which are in different energy ranges. &quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Quasiparticle-interference-QPI"><a href="#Quasiparticle-interference-QPI" class="headerlink" title="Quasiparticle interference (QPI)"></a>Quasiparticle interference (QPI)</h1><p>Scanning tunneling microscopy (STM) is another tool to image surface states in a topological insulator. In the process of STM we tunnel electrons into the surface from a metallic tip. In contrast to ARPES, the electrons are not going into free space, so we don’t have momentum resolution. On the other hand, we do trade momentum resolution for nearly atomic spatial resolution. We know where exactly on the surface the electron came from.</p><p>Tunneling into a uniform surface can tell us a little bit about which orbital on an atom, the electrons at a certain energy come from. Otherwise, we’d see a uniform surface, which wouldn’t have much information.  We can make things more interesting and, strangely enough, get more information by sprinkling some impurities on the surface. The impurities scatter the surface electrons and produce a standing wave pattern on the surface, which depends on the Fermi surface momenta of the electrons at the particular tunneling energy (Note: in this unit we refer to the equal energy surface in momentum space at the tunneling energy as Fermi surface for convenience). The resulting pattern is referred to QPI. Specifically, Fourier transforming the QPI pattern directly maps out the momentum transfer across the Fermi-surface of the surface state.</p><p>Clearly, we can expect to map out some properties of the momentum space scattering on the surface of the topological insulator.</p><p>In the simulation below. we see that the Fourier transform shows an interesting pattern:</p><p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/QPI_pic_adapted.png" alt><br>(adapted, copyright Hasan lab, Princeton, see license in the beginning of the chapter)  </p><p>By comparing the QPI patterns showing spin-dependent and spin-independent scattering (respectively on the left and right column on the right side of the arrow), we see that the intensity at momenta connecting opposite points on the Fermi surface is suppressed in the case of spin-independent scattering.</p><p>In fact, by comparing the fourier transform of the QPI on the right with the Fermi surface on the left, we begin to see that the absence of back-scattering, which is one of the key properties of the topological insulator surface state plays a key role. As you might remember from the quantum spin hall systems - elastic backscattering of electrons is forbidden between states at $\bf k$ and $-\bf k$ because of Kramers’ theorem. Looking at the QPI pattern from spin-independent impurities and comparing it with the Fermi surface confirms this.</p><h1 id="The-issue-of-bulk-conductivity"><a href="#The-issue-of-bulk-conductivity" class="headerlink" title="The issue of bulk conductivity"></a>The issue of bulk conductivity</h1><p>One of the central issues that has plagued the experimental progress with topological insulators is the presence of bulk doping or conductance in most naturally grown crystals. You can see this simply by looking at the ARPES plots below:</p><p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/bulk_conductance_TI.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p><p>What you see is that the Fermi-energy, which is the highest energy till which you can eject electrons in ARPES intersects the conduction band. This means that in the native state the conduction band of the electrons is occupied and the fermi level is not in the gap. In the figure above, the situation is worst for pure Antimony in the extreme left panel, which is really a semimetal with overlapping electron and hole bands. In this case, independent of fermi level position, the system would remain metallic. Moving from pure Sb to $Bi_2 Se_3$ improves this somewhat, but still does not make this an insulator. Theoretically, we do expect pure $Bi_2 Se_3$ to be an insulator - but in reality, the system typically have Se vacancies, which make it metallic.</p><p>Being metallic really ruins a lot of interesting properties of the topological insulators. So a lot of effort is going in to fixing it up. Below, we see some of the results from these attempts:</p><p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/insulating_TI.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p><p>where various combinations of $Bi$, $Se$ and $Te$ have been combined to drive the system insulating. By looking at the ARPES spectra, it should look convincing that by varying different conditions, the fermi level is indeed shifting in to the interior of the gap. The experimental tricks used to get this working range between changing the pressure of various elements in the growth condition to counter doping the surface etc.  But the resistance results seem to be improving quite a bit.</p><h1 id="Hexagonal-warping"><a href="#Hexagonal-warping" class="headerlink" title="Hexagonal warping"></a>Hexagonal warping</h1><p>ARPES measurements on the surface of topological materials in the bismuth family also demonstrated an interesting (even though non-topological) feature of the surface states.</p><p>The effective Dirac Hamiltonian is linear in momentum and has a full rotational symmetry in the $(x,y)$ plane of the surface, making the Fermi surface circular. However, moving away in energy from the Dirac point, experimentalists observed a different shape of the Fermi surface, similar to a snowflake:</p><p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/warping.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p><p>It’s clear that this shape cannot be explained by the Dirac Hamiltonian with its rotational invariance. In order to take into account this deformation of the Fermi surface, we have to think about the crystal symmetries of the surface. In BiSe and BiTe compounds, there is no full rotational symmetry, but only a lower three-fold rotation symmetry. We can take into account this effect by adding a correction to the effective Dirac Hamiltonian.</p><p>This is exactly what was done in this article:</p><ul><li>arXiv:0908.1418</li></ul><p>There Liang Fu made a relatively simple theoretical exercise. He listed all the terms in the Hamiltonian allowed by time-reversal and crystalline symmetries, that are proportional to $k^3.$ This is the result:</p><p>$$<br>H(\mathbf{k}) = E_0(k) + v, (1+\alpha \mathbf{k}^2),(k_x\sigma_y - k_y\sigma_x) + \frac{\lambda}{2},(k^3_++k^3_-),\sigma_z.<br>$$</p><p>You see a correction to the Dirac velocity proportional to $\alpha \mathbf{k}^2$, which doesn’t break the rotational symmetry, as well as the term with $\lambda$, which is responsible for the warping.</p><p>Let’s plot the spectrum of this extended effective Hamiltonian:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line"></span><br><span class="line">plot_warping()</span><br></pre></td></tr></table></figure><p>This Hamiltonian reproduces correctly the <em>hexagonal warping</em> of the Fermi surface. In particular, independently of the parameters $\lambda$ and $\alpha$, the vertices of the hexagon are always aligned with the $x$ crystal axis, as is observed experimentally.</p><p>In addition to modifying the shape of the Fermi surface, we see that the extra term is proportional to $\sigma_z$, and rotates the spin of the surface state out of plane. This strongly affects the scattering properties of the surface state.</p><h1 id="Outlook-from-basic-science-to-potential-applications"><a href="#Outlook-from-basic-science-to-potential-applications" class="headerlink" title="Outlook: from basic science to potential applications"></a>Outlook: from basic science to potential applications</h1><p>David Vanderbilt will conclude this week’s lectures by offering a perspective on the future of the field.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;WZmNeEwM1N4&quot;</span>, src_location=<span class="string">&quot;6.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;3DTI materials and signatures&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w5_qshe/w5_assignments/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w5_qshe/w5_assignments/</id>
    <published>2021-01-07T09:11:06.853Z</published>
    <updated>2021-01-07T09:11:06.853Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure><h1 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h1><p>As usual, start by grabbing the notebooks of this week (<code>w5_qshe</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p><h3 id="Kane-Mele-model"><a href="#Kane-Mele-model" class="headerlink" title="Kane-Mele model"></a>Kane-Mele model</h3><p>The first known implementation of quantum spin Hall effect is the Kane-Mele model, introduced in <a href="http://arxiv.org/abs/cond-mat/0411737">this paper</a>. It is a doubled copy of the Haldane model (get that one from the previous week’s notebooks), with spin up and spin down having next-nearest neighbor hoppings complex conjugate of each other due to spin-orbit coupling.</p><p>Implement the Kane-Mele model and add a staggered onsite potential to also be able to create a trivial gap. Calculate the scattering matrix topological invariant of that model.</p><p>How would you add disorder and calculate the topological invariant? (Hint: you need to add disorder to the scattering region, and make leads on both sides conducting)</p><h3 id="Quantum-Hall-regime"><a href="#Quantum-Hall-regime" class="headerlink" title="Quantum Hall regime"></a>Quantum Hall regime</h3><p>The helical edge states of quantum spin Hall effect survive for some time when a magnetic field is added. Make a Hall bar out of the BHZ model. Can you reproduce the experimental results? What do you see? Are the inversion symmetry breaking terms important?</p><p>What about conductance in a two terminal geometry: can you see the crossover from quantum spin Hall regime to quantum Hall regime?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Now share your results:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Quantum spin Hall effect&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1306-1925"><a href="#arXiv-1306-1925" class="headerlink" title="arXiv:1306.1925"></a>arXiv:1306.1925</h3><p><strong>Hint:</strong> A better material?</p><h3 id="arXiv-0808-1723"><a href="#arXiv-0808-1723" class="headerlink" title="arXiv:0808.1723"></a>arXiv:0808.1723</h3><p><strong>Hint:</strong> What happens when edge states meet.</p><h3 id="arXiv-1104-3282"><a href="#arXiv-1104-3282" class="headerlink" title="arXiv:1104.3282"></a>arXiv:1104.3282</h3><p><strong>Hint:</strong> A completely different approach.</p><h3 id="arXiv-1312-2559"><a href="#arXiv-1312-2559" class="headerlink" title="arXiv:1312.2559"></a>arXiv:1312.2559</h3><p><strong>Hint:</strong> Adding superconductors.</p><h3 id="arXiv-1303-1766"><a href="#arXiv-1303-1766" class="headerlink" title="arXiv:1303.1766"></a>arXiv:1303.1766</h3><p><strong>Hint:</strong> Sources of back-scattering in QSHE edge.</p><h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Quantum spin Hall effect&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w5_qshe/qshe_experiments/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w5_qshe/qshe_experiments/</id>
    <published>2021-01-07T09:11:06.853Z</published>
    <updated>2021-01-07T09:11:06.853Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">&quot;ignore&quot;</span>, UserWarning)</span><br><span class="line"></span><br><span class="line">bhz_parameters = &#123;</span><br><span class="line">    <span class="string">&quot;topo&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">0.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;topo2&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;triv&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: -<span class="number">0.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;lead&quot;</span>: &#123;<span class="string">&quot;A_lead&quot;</span>: <span class="number">1.5</span>, <span class="string">&quot;B_lead&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D_lead&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M_lead&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hopping functions for the BHZ model.</span></span><br><span class="line"><span class="comment"># Sometimes, we use different BHZ parameters in the</span></span><br><span class="line"><span class="comment"># scattering region and leads, so we treat them</span></span><br><span class="line"><span class="comment"># separately.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_onsite</span>(<span class="params">site, p, is_lead=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        B, D, M = p.B_lead, p.D_lead, p.M_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        B, D, M = p.B, p.D, p.M</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (M - <span class="number">4</span> * B) * pauli.s0sz</span><br><span class="line">        - <span class="number">4</span> * D * pauli.s0s0</span><br><span class="line">        + p.ez_y * np.kron(pauli.sy, (pauli.s0 + pauli.sz) / <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _onsite(site, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_lead</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _onsite(site, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_hopx</span>(<span class="params">site1, site2, p, is_lead=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        A, B, D = p.A_lead, p.B_lead, p.D_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A, B, D = p.A, p.B, p.D</span><br><span class="line">    <span class="keyword">return</span> B * pauli.s0sz + D * pauli.s0s0 + <span class="number">1j</span> * A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _hopx(site1, site2, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_lead</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _hopx(site1, site2, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_hopy</span>(<span class="params">site1, site2, p, is_lead=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        A, B, D = p.A_lead, p.B_lead, p.D_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A, B, D = p.A, p.B, p.D</span><br><span class="line">    <span class="keyword">return</span> B * pauli.s0sz + D * pauli.s0s0 - <span class="number">1j</span> * A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _hopy(site1, site2, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_lead</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _hopy(site1, site2, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_terminal</span>(<span class="params">L, w</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Make a two terminal system with the BHZ model. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w <span class="keyword">and</span> <span class="number">0</span> &lt;= x &lt; L</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_two_term</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> onsite(site, p) - p.mu * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_two_term_lead</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> onsite_lead(site, p) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Scattering region</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite_two_term</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Leads</span></span><br><span class="line">    lead = kwant.Builder(kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite_two_term_lead</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx_lead</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy_lead</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attach leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">w=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Translationally invariant BHZ system with a infinite or fixed width w.&quot;&quot;&quot;</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    <span class="keyword">if</span> w <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">            (x, y) = pos</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        syst = kwant.Builder(sym)</span><br><span class="line">        syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G_mu_plot</span>(<span class="params">p, mus, color</span>):</span></span><br><span class="line">    syst = two_terminal(<span class="number">40</span>, <span class="number">40</span>).finalized()</span><br><span class="line">    G = [</span><br><span class="line">        kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus</span><br><span class="line">    ]</span><br><span class="line">    ydim = <span class="string">r&quot;G $[e^2/h]$&quot;</span></span><br><span class="line">    kdims = [<span class="string">r&quot;$\mu$&quot;</span>, ydim]</span><br><span class="line">    plot = holoviews.Path((mus, np.array(G)), kdims=kdims, label=<span class="string">&quot;Conductance&quot;</span>)</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [-<span class="number">0.8</span>, -<span class="number">0.4</span>, <span class="number">0</span>, <span class="number">0.4</span>, <span class="number">0.8</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;ydim: (<span class="number">0</span>, <span class="number">10</span>)&#125;).opts(plot=ticks, style=&#123;<span class="string">&quot;color&quot;</span>: color&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G_Ez_plot</span>(<span class="params">p, E_zs</span>):</span></span><br><span class="line">    syst = two_terminal(<span class="number">40</span>, <span class="number">20</span>).finalized()</span><br><span class="line">    G = [</span><br><span class="line">        kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> p.ez_y <span class="keyword">in</span> E_zs</span><br><span class="line">    ]</span><br><span class="line">    ydim = <span class="string">r&quot;G $[e^2/h]$&quot;</span></span><br><span class="line">    kdims = [<span class="string">r&quot;$E_z$&quot;</span>, ydim]</span><br><span class="line">    plot = holoviews.Path((E_zs, np.array(G)), kdims=kdims, label=<span class="string">&quot;Conductance&quot;</span>)</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">0.10</span>, <span class="number">0.15</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>]&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;ydim: (<span class="number">0</span>, <span class="number">2</span>)&#125;).opts(plot=ticks)</span><br></pre></td></tr></table></figure><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;-HRBuCgOUvs&quot;</span>, src_location=<span class="string">&quot;5.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure><p>This topic is special, since in order to meaningfully discuss experimental progress we need to do something we didn’t do before in the course: we will show you the measurements and compare them with the <em>simple</em> theoretical expectations. Like this we will see what agrees and what doesn’t.</p><p>All the figures showing the experiments are copyright Physical Society of Japan (2008), published in <a href="http://journals.jps.jp/doi/abs/10.1143/JPSJ.77.031007"><br>J. Phys. Soc. Jpn. 77, 031007 (2008)</a> by  Markus König, Hartmut Buhmann, Laurens W. Molenkamp, Taylor Hughes, Chao-Xing Liu, Xiao-Liang Qi, and Shou-Cheng Zhang. They are available under CC-BY-NC-SA 4.0 International license.</p><h1 id="Two-limits-Mexican-hat-and-weak-pairing"><a href="#Two-limits-Mexican-hat-and-weak-pairing" class="headerlink" title="Two limits: Mexican hat and weak pairing"></a>Two limits: Mexican hat and weak pairing</h1><p>We just learned that topological insulators with inversion symmetry were simpler to think about. We will now use the  topological invariant to find a simple recipe for finding topological insulators. All we need to do is somehow vary the parity of the occupied states. One fact of nature that comes to our aid in this is that electrons in semiconductors typically occupy even parity $s$-orbitals and odd parity $p$-orbitals.</p><p>If we look up the bandstructure of a typical “non-topological” semiconductor, the highest valence-band is of odd parity and the lowest conduction band is even parity. As one moves down the periodic table to heavier elements with larger spin-orbit coupling the odd parity orbital switches spots with the even parity orbital. This <em>band inversion</em> is the domain where we can hope to find topological insulators.</p><p>Now you might think that all we have to do is go down the periodic table to heavier elements and just pick some material like HgTe (actually used in the creation of QSHE), but that’s not all yet. We still need to make a quantum well out of this semiconductor to make the system two-dimensional. This leads to two dimensional bands derived from the three dimensional band structure.</p><p>By carefully choosing the widths, it is possible to invert the odd and even parity bands. We saw from the last unit, that such a band-inversion leads to a topologically non-trivial value of the parity invariant. Right around the topological transition, the even and odd parity bands are degenerate. Thus, we can follow the discussion in the last unit to derive domain wall states at the edges.</p><p>We can write down the simplest Hamiltonian for an even and an odd parity band in a basis $|e,\sigma\rangle$ and $|o,\sigma\rangle$ in a block form </p><p>$$H({\bf k})=\left(\begin{array}{cc}\epsilon_e({\bf k})&amp;\Delta({\bf k})\\Delta^\dagger({\bf k})&amp;\epsilon_o({\bf k})\end{array}\right),$$</p><p>where $\Delta({\bf k})$ is the $2\times 2$ hybridization matrix. Inversion and time-reversal symmetries imply that $\Delta({\bf k})=-\Delta(-{\bf k})$ is odd under inversion and even under time-reversal.  Here we will focus on one such model, $\Delta({\bf k})=\alpha\sigma_z(k_x+i k_y)$, which we call the Bernevig-Hughes-Zhang model. </p><p>Since the even band is electron-like, we approximate the even-band dispersion $\epsilon_e({\bf k})$<br>as $\epsilon_e({\bf k}) = \delta_e + m_e k^2$, while we take the odd parity dispersion to be $\epsilon_o({\bf k})= \delta_o - m_o k^2$ for simplicity. The band inversion happens when $\delta_e &lt; \delta_o$.</p><p>The spectrum of this Hamiltonian is very similar to that of a Chern insulator (after all we essentially just doubled the degrees of freedom). Just like in most topological systems, the shape of the band structure depends on the relative strength of band inversion and inter-band coupling.</p><p>So below we see a qualitative band structure of one of the QSHE insulators, HgTe/CdTe quantum well, compared with the band structure of InAs/GaSb quantum well.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p_triv = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">0.0</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=-<span class="number">0.1</span>, M=-<span class="number">0.2</span>)</span><br><span class="line">p_topo = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">0.0</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=-<span class="number">0.1</span>, M=<span class="number">1.5</span>)</span><br><span class="line">syst = bhz()</span><br><span class="line">kwargs = &#123;<span class="string">&quot;zticks&quot;</span>: [-<span class="number">8</span>, -<span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>]&#125;</span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p_triv, **kwargs).relabel(<span class="string">&quot;Trivial&quot;</span>)</span><br><span class="line">    + spectrum(syst, p_topo, **kwargs).relabel(<span class="string">&quot;Topological&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>In the last unit, we understood the nature of the edge modes near the topological phase transition, where a doubled Dirac model was appropriate. Deep in the strongly band-inverted topological regime, the bulk band structure has a mexican hat structure with the gap proportional to $\alpha$. </p><p>The edge modes in this regime are quite different in structure from those near the topological transition. To see this, let us first set $k_y=0$ in the Hamiltonian. If we set $\alpha=0$ then there are two fermi points where the dispersion is roughly linear - let us label these points by $\tau_z=\pm 1$. We can describe the edge of the system, by assigning boundary conditions to the $k_x=\pm k_F$ modes in terms of time-reversal invariant phase-shifts. </p><p>The bulk solutions near $k_x\sim\pm k_F$ can be written as $\psi_\pm(x)=e^{-x/\xi}\psi_\pm(0)$. Matching boundary conditions, we find that a zero energy pair of edge solutions exists in the case of inverted bands. These solutions differ from the ones in the Dirac limit by the presence of the oscillating part of the wave function.</p><h1 id="Quantized-conductance-and-length-dependence"><a href="#Quantized-conductance-and-length-dependence" class="headerlink" title="Quantized conductance and length dependence"></a>Quantized conductance and length dependence</h1><p>Unlike in the case of Majoranas, not much thinking is required to figure out the relevant signature of the quantum spin Hall effect. There is a pair of modes on each edge of the sample that is protected from backscattering. All the other modes are gapped or backscattered, so the edge states are the only ones to carry current. This current will not suffer from backscattering.</p><p>If we consider the simplest case, a sample with only two terminals, then Landauer’s formula together with the absence of backscattering gives the conductance $G_0=2 e^2/h$.</p><p>When we move the Fermi level outside of the bulk gap, the bulk becomes conducting, and so the conductance increases.</p><p>We end up with this situation:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">p_topo = SimpleNamespace(</span><br><span class="line">    mu=<span class="literal">None</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">1.5</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=<span class="number">0.0</span>, M=<span class="number">0.2</span>, **bhz_parameters[<span class="string">&quot;lead&quot;</span>]</span><br><span class="line">)</span><br><span class="line">p_triv = SimpleNamespace(</span><br><span class="line">    mu=<span class="literal">None</span>,</span><br><span class="line">    ez_y=<span class="number">0.0</span>,</span><br><span class="line">    mu_lead=<span class="number">1.5</span>,</span><br><span class="line">    A=<span class="number">0.5</span>,</span><br><span class="line">    B=<span class="number">1.0</span>,</span><br><span class="line">    D=<span class="number">0.0</span>,</span><br><span class="line">    M=-<span class="number">0.2</span>,</span><br><span class="line">    **bhz_parameters[<span class="string">&quot;lead&quot;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r&quot;$-\pi/3$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi / <span class="number">3</span>, <span class="string">r&quot;$\pi/3$&quot;</span>)],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">1.5</span>, -<span class="number">1.0</span>, -<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: (-<span class="number">1.5</span>, <span class="number">1.5</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syst = bhz(w=<span class="number">20</span>)</span><br><span class="line">spec_topo = spectrum(syst, p_topo, **kwargs).relabel(<span class="string">&quot;spectrum (topo)&quot;</span>)</span><br><span class="line">spec_triv = spectrum(syst, p_triv, **kwargs).relabel(<span class="string">&quot;spectrum (triv)&quot;</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">50</span>)</span><br><span class="line">HLines = holoviews.HoloMap(&#123;mu: holoviews.HLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br><span class="line">VLines = holoviews.HoloMap(&#123;mu: holoviews.VLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br><span class="line">G_triv = G_mu_plot(p_triv, mus, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">G_topo = G_mu_plot(p_topo, mus, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">(G_triv * (G_topo * VLines) + spec_topo * HLines + spec_triv * HLines)</span><br></pre></td></tr></table></figure><p>Here on the left we see a comparison between the conductances of a trivial (blue curve) and a topological (red curve) insulator as a function of chemical potential. The other two panels show the spectra of a quantum spin Hall insulator in the topological and trivial phases. As we expected, conductance is quantized when the chemical potential is inside the band gap of a topological system.</p><p>Let’s now see what can be measured experimentally.</p><p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig13.png" alt></p><p>(copyright JPS, see license in the beginning of the chapter)</p><p>What you notice is that the maximum resistance for the 4.5 nm thick quantum well is much higher than for the 8 nm thick well. Given that theory predicts that the HgTe quantum wells described by Michael Wimmer in his video are topological when their thickness is between 6.3 nm and 12 nm, this measurement suggests that the lower resistance of the 8 nm thick well might be due to edge conductance. But even though it is the lower of the two, you might complain that the resistance of the 8 nm well is closer to $100$ $k\Omega$ than the predicted $12$ $k\Omega$ from the quantum of conductance.</p><p>The black curve here is the resistance of a trivial insulator, and the red one should be that of a topological one. The resistance of a trivial insulator becomes very high as expected, and there is a plateau-like feature in the topological regime.</p><p>Fortunately, it was revealed in further experiments by the Wurzburg group, that by reducing the length of the sample from length $L=20$ $\mu m$ to $L=1$ $\mu m$, the conductance maximum rises to about $12.9$ $k\Omega$:</p><p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig14.png" alt></p><p>(copyright JPS, see license in the beginning of the chapter)</p><p>We see something different from what we expected: the average resistance value at the plateau is correct, but only within 10% precision, very different from the $10^{-8}$ accuracy of the quantum Hall effect.</p><p>This difference most likely originates from backscattering. In the quantum Hall effect, backscattering is prohibited by the absence of modes going in the other direction. In the quantum spin Hall effect however, the protection is much weaker and is merely due to Kramers theorem.</p><p>The exact origin of the backscattering is hard to understand. It could be inelastic scattering that does not preserve energy, or it could also be some residual magnetic impurities, which break time reversal symmetry. In both cases, Kramers theorem does not hold. One of the papers that we suggest for review proposes an interesting theory for the origin of the backscattering, while another reports measurements of InAs/GaSb quantum well, where conductance seems much better quantized.</p><p>Regardless of the exact origin of backscattering, at any finite temperature, there is an inelastic scattering length $l_\phi$ beyond which we do not expect any protection from scattering. When the edge length $L$ is larger than $l_\phi$, we expect the edge to turn into an incoherent conductor with resistance of $(e^2/h) l_\phi/L$. </p><p>In principle, this allows us to measure $l_\phi$ for the quantum spin hall edges by looking at the length dependence of the conductance. Indeed, experiments find that small samples have conductance close to $G_0$, while in large samples the conductance is suppressed.</p><h1 id="Landau-levels"><a href="#Landau-levels" class="headerlink" title="Landau levels"></a>Landau levels</h1><p>We learned that the key ingredient to obtain an inversion symmetric topological insulator is band inversion - an electron-like band with a positive effective mass and a hole-like band with a negative effective mass are inverted.</p><p>The standard way to distinguish electrons from holes is to measure the sign of the Hall resistance, which is positive for electrons and negative for holes. Hence, we expect to measure a change in the sign of the Hall conductance as we change the position of the Fermi level from being above to being below the band gap.</p><p>In the first plot below, you see traces of the Hall resistance of a quantum spin Hall sample as a function of the applied magnetic field, for several values of the gate voltage, given by different colors. You see that for $V_g=-1$ V the Hall resistance is positive, while for $V_g = -2 V$ the resistance is negative. These are the two black traces. They both exhibit a very well formed $\nu=1$ quantum Hall plateau for high enough fields, and a vanishing Hall resistance for zero magnetic field. This is the standard, expected behavior.</p><p>For some traces between these two values, the resistance shoots up to very high values. This is because the Fermi level is in the middle of the band gap. As expected, we thus observe insulating behavior.</p><p>However, you may notice something interesting. Let’s focus for instance on the green and red traces taken for two very close values of $V_g$. Because these correspond to Fermi levels in the middle of the band gap, they show a very high resistance, except for a range of magnetic field values, where they also exhibit a quantum Hall plateau!</p><p>This proves what we hoped to find: there is a Landau level of electrons that crosses with a Landau level of holes.</p><p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig11.png" alt></p><p>(copyright JPS, see license in the beginning of the chapter)</p><p>As shown in the lower panel, this particular feature is due to the unique structure of Landau levels which you obtain in the presence of a band inversion.</p><p>The Landau levels of an electron-like band have a positive slope as a function of magnetic field, while those of a hole-like band have a negative slope. In a trivial bandstructure, all negative energy levels would bend down as a function of magnetic field, while all positive energy levels would bend up. As a consequence, if you place the Fermi level in the middle of the band gap and increase the magnetic field, no Landau level will ever cross the Fermi level.</p><p>However, in the presence of a band inversion, you obtain what is shown in the figure: the lowest Landau levels coming from the inverted bands go in the “wrong” direction. At some value of the magnetic field, they must cross. Furthemore, they will both cross the Fermi level if it is in the middle of the zero-field band gap.</p><p>Due to this fact, one observes a Hall effect in a certain range of fields, even when the Fermi level is placed in the middle of the zero-field band gap. And indeed, by comparing the experimental results with the expected behavior of the Landau levels, you see that the positions of the Fermi-level crossings coincide with the re-entrant Hall plateaus of the experimental traces - as marked by the green and red arrows.</p><p>As a further confirmation that this effect is due to band inversion, this behavior was only observed in samples with a thickness above the expected threshold value to obtain a quantum spin Hall phase, and never in samples with a smaller thickness.</p><h1 id="Localization-of-the-edge-states-by-magnetic-field"><a href="#Localization-of-the-edge-states-by-magnetic-field" class="headerlink" title="Localization of the edge states by magnetic field"></a>Localization of the edge states by magnetic field</h1><p>Theoretically, the hallmark of the topological insulator is the quantized conductance of the edge states that are protected from elastic backscattering. In the last unit, we learned that the key to this protection is time-reversal symmetry. Therefore, breaking time reversal symmetry by for example applying a magnetic field, should suppress the quantized conductance.</p><p>We can think about this more explicitly by considering a simple model for the helical edge states with a magnetic field $\bf B$:</p><p>$$H=v_F k_x\sigma_z+{\bf B}\cdot {\bf \sigma},$$</p><p>where $\bf \sigma$ are Pauli matrices representing the spin degree of freedom at the edge. This is what we get from the BHZ model, which conserves spin. For more general models we would interpret $\bf \sigma$ as a pseudo-spin degree of freedom, which is odd under time-reversal.</p><p>If we consider the simple case of a magnetic field ${\bf B}=B {\bf x}$ along the x-direction, we find that the edge spectrum $E=\pm\sqrt{v_F^2 k_x^2+B^2}$ becomes gapped. Clearly, the edge becomes insulating if we set the chemical potential at $E=0$.</p><p>We can very easily calculate that this is the case if we plot the conductance of the QSHE model as a function of magnetic field:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">1.5</span>, **bhz_parameters[<span class="string">&quot;topo2&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> bhz_parameters[<span class="string">&quot;topo2&quot;</span>].items():</span><br><span class="line">    <span class="comment"># setting the parameters for the lead the same as the scattering system</span></span><br><span class="line">    p.__dict__[key + <span class="string">&quot;_lead&quot;</span>] = value</span><br><span class="line"></span><br><span class="line">syst = bhz(w=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: (-<span class="number">1.5</span>, <span class="number">1.5</span>),</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r&quot;$-\pi/3$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>), (np.pi / <span class="number">3</span>, <span class="string">r&quot;$\pi/3$&quot;</span>)],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">1.5</span>, -<span class="number">1.0</span>, -<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="keyword">lambda</span> p: <span class="string">&quot;Band structure&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E_zs = np.linspace(<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">50</span>)</span><br><span class="line">VLines = holoviews.HoloMap(</span><br><span class="line">    &#123;ez_y: holoviews.VLine(ez_y) <span class="keyword">for</span> ez_y <span class="keyword">in</span> E_zs&#125;, kdims=[<span class="string">r&quot;$E_z$&quot;</span>]</span><br><span class="line">)</span><br><span class="line">spectra = holoviews.HoloMap(</span><br><span class="line">    &#123;p.ez_y: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.ez_y <span class="keyword">in</span> E_zs&#125;, kdims=[<span class="string">r&quot;$E_z$&quot;</span>]</span><br><span class="line">)</span><br><span class="line">G_Ez_plot(p, E_zs) * VLines + spectra * holoviews.HLine(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>However, even if we consider energies $E&gt;B$ above the gap, the eigenstates at $\pm k_x$ are no longer Kramers’ pairs, i.e. related by time-reversal symmetry. Therefore, any mechanism which changes momentum by $2 k_x$ can backscatter electrons from left movers to right movers. </p><p>Edges of semiconductors are typically quite disordered - so we expect the random potential at the edge to provide “elastic backscattering” that can change the momentum without changing the energy. Such backscattering, in addition to any other “inelastic backscattering” by phonons etc, would decrease the conductance of the edge from the ideal quantized value. If we set $B=0$, elastic back-scattering that can occur at finite $B$ is forbidden, so we generally expect the application of a magnetic field to reduce conductance of the edge.</p><p>We see below that indeed the conductance of the $L=20,\mu m$ device is strongly reduced by the application of a magnetic field: </p><p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig15.png" alt></p><p>(copyright JPS, see license in the beginning of the chapter)</p><p>However, we notice that this effect seems to work only when the magnetic field is perpendicular to the sample. In-plane magnetic fields do not seem to do a whole lot (there is an effect, but much larger fields are required). According to our model Hamiltonian, an in-plane field should have opened a gap, while a perpendicular field which adds a term proportional to $\sigma_z$ should have not done anything.</p><p>So, while the experiment sees something similar to what we hoped to find using a simple theory, the effect of the magnetic field seems reversed. There may be several explanations for this phenomenon, such as a presence of extra terms in the Hamiltonian that rotate the spins of the edge states without breaking time-reversal symmetry.</p><p>You might be worried that the suppression of conductance is only shown for the long device, which does not show quantized conductance. If you are, then you are absolutely right in worrying about this :-)</p><p>Localization of QSHE edge states by magnetic field is relatively poorly understood, and we are not aware of a final experiment that would prove its existence or tell us in details what it is that happens at the QSHE edge in a magnetic field. As you will learn in two weeks, opening the gap by magnetic field opens new pathways for the creation of Majoranas, and so it is still a very important direction of research.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Why did we not see a similar suppression of conductance with magnetic field in the case of  &quot;</span></span><br><span class="line">    <span class="string">&quot;the quantum Hall effect in week 3?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The quantum Hall effect appeared in much higher quality samples.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There was no spin in the quantum Hall effect, so the magnetic field could not couple to anything.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The topological protection of quantum Hall edges does not rely on time-reversal, unlike quantum spin &quot;</span></span><br><span class="line">    <span class="string">&quot;Hall edges.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The suppression here arises from inelastic scattering, which could not arise in the quantum Hall case.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The magnetic field dependence here arises from the fact that B breaks time-reversal symmetry, which is  &quot;</span></span><br><span class="line">    <span class="string">&quot;required for the protection of edge states in the quantum spin Hall effect. &quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;Kop4zXWQ1Zc&quot;</span>, src_location=<span class="string">&quot;5.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>Questions about what you just learned? Ask them below!</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;QSHE - experiments&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w5_qshe/fermion_parity_pump/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w5_qshe/fermion_parity_pump/</id>
    <published>2021-01-07T09:11:06.844Z</published>
    <updated>2021-01-07T09:11:06.844Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line">bhz_parameters = &#123;</span><br><span class="line">    <span class="string">&quot;topo&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;triv&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: -<span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;topo2&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.3</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;slowed&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.05</span>, <span class="string">&quot;B&quot;</span>: <span class="number">0.08</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.15</span>, <span class="string">&quot;M&quot;</span>: -<span class="number">0.3</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.5</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hoppings for bhz model</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (p.M - <span class="number">4</span> * p.B) * pauli.s0sz - <span class="number">4</span> * p.D * pauli.s0s0 + p.del_z * pauli.sysy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 + <span class="number">1j</span> * p.A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 - <span class="number">1j</span> * p.A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">w=<span class="number">20</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Make ribbon system with bhz model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    slowed parameters are used on the edge for finite size system.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_x</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    slowed_par = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;slowed&quot;</span>])</span><br><span class="line">    <span class="keyword">if</span> w <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[(lat(<span class="number">0</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w))] = onsite</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>, -<span class="number">1</span>)] = <span class="keyword">lambda</span> site, p: onsite(site, slowed_par)</span><br><span class="line">        syst[lat(<span class="number">1</span>, -<span class="number">1</span>), lat(<span class="number">0</span>, -<span class="number">1</span>)] = <span class="keyword">lambda</span> site1, site2, p: hopping_x(</span><br><span class="line">            site1, site2, slowed_par</span><br><span class="line">        )</span><br><span class="line">        syst[lat(<span class="number">0</span>, <span class="number">0</span>), lat(<span class="number">0</span>, -<span class="number">1</span>)] = hopy</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>, w)] = <span class="keyword">lambda</span> site, p: onsite(site, slowed_par)</span><br><span class="line">        syst[lat(<span class="number">1</span>, w), lat(<span class="number">0</span>, w)] = <span class="keyword">lambda</span> site1, site2, p: hopping_x(</span><br><span class="line">            site1, site2, slowed_par</span><br><span class="line">        )</span><br><span class="line">        syst[lat(<span class="number">0</span>, w), lat(<span class="number">0</span>, w - <span class="number">1</span>)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_cylinder</span>(<span class="params">w=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Make cylinder system with bhz model. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_x</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy_phase</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopy(site1, site2, p) * np.exp(<span class="number">1j</span> * p.ky)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, -w + <span class="number">1</span>), lat)] = hopy_phase</span><br><span class="line"></span><br><span class="line">    syst[lat(<span class="number">0</span>, <span class="number">0</span>)] = onsite</span><br><span class="line">    syst[lat(<span class="number">0</span>, w - <span class="number">1</span>)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lead</span>(<span class="params">t, trs=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym, time_reversal=<span class="number">1j</span> * pauli.sys0)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">1.8</span> * t * pauli.s0sz</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t * pauli.s0sz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_scatter_sys</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        x, y = pos</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="number">0</span>) * (<span class="number">0</span> &lt;= y &lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    lead_cylinder = bhz_cylinder()</span><br><span class="line">    lead = make_lead(<span class="number">1.0</span>)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    syst.attach_lead(lead_cylinder)</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scattering_det_pfaff</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pfaffian</span>(<span class="params">syst, p, ky</span>):</span></span><br><span class="line">        p.ky = ky</span><br><span class="line">        smat = kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).data</span><br><span class="line">        <span class="comment"># since we get relatively large numerical errors we project the matrix on</span></span><br><span class="line">        <span class="comment"># the space of antisymmetric matrices</span></span><br><span class="line">        smat = <span class="number">0.5</span> * (smat - smat.T)</span><br><span class="line">        <span class="keyword">return</span> pf.pfaffian(smat)</span><br><span class="line"></span><br><span class="line">    pfaff = [pfaffian(syst, p, <span class="number">0</span>), pfaffian(syst, p, np.pi)]</span><br><span class="line"></span><br><span class="line">    ks = np.linspace(<span class="number">0.0</span>, np.pi, <span class="number">50</span>)</span><br><span class="line">    det = [np.linalg.det(kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).data) <span class="keyword">for</span> p.ky <span class="keyword">in</span> ks]</span><br><span class="line">    det = np.array(det)</span><br><span class="line"></span><br><span class="line">    phase = np.angle(pfaff[<span class="number">0</span>]) + <span class="number">0.5</span> * np.cumsum(np.angle(det[<span class="number">1</span>:] / det[:-<span class="number">1</span>]))</span><br><span class="line">    kdims = [<span class="string">&quot;$k_y$&quot;</span>, <span class="string">&quot;phase&quot;</span>]</span><br><span class="line">    plot = holoviews.Path((ks[<span class="number">1</span>:], phase), kdims=kdims).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    plot *= holoviews.Points(([<span class="number">0</span>, np.pi], np.angle(pfaff)), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;g&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    xlims, ylims = <span class="built_in">slice</span>(-<span class="number">0.2</span>, np.pi + <span class="number">0.2</span>), <span class="built_in">slice</span>(-np.pi - <span class="number">0.2</span>, np.pi + <span class="number">0.2</span>)</span><br><span class="line">    pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">&quot;$\pi$&quot;</span>)], <span class="string">&quot;yticks&quot;</span>: pi_ticks&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.relabel(<span class="string">&quot;Winding&quot;</span>, depth=<span class="number">1</span>)[xlims, ylims].opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$A=&#123;:.2&#125;$, $B=&#123;:.2&#125;$, $D=&#123;:.2&#125;$, $M=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    <span class="keyword">return</span> title.<span class="built_in">format</span>(p.A, p.B, p.D, p.M)</span><br></pre></td></tr></table></figure><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Charles Kane from the University of Pennsylvania will introduce today’s lecture on two dimensional topological insulators with time-reversal symmetry.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;n5oUQvvsYd0&quot;</span>, src_location=<span class="string">&quot;5.1-intro&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Adding-symmetry-to-a-topological-insulator"><a href="#Adding-symmetry-to-a-topological-insulator" class="headerlink" title="Adding symmetry to a topological insulator"></a>Adding symmetry to a topological insulator</h1><p>In general, there are different approaches to discover new types of topological systems.</p><p>We have already used a very powerful method to make a Kitaev chain and the Chern insulator model. We started from guessing what kind of model to use for the edge, such that it is impossible to obtain without the bulk. Then we combined many such edges (dots for the Kitaev chain and wires for the Chern insulator) and tailored the coupling between them to leave exactly the type of model that we want on one edge.</p><p>A very skilled researcher in topology (or more specifically <a href="https://en.wikipedia.org/wiki/K-theory">K-theory</a>) may also just calculate the expected topological classification of a system starting only from its dimensionality and symmetries. This is also a powerful method, but often it’s too hard and requires a very high skills in math.</p><p>Another approach that we can undertake is to start with one topological Hamiltonian and see what happens if we force the Hamiltonian to have some extra symmetry. This is the approach we will use in this chapter.</p><p>Let’s start from a simple example involving something which we already know, a quantum dot with the Hamiltonian $H_0$. We know that there is a topological invariant, the number of filled energy levels.</p><p>Now we can ask what happens if we force the dot to have a particle-hole symmetry. The Hamiltonian becomes</p><p>$$<br>H_\textrm{BdG} =<br>\begin{pmatrix}<br>H_0 &amp; 0\<br>0 &amp; -H_0^*<br>\end{pmatrix}.<br>$$</p><p>This model is clearly topologically trivial from the point of view of the old invariant, since the number of filled states is constant. However, there are still level crossings that appear. We may ask if these crossings stay protected if we also include a finite superconducting pairing $\Delta$ in the Hamiltonian, which couples the two blocks $H_0$ and $-H_0^*$.</p><p>Of course we know the answer: the crossings stay protected due to the change in the Pfaffian invariant. So what we did was to construct a topologically non-trivial superconducting dot by adding particle-hole symmetry to a topological Hamiltonian with a lower symmetry.</p><p>Let’s now apply the same logic to a new system. Specifically, let’s add time-reversal symmetry to a Chern insulator. The Chern insulator has chiral edge states whose direction of propagation is flipped by time-reversal symmetry $\mathcal{T}$. So let’s consider a Hamiltonian of the form</p><p>$$<br>H =<br>\begin{pmatrix}<br>H_0 &amp; 0\<br>0 &amp; \mathcal{T}H_0\mathcal{T}^{-1}<br>\end{pmatrix},.<br>$$</p><p>If $H_0$ is the Hamiltonian of a Chern insulator with $N$ edge states, then $H$ will have $N$ pairs of counterpropagating edge states that transform into each other by time-reversal symmetry. Moreover, the full $H$ obeys time-reversal symmetry, which merely exchanges the two blocks.</p><p>The following sketch describes the situation in the case $N=1$:</p><p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_insulator.svg" alt></p><p>The next task which we now face is to understand if such edges stay topologically protected once we add coupling between the two blocks.</p><h1 id="A-perfectly-transmitted-channel-and-Kramers-degeneracy"><a href="#A-perfectly-transmitted-channel-and-Kramers-degeneracy" class="headerlink" title="A perfectly transmitted channel and Kramers degeneracy"></a>A perfectly transmitted channel and Kramers degeneracy</h1><p>We could try to see if all the edge states can be removed by adding some terms to the Hamiltonian, but instead we will use a closely related fact.</p><p>Let’s study transport through such edge states as a function of their total number and let’s only use the fact that time-reversal symmetry is present. Imagine, there is a total of $N$ states going in each direction along the edge, and that the edge is composed of a disordered region sandwiched between two clean regions. Again, let’s represent the situation for the case $N=1$.</p><p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_scattering.svg" alt></p><h2 id="Scattering-states"><a href="#Scattering-states" class="headerlink" title="Scattering states"></a>Scattering states</h2><p>We label incoming states on the left and right with $\left|n,\textrm{L}\right\rangle$ and $\left|n,\textrm{R}\right\rangle$. The index $n$ goes from $1$ to $N$. The outgoing states are the time-reversed partners of the incoming states, so they are given by $\mathcal{T}\left|n,\textrm{L}\right\rangle$ and $\mathcal{T}\left|n,\textrm{R}\right\rangle$. Scattering states in the left and right regions are superpositions of incoming and outgoing states,</p><p>$$<br>\left|\Psi,\textrm{L}\right\rangle = \sum_{n=1}^N \alpha_{n,\textrm{L}},\left|n,\textrm{L}\right\rangle + \beta_{n,\textrm{L}},\mathcal{T}\left|n,\textrm{L}\right\rangle,,<br>$$<br>$$<br>\left|\Psi,\textrm{R}\right\rangle = \sum_{n=1}^N \alpha_{n,\textrm{R}},\left|n,\textrm{R}\right\rangle + \beta_{n,\textrm{R}},\mathcal{T}\left|n,\textrm{R}\right\rangle,.<br>$$</p><p>We can form vectors out of all the coefficients in the superposition, for instance $\alpha_\textrm{L} = (\alpha_{1,\textrm{L}},\dots,\alpha_{N,\textrm{L}})^T$ for the incoming states on the left side. Incoming and outgoing modes are then related by the scattering matrix $S$ of the disordered region,</p><p>$$<br>\begin{pmatrix} \beta_\textrm{L} \ \beta_\textrm{R} \end{pmatrix} = S \begin{pmatrix} \alpha_\textrm{L} \ \alpha_\textrm{R} \end{pmatrix}.<br>$$</p><p>There are a total of $2N$ incoming and $2N$ outgoing modes, so $S$ is a $2N\times 2N$ matrix. Since we are including all possible initial and final states, $S$ is also unitary, $S=S^\dagger$. It can be split into reflection and transmission blocks of dimension $N\times N$,</p><p>$$<br>S =<br>\begin{pmatrix}<br>r &amp; t\<br>t’ &amp; r’<br>\end{pmatrix},.<br>$$</p><p>If we can gap out the edges by adding some extra terms to the Hamiltonian, or backscatter them by adding disorder, then we should be able to achieve the situation where there is no transmission at all, $t = t’ = 0$. In this case, all modes must be reflected back, so the reflection blocks of the scattering matrix become unitary, $r^\dagger r = r’^\dagger r’ = 1$.</p><p>To see whether this is possible at all, we first have to understand the constraints that time-reversal symmetry imposes on $S$.</p><h2 id="Scattering-matrices-with-time-reversal-symmetry"><a href="#Scattering-matrices-with-time-reversal-symmetry" class="headerlink" title="Scattering matrices with time-reversal symmetry"></a>Scattering matrices with time-reversal symmetry</h2><p>Let’s recall some basic facts about time-reversal symmetry, which we already studied in the first week. Time-reversal symmetry has an antiunitary operator $\mathcal{T}$ which commutes with the Hamiltonian. Being antiunitary, $\mathcal{T}$ may come in two flavors - either $\mathcal{T}^2=1$ or $\mathcal{T}^2=-1$. The first case applies to systems with no or integer spin, such that $\mathcal{T}=\mathcal{K}$ in the simplest case, where $\mathcal{K}$ is the complex conjugation operator. The second case applies to systems with half-integer spin, and in the simplest case we have $\mathcal{T}=i\sigma_y\mathcal{K}$.</p><p>Let’s apply the time-reversal operator to our scattering states. We get</p><p>$$<br>\mathcal{T}\left|\Psi,\textrm{L}\right\rangle = \sum_{n=1}^N \alpha^<em>_{n,\textrm{L}},\mathcal{T}\left|n,\textrm{L}\right\rangle + \beta^</em><em>{n,\textrm{L}},\mathcal{T}^2\left|n,\textrm{L}\right\rangle,,<br>$$<br>$$<br>\mathcal{T}\left|\Psi,\textrm{R}\right\rangle = \sum</em>{n=1}^N \alpha^<em>_{n,\textrm{R}},\mathcal{T}\left|n,\textrm{R}\right\rangle + \beta^</em>_{n,\textrm{R}},\mathcal{T}^2\left|n,\textrm{R}\right\rangle,.<br>$$</p><p>Now, since time-reversal symmetry does not change the energy of a state, $\mathcal{T}\left|\Psi,\textrm{R}\right\rangle$ and $\mathcal{T}\left|\Psi,\textrm{L}\right\rangle$ are scattering states with the same energy as $\left|\Psi,\textrm{R}\right\rangle$ and $\left|\Psi,\textrm{L}\right\rangle$. Hence, the coefficients of incoming and outgoing modes are still related by the same scattering matrix $S$ as before. Note, however, that applying $\mathcal{T}$ exchanged the role of the $\alpha$’s and $\beta$’s, such that the $\alpha$’s now correspond to outgoing states and the $\beta$’s to incoming states. Hence, we have</p><p>$$<br> S\mathcal{T}^2 \begin{pmatrix}\beta^<em>_\textrm{L} \ \beta^</em>_\textrm{R} \end{pmatrix} = \begin{pmatrix} \alpha^<em>_\textrm{L} \ \alpha^</em>_\textrm{R} \end{pmatrix},.<br>$$</p><p>Multiplying both sides by $\mathcal{T}^2S^\dagger$ and taking the complex conjugate gives</p><p>$$<br>\begin{pmatrix} \beta_\textrm{L} \ \beta_\textrm{R} \end{pmatrix} = \mathcal{T}^2,S^T  \begin{pmatrix} \alpha_\textrm{L} \ \alpha_\textrm{R} \end{pmatrix}.<br>$$</p><p>By comparing this equation with the one a few lines above, we finally obtain</p><p>$$<br>S = \mathcal{T}^2 S^T.<br>$$</p><p>So if $\mathcal{T}^2=1$, the scattering matrix is symmetric ($S=S^T$), while if $\mathcal{T}^2=-1$, it is antisymmetric ($S=-S^T$).</p><p>What does this imply if we try to set $t=t’=0$?</p><p>If $S=S^T$, it turns out there is really nothing special we can tell. However, if $S=-S^T$ and $t=t’=0$, the $N\times N$ reflection matrix must be both unitary, $r^\dagger r=1$, and antisymmetric, $r=-r^T$.</p><p>If $N$ is odd, this isn’t possible at all, since any odd-dimensional antisymmetric matrix <a href="https://en.wikipedia.org/wiki/Skew-symmetric_matrix#Spectral_theory">must have</a> a single zero eigenvalue, while unitary matrices only have eigenvalues with unit norm!</p><p>We are forced to conclude that it is impossible to have $r$ unitary, and therefore it is impossible to have $t=0$ in this case. Furthermore, this zero eigenvalue of $r$ means that there is always a single mode that is transmitted with unit probability.</p><p>This is the discovery that Charles Kane described in the introductory video. We can quickly check it by randomly selecting an antisymmetric scattering matrix with odd $N$, like the following one with $N=3$,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">3</span></span><br><span class="line">np.random.seed(<span class="number">12</span>)</span><br><span class="line">S = kwant.rmt.circular(N * <span class="number">2</span>, sym=<span class="string">&quot;AII&quot;</span>)</span><br><span class="line"></span><br><span class="line">pprint_matrix(S)</span><br></pre></td></tr></table></figure><p>and looking at the eigenvalues of $r^\dagger r$ and $t^\dagger t$:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r = S[:N, :N]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reflection eigenvalues&quot;</span>)</span><br><span class="line">pprint_matrix(np.linalg.eigvalsh(r @ r.T.conj()))</span><br><span class="line"></span><br><span class="line">t = S[:N, N:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Transmission eigenvalues&quot;</span>)</span><br><span class="line">pprint_matrix(np.linalg.eigvalsh(t @ t.T.conj())[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><blockquote><p>We conclude that if $\mathcal{T}^2=-1$ and the number of edge states going in one direction is odd, they cannot be gapped out, and the system is topological. On the other hand, if there is an even number of such edge states, they can be gapped out. Since these are the only two options, the integer invariant of a Chern insulator is reduced to a $\pm 1$ invariant in the presence of time reversal symmetry. These topologically protected, counterpropagating edge states are often referred to as <strong>helical edge states</strong>.</p></blockquote><h1 id="Helical-edge-states-are-Kramers-pairs"><a href="#Helical-edge-states-are-Kramers-pairs" class="headerlink" title="Helical edge states are Kramers pairs"></a>Helical edge states are Kramers pairs</h1><p>You might ask yourself what makes $\mathcal{T}^2=-1$ special, leading to the topological protection of the helical edge states.</p><p>As was mentioned in the first week, if $\mathcal{T}^2=-1$ then Kramers’ theorem applies. Kramers’ theorem tells us that given an eigenstate $|\Psi\rangle$ of the Hamiltonian with energy $E$, its time-reversed partner $|\Psi_\mathcal{T}\rangle\equiv\mathcal{T}|\Psi\rangle$ has the same energy, and the two states are orthogonal, $\langle \Psi | \Psi_\mathcal{T}\rangle=0$. These two states form a so-called <strong>Kramers pair</strong>. As we already know, this leads to the fact that Hamiltonians with spinful time-reversal symmetry have two-fold degenerate energy levels - <strong>Kramers degeneracy</strong>.</p><p>Now, the two counterpropagating helical modes are time-reversed partners of each other, so they form precisely such a Kramers pair. The condition $\langle \Psi | \Psi_\mathcal{T}\rangle=0$ implies that it is impossible to introduce any backscattering between the two states, unless we break time-reversal symmetry. This is the origin of the unit transmission and of the topological protection of helical edge states.</p><p>To gain a more intuitive understanding of this fact at a more microscopic level, we can assume that the projection of the electrons’ spin along a given axis is conserved, say the axis $z$ perpendicular to the plane. Then at the edge you have, say, a right-moving mode with spin up and a left-moving mode with spin down, and no other modes if $N=1$. Let’s draw again the picture of a helical edge state entering the disordered region:</p><p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/spin_flip.svg" alt></p><p>Thus, an electron moving to the right must have spin up by assumption. In order to be reflected, its spin must also be flipped.  However, this spin-flip scattering process is forbidden, and again we conclude that the electron is transmitted with probability one.</p><p>In the case $\mathcal{T}^2=1$, there is no Kramers’ theorem. As a consequence, even though you can construct models which have counterpropagating edge states, you will find that they have no topological protection and can be gapped out without breaking the time-reversal symmetry.</p><h1 id="The-quantum-spin-Hall-effect"><a href="#The-quantum-spin-Hall-effect" class="headerlink" title="The quantum spin Hall effect"></a>The quantum spin Hall effect</h1><p>There is no really precise name for the 2D topological insulator with time-reversal symmetry. It is often called “$\mathbb{Z}_2$ topological insulator.” However, this simply indicates that there are only two values of the topological invariant, and so it isn’t a very specific name.</p><p>The most commonly used name for this system is “quantum spin Hall insulator.” To understand why, let’s analyse a Hall bar made of such a non-trivial insulator. We will only need a Hall bar with four terminals, as shown below:</p><p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_hallbar.svg" alt></p><p>We have a finite voltage applied to terminal 1, so electrons are injected into the system from there. You can see that because of the helical edge states, there are as many modes connecting terminal 1 to terminal 3 as there are to terminal 4. A moment of thought, or otherwise a quick calculation, should convince you that in this case there is no net current flowing orthogonal to the applied voltage. The Hall conductance is zero, which is the expected result if time-reversal symmetry is preserved, as it is in our system.</p><p>However, counterpropagating edge states have to have exactly opposite spin due to Kramers degeneracy. This means that there may be a net spin current across the sample, orthogonal to the applied voltage.</p><p>In particular, let’s again make the simple assumption that the spin projection along some axis is conserved. Then, in the figure above, all modes colored in red have spin up, and all modes colored in blue have spin down. So terminal 1 distributes electrons coming out of it according to their spin: all electrons with spin up end up in terminal 4, and all those with spin down in terminal 3. The system has a quantized spin current between terminals 3 and 4, hence the name “quantum spin Hall effect”.</p><p>However, the quantized spin Hall current is not a general property of a quantum spin Hall insulator. Here, it arises because we have combined time reversal symmetry with a spin conservation law, and as we learned in the first week, conservation laws are boring from a topological point of view.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider the simple case where spin is conserved. &quot;</span></span><br><span class="line">    <span class="string">&quot;In the quantum spin Hall bar system above, what happens if, instead of applying a voltage between terminals 1 and 2, &quot;</span></span><br><span class="line">    <span class="string">&quot;you manage to apply a *spin-polarized* current between terminals 1 and 2?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The system will develop an opposite spin-polarized current to compensate the effect.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A spin-polarized current will develop between terminals 3 and 4.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A voltage difference will develop between terminals 3 and 4.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is impossible to apply such a current unless the bulk gap closes.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The spin-polarized current will create an electron population imbalance between terminals 3 and 4. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence, similar to the Hall effect, a voltage will develop orthogonal to the current.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="A-model-for-the-quantum-spin-Hall-insulator"><a href="#A-model-for-the-quantum-spin-Hall-insulator" class="headerlink" title="A model for the quantum spin Hall insulator"></a>A model for the quantum spin Hall insulator</h1><p>There is an important model which can be used to describe quantum spin Hall insulators, known as the <strong>Bernevig-Hughes-Zhang model</strong> or, in short, BHZ model. In essence, this model is equivalent to two copies of the Chern insulator Hamiltonian on the square lattice that we studied in the fourth week.</p><p>The BHZ Hamiltonian takes the form</p><p>$$<br>H_\textrm{BHZ}(\mathbf{k}) = \begin{pmatrix} h(\mathbf{k}) &amp; 0 \ 0 &amp; h^*(-\mathbf{k}) \end{pmatrix},,<br>$$</p><p>with</p><p>$$<br>h(\mathbf{k}) = \epsilon(\mathbf{k}) + \mathbf{d}(\mathbf{k})\cdot \pmb{\sigma},.<br>$$</p><p>Here $\pmb\sigma = (\sigma_x, \sigma_y, \sigma_z)$ is a vector of Pauli matrices acting on the electron/hole degree of freedom (the original two bands of the Chern insulator), $\epsilon(\mathbf{k}) = C - D(k_x^2+k_y^2)$, the vector $\mathbf{d} = [A k_x, -A k_y, M(\mathbf{k})]$, and<br>$M(\mathbf{k}) = M - B(k_x^2+k_y^2)$.</p><p>You can see that it is basically two copies of the massive Dirac Hamiltonian we used to study Chern insulators. In particular, there is a linear coupling in momentum between the holes and the electrons. The gap in the Hamiltonian is given by the term $M(\mathbf{k})$, a momentum-dependent effective mass.</p><p>By changing the sign of $M$ from negative to positive, you get a gap closing at $\mathbf{k}=\pmb{0}$:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(Bz=<span class="number">0.0</span>, **bhz_parameters[<span class="string">&quot;topo2&quot;</span>])</span><br><span class="line">syst = bhz(w=<span class="literal">None</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;k_x&quot;</span>: k, <span class="string">&quot;k_y&quot;</span>: k, <span class="string">&quot;title&quot;</span>: title&#125;</span><br><span class="line">Ms = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.M: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>])</span><br></pre></td></tr></table></figure><p>This gap closing turns your trivial insulator into a topologically non-trivial quantum spin Hall insulator.</p><p>In the rest of this lecture, we will use the BHZ model as a toy-model to illustrate the behavior of a quantum spin Hall insulator using numerical examples. The BHZ model, however, is more than a toy-model, and it can be used to capture the behavior of some real semiconducting materials. For this reason, the BHZ model will be a main protagonist in the next chapter, where we will discuss real materials and the experimental evidence for the quantum spin Hall effect.</p><h1 id="Alternative-point-of-view-fermion-parity-pump"><a href="#Alternative-point-of-view-fermion-parity-pump" class="headerlink" title="Alternative point of view: fermion parity pump"></a>Alternative point of view: fermion parity pump</h1><p>In the previous cases of the Kitaev chain and the quantum Hall effect, the bulk topological invariant that we eventually obtained was characterized by the response to some adiabatic experiment.</p><p>Since the time-reversal invariant topological insulator is two dimensional like a quantum Hall system, it is reasonable to put the system in a Corbino geometry and change the flux through the system, creating an azimuthal electric field:</p><p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_corbino.svg" alt></p><p>However, because of time-reversal symmetry, the system is forbidden from having a Hall conductance and therefore there cannot be any charge transfer between the two edges of the disk. For instance, if we consider two copies of the Haldane model with opposite spin, there will be two quantum Hall pumps working in opposite directions (one transferring charge from the inner edge to the outer edge, the other one from the outer edge to the inner one). So the net charge transferred is zero.</p><p>Because the two pumps act on electrons with opposite spin, you might be tempted to define a spin current, which would flow in response to the electric field, orthogonal to it. However, as we just discussed, the spin along a given direction may not be conserved, so generally this is not a good way to define a robust pumping effect.</p><p>To understand what exactly happens in the pumping process, let’s look at the energy spectrum of the edge states for the BHZ model in the cylinder geometry. As we discussed in the quantum Hall lectures, the cylinder geometry is really equivalent to the Corbino disk, except that it is easier to study.</p><p>You also learned that in a cylinder of finite circumference $L$, the momenta of the allowed edge states are quantized at values determined by the flux.</p><p>To make things more simple, you may actually imagine that the circumference of the cylinder is just a single unit cell long. We then have only one allowed value of the momentum $k$ along the edge, which is exactly proportional to the flux threaded through the cylinder, $k = 2\pi \Phi/\Phi_0$.</p><p>So let’s look at the energy spectrum of a cylinder as a function of $k$ (or equivalently $\Phi$), and compare a cylinder in the quantum spin Hall phase with a cylinder in the trivial insulating phase.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">half_pi_ticks = [(<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi / <span class="number">2</span>, <span class="string">r&quot;$\pi/2$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">style = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(<span class="number">0</span>, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: half_pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>),</span><br><span class="line">    <span class="string">&quot;xlims&quot;</span>: [<span class="number">0</span>, np.pi],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syst = bhz(<span class="number">20</span>)</span><br><span class="line">p1 = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;topo&quot;</span>])</span><br><span class="line">p2 = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;triv&quot;</span>])</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p1, **style).relabel(<span class="string">&quot;Topological&quot;</span>) * holoviews.HLine(<span class="number">0</span>)</span><br><span class="line">    + spectrum(syst, p2, **style).relabel(<span class="string">&quot;Trivial&quot;</span>) * holoviews.HLine(<span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>In both cases you see that at $k=0$ there are isolated pairs of states with degenerate energies, between the valence and conduction bands. The Fermi energy is set at $E=0$, in the middle of the gap between conduction and valence bands. These states are the Kramers pairs at the edges - one pair for the topological case, two for the trivial case.<br>You also see the splitting of Kramers pairs as soon as $k$ goes away from zero. This is because $k = 0$ is a time-reversal invariant point, a point in momentum space that is mapped to itself by time-reversal symmetry.</p><p>The plot ends at $k=\pi$ (that is, $\Phi=h/2e$), which is another time-reversal invariant point. Indeed, time-reversal symmetry sends $\Phi\to-\Phi$, but for $\Phi=h/2e$ this corresponds exactly to adding or subtracting a flux quantum. Hence, all the physical properties of the system remain unchanged under the action of time-reversal for this value of the flux. And indeed you can see that all levels meet again and form Kramers pairs.</p><blockquote><p>We now see an interesting difference though. In the topological case, the Kramers pairs at $k=\pi$ are not the same as those at $k=0$. In the trivial case however, the pairs are the same. As a consequence, in the topological case there is an odd number of levels crossing zero-energy, while in the trivial cases there is an even number of them. Therefore changing the flux by $h/2e$ in the topological case changes the fermion parity at the edge, while it does nothing in the trivial case. We have thus obtained a <strong>fermion parity pump</strong>.</p></blockquote><p>Strangely, this reminds us of the topological superconducting ring that we studied in the second week of the course. There we also had a fermion parity change in response to a flux. It turns out that this is not a coincidence, as we will see when we discuss how to realize topological superconductors using topological insulators.</p><p>You may appreciate that our argument did not rely on spin being a good quantum number, or on any other detail of the system, but only on Kramers theorem. And in fact it holds very generally. Deforming the dispersion of Kramers pairs does not break the fermion parity pump, as long as the way states combine to form Kramers pairs at $k=0$ and $k=\pi$ is unchanged.</p><h1 id="Pumping-expression-for-the-topological-invariant"><a href="#Pumping-expression-for-the-topological-invariant" class="headerlink" title="Pumping expression for the topological invariant"></a>Pumping expression for the topological invariant</h1><p>At this point, following the same path we followed for Chern insulator, we would like to find an expression for a topological bulk invariant which characterizes the quantum spin Hall effect.</p><p>However, we now encounter a problem: for complicated topological systems in higher dimensions, it is hard to evaluate the topological invariant. We know when the system is topological, and we know which values the topological invariant can take (for now just two: trivial and non-trivial), but it becomes hard to find and evaluate the correct expression for it.</p><p>We were able to calculate the Chern number using Berry curvature. The analogous computation for the topological invariant of the quantum spin Hall insulator is too involved, and so we will not present it in our course.</p><p>The scattering formulation of the topological invariant, however, is easy to implement and utilize. We can apply it by taking the cylinder threaded by a flux and connecting it to leads in the following geometry:</p><p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_pumping.svg" alt></p><p>Let us now study what happens when we try to inject electrons into the edges of the cylinder. Since we have “rolled-up” our system along one direction, we have a one-dimensional scattering problem. Similar to a Thouless pump, we expect to be able to find a topological signature in the reflection matrix $r$ for an electron coming in from the left.</p><p>As we vary the flux, the reflection properties may change, leading to a $k$-dependent reflection matrix $r(k)$. We assume that the bulk is gapped, so transmission is suppressed, and therefore $r$ is unitary. Moreover, at $k=0$ and $k=\pi$, $r$ is also antisymmetric because of time-reversal symmetry.</p><p>It turns out that the topological invariant has a relatively simple form:</p><p>$$<br>Q = \frac{\textrm{Pf}[r(0)]}{\textrm{Pf}[r(\pi)]}\sqrt{\frac{\det[r(\pi)]}{\det[r(0)]}}<br>$$</p><p>This expression relies on the antisymmetry of $r$ at $k=0$ and $k=\pi$. At these values we can compute the Pfaffian. The eigenvalues of $r$ come in pairs of opposite sign $e^{i\alpha}$, $-e^{i\alpha}$, which correspond to the Kramers pairs formed by the helical edge states. This means we can calculate the Pfaffian at these momentum values, but its phase is arbitrary.</p><p>We can however compute $\sqrt{\det[r(k)]}$ for all the intermediate values of $k$. To get rid of the sign ambiguity of the square root, we require that $\sqrt{\det[r(k)]}$ is continuous for all $k$, and that $\sqrt{\det[r(0)]} = \textrm{Pf}[r(0)]$. This only gives a unique answer if $\det r \neq 0$ for all $k$.</p><p>This gives us a curve which starts at $\textrm{Pf}[r(0)]$ and ends at either $\textrm{Pf}[r(\pi)]$ or $-\textrm{Pf}[r(\pi)]$. These two cases distinguish the trivial and nontrivial systems.</p><p>In the plot below, we show how this trajectory changes for our cylinder geometry as the BHZ model is driven through the topological phase transition. In the right panel, the green dots give you the phase of $\textrm{Pf}[r(0)]$ and $\textrm{Pf}[r(\pi)]$, and the blue line the phase of $\det[r(k)]$.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(a=<span class="number">1.0</span>, Bz=<span class="number">0.0</span>, ky=<span class="literal">None</span>, **bhz_parameters[<span class="string">&quot;topo2&quot;</span>])</span><br><span class="line">syst = bhz(w=<span class="literal">None</span>)</span><br><span class="line">scat_syst = make_scatter_sys()</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;k_x&quot;</span>: k, <span class="string">&quot;k_y&quot;</span>: k, <span class="string">&quot;title&quot;</span>: title&#125;</span><br><span class="line">Ms = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">(</span><br><span class="line">    holoviews.HoloMap(&#123;p.M: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>])</span><br><span class="line">    + holoviews.HoloMap(</span><br><span class="line">        &#123;p.M: scattering_det_pfaff(scat_syst, p) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>We now have a quantity equal to $\pm 1$, which cannot change continuously unless there’s a gap closing (when there’s a gap closing, $\det r$ becomes equal to $0$). It is relatively hard to prove that this invariant counts the pumping of fermion parity, but if you’re interested, check out this paper:</p><ul><li>arXiv:1107.2215</li></ul><p>From reading the paper, or just from the above discussion, you see that it takes a lot of effort to derive an explicit expression for a topological invariant. Even though it is a hard task, sometimes one can guess the right result (one of us was indeed able to guess the above expression for $Q$ before it was known). Other times, one can invoke some simplification and obtain some important insight. This is what we will do in the next unit.</p><h1 id="A-simplification-inversion-symmetry"><a href="#A-simplification-inversion-symmetry" class="headerlink" title="A simplification: inversion symmetry"></a>A simplification: inversion symmetry</h1><p>As just mentioned, topological invariants in higher dimensions are often difficult to write down and evaluate in the general case. Luckily, in the presence of <a href="http://en.wikipedia.org/wiki/Parity_%28physics%29#Effect_of_spatial_inversion_on_some_variables_of_classical_physics">inversion symmetry</a> - which reverses the lattice coordinates with respect to a symmetry center - the topological condition can be stated in rather simple terms.<br>This turns out to be quite useful to describe most topological materials, which happen to have crystal structure with inversion symmetry.</p><p>From our earlier discussion, we know that a system is a time-reversal invariant topological insulator if it has an odd number of helical edge states. We will now see how we can find an expression for the bulk topological invariant, using inversion symmetry and bulk-boundary correspondence.</p><p>So let’s consider a two-dimensional Bloch Hamiltonian $H(\mathbf{k})$ with both inversion and time-reversal symmetry. Inversion symmetry has a unitary operator $\mathcal{P}$ which maps $\mathbf{k}\rightarrow -\mathbf{k}$ and satisfies $\mathcal{P}^2=1$. If we have both inversion symmetry $\mathcal{P}$ and time-reversal $\mathcal{T}$, we get an anti-unitary symmetry $\mathcal{T}\otimes\mathcal{P}$, which preserves $\mathbf{k}$ and squares to $-1$.</p><blockquote><p>These are precisely the conditions needed for Kramers theorem to apply - only this time, every point $\mathbf{k}$ is mapped to itself because inversion symmetry is included as well. We conclude that every eigenstate at any $\mathbf{k}$ is two-fold degenerate.  We may label these two eigenstates with an index $\sigma=\pm$. If spin is a good quantum number, $\sigma$ labels two states with opposite spin. However, this may not be the case so we will just refer to it as a pseudospin associated with Kramers degeneracy.</p></blockquote><p>Note that the simplification obtained by adding inversion symmetry is that the spectrum is two-fold degenerate at all $\mathbf{k}$ in the Brillouin zone. Time-reversal symmetry alone cannot guarantee that, because it maps $\mathbf{k}$ to $-\mathbf{k}$.</p><p>Our next step is to calculate the effective description of helical edge states at a domain wall between a topological phase and a non-topological phase. This is something we already know how to do thanks to our experience with domain walls in the Kitaev chain and in Chern insulators. It will give us insight into the topological transition and the bulk topological invariant.</p><h2 id="Study-of-a-domain-wall"><a href="#Study-of-a-domain-wall" class="headerlink" title="Study of a domain wall"></a>Study of a domain wall</h2><p>Let’s imagine that the helical edge runs along the $y$ direction, and that the domain wall is described by a mass profile $M(x)$ along the $x$ direction, which is zero at the domain wall:</p><p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_domain_wall.svg" alt></p><p>In this configuration, $k_y$ is still a good quantum number, and we can study the energy dispersion of states bound to the domain wall as a function of $k_y$. If the edge is gapless there must be a momentum, say $\bar{k}_y$, where counterpropagating modes cross at the Fermi level. Let’s fix $k_y=\bar{k}_y$, and write down an effective Hamiltonian for the motion transverse to the domain wall.</p><p>We have in total four states, distinguished by two quantum numbers: their direction of propagation, which we denote with $b=\pm$, and their pseudospin $\sigma$. Inversion symmetry $\mathcal{P}$ flips the direction of propagation $b$, while the pseudo-spin degeneracy $\sigma$ is related to the combination of inversion and time-reversal $\mathcal{T}\otimes\mathcal{P}.$ To lowest order in the momentum $k_x$ perpendicular to the domain wall, the states at the transition point disperse linearly with $k_x$, and are two-fold degenerate. In fact, as we noted from Kramers degeneracy, the Hamiltonian must be chosen such that none of the terms break the two-fold degeneracy associated with the pseudospin $\sigma$. This means that the domain wall cannot couple states with different values of $\sigma$, which leads us to an effective Hamiltonian</p><p>$$<br>H(\bar{k}<em>y)=\sum</em>{\sigma,b},k_x b,|b,\sigma\rangle\langle b,\sigma|+M(x)(|+,\sigma\rangle\langle -,\sigma|+h.c.)],.<br>$$</p><p>where the factor $b$ is odd under time-reversal symmetry so that $k_x b$ is even under time-reversal symmetry.</p><p>We are back to an old friend, the one dimensional Dirac Hamiltonian with a position-dependent mass $M(x)$. Adapting our arguments from the first week, we can immediately say that the domain-wall hosts a pair of zero modes only if $M(x)$ changes sign.</p><p>As interesting as this sounds, we must remember that this pair of zero modes is present for $k_y=\bar{k}_y$. Because of inversion symmetry, there is necessarily an identical pair at $-\bar{k}_y$. So we get a total of 4 degenerate domain wall states from this type of gap closing - an even number of pairs. As we know form before, such pairs of gap closings do not affect the value of the topological invariant on the two sides of the domain walls. To change the value of the topological invariant, we would need an odd number of pairs crossing zero energy.</p><p>However, there are points in momentum space which are mapped onto each other by time-reversal symmetry, up to a reciprocal lattice vector. For these values, the above counting does not hold. People refer to these momenta as “time-reversal invariant momenta” or TRIMs. In the simple case of a square Brillouin zone, they are the points $(k_x, k_y) = (0,0), (0,\pi), (\pi,0),(\pi,\pi)$.</p><p>Since TRIMs are their own time-reversed partners, it is still possible for a gap closing at $\bar{k}_y=0$ or $\bar{k}_y=\pi$ to change the topology of the system. In this case, our doubling problem in momentum space is solved, and we can produce just one pair of edge modes at the domain wall. If we move the momentum $k_y$ slightly away from $\bar{k}_y$, the degenerate pair of modes splits linearly to form a single helical mode that produces a non-trivial fermion parity pump.</p><p>To make the distinction clear between a gap closing at a finite $\bar{k}_y$ and at a time-reversal invariant point, let’s draw a sketch of the edge dispersion in the two cases.</p><p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_edge_dispersions.svg" alt></p><p>Kramers pairs are colored in red and blue and have the same linestyle. On the left, you have two pairs of Kramers partners, which however never meet at zero energy. On the right, there is a single Kramers pair meeting at zero energy. This argument summarizes the simplification that inversion symmetry brings to time-reversal invariant topological insulators.</p><blockquote><p>We can determine the topological invariant for the inversion symmetric topological insulators entirely from the bulk Hamiltonian at time-reversal invariant momenta, since gap closings at any other point can only add domain wall states in multiples of four.</p></blockquote><p>Does this mean that any gap closing at a TRIM is a topological transition? The states $|b,\sigma\rangle$ are Bloch states with definite values of $k_y$. We are considering a time-reversal invariant value of $k_y$, and since $b$ is flipped by inversion symmetry, we can apply inversion symmetry to conclude that the states $|\pm,\sigma\rangle$<br>transform into each other under inversion i.e. $\mathcal{P}|\pm,\sigma\rangle= |\mp,\sigma\rangle$. By combining these states<br>into symmetric and anti-symmetric superpositions</p><p>$$|e,\sigma\rangle=\frac{1}{\sqrt{2}}\left[|+,\sigma\rangle, + ,|-,\sigma\rangle\right],,\quad |o,\sigma\rangle=\frac{i}{\sqrt{2}}\left[|+,\sigma\rangle, - ,|-,\sigma\rangle\right],$$</p><p>we obtain states that are even ($e$) and odd ($o$) under inversion—they are eigenstates of $\mathcal{P}$ with eigenvalue $+1$ or $-1$. They are also eigenstates of $M$ at $k_x=k_y=0$. The factor of $i$ in $|o,\sigma\rangle$ ensures a consistency under the time-reversal transformation, such that $\mathcal{T}|(e,o),\sigma\rangle=\sigma|(e,o),\sigma\rangle$.</p><p>Every gap closing at a TRIM is an even parity state crossing with an odd parity state. The effective Hamiltonian of such a gap closing must also add an extra Kramers pair of states at the domain wall, and therefore indeed every gap closing at a TRIM is a topological phase transition, while gap closings at all the other momenta are unimportant due to inversion symmetry.</p><p>This leads to a simplified way of computing a topological invariant of quantum spin Hall insulators with inversion symmetry:</p><blockquote><p>To compute a bulk topological invariant for a two-dimensional topological state with time reversal and inversion symmetry we need to keep track of the parity $P$ of all the occupied eigenstates of $H(\mathbf{k})$ at the different time-reversal invariant momenta in the Brillouin zone. We may write such a bulk topological invariant as a product</p></blockquote><blockquote><p>$$Q=\prod_{n,j}P_{n,j},,$$</p></blockquote><blockquote><p>where $P_{n,j}$ is the parity, $n$ runs over the occupied bands of $H(\mathbf{k})$ and $j$ over the time-reversal invariant momenta.</p></blockquote><p>You might now worry whether this definition of the invariant relied on having a smooth domain wall. From the fermion parity pump argument, bulk-edge correspondence implies that the bulk must be topologically non-trivial once you have edge states for any termination. Reversing this argument, we know that once we have a topologically non-trivial bulk, we must have helical edge states for any termination.</p><p>Thus, by looking at smooth domain walls we are able to establish a connection between the topological invariant in the presence of time-reversal and inversion symmetry, and the existence of helical edge states and fermion-parity pumping that characterizes the two dimensional topological insulator.</p><p>As a bonus, thanks to the previous arguments we can begin to understand how to look for two-dimensional topological insulators among real materials, or how to create them. The main idea is to generate a “band-inversion” between an even and an odd parity band at a TRIM.</p><p>Such a band inversion is not impossible to achieve in real materials, and can be captured using the BHZ model. But let’s leave this to the next lecture.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What is the value of the parity invariant $Q$ if you stack together two quantum spin Hall systems  &quot;</span></span><br><span class="line">    <span class="string">&quot;in the topological phase (i.e., both with $Q=-1$)?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The system has edge states and is therefore topologically non-trivial.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The total number of odd parity occupied orbitals must be even, so you get $Q=1$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It depends on whether the helical states in the two layers have same &quot;</span></span><br><span class="line">    <span class="string">&quot;or opposite spin for a given direction.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The invariant depends on the number of edge Dirac points at $k$ away from 0.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Both layers have $Q=-1$ and hence an odd number of odd parity orbitals. Therefore, by combining the layers  &quot;</span></span><br><span class="line">    <span class="string">&quot;we get an even number of odd parity orbitals. Hence $Q$, which is the parity of odd parity orbitals must be &quot;</span></span><br><span class="line">    <span class="string">&quot;$Q=1$.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;ft9ppqqLhH4&quot;</span>, src_location=<span class="string">&quot;5.1-summary&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>Questions about what you just learned? Ask them below!</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;QSHE - theory&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w4_haldane/w4_assignments/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w4_haldane/w4_assignments/</id>
    <published>2021-01-07T09:11:06.843Z</published>
    <updated>2021-01-07T09:11:06.843Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure><h1 id="Simulations-more-Chern-insulators"><a href="#Simulations-more-Chern-insulators" class="headerlink" title="Simulations: more Chern insulators"></a>Simulations: more Chern insulators</h1><p>As usual, start by grabbing the notebooks of this week (<code>w4_haldane</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p><h3 id="Yet-another-Chern-insulator"><a href="#Yet-another-Chern-insulator" class="headerlink" title="Yet another Chern insulator"></a>Yet another Chern insulator</h3><p>One more tight binding of a Chern insulator that you can encounter in the wild is a regular square lattice with half a flux quantum of magnetic field per unit cell. If you made the Hofstadter butterfly assignment from the previous week, it’s just in the middle of the butterfly. Half a flux quantum per unit cell means that the hoppings in one direction are purely imaginary, and different rows have alternating signs</p><p>$$t_y = t,\quad t_x = (-1)^y it.$$</p><p>This model has a dispersion very similar to graphene: it has two Dirac cones without a gap. Like graphene it also has two sites per unit cell, and sublattice symmetry.</p><p>Simulate this model. Think which parameters you need to add to it to make it a Chern insulator. Check that the edge states appear, and calculate the Berry curvature.</p><h3 id="Back-to-the-winding"><a href="#Back-to-the-winding" class="headerlink" title="Back to the winding"></a>Back to the winding</h3><p>Integration of Berry curvature is just another way to calculate the same quantity: the topological invariant. Verify that the winding of reflection phase gives the same results. To do that, make the pumping geometry out of a Chern insulator rolled into a cylinder, thread flux through it, and check that the topological invariant obtained through Berry curvature integration is the same as that obtained from winding.</p><p>We know that Berry curvature is concentrated close to the Dirac points. Do you notice anything similar for the pumped charge?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Now share your results:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Chern insulators&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1012-4723"><a href="#arXiv-1012-4723" class="headerlink" title="arXiv:1012.4723"></a>arXiv:1012.4723</h3><p><strong>Hint:</strong> The hunt for flat bands.</p><h3 id="arXiv-1409-6715"><a href="#arXiv-1409-6715" class="headerlink" title="arXiv:1409.6715"></a>arXiv:1409.6715</h3><p><strong>Hint:</strong> Making a Chern insulator more like quantum Hall effect.</p><h3 id="arXiv-1208-4579"><a href="#arXiv-1208-4579" class="headerlink" title="arXiv:1208.4579"></a>arXiv:1208.4579</h3><p><strong>Hint:</strong> A Chern insulator without lattice.</p><h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure><p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Chern insulators&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://ihuyi.xyz/2021/01/07/src/w4_haldane/haldane_model/"/>
    <id>http://ihuyi.xyz/2021/01/07/src/w4_haldane/haldane_model/</id>
    <published>2021-01-07T09:11:06.843Z</published>
    <updated>2021-01-07T09:11:06.843Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"></span><br><span class="line">%output size=<span class="number">150</span> fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haldane</span>(<span class="params">w=<span class="number">20</span>, boundary=<span class="string">&quot;zigzag&quot;</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape_zigzag</span>(<span class="params">pos</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0.5</span> / np.sqrt(<span class="number">3</span>) - <span class="number">0.1</span> &lt;= pos[<span class="number">1</span>] &lt; np.sqrt(<span class="number">3</span>) * w / <span class="number">2</span> + <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape_armchair</span>(<span class="params">pos</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> &lt;= pos[<span class="number">0</span>] &lt; w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> site.family == a:</span><br><span class="line">            <span class="keyword">return</span> p.m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -p.m</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nn_hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.t</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nnn_hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1j</span> * p.t_2</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.honeycomb()</span><br><span class="line">    a, b = lat.sublattices</span><br><span class="line">    nnn_hoppings_a = (((-<span class="number">1</span>, <span class="number">0</span>), a, a), ((<span class="number">0</span>, <span class="number">1</span>), a, a), ((<span class="number">1</span>, -<span class="number">1</span>), a, a))</span><br><span class="line">    nnn_hoppings_b = (((<span class="number">1</span>, <span class="number">0</span>), b, b), ((<span class="number">0</span>, -<span class="number">1</span>), b, b), ((-<span class="number">1</span>, <span class="number">1</span>), b, b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> boundary == <span class="string">&quot;zigzag&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[lat.shape(ribbon_shape_zigzag, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> boundary == <span class="string">&quot;armchair&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">0</span>, np.sqrt(<span class="number">3</span>))))</span><br><span class="line">        syst[lat.shape(ribbon_shape_armchair, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[lat.neighbors()] = nn_hopping</span><br><span class="line">    syst[</span><br><span class="line">        [kwant.builder.HoppingKind(*hopping) <span class="keyword">for</span> hopping <span class="keyword">in</span> nnn_hoppings_a]</span><br><span class="line">    ] = nnn_hopping</span><br><span class="line">    syst[</span><br><span class="line">        [kwant.builder.HoppingKind(*hopping) <span class="keyword">for</span> hopping <span class="keyword">in</span> nnn_hoppings_b]</span><br><span class="line">    ] = nnn_hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Qi_Wu_Zhang</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.mu * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0.5j</span> * p.delta * pauli.sy - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1j</span> * p.gamma * pauli.sx - p.gamma * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">    syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">berry_curvature</span>(<span class="params">syst, p, ks, num_filled_bands=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Berry curvature of a system.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    sys : kwant.Builder</span></span><br><span class="line"><span class="string">        A 2D infinite system.</span></span><br><span class="line"><span class="string">    p : SimpleNamespace</span></span><br><span class="line"><span class="string">        The arguments expected by the system.</span></span><br><span class="line"><span class="string">    ks : 1D array-like</span></span><br><span class="line"><span class="string">        Values of momentum grid to be used for Berry curvature calculation.</span></span><br><span class="line"><span class="string">    num_filled_bands : int</span></span><br><span class="line"><span class="string">        The number of filled bands.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    bc : 2D array</span></span><br><span class="line"><span class="string">        Berry curvature on each square in a `ks x ks` grid.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Calculate an array of eigenvectors.</span></span><br><span class="line">    B = np.array(syst.symmetry.periods).T</span><br><span class="line">    A = B @ np.linalg.inv(B.T @ B)</span><br><span class="line"></span><br><span class="line">    syst = kwant.wraparound.wraparound(syst).finalized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">energy</span>(<span class="params">kx, ky</span>):</span></span><br><span class="line">        k = np.array([kx, ky])</span><br><span class="line">        kx, ky = np.linalg.solve(A, k)</span><br><span class="line">        H = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p, k_x=kx, k_y=ky), sparse=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> scipy.linalg.eigh(H)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    vectors = np.array(</span><br><span class="line">        [[energy(kx, ky)[:, :num_filled_bands] <span class="keyword">for</span> kx <span class="keyword">in</span> ks] <span class="keyword">for</span> ky <span class="keyword">in</span> ks]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The actual Berry curvature calculation</span></span><br><span class="line">    vectors_x = np.roll(vectors, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    vectors_xy = np.roll(vectors_x, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    vectors_y = np.roll(vectors, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    shifted_vecs = [vectors, vectors_x, vectors_xy, vectors_y]</span><br><span class="line"></span><br><span class="line">    v_shape = vectors.shape</span><br><span class="line"></span><br><span class="line">    shifted_vecs = [i.reshape(-<span class="number">1</span>, v_shape[-<span class="number">2</span>], v_shape[-<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> shifted_vecs]</span><br><span class="line"></span><br><span class="line">    dets = np.ones(<span class="built_in">len</span>(shifted_vecs[<span class="number">0</span>]), dtype=<span class="built_in">complex</span>)</span><br><span class="line">    <span class="keyword">for</span> vec, shifted <span class="keyword">in</span> <span class="built_in">zip</span>(shifted_vecs, np.roll(shifted_vecs, <span class="number">1</span>, <span class="number">0</span>)):</span><br><span class="line">        dets *= [np.linalg.det(a.T.conj() @ b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(vec, shifted)]</span><br><span class="line">    bc = np.angle(dets).reshape(<span class="built_in">int</span>(np.sqrt(<span class="built_in">len</span>(dets))), -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    bc = (bc + np.pi / <span class="number">2</span>) % (np.pi) - np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_berry_curvature</span>(<span class="params">syst, p, ks=<span class="literal">None</span>, title=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> ks <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ks = np.linspace(-np.pi, np.pi, <span class="number">150</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">    bc = berry_curvature(syst, p, ks)[<span class="number">1</span>:-<span class="number">1</span>, <span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    vmax = <span class="built_in">max</span>(np.<span class="built_in">abs</span>(bc).<span class="built_in">min</span>(), np.<span class="built_in">abs</span>(bc).<span class="built_in">max</span>())</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">&quot;bounds&quot;</span>: (ks.<span class="built_in">min</span>(), ks.<span class="built_in">min</span>(), ks.<span class="built_in">max</span>(), ks.<span class="built_in">max</span>()),</span><br><span class="line">        <span class="string">&quot;kdims&quot;</span>: [<span class="string">r&quot;$k_x$&quot;</span>, <span class="string">r&quot;$k_y$&quot;</span>],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>(title):</span><br><span class="line">        kwargs[<span class="string">&quot;label&quot;</span>] = title(p)</span><br><span class="line"></span><br><span class="line">    plot = &#123;<span class="string">&quot;xticks&quot;</span>: pi_ticks, <span class="string">&quot;yticks&quot;</span>: pi_ticks&#125;</span><br><span class="line">    style = &#123;<span class="string">&quot;clims&quot;</span>: [-vmax, vmax]&#125;</span><br><span class="line">    <span class="keyword">return</span> holoviews.Image(bc, **kwargs).opts(plot=plot, style=style)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$t=&#123;:.2&#125;$, $t_2=&#123;:.2&#125;$, $M=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    <span class="keyword">return</span> title.<span class="built_in">format</span>(p.t, p.t_2, p.m)</span><br></pre></td></tr></table></figure><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Duncan Haldane from Princeton University will teach us about an interesting two dimensional toy-model which he <a href="http://faculty.washington.edu/cobden/papers/haldane88.pdf">introduced</a> in 1988, and which has become a prototype for the anomalous quantum Hall effect.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;7nVO4uMm-do&quot;</span>, src_location=<span class="string">&quot;4.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure><p>We will now study the model in detail, starting from the beginning.  Along the way, we will also learn about the Chern number, the bulk topological invariant of a quantum Hall state.</p><h1 id="Dirac-cones-in-graphene"><a href="#Dirac-cones-in-graphene" class="headerlink" title="Dirac cones in graphene"></a>Dirac cones in graphene</h1><p>In the last chapter we saw how it is possible to obtain a quantum Hall state by coupling one-dimensional systems. At the end, our recipe was to first obtain a Dirac cone, add a mass term to it and finally to make this mass change sign. Following this recipe we were able to obtain chiral edge states without applying an external magnetic field.</p><p>There is a real (and a very important) two-dimensional system which has Dirac cones: <a href="http://en.wikipedia.org/wiki/Graphene">graphene</a>. So in this chapter we will take graphene and make it into a topological system with chiral edge states.</p><p>Graphene is a single layer of carbon atoms arranged in a honeycomb lattice. It is a triangular lattice with two atoms per unit cell, type $A$ and type $B$, represented by red and blue sites in the figure:</p><p><img src="/2021/01/07/src/w4_haldane/haldane_model/graphene.svg" alt></p><p>Hence, the wave function in a unit cell can be written as a vector $(\Psi_A, \Psi_B)^T$ of amplitudes on the two sites $A$ and $B$. Taking a simple tight-binding model where electrons can hop between neighboring sites with hopping strength $t$, one obtains the Bloch Hamiltonian:</p><p>$$<br>H_0(\mathbf{k})= \begin{pmatrix} 0 &amp; h(\mathbf{k}) \ h^\dagger(\mathbf{k}) &amp; 0 \end{pmatrix},,<br>$$</p><p>with $\mathbf{k}=(k_x, k_y)$ and</p><p>$$h(\mathbf{k}) = t_1,\sum_i,\exp,\left(i,\mathbf{k}\cdot\mathbf{a}_i\right),.$$</p><p>Here $\mathbf{a}_i$ are the three vectors in the figure, connecting nearest neighbors of the lattice [we set the lattice spacing to one, so that for instance $\mathbf{a}_1=(1,0)$].  Introducing a set of Pauli matrices $\sigma$ which act on the sublattice degree of freedom, we can write the Hamiltonian in a compact form as</p><p>$$H_0(\mathbf{k}) = t_1,\sum_i,\left[\sigma_x,\cos(\mathbf{k}\cdot\mathbf{a}_i)-\sigma_y ,\sin(\mathbf{k}\cdot\mathbf{a}_i)\right],.$$</p><p>The energy spectrum $E(\mathbf{k}) = \pm ,\left|h(\mathbf{k})\right|$ gives rise to the famous band structure of graphene, with the two bands touching at the six corners of the Brillouin zone:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, t_2=<span class="number">0.0</span>, m=<span class="number">0.0</span>, phi=np.pi / <span class="number">2</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">&quot;infinite&quot;</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">150</span>)</span><br><span class="line">spectrum(syst, p, k_x=k, k_y=k, title=title)</span><br></pre></td></tr></table></figure><p>Only two of these six Dirac cones are really distinct, the ones at $\mathbf{K}=(2\pi/3, 2\pi/3\sqrt{3})$ and $\mathbf{K}’=(2\pi/3, -2\pi/3\sqrt{3})$. All the others can be obtained by adding some reciprocal lattice vector to $\mathbf{K}$ and $\mathbf{K}’$.</p><h1 id="Discrete-symmetries-of-graphene"><a href="#Discrete-symmetries-of-graphene" class="headerlink" title="Discrete symmetries of graphene"></a>Discrete symmetries of graphene</h1><p>The symmetries of graphene were discussed intensively in the video, so let’s review them.</p><p>As we already said in our first week, graphene is the prototype of a system with sublattice symmetry, which makes the Hamiltonian block off-diagonal with respect to the two sublattices. The sublattice symmetry reads</p><p>$$\sigma_z,H_0(\mathbf{k}),\sigma_z = -H_0(\mathbf{k}),.$$</p><p>Sublattice symmetry is only approximate, and it is consequence of the nearest neighbor tight-binding model. Just like the inversion symmetry mentioned in the video, it protects the Dirac points and needs to be broken in order to open a gap.</p><p>In addition to sublattice and inversion symmetry, the honeycomb lattice also has a three-fold rotation symmetry around the center of the unit cell. This symmetry is important to make the Dirac cones appear in the first place, but it will not play a role in all that follows.</p><p>Finally, there is time-reversal symmetry, which at the moment is perfectly preserved in our tight-binding model. Since we are not considering the spin degree of freedom of the electrons, the time-reversal symmetry operator in real space is just complex conjugation. In momentum space representation, time-reversal symmetry reads</p><p>$$ H_0(\mathbf{k}) = H_0^*(-\mathbf{k}),.$$</p><p>It’s important to note that time-reversal symmetry sends $\mathbf{K}$ into $\mathbf{K}’$ and therefore it exchanges the two Dirac cones.</p><p>The product of (approximate) sublattice and time-reversal symmetries yields a further discrete symmetry, a particle-hole symmetry $\sigma_z H^*(-\mathbf{k}),\sigma_z = -H_0(\mathbf{k})$.</p><h1 id="Making-graphene-topological"><a href="#Making-graphene-topological" class="headerlink" title="Making graphene topological"></a>Making graphene topological</h1><p>Let’s recall that our goal is to make our graphene sheet enter a quantum Hall state, with chiral edge states. The first necessary step is to make the bulk of the system gapped. </p><p>How can we open a gap in graphene? The Dirac points are protected by both sublattice (inversion) and time-reversal symmetry. So there are many ways we can think of to open an energy gap at $\mathbf{K}$ and $\mathbf{K}’$.</p><h2 id="First-try"><a href="#First-try" class="headerlink" title="First try"></a>First try</h2><p>The easiest way to break sublattice symmetry is to assign an opposite onsite energy $M$ or $-M$ to the $A$ or $B$ sites respectively. The Hamiltonian is then given by</p><p>$$ H_0(\mathbf{k}) + M,\sigma_z,.$$</p><p>This leads to a gapped spectrum,</p><p>$$E(\mathbf{k})=\pm \sqrt{\left|h(\mathbf{k})\right|^2 + M^2},.$$</p><p>However, we quickly realize that by doing this we end up in a rather boring situation. Taking the limit $\left|M\right| \gg t_1$, we obtain electronic states which are localized in one of the two sublattices $A$ or $B$, independent of the sign of $M$. Most importantly, there is no trace of edge states.</p><p>It’s easy to see why this mass term is hopeless: it preserves time-reversal symmetry. And with the time-reversal symmetry present, it is definitely impossible to obtain chiral edge states.</p><h2 id="Second-try"><a href="#Second-try" class="headerlink" title="Second try"></a>Second try</h2><p>There is another, more ingenious way to gap out the Dirac cones in graphene, which is the essence of today’s model. It involves adding imaginary second-nearest neighbor hoppings, with the following distinctive pattern:</p><p><img src="/2021/01/07/src/w4_haldane/haldane_model/haldane_hoppings.svg" alt></p><p>With the direction of the arrow, we denote the direction in which the hopping is $+it_2$ (it is $-it_2$ in the opposite direction).</p><p>Note the following things about these hoppings:</p><ul><li>they are purely imaginary and, furthermore, they all have the same chirality, in the sense that they all follow the orientation of your right hand, if the thumb points out from the screen.</li><li>they couple sites of same type: $A$ with $A$ and $B$ with $B$.</li></ul><p>These characteristics tell us that the new hoppings break both time-reversal symmetry and sublattice symmetry. Now the full Hamiltonian becomes</p><p>$$<br>H(\mathbf{k}) = H_0(\mathbf{k})+ M\sigma_z + 2t_2\sum_i,\sigma_z,\sin(\mathbf{k}\cdot\mathbf{b}_i),.<br>$$</p><p>The last term changes sign under time-reversal symmetry, breaking it. This is the Hamiltonian of the Haldane model.</p><p>Let’s see what happens to the system when these special second neighbor hoppings are turned on:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>, t_2=<span class="literal">None</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">&quot;infinite&quot;</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;k_x&quot;</span>: k, <span class="string">&quot;k_y&quot;</span>: k, <span class="string">&quot;title&quot;</span>: title&#125;</span><br><span class="line">t_2s = np.linspace(<span class="number">0</span>, <span class="number">0.10</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.t_2: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.t_2 <span class="keyword">in</span> t_2s&#125;, kdims=[<span class="string">r&quot;$t_2$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>When $t_2=0$ and at a finite $M$, the system is in a boring gapped phase, generically without zero energy states. As you heard in the video, there might be zero energy states for some specific termination of the lattice, but these are not particularly interesting.</p><p>Adding a small $t_2$ initially does not change the situation, but when $t_2$ passes through a value $\pm M/3\sqrt{3}$ the gap closes and changes sign. Importantly, the gap closes <em>only at one of the two Dirac points</em>: at $\mathbf{K}’$ for $t_2=M/3\sqrt{3}$ and at $\mathbf{K}$ for $t_2=-M/3\sqrt{3}$.</p><p>And when it does, chiral edge states appear! We can see this by looking at the one-dimensional band structure of a ribbon of graphene. To convince you that they are of topological origin, let’s look at the bandstructure for ribbons with two different lattice terminations: armchair and zigzag. In a zigzag ribbon, $\mathbf{K}$ and $\mathbf{K}’$ correspond to different momenta parallel to the ribbon direction, while in an armchair one they correspond to the same one.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;svg&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ribbon_bandstructure</span>(<span class="params">t_2, boundary</span>):</span></span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, t_2=t_2, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> boundary == <span class="string">&quot;zigzag&quot;</span>:</span><br><span class="line">        syst = haldane(w=<span class="number">20</span>, boundary=<span class="string">&quot;zigzag&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> boundary == <span class="string">&quot;armchair&quot;</span>:</span><br><span class="line">        syst = haldane(w=<span class="number">20</span>, boundary=<span class="string">&quot;armchair&quot;</span>,)</span><br><span class="line"></span><br><span class="line">    style = &#123;</span><br><span class="line">        <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">        <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E/t$&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">        <span class="string">&quot;yticks&quot;</span>: [-<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">        <span class="string">&quot;ylims&quot;</span>: [-<span class="number">3.2</span>, <span class="number">3.2</span>],</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> spectrum(syst, p, **style)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t_2s = np.linspace(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">20</span>)</span><br><span class="line">boundaries = [<span class="string">&quot;zigzag&quot;</span>, <span class="string">&quot;armchair&quot;</span>]</span><br><span class="line">plots = &#123;</span><br><span class="line">    (t_2, boundary): ribbon_bandstructure(t_2, boundary)</span><br><span class="line">    <span class="keyword">for</span> t_2 <span class="keyword">in</span> t_2s</span><br><span class="line">    <span class="keyword">for</span> boundary <span class="keyword">in</span> boundaries</span><br><span class="line">&#125;</span><br><span class="line">holoviews.HoloMap(plots, kdims=[<span class="string">r&quot;$t_2$&quot;</span>, <span class="string">&quot;Boundary&quot;</span>])</span><br></pre></td></tr></table></figure><p>The appearance of edge states means that graphene has entered a topological phase after the gap closing. This phase is akin to the quantum Hall phase - the edge states are of the same kind. However, as Duncan Haldane explained in the introduction, it is realized without a strong magnetic field.</p><p>As you know, this means we have created a <strong>Chern insulator</strong>. The reason for this name will become obvious in the second part of the lecture.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens if we take a Haldane model in the topological phase and turn &quot;</span></span><br><span class="line">    <span class="string">&quot;on a weak magnetic field?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Magnetic field introduces Landau levels, which change the number of edge states.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since the magnetic field is weak, nothing changes as long as it doesn&#x27;t close the gap&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The bulk gap closes and there are no edge states anymore.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The gap doesn&#x27;t close but the edge states may change direction &quot;</span></span><br><span class="line">    <span class="string">&quot;of propagation, depending on the sign of magnetic field.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;Topological robustness is still present, so the number of edge states cannot change unless the gap closes.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="Pumping-in-terms-of-Berry-phase"><a href="#Pumping-in-terms-of-Berry-phase" class="headerlink" title="Pumping in terms of Berry phase"></a>Pumping in terms of Berry phase</h1><p>Last week we understood the quantum Hall effect in terms of a pumping argument that we attributed to Laughlin.</p><p>Our pumping argument involved putting our system on a cylinder and adiabatically pumping a magnetic flux $\Phi$ through the cylinder so that the Hamiltonian returns to itself. The flux enters the Hamiltonian through minimal substitution as $H(\mathbf{k})\rightarrow H(\mathbf{k}+e\mathbf{A})$ where ${\bf A}=\hat{\mathbf{y}},\Phi/L$.</p><p>Thus we can understand the effects of flux pumping on the Hamiltonian in terms of a change in momentum. When the flux is changed by the appropriate number of quanta, the momentum $\mathbf{k}$ changes by a reciprocal lattice vector and, hence the Bloch Hamiltonian returns to its original value. To simplify the discussion, in the following we will use a square Brillouin zone, with $k_x$ and $k_y$ defined in an interval $[0, 2\pi]$, but all our arguments also apply for the hexagonal Brillouin zone of graphene.</p><p>Let’s imagine the adiabatic time-evolution of an eigenstate $\left|\psi(\mathbf{k})\right\rangle$ of this Hamiltonian, with energy $E(\mathbf{k})$, as $\mathbf{k}$ is changed slowly. Suppose the Hamiltonian is such that $\left|\psi(\mathbf{k})\right\rangle$ remains non-degenerate as in the case of the Haldane model.  We can then adiabatically explore an energy band by moving $\mathbf{k}$, without the risk of encountering a level crossing. After a while, let’s say a time $T$, we bring $\mathbf{k}$ back to its initial value after going around the entire Brillouin Zone. For instance, we can consider the following closed path $C$, where $k_y$ changes by $2\pi$ at a fixed $k_x$, starting from $k_y=0$:</p><p><img src="/2021/01/07/src/w4_haldane/haldane_model/bz_path.svg" alt></p><p>We then ask: what is the final quantum state at the time $T$? For a long time people guessed that it would just be given by the initial state $\left|\psi(k_x, k_y+2\pi)\right\rangle\equiv\left|\psi(k_x, k_y)\right\rangle$ times  the usual phase $\exp\left(-i \int_0^T E[\mathbf{k}(t)],d t\right)$, which an eigenstate of the Hamiltonian accumulates with time. </p><p>This would be rather boring. Berry instead realized that for a closed loops there is an additional phase $\gamma$, which in our case may depend on $k_x$:</p><p>$$\gamma(C) = \oint_C,\mathbf{A}(\mathbf{k}),\cdot d\mathbf{k},.$$</p><p>Here, $\mathbf{A}(\mathbf{k})=i\left\langle,\psi(\mathbf{k}) ,|,\nabla_\mathbf{k},\psi(\mathbf{k})\right\rangle$ is a vector with two complex entries, which are obtained by taking the derivatives of $\left|\psi(\mathbf{k})\right\rangle$ with respect to $k_x$ and $k_y$ and then taking the inner product with $\left\langle\psi(\mathbf{k})\right|$. This vector goes by the rather obscure name of Berry connection. In our example, the final quantum state at the end of the cycle is thus</p><p>$$\exp,\left[i\gamma(k_x)\right],\exp,\left(-i \int_0^T E[\mathbf{k}(t)],d t\right),\left|\psi(\mathbf{k})\right\rangle,.$$</p><p>We have made explicit the fact that $\gamma$ in our case may depend on $k_x$. We will not derive the formula for the Berry phase, something which can be done directly from the Schrödinger equation, see for instance <a href="http://arxiv.org/abs/0907.2021">here</a>. What is important to know about $\gamma$ is that it is a <strong>geometric phase</strong>: its value depends on the path $C$ but not on how the path is performed in time, so not on the particular expression for $\mathbf{k}(t)$. We’ll soon see that sometimes it can have an even stronger, topological character.  </p><h2 id="Flux-pumping"><a href="#Flux-pumping" class="headerlink" title="Flux pumping"></a>Flux pumping</h2><p>The phase $\gamma(k_x)$ must bear information about the charge pumped during an adiabatic cycle over $k_y$. Now we take advantage of pumped charge being invariant as long as the energy gap is preserved. This means that we have the freedom to change the energy dispersion $E(k_x,k_y)$ arbitrarily, as long as we do not close the gap.</p><p>It is convenient to make the energy dispersion completely flat along the $k_x$ direction for $k_y=0$, analogous to the case of Landau levels. In this way, since at fixed $k_y$ all the wave functions have the same energy, we can choose our initial quantum state to be localized in a single unit cell in the $x$ direction,</p><p>$$\left|\psi(n,t=0)\right\rangle=\int_0^{2\pi} dk_x, e^{i k_x n},\left|\psi(k_x, k_y=0)\right\rangle,.$$</p><p>Starting from this state, after one adiabatic cycle we obtain</p><p>$$\left|\psi(n,t=T)\right\rangle=\int_0^{2\pi} dk_x, e^{i k_x n},\exp,\left[i\gamma(k_x)-i\theta(k_x)\right],\left|\psi(k_x, k_y=2\pi)\right\rangle,$$</p><p>where $\theta(k_x)=\int_0^T E[k_x, k_y(t)],d t$ is the dynamical phase. Now we notice something strange. While $\theta(k_x)$ is a truly periodic function of $k_x$ because $E(k_x)=E(k_x+2\pi)$, the only restriction on the Berry phase $\gamma(k_x)$ is to be periodic modulo $2\pi$. That is, we can have $\gamma(k_x+2\pi)=\gamma(k_x)+2\pi W$ with $W$ an integer number.</p><p>Let’s try to deform the dispersion along $k_y$ in order to make the combination $\gamma(k_x)-\theta(k_x)$ as large as possible (just like before, this is allowed as long as we do not close the gap). The best we can do is choose $\theta(k_x)$ so that </p><p>$$\gamma(k_x)-\theta(k_x)=W k_x.$$</p><p>Plugging this in to the form of the wave-function we see that </p><p>$$\left|\psi(n,t=T)\right\rangle=\int dk_x e^{i k_x (n+W)},\left|\psi(k_x, k_y=0)\right\rangle,$$</p><p>which means that every wave function is shifted over by $W$ unit cells. Thus the system with the wave functions $\left|\psi(\mathbf{k})\right\rangle$ pumps $W$ units of charge if the Berry phase satisfies </p><p>$$\gamma(k_x+2\pi)-\gamma(k_x)=2\pi W.$$</p><blockquote><p>The quantity $W$ is called the <strong>Chern number</strong> and is the topological invariant characterizing the bandstructure of two dimensional quantum Hall systems. Because it is an integer, it cannot be changed by any continuous deformation of the Hamiltonian, provided the gap does not close. The Chern number is in fact the bulk topological invariant for all insulators with broken time-reversal symmetry. If $W=0$, we have a topologically trivial insulator with no chiral edge states. If $W=n$ there are $n$ chiral edge states at the boundary of the insulator.</p></blockquote><h1 id="Compact-form-of-the-Chern-number-as-Berry-curvature"><a href="#Compact-form-of-the-Chern-number-as-Berry-curvature" class="headerlink" title="Compact form of the Chern number as Berry curvature"></a>Compact form of the Chern number as Berry curvature</h1><p>We did not denote the Berry connection as $\mathbf{A}(\mathbf{k})$ just by chance. We picked that letter because this vector reminds us a lot of the vector potential $\mathbf{A}(\mathbf{r})$ that is used in electromagnetism.</p><p>Just like the vector potential, the definition of $\mathbf{A}(\mathbf{k})$ depends on a particular choice of the person making the calculation. If you decide to multiply the quantum state by a phase, $\left|\psi(\mathbf{k})\right\rangle,\to \exp,[i\lambda(\mathbf{k})],\left|\psi(\mathbf{k})\right\rangle$, then you get that the Berry connection transforms as $\mathbf{A}(\mathbf{k}),\to,\mathbf{A}(\mathbf{k})+\nabla_\mathbf{k} ,\lambda$. However, when you take the integral of $\mathbf{A}(\mathbf{k})$ on a closed path, the result is independent of $\lambda$. That’s why the Berry phase is only meaningful for closed paths. </p><p>Now that we have established an analogy with the vector potential, we cannot avoid the idea of taking the curl of the Berry connection, which is known as the <strong>Berry curvature</strong>:</p><p>$$\mathbf{\Omega}(\mathbf{k}) = \nabla_\mathbf{k} \times \mathbf{A}(\mathbf{k})=i\left[\left\langle \frac{\partial \psi(\mathbf{k})}{\partial k_x},\Bigg|,\frac{\partial,\psi(\mathbf{k})}{\partial k_y}\right\rangle-\left\langle \frac{\partial \psi(\mathbf{k})}{\partial k_y},\Bigg|,\frac{\partial,\psi(\mathbf{k})}{\partial k_x}\right\rangle\right],.$$</p><p>The Berry curvature is like a <em>magnetic field in momentum space</em>. Just like the magnetic field $\mathbf{B}(\mathbf{r})=\nabla_\mathbf{r}\times\mathbf{A}(\mathbf{r})$ in electromagnetism, it is a local quantity which does not suffer from the ambiguities of the vector potential (it is gauge independent).</p><p>The main advantage of introducing the analogy with the magnetic field is that it motivates us to use Stokes theorem. The Brillouin Zone has the shape of a torus. Therefore the curve $k_x=0$ and $k_x=2\pi$ on the torus bounds the entire Brillouin zone. Using Stokes theorem on this curve we can conclude that </p><p>$$2\pi W=\gamma(2\pi)-\gamma(0)=\iint_{\textrm{BZ}} \mathbf{\Omega}(\mathbf{k}),\cdot,d\mathbf{S},,$$</p><p>where the integral extends over the entire Brillouin Zone.</p><blockquote><p>As a result of this formalism, we have established two things. First, there is a Chern number which is defined entirely in terms of the momentum space wave functions. Second, the analogy with the magnetic field allows us to obtain an explicit expression for the Chern number in terms of derivatives of the wave functions.</p></blockquote><p>Loosely speaking, a situation with a non-zero Chern number is a bit like having a magnetic monopole, because we have a finite flux coming out of a closed surface. Now, you probably know that experimentally a magnetic monopole was never observed. For our Chern number in the Brillouin zone the situation is more exciting, as situations where it is non-zero are realized in nature.</p><p>To see how this can happen, we first have to understand the following: if there is Berry curvature in the Brillouin zone, what are its sources?</p><h1 id="Gap-closings-are-sources-of-Berry-curvature"><a href="#Gap-closings-are-sources-of-Berry-curvature" class="headerlink" title="Gap closings are sources of Berry curvature"></a>Gap closings are sources of Berry curvature</h1><p>The Berry phase can only be computed if the Hamiltonian has a gap. For a Hamiltonian $H(\mathbf{k})$ with many bands $E_n(\mathbf{k})$, this means that we can compute the Chern number only for an isolated band $E_n(\mathbf{k})$ which does not touch any other band. If there is a band touching, the Berry phase is undefined.</p><p>Now let’s go back to our analogy with electromagnetism. We know that we cannot compute the electric or magnetic flux through a surface if there are electric or magnetic charges sitting exactly on it. That’s because the electric or magnetic fields are <em>not defined</em> at the points where their sources are.</p><p>This analogy suggests the following: that the sources for Berry flux in momentum space are points where two bands touch, just like the Dirac points at the $\mathbf{K}$ and $\mathbf{K}’$ points of the Brillouin zone in graphene.</p><p>This may sound a bit abstract and confusing: where are these points located? We are used to thinking about sources of flux in real space, not in momentum space. In fact, just like you do with a two-dimensional sphere surrounding a charge in three-dimensional space, you can think of the Brillouin zone as lying in a three-dimensional space, with two directions given by $k_x$ and $k_y$ and the third given by the <strong>magnitude of the energy gap</strong>. </p><p>The situation is explained by the following sketch, which also gives a bird’s-eye view of the phase diagram of the Haldane model as a function of the ratio $t_2/M$:</p><img src="/2021/01/07/src/w4_haldane/haldane_model/phasediagram.svg" alt="Phase diagram" style="width: 70%"><p>What you see in the sketch above is a schematic illustration of the energy spectrum close to the Dirac points in the Brillouin zone, for some representative values of $t_2/M$ (for simplicity we drew the Brillouin zone as a square and not a hexagon, but that’s not essential). The two massless Dirac cones appearing for $t_2=\pm M/(3\sqrt{3})$ are the sources of the Berry curvature, which then “spreads“ along the vertical axis, passing through the Brillouin zones of the gapped phases.</p><p>The $t_2=0$ Brillouin zone is “sandwiched“ between the two gap closings: it has opposite curvature for the two Dirac points, and a total Chern number of zero.</p><p>The Brillouin zones for $|t_2|&gt;M/(3\sqrt{3})$, on the other hand, have Berry curvature with the same sign for both Dirac points, and a total Chern number equal to $\pm 1$.</p><p>To see this more clearly, we can compute the Berry curvature numerically and plot it over the whole Brillouin zone as a function of $t_2$:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>, t_2=<span class="literal">None</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">&quot;infinite&quot;</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;title&quot;</span>: title, <span class="string">&quot;ks&quot;</span>: np.linspace(-<span class="number">2</span> * np.pi, <span class="number">2</span> * np.pi, <span class="number">150</span>, endpoint=<span class="literal">False</span>)&#125;</span><br><span class="line">t_2s = np.linspace(-<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.t_2: plot_berry_curvature(syst, p, **kwargs) <span class="keyword">for</span> p.t_2 <span class="keyword">in</span> t_2s&#125;, kdims=[<span class="string">r&quot;$t_2$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">question = <span class="string">&quot;How does time-reversal symmetry influence the Berry curvature?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The Berry curvature breaks time-reversal, so it must be zero if time-reversal is present.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Time reversal symmetry doesn&#x27;t constrain Berry curvature at all.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There is no constraint, only the integral of Berry curvature (Chern number) should be zero.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Berry curvature and momentum change sign under time-reversal, so that the Berry curvature &quot;</span></span><br><span class="line">    <span class="string">&quot;at one momentum becomes opposite to the Berry curvature at opposite momentum.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(question=question, answers=answers, correct_answer=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>You can see that the Berry curvature is really located around the Dirac points. Around $t_2=0$, the two Dirac points give canceling contributions. After a gap closing however, the contribution of one of the two Dirac points changes sign, so that the two add to $\pm 1$ instead of canceling each other.</p><p>From both the plots above, you can also infer that each Dirac point always contributes a Berry curvature equal to $\pm 1/2$, depending on the sign of the mass in the effective Dirac Hamiltonian. We always obtain an integer number because the number of Dirac points in the Brillouin zone is even. It also implies that when the gap changes sign at a Dirac point, the Chern number changes by exactly one!</p><p>At the same time it’s important to know that the particular distribution of the Berry curvature depends on all the details of the eigenstates of the Hamiltonian, so it changes a lot from model to model. And in fact, it is a special feature of the Haldane model that the Berry curvature is focused around two distinct points in the Brillouin zone.</p><p>For instance, here is a slider plot for the Berry curvature for the quantum Hall lattice model studied in the previous chapter.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, gamma=-<span class="number">0.5</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = Qi_Wu_Zhang()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title_Qi</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$t=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$, $\gamma=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    <span class="keyword">return</span> title.<span class="built_in">format</span>(p.t, p.mu, p.delta, p.gamma)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kwargs = &#123;<span class="string">&quot;title&quot;</span>: title_Qi&#125;</span><br><span class="line">mus = np.linspace(-<span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: plot_berry_curvature(syst, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>You can see that for $\mu &lt; -2t - 2\gamma$ there is a net curvature, and that when $\mu = -2t - 2\gamma$ some flux of opposite sign appears at $k_x = k_y=0$, the Dirac point, which leaves no net curvature and leads to a change in the Chern number. This is the signature of the topological transition seen from the Berry curvature.</p><h1 id="Summary-extending-the-model-to-spinful-electrons-and-photons"><a href="#Summary-extending-the-model-to-spinful-electrons-and-photons" class="headerlink" title="Summary: extending the model to spinful electrons and photons"></a>Summary: extending the model to spinful electrons and photons</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;0gxE68kvdmw&quot;</span>, src_location=<span class="string">&quot;4.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>Questions about what you just learned? Ask them below!</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Haldane model&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    
  </entry>
  
</feed>
