<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2021/01/16/hexo%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="用Hexo部署博客到Ubuntu服务器"><a href="#用Hexo部署博客到Ubuntu服务器" class="headerlink" title="用Hexo部署博客到Ubuntu服务器"></a>用Hexo部署博客到Ubuntu服务器</h1><h1 id="本地安装Hexo-node-js-git"><a href="#本地安装Hexo-node-js-git" class="headerlink" title="本地安装Hexo,node.js,git"></a>本地安装Hexo,node.js,git</h1><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>首先需要一台Ubuntu服务器，并且可以用<code>ubuntu</code>用户身份正常登陆.</p>
<h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>配置服务器的登陆选项，添加SSH，SSH公钥就用之前安装git时生成的公钥即可.</p>
<p>在本地下载Xshell等工具，登陆方式也可以选为本地的私钥.</p>
<blockquote>
<p>注意在使用Xshell等终端时，若不小心键入了<code>ctrl+s</code>, 则这个命令为暂时挂起终端，只需要按<code>ctrl+q</code>即可继续输入</p>
</blockquote>
<h2 id="安装Git和Nginx"><a href="#安装Git和Nginx" class="headerlink" title="安装Git和Nginx"></a>安装Git和Nginx</h2><p>Git 用于版本管理和部署，Nginx 用于静态博客托管。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git nginx -y</span><br></pre></td></tr></table></figure>

<h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><p>在<code>/var/repo/</code>下创建名为<code>hexo_static</code>的裸仓库。用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/repo/</span><br><span class="line">sudo chown -R $USER:$USER /var/repo/</span><br><span class="line">sudo chmod -R 755 /var/repo/</span><br><span class="line"></span><br><span class="line">cd /var/repo/</span><br><span class="line">git init --bare hexo_static.git</span><br></pre></td></tr></table></figure>

<h2 id="配置Nginx托管文件目录"><a href="#配置Nginx托管文件目录" class="headerlink" title="配置Nginx托管文件目录"></a>配置Nginx托管文件目录</h2><p>创建<code>/var/www/hexo</code>目录，用于Nginx托管，修改目录所有权和权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /var/www/hexo</span><br><span class="line"></span><br><span class="line">sudo chown -R $USER:$USER /var/www/hexo</span><br><span class="line">sudo chmod -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure>

<p>随后修改Nginx的<code>default</code>设置，使<code>root</code>指向<code>hexo</code>目录.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-available/<span class="keyword">default</span></span><br></pre></td></tr></table></figure>

<p>注意一定要加<code>sudo</code>,否则会提醒<code>default</code>是只读文件.</p>
<p>修改文件中对应的项</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span> default_server;</span><br><span class="line">    listen [::]:<span class="number">80</span> default_server ipv6only=<span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line">    root /<span class="keyword">var</span>/www/hexo; # 需要修改的部分</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Vim的操作方法比较特殊，可以在网上查查</p>
</blockquote>
<p>重启Nginx服务，使得改动生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>

<h2 id="创建Git钩子"><a href="#创建Git钩子" class="headerlink" title="创建Git钩子"></a>创建Git钩子</h2><blockquote>
<p>不清楚钩子是什么</p>
</blockquote>
<p>在自动生成的 hooks 目录下创建一个新的钩子文件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">vim /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<p>在该文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/hexo_static.git checkout -f</span><br></pre></td></tr></table></figure>

<p>保存并退出文件，并让该文件变为可执行文件。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">chmod +x /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<h1 id="回到本地配置"><a href="#回到本地配置" class="headerlink" title="回到本地配置"></a>回到本地配置</h1><h2 id="修改Hexo的默认配置"><a href="#修改Hexo的默认配置" class="headerlink" title="修改Hexo的默认配置"></a>修改Hexo的默认配置</h2><p>在站点config.yml中修改博客的地址<code>url</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site <span class="keyword">is</span> put <span class="keyword">in</span> a subdirectory, <span class="keyword">set</span> url <span class="keyword">as</span> <span class="string">&#x27;http://yoursite.com/child&#x27;</span> and root <span class="keyword">as</span> <span class="string">&#x27;/child/&#x27;</span></span><br><span class="line"></span><br><span class="line">url: http:<span class="comment">//server-ip # 没有绑定域名时填写服务器的实际 IP 地址。</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>

<h2 id="通过Git部署"><a href="#通过Git部署" class="headerlink" title="通过Git部署"></a>通过Git部署</h2><p>先在任意位置处打开powershell, 从服务器上把<code>hexo_static</code>仓库克隆下来, 以此来将服务器地址添加到受信任的站点中。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git clone ubuntu<span class="variable">@server_ip</span><span class="symbol">:/var/repo/hexo_static</span>.git</span><br></pre></td></tr></table></figure>

<p>注意在第一次进行这一步时会提示是否继续，选yes即可。</p>
<p>再编辑Hexo的<code>config.yml</code>文件，找到Deployment, 修改为</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line">  <span class="symbol">type:</span> git</span><br><span class="line">   <span class="symbol">repo:</span> ubuntu<span class="variable">@server_ip</span><span class="symbol">:/var/repo/hexo_static</span>.git</span><br><span class="line">  <span class="symbol">branch:</span> master</span><br></pre></td></tr></table></figure>

<p>最后记得安装Hexo部署到Git仓库的包.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>于是就可用<code>hexo d</code>命令来部署了。大功告成。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w1_topointro/0d/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line">%opts Layout [sublabel_format=<span class="string">&#x27;&#x27;</span> aspect_weight=<span class="number">1</span> figure_size=(<span class="number">100</span>) vspace=<span class="number">0.4</span>]</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">randn = np.random.randn</span><br><span class="line"></span><br><span class="line">alphas = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">dims = SimpleNamespace(</span><br><span class="line">    E=holoviews.Dimension(<span class="string">r&quot;$E$&quot;</span>),</span><br><span class="line">    alpha=holoviews.Dimension(<span class="string">r&quot;$\alpha$&quot;</span>),</span><br><span class="line">    Q=holoviews.Dimension(<span class="string">r&quot;$Q$&quot;</span>),</span><br><span class="line">    Q_BdG=holoviews.Dimension(<span class="string">r&quot;$Q_&#123;BdG&#125;$&quot;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_real_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = randn(N, N)</span><br><span class="line">    H += H.T</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cons_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = np.kron(pauli.s0, randn(N, N)) + np.kron(pauli.sz, randn(N, N))</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    H = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random_symplectic_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="keyword">if</span> N % <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Matrix dimension should be a multiple of 2&quot;</span>)</span><br><span class="line">    sy = np.kron(np.eye(N // <span class="number">2</span>), np.array([[<span class="number">0</span>, -<span class="number">1j</span>], [<span class="number">1j</span>, <span class="number">0</span>]]))</span><br><span class="line">    h = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    h += h.T.conj()</span><br><span class="line">    Th = sy @ h.conj() @ sy</span><br><span class="line">    <span class="keyword">return</span> (h + Th) / <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_chiral_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    temp1 = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    temp2 = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    H = np.kron(pauli.sx, temp1) + np.kron(pauli.sy, temp2)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_BdG_ham</span>(<span class="params">N</span>):</span></span><br><span class="line">    <span class="comment"># This is antisymmetric basis</span></span><br><span class="line">    H = <span class="number">1j</span> * randn(<span class="number">2</span> * N, <span class="number">2</span> * N)</span><br><span class="line">    H += H.T.conj()</span><br><span class="line">    <span class="keyword">return</span> H / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">energies</span>(<span class="params">alpha, H0, H1</span>):</span></span><br><span class="line">    H = (<span class="number">1</span> - alpha) * H0 + alpha * H1</span><br><span class="line">    <span class="keyword">return</span> np.linalg.eigvalsh(H)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_spectrum</span>(<span class="params">alphas, H0, H1</span>):</span></span><br><span class="line">    spectrum = [energies(a, H0, H1) <span class="keyword">for</span> a <span class="keyword">in</span> alphas]</span><br><span class="line">    <span class="keyword">return</span> np.array(spectrum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_Q</span>(<span class="params">spectrum</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Finds the number of bands that are under zero energy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    spectrum : numpy array</span></span><br><span class="line"><span class="string">        Array that contains the energies levels for every alpha.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    Q : list</span></span><br><span class="line"><span class="string">        Number of bands under zero energy.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">len</span>(s[s &lt; <span class="number">0</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> spectrum]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_hamiltonian_spectrum</span>(<span class="params">alphas, spectrum, E_range=(<span class="params">-<span class="number">4</span>, <span class="number">4</span></span>)</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function that plots a spectrum for a range of alphas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    spectrum : numpy array</span></span><br><span class="line"><span class="string">        Array that contains the energies levels for every alpha.</span></span><br><span class="line"><span class="string">    E_range : tuple</span></span><br><span class="line"><span class="string">        The upper and lower limit of the y-dimension.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    plot : holoviews.Path object</span></span><br><span class="line"><span class="string">        Plot of alphas vs. spectrum.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    E_min, E_max = E_range</span><br><span class="line">    energy = dims.E.clone()</span><br><span class="line">    energy.<span class="built_in">range</span> = <span class="built_in">tuple</span>(E_range)</span><br><span class="line">    plot = (holoviews.Path((alphas, spectrum), kdims=[dims.alpha, energy]) * holoviews.HLine(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [E_min, <span class="number">0</span>, E_max]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_Q</span>(<span class="params">alphas, Q, Q_range, Q_dim=dims.Q</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function that plots value of Q for a range of alphas.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    Q : numpy array</span></span><br><span class="line"><span class="string">        Vector that contains the value of Q for every alpha.</span></span><br><span class="line"><span class="string">    Q_range : tuple</span></span><br><span class="line"><span class="string">        The upper and lower limit of the y-dimension.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    plot : holoviews.Path object</span></span><br><span class="line"><span class="string">        Plot of alphas vs. Q.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    Q_min, Q_max = Q_range</span><br><span class="line">    Q_mid = (Q_max + Q_min) / <span class="number">2</span></span><br><span class="line">    Q_dim = Q_dim.clone()</span><br><span class="line">    Q_dim.<span class="built_in">range</span> = <span class="built_in">tuple</span>(Q_range)</span><br><span class="line">    plot = holoviews.Area((alphas, Q), kdims=[dims.alpha], vdims=[Q_dim]).opts(style=&#123;<span class="string">&quot;alpha&quot;</span>: <span class="number">0.4</span>&#125;)</span><br><span class="line">    plot *= holoviews.Curve((alphas, Q), kdims=[dims.alpha], vdims=[Q_dim])</span><br><span class="line">    <span class="keyword">return</span> plot.opts(</span><br><span class="line">        plot=&#123;</span><br><span class="line">            <span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</span><br><span class="line">            <span class="string">&quot;yticks&quot;</span>: [<span class="built_in">int</span>(Q_min), <span class="built_in">int</span>(Q_mid), <span class="built_in">int</span>(Q_max)],</span><br><span class="line">            <span class="string">&quot;aspect&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="Topology-and-symmetry"><a href="#Topology-and-symmetry" class="headerlink" title="Topology and symmetry"></a>Topology and symmetry</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;5ysdSoorJz4&quot;</span>, src_location=<span class="string">&quot;1.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Zero-dimensional-quantum-systems"><a href="#Zero-dimensional-quantum-systems" class="headerlink" title="Zero-dimensional quantum systems"></a>Zero-dimensional quantum systems</h1><p>Imagine a quantum system with a finite number of states $N$. The Hamiltonian of such a system is represented by a matrix $H$ of dimension $N\times N$.<br>This matrix is Hermitian, $H=H^\dagger$. Its real eigenvalues $E_n$ correspond to the allowed energies of the system,</p>
<p>$$H,\left|n\right\rangle = E_n,\left|n\right\rangle,,$$</p>
<p>with $\left|n\right\rangle$ the corresponding eigenstate. Let’s say that $H$ describes a small quantum dot with a few levels. We can imagine that the quantum dot is in weak contact with a metallic lead, as in the following sketch:</p>
<p><img src="/2021/01/07/src/w1_topointro/0d/dot.svg" alt></p>
<p>The presence of a metallic lead allows us to measure all the energies $E_n$ of the electronic states in the dot with respect to the Fermi level $E_F$ of the electrons in the metallic lead. In the following we will set $E_F=0$. Hence, all negative energies $E_n&lt;0$ correspond to filled states in the dot, and all positive energies $E_n&gt;0$ to empty states. In the sketch, the lead and the dot are separated by a potential barrier, such that they are only coupled very weakly. Thus, we can still consider the dot as an isolated system, to a good approximation.</p>
<p>We are now ready to start on the main theme of this course, topology.</p>
<h2 id="Topology-and-gapped-quantum-systems"><a href="#Topology-and-gapped-quantum-systems" class="headerlink" title="Topology and gapped quantum systems"></a>Topology and gapped quantum systems</h2><p>Topology studies whether objects can be transformed continuously into each other. In condensed matter physics we can ask whether the Hamiltonians of two quantum systems can be continuously transformed into each other. If that is the case, then we can say that two systems are ‘topologically equivalent’.</p>
<p>If we considered all Hamiltonians without any constraint, every Hamiltonian could be continuously deformed into every other Hamiltonian, and all quantum systems would be topologically equivalent. This changes drastically if we restrict ourselves to systems with an energy gap. This means that there is a finite energy cost to excite the system above its ground state.<br>If an energy gap is present, then the Hamiltonian of the system has no eigenvalues in a finite interval around zero energy.</p>
<p>We can now use the following criterion: we say that two gapped quantum systems are topologically equivalent if their Hamiltonians can be continuously deformed into each other <em>without ever closing the energy gap</em>.</p>
<p>In the following, we will see that often one is interested in some more specific criterion: for instance, that some symmetry may be preserved throughout the continuous path which connects two Hamiltonians.</p>
<p>However, for the moment let’s just see these ideas at play using our quantum dot as a simple test case. Imagine our dot is initially described by a random $H$, such as:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">30</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure>

<p>For simplicity, we have taken $H$ to be real. Let’s now deform this Hamiltonian into another Hamiltonian $H’$, also real. We can imagine that this deformation describes the changes that occur to the dot as an external parameter, such as a gate voltage, is varied. We can parameterize the deformation by</p>
<p>$H(\alpha) = \alpha H’ + (1-\alpha) H,$</p>
<p>so that at $\alpha=0$ we are at the initial Hamiltonian and at $\alpha=1$ we are at the final Hamiltonian. Let’s see what the energy levels do as a function of $\alpha$ (we use more levels here than in the matrix above so that the spectrum looks more interesting).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">69</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum)</span><br></pre></td></tr></table></figure>

<p>You may notice from the plot that as $\alpha$ varies, it can happen that an energy level crosses zero energy. When this happens, we break the condition that there should be an energy gap in the system. Notice, however, that this does not necessarily mean that there is no continuous transformation between $H$ and $H’$ such that the gap does not close. It simply means that this particular path has gap closings. Perhaps it is possible to find another path which does not.</p>
<p>So are $H$ and $H’$ topologically equivalent or not? Let’s look at this situation:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">6</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum)</span><br></pre></td></tr></table></figure>

<p>We see that one level does cross zero (even twice), but it seems obvious that we can just push it down a little bit and we find a continuous path between two Hamiltonians. So we need to come up with an easier way to figure out if Hamiltonians can be transformed into each other or not.</p>
<h1 id="The-concept-of-a-topological-invariant"><a href="#The-concept-of-a-topological-invariant" class="headerlink" title="The concept of a topological invariant"></a>The concept of a topological invariant</h1><p>In order to know whether there is any path which connects $H$ and $H’$ without closing the gap, we can count the number of levels below zero energy, i.e. the number of filled energy levels. This is possible because the eigenvalues of gapped Hamiltonians can move freely as long as they don’t cross zero energy. Therefore continuous transformations exist exactly between Hamiltonians with the same number of energy levels below zero.</p>
<p>Since this number can not change under continuous transformations inside the set of gapped Hamiltonians, we call it a <em>topological invariant</em> $Q$.</p>
<p>Below, we plot the energy levels along our path from $H$ to $H’$ again, together with our topological invariant, the number of filled energy levels. You can see that this number changes between 3, 4 and 5. Hence we can say that $H$ and $H’$ are not topologically equivalent.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">69</span>)</span><br><span class="line">H0 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_real_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum)</span><br><span class="line">    + plot_Q(alphas, Q, [<span class="number">2</span>, <span class="number">6</span>])</span><br><span class="line">).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>The plot makes it clear that we do not actually have to count the number of filled energy levels for both $H$ and $H’$, so it is enough to keep track of <em>zero energy crossings</em>. Whenever an energy level crosses zero energy, the number of levels below zero energy changes. Such a crossing therefore changes the topological invariant. We call that a <em>topological phase transition</em>.</p>
<p>If two Hamiltonians have a different topological invariant, they must be separated by such a transition. In other words, it is impossible to go from one to the other without closing the gap.</p>
<p>On the other hand, if there are equally many levels crossing from below to above zero energy as the other way around, the number of levels below zero energy does not change. The topological invariant is therefore the same for the initial and final Hamiltonian. In this case, there must be a continuous transformation between the initial and final Hamiltonian which does not close the gap.</p>
<p>Once we have identified a topological invariant, we can <em>classify</em> all quantum Hamiltonians according to its value. In this way we create classes of Hamiltonians which are all topologically equivalent, and we can keep track of all the different <em>topological phases</em> that these Hamiltonians can support.</p>
<h2 id="Role-of-conservation-laws"><a href="#Role-of-conservation-laws" class="headerlink" title="Role of conservation laws"></a>Role of conservation laws</h2><p>Let’s now consider the case that the Hamiltonian of the quantum dot satisfies a symmetry constraint. This means that there is a unitary matrix, for example $U = \sigma_z \otimes 1!!1$ where $\sigma_z$ is the third Pauli matrix, such that the Hamiltonian commutes with this matrix:</p>
<p>$$U^\dagger H U = H.$$</p>
<p>This means that the system has a conservation law, and that the Hamiltonian can be brought to a block-diagonal form:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modes = <span class="number">5</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">H0 = make_cons_ham(<span class="number">2</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure>

<p>We can now look at the spectrum and the topological invariant of each subblock individually,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%opts Layout [aspect_weight=<span class="number">1</span> fig_inches=(<span class="number">8</span>, <span class="number">6</span>) fig_size=<span class="number">100</span> ]</span><br><span class="line">np.random.seed(<span class="number">13</span>)</span><br><span class="line">H0 = make_cons_ham(modes)</span><br><span class="line">H1 = make_cons_ham(modes)</span><br><span class="line">spectrum1 = find_spectrum(alphas, H0[:modes, :modes], H1[:modes, :modes])</span><br><span class="line">spectrum2 = find_spectrum(alphas, H0[modes:, modes:], H1[modes:, modes:])</span><br><span class="line">Q1 = find_Q(spectrum1)</span><br><span class="line">Q2 = find_Q(spectrum2)</span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum1, [-<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    + plot_hamiltonian_spectrum(alphas, spectrum2, [-<span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line">    + plot_Q(alphas, Q1, [<span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">    + plot_Q(alphas, Q2, [<span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">).cols(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>and combine them to get the spectrum and the topological invariant of the whole system:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>As you can see, unitary symmetries play a rather boring role. As usual, they allow to reduce the dimension of the problem at hand, but nothing more. There are however other symmetries which can have a rich influence on topology. An important example is time-reversal symmetry, as we will see next.</p>
<h1 id="Time-reversal-symmetry"><a href="#Time-reversal-symmetry" class="headerlink" title="Time-reversal symmetry"></a>Time-reversal symmetry</h1><p>In our previous examples, you might have wondered, whether there was anything special with choosing real matrices? Indeed there was something special. A real Hamiltonian is a manifestation of time-reversal symmetry. Time-reversal symmetry is represented by an anti-unitary operator, and as such it can always be written as the product $\mathcal{T}=U\mathcal{K}$ of a unitary matrix times complex conjugation. In the case above, we had simply $\mathcal{T}\equiv\mathcal{K}$. Our real Hamiltonians clearly obeyed time-reversal symmetry since $H=H^*$.</p>
<p>Let’s now break time-reversal symmetry, create random Hamiltonians with complex entries and see what happens.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">91</span>)</span><br><span class="line">H0 = make_random_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">92</span>)</span><br><span class="line">H0 = make_random_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>As you can see, there aren’t really many differences with the previous case. The different energy levels move, and the topological invariant changes when one of them crosses zero.</p>
<p>There is, however, a very important case where time-reversal symmetry makes a real difference. For systems with spin $1/2$, time-reversal symmetry has the operator</p>
<p>$$<br>\mathcal{T}=i\sigma_y \mathcal{K},<br>$$</p>
<p>with $\sigma_y$ the second Pauli matrix acting on the spin degree of freedom. In that case $\mathcal{T}^2=-1$. A Hamiltonian with this type of time-reversal symmetry obeys the equation</p>
<p>$$<br>H = \sigma_y, H^* \sigma_y.<br>$$</p>
<p>The following matrix is an example of such Hamiltonian:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">49</span>)</span><br><span class="line">H0 = make_random_symplectic_ham(N=<span class="number">4</span>)</span><br><span class="line">pprint_matrix(H0)</span><br></pre></td></tr></table></figure>

<p>Hamiltonians of this type have the following property: every energy eigenvalue $E_n$ is doubly degenerate (Kramers’ degeneracy). We can see the consequences of Kramers’ degeneracy on our game of deforming one random Hamiltonian into another.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">2285</span>)</span><br><span class="line">H0 = make_random_symplectic_ham(N=<span class="number">10</span>)</span><br><span class="line">H1 = make_random_symplectic_ham(N=<span class="number">10</span>)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">Q = find_Q(spectrum)</span><br><span class="line">(plot_hamiltonian_spectrum(alphas, spectrum) + plot_Q(alphas, Q, [<span class="number">3</span>, <span class="number">7</span>])).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>While the spectrum looks quite similar to the previous ones, whenever a line crosses zero energy, our topological invariant makes a jump of two, and not one! In this case, time-reversal symmetry constrains the topological invariant to only take even values. This is an example of how topological properties can be influenced by discrete symmetries.</p>
<h1 id="Sublattice-symmetry"><a href="#Sublattice-symmetry" class="headerlink" title="Sublattice symmetry"></a>Sublattice symmetry</h1><p>We just saw that time-reversal symmetry can forbid the topological invariant to take a certain set of values. We now study another case where a symmetry changes the topological properties dramatically.</p>
<p>Let’s now take a system where we can split all the degrees of freedom into two groups (say group $A$ and group $B$) such that the Hamiltonian only has nonzero matrix elements between two groups, and not inside each group. This situation arises naturally when the lattice has two sublattices, as in the hexagonal carbon lattice of graphene. So let’s imagine our quantum dot is now a graphene dot:</p>
<p><img src="/2021/01/07/src/w1_topointro/0d/graphene_dot.svg" alt></p>
<p>As a consequence of sublattice symmetry, the Hamiltonian of the graphene dot looks like this:</p>
<p>$$<br>H =<br>\begin{pmatrix}<br>0 &amp; H_{AB} \<br>H_{AB}^\dagger &amp; 0<br>\end{pmatrix}.<br>$$</p>
<p>We can once again generate a random Hamiltonian with sublattice symmetry, here:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">98</span>)</span><br><span class="line">pprint_matrix(make_chiral_ham(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>If we introduce a diagonal matrix $\sigma_z$ that equals $+1$ for sites on sublattice $A$, and $-1$ for sites on sublattice $B$, we can write the sublattice symmetry of the Hamiltonian as</p>
<p>$$<br>\sigma_z H \sigma_z = -H.<br>$$</p>
<p>This immediately means that if $(\psi_A, \psi_B)^T$ is an eigenvector of the Hamiltonian with energy $\varepsilon$, then<br>$(\psi_A, -\psi_B)^T$ is an eigenvector with energy $-\varepsilon$. A symmetric spectrum is the consequence of sublattice symmetry.</p>
<p>What does this mean for the topological classification?<br>Clearly, the number of states with negative energy is the same as the number of states with positive energy, and that means we don’t ever expect a single level to cross zero energy.</p>
<p>Let’s once again see if this is correct by transforming a random Hamiltonian with sublattice symmetry into another one.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modes = <span class="number">10</span></span><br><span class="line">np.random.seed(<span class="number">99</span>)</span><br><span class="line">H0 = make_chiral_ham(modes)</span><br><span class="line">H1 = make_chiral_ham(modes)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">3</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>Indeed, we can deform all the Hamiltonians with sublattice symmetry into one another without closing the gap.<br>This means that an extra symmetry may render topological classification trivial.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;OK, let&#x27;s see what we have so far. Which symmetry certainly &quot;</span></span><br><span class="line">    <span class="string">&quot;does not restrict the values that the topological invariant can take?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Spinless time-reversal symmetry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sublattice symmetry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Conservation law&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Spinful time-reversal symmetry&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;We cannot be sure about the conservation law, since the blocks may have different remaining symmetries. &quot;</span></span><br><span class="line">    <span class="string">&quot;And we just saw that sublattice symmetry makes every system trivial, while spinful time-reversal &quot;</span></span><br><span class="line">    <span class="string">&quot;makes the numbers of levels even.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">0</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Particle-hole-symmetry"><a href="#Particle-hole-symmetry" class="headerlink" title="Particle-hole symmetry"></a>Particle-hole symmetry</h1><p>There is another symmetry that has a strong influence on topology: particle-hole symmetry. It shows up in superconducting systems. As an example, imagine bringing our quantum dot in contact with a superconductor, like this:</p>
<p><img src="/2021/01/07/src/w1_topointro/0d/SCdot.svg" alt></p>
<p>A superconductor will create and annihilate pairs of electrons by breaking apart <a href="https://en.wikipedia.org/wiki/Cooper_pair">Cooper pairs</a> and forming them.<br>This results in a Hamiltonian:</p>
<p>$$<br>\mathcal{H} = \sum_{nm} H_{nm} c^\dagger_nc_m + \tfrac{1}{2} (\Delta_{nm} c^\dagger_n c^\dagger_m + \Delta^*_{nm} c_m c_n),<br>$$</p>
<p>where $c^\dagger_n, c_n$ are the creation and annihilation operators of the electrons. We recall that these operators anticommute, obeying the relations $c_nc_m+c_mc_n=0$ and $c^\dagger_n c_m + c_m c^\dagger_n = \delta_{mn}$, where $\delta_{mn}=0$ if $m\neq n$ and $1$ if $m=n$.</p>
<p>The $H$-term is the dynamics of the electrons in the dot, while $\Delta$ describes the pair creation and annihilation. The matrix $\Delta$ is antisymmetric because the fermion operators anticommute. Now $\mathcal{H}$ does not conserve the number of electrons, but still conserves the parity of the number of electrons, that is whether the number of electrons is even or odd. We can now group all the creation and annihilation operators in a vector, $C = (c_1, \dots, c_n, c^\dagger_1, \dots, c^\dagger_n)^T$. Then we write $\mathcal{H}$ in the form ‘row multiplies matrix multiplies column’:</p>
<p>$$<br>\mathcal{H} = \frac{1}{2} C^\dagger H_\textrm{BdG},C,.<br>$$</p>
<p>The matrix $H_\textrm{BdG}$ is known as the Bogoliubov-de Gennes Hamiltonian, and it has the following structure:</p>
<p>$$<br>H_\textrm{BdG} = \begin{pmatrix} H &amp; \Delta \ -\Delta^* &amp; -H^* \end{pmatrix}.<br>$$</p>
<p>The Bogoliubov-de Gennes Hamiltonian acts on wave functions whose first half is composed out of annihilation operators of electrons, and the second half out of creations operators of the same electrons.<br>We can think of them as annihilation operators of an extra set of holes, so that we double the amount of degrees of freedom in the system.</p>
<p>Since holes are related to the electrons, $H_{BdG}$ automatically has an extra symmetry.<br>This symmetry exchanges electrons with holes, and has an antiunitary operator $\mathcal{P}=\tau_x \mathcal{K}$, where the Pauli matrix $\tau_x$ acts on the particle and hole blocks. We have that:</p>
<p>$$<br>\mathcal{P} H_\textrm{BdG} \mathcal{P}^{-1} = -H_\textrm{BdG}.<br>$$</p>
<p>Particle-hole symmetry is represented by an anti-unitary operator which anti-commutes with the Hamiltonian (compare this situation with that of time-reversal and sublattice symmetries). Because of the minus sign in the particle-hole symmetry, the spectrum of $H_\textrm{BdG}$ must be symmetric around zero energy (that is, the Fermi level). Indeed, for every eigenvector $\psi = (u, v)^T$ of $H_\textrm{BdG}$ with energy $E$, there will be a particle-hole symmetric eigenvector $\mathcal{P}\psi=(v^<em>, u^</em>)^T$ with energy $-E$.</p>
<h2 id="Fermi-level-crossings-in-a-random-Bogoliubov-de-Gennes-Hamiltonian"><a href="#Fermi-level-crossings-in-a-random-Bogoliubov-de-Gennes-Hamiltonian" class="headerlink" title="Fermi level crossings in a random Bogoliubov-de Gennes Hamiltonian"></a>Fermi level crossings in a random Bogoliubov-de Gennes Hamiltonian</h2><p>Let’s generate a random Bogoliubov-de Gennes Hamiltonian $H_\textrm{BdG}$:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modes = <span class="number">2</span></span><br><span class="line">np.random.seed(<span class="number">101</span>)</span><br><span class="line">H0 = make_BdG_ham(modes)</span><br><span class="line">H1 = make_BdG_ham(modes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print in &#x27;normal&#x27; basis</span></span><br><span class="line">H0_normal = np.kron(np.array([[<span class="number">1</span>, -<span class="number">1j</span>], [<span class="number">1</span>, <span class="number">1j</span>]]), np.identity(modes)) @ H0</span><br><span class="line">H0_normal = H0_normal @ np.kron(np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1j</span>, -<span class="number">1j</span>]]), np.identity(modes))</span><br><span class="line">pprint_matrix(H0_normal)</span><br></pre></td></tr></table></figure>

<p>We can now see what happens when we deform it into a second one. You can indeed see clearly that the spectrum is mirrored around the line $E=0$, just like it was in the presence of sublattice symmetry.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">modes = <span class="number">10</span></span><br><span class="line">np.random.seed(<span class="number">5</span>)</span><br><span class="line">H0 = make_BdG_ham(modes)</span><br><span class="line">H1 = make_BdG_ham(modes)</span><br><span class="line">spectrum = find_spectrum(alphas, H0, H1)</span><br><span class="line">plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">3</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>You can however notice that, unlike in the case of sublattice symmetry, energy levels do not repel around zero energy, so that crossings at zero energy appear.</p>
<h2 id="Fermion-parity-switches"><a href="#Fermion-parity-switches" class="headerlink" title="Fermion parity switches"></a>Fermion parity switches</h2><p>Let’s think a bit more about these crossings. At first, they might look a bit mysterious. In general a crossing between energy levels happens in the presence of a conserved quantity, and our random Bogoliubov-de Gennes Hamiltonian does not seem to have an obvious one. Let’s however recall what we said earlier: While the mean-field Hamiltonian of a superconductor does not conserve the number of particles, it conserves the parity of this number. In other words, forming and breaking Cooper pairs does not affect whether the superconducting quantum dots contains an even or odd number of electrons. In short, fermion parity is a conserved quantity (provided that isolated electrons do not enter or leave the dot, a possibility which we will disregard).</p>
<p>The above observation reveals that the existence of crossings is due to the fermion parity conservation. Fermion parity, however, is a many-body quantity, which cannot be directly described in terms of the single particle picture of the Bogoliubov-de Gennes Hamiltonian.<br>To understand the existence of the crossings, recall that to obtain a Bogoliubov-de Gennes description of the superconductor we had to double the number of degrees of freedom by introducing holes.<br>Hence, unlike in the case of sublattice symmetry, a pair of $\pm E$ energy levels does not corresponds to two distinct quantum states, but to a <em>single</em> quantum state.<br>This quantum state is a coherent superposition of electrons and holes - a <em>Bogoliubov quasiparticle</em>: it has an excitation energy $E$, and it is created by an operator $a^\dagger = u c^\dagger + v c$.<br>Populating the partner state at energy $-E$ is the same as emptying the positive energy state.</p>
<p>When a pair of levels crosses zero energy, the excitation energy $E$ of the Bogoliubov quasiparticle changes sign and it becomes favorable to add a Bogoliubov quasiparticle to, or remove it from the superconducting quantum dot. In other words, at each crossing the fermion parity in the ground state of the dot changes from even to odd, or vice versa. Hence these crossings are <em>fermion parity switches</em>.</p>
<p>Since the ground state fermion parity is preserved by the superconducting Hamiltonian if there are no Bogoliubov quasiparticles crossing zero energy, the ground state fermion parity is the topological invariant of this system. It is clear however that this invariant is of a different nature than the one of the non-superconducting systems, which is given by the number of negative eigenvalues of the Hamiltonian. The latter cannot change for a Bogoliubov-de Gennes Hamiltonian, which has a symmetric energy spectrum, and hence it is not suitable to describe changes in fermion parity. Is there a way to compute this new invariant directly from the Bogoliubov-de Gennes Hamiltonian?</p>
<h2 id="The-Pfaffian-invariant"><a href="#The-Pfaffian-invariant" class="headerlink" title="The Pfaffian invariant"></a>The Pfaffian invariant</h2><p>In order to introduce the new invariant, we have to start with a basis transformation, that makes the Hamiltonian an antisymmetric matrix. We use the following unitary transformation in particle-hole space,</p>
<p>$$<br>\tilde{H}<em>{BdG}=\frac{1}{2}\left( \begin{array}{cc}<br>1 &amp; 1 \<br>i &amp; -i \end{array} \right)<br>H</em>{BdG}<br>\left( \begin{array}{cc}<br>1 &amp; -i \<br>1 &amp; i \end{array} \right),.<br>$$</p>
<p>We then have</p>
<p>$$<br>\tilde{H}_\textrm{BdG} = \frac{1}{2}\begin{pmatrix} H-H^<em>+\Delta-\Delta^</em> &amp; -iH-iH^<em>+i\Delta+i\Delta^</em> \ +iH+iH^<em>+i\Delta+i\Delta^</em> &amp; H-H^<em>-\Delta+\Delta^</em> \end{pmatrix}.<br>$$</p>
<p>We already know that the pairing matrix $\Delta$ is antisymmetric. Since $H$ is Hermitian $H-H^<em>$ is also antisymmetric and $H+H^</em>$ is symmetric. Then we can see that $\tilde{H}_\textrm{BdG}$ is antisymmetric.</p>
<p>There is a special number that we can compute for antisymmetric matrices, the <a href="http://en.wikipedia.org/wiki/Pfaffian">Pfaffian</a>. Its rigorous definition is not important for our course. The basic idea is simple: The eigenvalues of antisymmetric matrices always come in pairs. In the case of our $\tilde{H}_{BdG}$, these are the energy eigenvalues $\pm E_n$. By taking their product we obtain the determinant of the matrix, equal to $\prod_n (-E_n^2)$. The key property of the Pfaffian is that it allows to take a square root of the determinant, equal to $\pm \prod_n iE_n$, in such a way that the sign of the product is uniquely defined. At a fermion parity switch a single $E_n$ changes sign, so the Pfaffian changes sign as well (while the determinant stays the same).</p>
<p>This feature of the Pfaffian really makes it what we are looking for. Let’s try out the sign of the Pfaffian as our topological invariant $Q_\textrm{BdG}$:</p>
<p>$$ Q_\textrm{BdG} = \textrm{sign}\left[,\textrm{Pf} (i H_\textrm{BdG}),\right],.$$</p>
<p>We have included a factor of $i$ just for convenience, so that the Pfaffian is a real number.</p>
<p>Whenever we need to compute a Pfaffian we just use the <a href="http://arxiv.org/abs/1102.3440">Pfapack</a> package that calculates Pfaffians for numerical matrices. Let’s use that package and check that the Pfaffian indeed allows us to calculate the fermion parity of the ground state of $H_\textrm{BdG}$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_pfaffian</span>(<span class="params">alphas, H0, H1</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Function caculates the Pfaffian for a Hamiltonian.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    alphas : numpy array</span></span><br><span class="line"><span class="string">        Range of alphas for which the energies are calculated.</span></span><br><span class="line"><span class="string">    H0 : numpy array</span></span><br><span class="line"><span class="string">        Hamiltonian, same size as H1.</span></span><br><span class="line"><span class="string">    H1 : numpy array</span></span><br><span class="line"><span class="string">        Hamiltonian, same size as H0.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    pfaffians : numpy array</span></span><br><span class="line"><span class="string">        Pfaffians for each alpha.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">H</span>(<span class="params">alpha</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> - alpha) * H0 + alpha * H1</span><br><span class="line"></span><br><span class="line">    pfaffians = [np.sign(np.real(pf.pfaffian(<span class="number">1j</span> * H(a)))) <span class="keyword">for</span> a <span class="keyword">in</span> alphas]</span><br><span class="line">    <span class="keyword">return</span> np.array(pfaffians)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pfaffian = find_pfaffian(alphas, H0, H1)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    plot_hamiltonian_spectrum(alphas, spectrum, [-<span class="number">1.5</span>, <span class="number">1.5</span>])</span><br><span class="line">    + plot_Q(alphas, pfaffian, [-<span class="number">1.2</span>, <span class="number">1.2</span>], dims.Q_BdG)</span><br><span class="line">).cols(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>You can see how the Pfaffian invariant $Q_\textrm{BdG}$ changes its value from $+1$ to $-1$ at every zero-energy crossing.<br>This means that it is the correct expression for the ground state fermion parity and for the topological invariant.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens to the topological invariant if we take the superconducting&quot;</span></span><br><span class="line">    + <span class="string">&quot; Hamiltonian and set $\Delta=0$?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The Pfaffian invariant still captures all of the topological properties.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hamiltonian loses particle-hole symmetry and becomes topologically trivial.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hamiltonian now has a new conservation law so there are two blocks, each with its own invariant.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It isn&#x27;t allowed to set $\Delta=0$&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;If $\Delta=0$ the numbers of filled electron and hole states is conserved, and so the invariant once again&quot;</span></span><br><span class="line">    <span class="string">&quot; becomes just the number of filled states.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;C7HoXjVbpoM&quot;</span>, src_location=<span class="string">&quot;1.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Hamiltonians, Topology and Symmetry&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w0_background/band_structures/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="A-quick-review-of-band-structures"><a href="#A-quick-review-of-band-structures" class="headerlink" title="A quick review of band structures"></a>A quick review of band structures</h1><p>For the material of this course we assume familiarity with basic linear algebra, quantum mechanics and solid state physics.<br>In this chapter, we briefly review the concepts most relevant to this course.<br>If you think you know how you would proceed if you are given to compute the bandstructure of graphene then you can likely skip this chapter.</p>
<h2 id="Quantum-mechanics-electrons-as-waves"><a href="#Quantum-mechanics-electrons-as-waves" class="headerlink" title="Quantum mechanics: electrons as waves"></a>Quantum mechanics: electrons as waves</h2><p>Quantum mechanics begins with stating that particles such as electrons should really be treated<br>as waves. These waves are described by the famous Schrodinger equation<br>$$i\hbar\partial_t \Psi = H\Psi,$$<br>where at this point $\Psi$ is the “wave-function” and $H$ is the Hamiltonian.<br>The problem of analyzing this Schrodinger equation can be reduced to the eigenvalue problem in linear algebra, though in many cases the vector space might be infinite dimensional.<br>In the following, we assume familiarity with basic finite dimensional linear (matrix) algebra.</p>
<h3 id="Schrodinger-equation-besides-electrons"><a href="#Schrodinger-equation-besides-electrons" class="headerlink" title="Schrodinger equation besides electrons"></a>Schrodinger equation besides electrons</h3><p>Our main focus is quantum-mechanical systems, however, as we will see, many ideas apply also in completely classical context of sound propagation and elasticity.<br>To see this, let us  convert a familiar wave-equation for a string in to a Schrodinger-like form.<br>You must have seen a wave-equation for a string that looks like<br>$$\partial_t^2 h-c^2\partial_x^2 h=0,$$<br>where $h(x,t)$ is the vertical displacement of the string.<br>This wave-equation is second order in time.<br>Let’s try to make it first order like the Schrodinger equation by defining $h_1(x,t)=c^{-1} \partial_t h(x,t)$ and $h_2(x,t)=\partial_x h(x,t)$.<br>After doing this we see that our wave-equation turns into a pair of equations that are linear order in time:<br>$$\partial_t h_2 = c\partial_x h_1$$<br>and<br>$$\partial_t h_1=-c\partial_x h_2.$$</p>
<p>We can turn this into the Schrodinger equation if we define:<br>$$\Psi(x,t)=\left(\begin{array}{c}h_1(x,t)\h_2(x,t)\end{array}\right)\quad H=c\left(\begin{array}{cc}0&amp; i\-i &amp; 0\end{array}\right)(-i\partial_x).$$<br>Now those of you who know basic quantum mechanics might say this is a very strange Schrodinger equation.<br>But this indeed is the wave-function for helical Majorana particles that we encounter later on.</p>
<h3 id="Applying-the-Schrodinger-equation"><a href="#Applying-the-Schrodinger-equation" class="headerlink" title="Applying the Schrodinger equation"></a>Applying the Schrodinger equation</h3><p>The wave-function $\Psi$ in the Schrodinger equation that describes electrons is typically a complex though the Hamiltonian is not a matrix (thankfully):<br>$$H=-\frac{\hbar^2}{2m}\partial_x^2 + V(x),$$<br>where $m$ is the mass of the electron and $V(x)$ is the background potential energy over which the electron is moving.</p>
<p>The main things that you should remember about wave equations for electrons are:  </p>
<ul>
<li>$\Psi(x,t)$ is complex, </li>
<li>$H$ is a Hermitian  matrix or operator </li>
<li>density of electrons are related to $|\Psi(x,t)|^2$.</li>
<li>If $N$ is the number of electrons, one must occupy $N$ orthogonal wave-functions.</li>
</ul>
<p>The last point is more subtle and is called the <strong>Pauli exclusion principle</strong>. We elaborate on orthogonality later.</p>
<p>Since we are interested in static properties of electrons in materials for much of our course, it helps to make the simplifying ansatz: $\Psi=e^{-i E t/\hbar}\psi$.<br>This ansatz simplifies the Schrodinger equation to a time-independent form:<br>$$H\psi=E\psi,$$<br>which is an eigenvalue problem in linear algebra.</p>
<p>We can often model electrons in materials within the  <strong>tight-binding</strong> approximation where electrons are assumed to occupy a discrete set of orbitals.<br>We then take $\psi_a$ to be the wave-function of the electron on orbital $a$.<br>The wave-functions $\psi_a$ can be combined into $\psi$, which is then a vector.<br>In this case, the Hamiltonian $H$ becomes a matrix with components $H_{ab}$.<br>These definitions transform the time-independent Schrodinger equation into a matrix eigenvalue problem from linear algebra.<br>Once we know how to set-up the matrix $H_{ab}$ to model a particular material, we can extract the properties of the material from the wave-function components $\psi_a$ and energy (eigenvalue) $E$.<br>A few key properties of the Schrodinger equation $H\psi^{(n)}=E^{(n)}\psi^{(n)}$ are: </p>
<ul>
<li>if $H$ is an $N\times N$ matrix, the eigenvalue index $n$ goes from $n=1,\dots,N$. </li>
<li>$H$ is Hermitian i.e. $H_{ab}=H_{ba}^*$. </li>
<li>Eigenstates are orthogonal i.e. $\psi^{(n)\dagger} \psi^{(m)}=0$ for $m\neq n$.</li>
</ul>
<p>Physicists have a convenient notation for doing linear algebra called the Dirac <strong>bra-ket</strong> notation.<br>In this notation, wave-functions such as $\psi$ are represented by <strong>kets</strong> i.e. $\psi\rightarrow |\psi\rangle$.<br>We construct the ket $|\psi\rangle$ from the components of the wave-function $\psi_a$ using the equation: $$|\psi\rangle=\sum_a \psi_a |a\rangle.$$<br>Similarly, we turn the Hamiltonian $H$ in to  an <strong>operator</strong> using the equation :$$H=\sum_{ab}H_{ab}|a\rangle \langle b|,$$<br>where $H_{ab}$ are the elements of the matrix $H$ from the last paragraph.<br>We call the object $\langle b|$ a <strong>bra</strong> and together with the ket it forms a bra-ket with the property $\langle b| a\rangle=\delta_{ab}$.<br>The Schrodinger equation now looks like $$H|\psi\rangle = E|\psi\rangle,$$<br>which can be checked to be the same equation as the linear algebra form. </p>
<h3 id="Example-Atomic-triangle"><a href="#Example-Atomic-triangle" class="headerlink" title="Example: Atomic triangle"></a>Example: Atomic triangle</h3><p>Let’s now work out the simple example of electrons moving in a triangle of atoms, where each atom has one orbital. We label the orbitals as $|0\rangle,|1\rangle,|2\rangle$.<br>With this labeling, the <strong>hopping</strong> amplitude $t$ of electrons between orbitals has the Hamiltonian<br>$$H=-t(|0\rangle \langle 1|+|1\rangle \langle 2|+|2\rangle \langle 0|)+h.c,$$<br>where $h.c.$ stands for Hermitian conjugate, which means that you reverse the ordering of the labels and take a complex conjugate.<br>We can also write the Hamiltonian in matrix form<br>$$H_{ab}=-\left(\begin{array}{ccc}0&amp;t&amp;t^<em>\t^</em>&amp;0&amp;t\t&amp;t^*&amp;0\end{array}\right).$$<br>Diagonalizing this matrix is a straightforward exercise that results in three eigenvectors $\psi^{(n)}_a$ (with $n=1,2,3$)<br>corresponding to energy eigenvalues<br>$$E^{(n)}=-2 |t| \cos{\theta},|t|\cos{\theta}\pm |t|\sqrt{3}\sin{\theta}$$<br>(where $t=|t|e^{i\theta}$).<br>The corresponding eigenvectors<br>$$\psi^{(n)}_a=3^{-1/2}(1,1,1),3^{-1/2}(1,\omega,\omega^2),3^{-1/2}(1,\omega^2,\omega)$$<br>where $\omega$ is the cube-root of unity (i.e. $\omega^3=1$).</p>
<h2 id="Bloch’s-theorem-for-bulk-electrons"><a href="#Bloch’s-theorem-for-bulk-electrons" class="headerlink" title="Bloch’s theorem for bulk electrons"></a>Bloch’s theorem for bulk electrons</h2><p>Actually, we can even solve the problem of an electron in an N site ring (triangle being $N=3$).<br>The trick to doing this is a neat theorem called Bloch’s theorem.<br>Bloch’s theorem is the key to understanding electrons in a crystal.<br>The defining property of a crystal is that the atomic positions repeat in a periodic manner in space.<br>We account for ALL the atoms in the crystal by first identifying a finite group of orbitals called the <strong>unit-cell</strong>.<br>We choose the unit-cell so that we can construct the crystal by translating the unit cell by a discrete set of vectors called lattice vectors to $n$.<br>We label the orbitals in the unit-cell by the index $l$, which takes a finite set of values.<br>By combining the unit cell and the lattice vectors, we  construct positions $a=(l,n)$<br>of all the orbitals in the crystal.<br>For our example of an atomic ring of size $N$, the index $l$ wouldn’t be needed since there is only one orbital per unit-cell and $n$ would take values $1$ to $N$.<br>In a three-dimensional crystal, $n=(n_x,n_y,n_z)$ would be a vector of integers.<br>The Hamiltonian for a crystal has matrix elements that satisfy $H_{(l,n),(l’,m)}=H_{(l,n-m),(l’,0)}$ for all pairs of unit-cell $n$ and $m$. </p>
<blockquote>
<p>Bloch’s theorem states that the Schrodinger equation for such Hamiltonians in crystals can be solved by the ansatz: $$\psi_{(l,n)}=e^{i k n}u_l,$$<br>where $u_l$ is the periodic part of the Bloch function which is identical in each unit-cell.</p>
</blockquote>
<p>The parameter $k$ is called crystal momentum and is quite analogous to momentum (apart from a factor of $\hbar$)<br>except that it is confined in the range $k\in [-\pi,\pi]$ which is referred to as the <strong>Brillouin Zone</strong>.<br>You can now substitute this ansatz into the Schrodinger equation: $\sum_{l’m}H_{(l,n),(l’,m)}u_{l’}e^{i k m}=E(k) e^{i k n}u_{l}(k)$.<br> Thus the Bloch functions $u(k)$ and energies $E(k)$ are obtained from the eigenvalue equation (so-called Bloch equation) $$H(k)u(k)=E(k)u(k),$$<br>where $$H(k)<em>{ll’}=\sum</em>{m}H_{(l,-m),(l’,0)}e^{-i k m}.$$<br>The Bloch equation written above is an eigenvalue problem at any momentum $k$.<br>The resulting eigenvalues $E^{(n)}(k)$ consitute the bandstructure of a material, where the eigenvalue label $n$ is also called a band index. </p>
<h3 id="Example-Su-Schrieffer-Heeger-model"><a href="#Example-Su-Schrieffer-Heeger-model" class="headerlink" title="Example: Su-Schrieffer-Heeger model"></a>Example: Su-Schrieffer-Heeger model</h3><p>Let us now work through an example.<br>The Su-Schrieffer-Heeger (SSH) model is the simplest model for polyacetylene, which to a physicist can be thought of as a chain of atoms with one orbital per atom.<br>However, the hopping strength alternates (corresponding to the alternating bond-length ) between $t_1$ and $t_2$.<br>Ususally you could assume that since each orbital has one atom there is only one atom per unit cell.<br>But this would mean all the atoms are identical.<br>On the other hand, in polyacetylene, half the atoms are on the right end of a short bond and half of them are on the left.<br>Thus there are two kinds of atoms - the former kind we label $R$ and the latter $L$. Thus there are two orbitals per unit cell that we label $|L,n\rangle$ and $|R,n\rangle$ with $n$ being the unit-cell label.</p>
<p><img src="/2021/01/07/src/w0_background/band_structures/Trans-_CH_n.svg" alt></p>
<p>The Hamiltonian for the SSH model is<br>$$H=\sum_n {t_1(|L,n\rangle\langle R,n|+|R,n\rangle\langle L,n|)+t_2(|L,n\rangle\langle R,n-1|+|R,n-1\rangle\langle L,n|)}.$$<br>This Hamiltonian is clearly periodic with shift of $n$ and the non-zero matrix elements of the Hamiltonian can be written as $H_{(L,0),(R,0)}=H_{(R,0),(L,0)}=t_1$ and $H_{(L,1),(R,0)}=H_{(R,-1),(L,0)}=t_2$.<br>The $2\times 2$ Bloch Hamiltonian is calculated to be: $$H(k)_{ll’=1,2}=\left(\begin{array}{cc}0&amp; t_1+t_2 e^{i k}\t_1+t_2 e^{-ik}&amp;0\end{array}\right).$$</p>
<p>We can calculate the eigenvalues of this Hamiltonian by taking determinants and we find that the eigenvalues are<br>$$E^{(\pm)}(k)=\pm \sqrt{t_1^2+t_2^2+2 t_1 t_2\cos{k}}.$$<br>Since $L$ and $R$ on a given unit-cell surrounded one of the shorter bonds (i.e. with larger hopping ) we expect $t_1&gt;t_2$. As $k$ varies across $[-\pi,\pi]$, $E^{(+)}(k)$ goes from $t_1-t_2$ to $t_1+t_2$. Note that the other energy eigenvalue is just the negative $E^{(-)}(k)=-E^{(+)}(k)$. </p>
<blockquote>
<p>As $k$ varies no energy eigenvalue $E^{(\pm)}(k)$ ever enters the range $-|t_1-t_2|$ to $|t_1-t_2|$. This range is called an <strong>band gap</strong>, which is the first seminal prediction of Bloch theory that explains insulators.</p>
</blockquote>
<p>This notion of an insulator is rather important in our course.<br>So let us dwell on this a bit further. Assuming we have a periodic ring with $2N$ atoms so that $n$ takes $N$ values, single valuedness of the wave-function $\psi_{(l,n)}$ requires that $e^{i k N}=1$.<br>This means that $k$ is allowed $N$ discrete values separated by $2\pi/N$ spanning the range $[-\pi,\pi]$.<br>Next to describe the lower-energy state of the electrons we can fill only the lower eigenvalue $E^{(-)}(k)$ with ane electron at each $k$ leaving the upper state empty.<br>This describes a state with $N$ electrons. Furthermore, we can see that to excite the system one would need to transfer an electron from a negative energy state to a positive energy state that would cost at least $2(t_1-t_2)$ in energy.<br> Such a gapped state with a fixed number of electrons cannot respond to an applied voltage and as such must be an insulator. </p>
<p>This insulator is rather easy to understand in the $t_2=0$ limit and corresponds to the double bonds in the polyacetylene chain being occupied by localized electrons. </p>
<h2 id="k-cdot-p-perturbation-theory"><a href="#k-cdot-p-perturbation-theory" class="headerlink" title="$k\cdot p$ perturbation theory"></a>$k\cdot p$ perturbation theory</h2><p>Let us now think about how we can use the smoothness of $H(k)$ to predict energies and wave-functions at finite $k$ from $H(k=0)$ and its derivatives.<br>We start by expanding the Bloch Hamiltonian<br>$$H(k)\approx H(k=0)+k H^{‘}(k=0)+(k^2/2)H^{‘’}(k=0)$$.<br>Using standard perturbation theory we can conclude that:<br>  the velocity and mass of a non-degenerate band near $k\sim 0$ is written as<br>  $$v_n =\partial_k E^{(n)}(k)= u^{(n)\dagger} H^{‘}(k=0) u^{(n)}$$<br>  and<br>  $$m_n^{-1}=\partial^2_k E^{(n)}(k)=u^{(n)\dagger} H^{‘’}(k=0) u^{(n)}+\sum_{m\neq n}\frac{|u^{(n)\dagger} H^{‘}(k=0) u^{(m)}|^2}{E^{(n)}(k=0)-E^{(m)}(k=0)},$$<br>where $E^{(n)}(k=0)$ and $u^{(n)}(k=0)$ are energy eigenvalues and eigenfunctions of $H(k=0)$. One of the immediate consequences of this is that the effective mass $m_n $ vanishes as the energy denominator $E^{(n)}(k=0)-E^{(m)}(k=0)$ (i.e. gap ) becomes small. This can be checked to be the case by expanding<br>$$E^{(-)}(k)\simeq -(t_1-t_2)-\frac{t_2^2}{(t_1-t_2)}k^2$$. </p>
<h3 id="Discretizing-continuum-models-for-materials"><a href="#Discretizing-continuum-models-for-materials" class="headerlink" title="Discretizing continuum models for materials"></a>Discretizing continuum models for materials</h3><p>The series expansion of $H(k)$ that we discussed in the previous paragraph is a continuum description of a material.<br>This is because the series expansion is valid for small $k$ that is much smaller than the Brillouin zone.<br>The continuum Hamiltonian is obtained by replacing $k$ in the series expasion by $\hbar^{-1}p$, where $p=-i\hbar\partial_x$ is the momentum operator. </p>
<p>A continuum Hamiltonian is sometimes easier to work with analytically then the crystal lattice of orbitals.<br>On the other hand, we need to discretize the continuum Hamiltonian to simulate it numerically. We can do this representing $k$ as a discrete derivative operator: $$k=-i\partial_x\approx -i(2\Lambda)^{-1}\sum_n (|n+1\rangle\langle n|-|n\rangle\langle n+1|).$$<br>The label $n$ is discrete-analogous to the unit-cell label, where the unit cell has size $\Lambda$.<br>To check that this is a representation of the derivative, apply $i k=\partial_x$ to $|\psi\rangle$ as $i k|\psi\rangle\approx \sum_n \frac{\psi_{n+1}-\psi_{n-1}}{2\Lambda}|n\rangle$.<br>In addition, we need to represent the $N\times N$ matrix structure of $H(k=0)$.<br>This is done by introducing label $a=1,\dots N$ so that the Hamiltonian is defined on a space labeled by $|a,n\rangle$.<br>Applying these steps to the the $k\cdot p$ Hamiltonian takes the discrete form:<br>$$H(k)\approx \sum_{n,a,b} H(k=0)<em>{ab}|a,n\rangle \langle b,n| +i H^{‘}(k=0)</em>{ab}(|a,n+1\rangle\langle b,n|-|a,n\rangle\langle b,n+1|),$$<br>where we have dropped the $k^2$ term for compactness.<br>For future reference, $k^2$ would discretize into $k^2=-\sum_n (|n\rangle \langle n+2|+|n+2\rangle\langle n|-2|n\rangle \langle n|)$.</p>
<p>But wait! Didn’t we just go in a circle by starting in a lattice Hamiltonian and coming back to a discrete Hamiltonian?<br>Well, actually, the lattice in the newly discretized model has almost nothing to do with the microscopic lattice we started with.<br>More often than not, the lattice constant $\Lambda$ (i.e. effective size of the unit-cell) in the latter representation is orders of magnitude larger than the microscopic lattice constant.<br>So the discrete model following from $k\cdot p$ is orders of magnitude more efficient to work with than tht microscopic model, which is why we most often work with these.<br>Of course, there is always a danger of missing certain lattice level phenomena in such a coarse-grained model.<br>Practically, we often do not start with an atomistic lattice model, but rather with a continuum $k\cdot p$ model and then discretize it.<br>This is because, the latter models can often be constrained quite well by a combination symmetry arguments as well as experimental measurements.<br>For example the $k\cdot p$ model for the conduction band minimum state of a GaAs quantum well is<br>$$H(k)=\hbar^2 k^2/2m^<em>+\alpha_R (\sigma_x k_y-\sigma_y k_x),$$<br>where $m^</em>$ is the electron effective mass, $\sigma_{x,y}$ are Pauli matrices and $\alpha_R$ is the Rashba spin-orbit coupling. This model is rather complicated to derive from the atomistic level (though it can be done). On the hand, it has also been checked experimentally through transport.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The main goal of this section was to review the simplest models for how electrons in crystals can be described quantum mechanically.</p>
<p>Let us summarize this review of bandstructures: </p>
<ul>
<li>Quantum mechanics views electrons as waves described by the Schrodinger equation.</li>
<li>The Schrodinger equation written in a basis of orbitals becomes a matrix eigenvalue problem from linear algebra.</li>
<li>The Schrodinger equation for electrons in crystals can be solved using Bloch’s theorem, where crystal momentum $k$ is a good quantum number.</li>
<li>The crystal momentum $k$ is periodic within the Brillouin zone.</li>
<li>We can treat the crystal momentum $k$ as a derivative when $k$ is small - called the $k\cdot p$ approximation.</li>
<li>We solve this Hamiltonian numerically by discretizing the derivative $k$.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w9_disorder/w9_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h1><h2 id="1D-localization"><a href="#1D-localization" class="headerlink" title="1D localization"></a>1D localization</h2><p>As usual, start by grabbing the notebooks of this week (<code>w9_disorder</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<p>Our aim now is to verify that Anderson localization works in one-dimensional systems.</p>
<p>Simulate the Anderson model of a ribbon of appropriate and large width $W$  as a function of length $L$.</p>
<p>Anderson model is just the simpest <a href="http://kwant-project.org/doc/1.0/tutorial/tutorial1">tight binding model on a square lattice</a> with random onsite potential.</p>
<p>Tune your model in the clean limit such that it has a relatively large number of modes (at least 3). Then calculate conductance as a function of $L$ at a finite disorder, while keeping $W$ constant.</p>
<p>The weak disorder regime should look ohmic or classical i.e $g \sim N_{ch}\lambda_{MFP}/L$. Here $\lambda_{MFP}$ is the mean free path, and $N_{ch}$ is the number of channels.</p>
<p>First, verify that when $g \gtrsim 1$ you observe the classical behavior and evaluate the mean free path.</p>
<p>Verify that the scaling also holds for different disorder strengths and different widths.</p>
<p>Examine the plot for larger $L$, but this time plot $\textrm{ln}(g)$ to verify that at large $L$ the conductance $g$ goes as $g \sim \exp(-L/\xi)$. Try to guess how $\xi$ is related to $\lambda_{MFP}$ by comparing the numbers you get from the plot in this part and the previous.</p>
<p>Check what happens when you reduce the disorder? Is there sign of a insulator- metal transition at lower disorder?</p>
<h2 id="Griffiths-phase"><a href="#Griffiths-phase" class="headerlink" title="Griffiths phase"></a>Griffiths phase</h2><p>A disordered Kitaev chain has a peculiar property. Close to the transition point it can have infinite density of states even despite it is insulating.</p>
<p>Calculate the energies of all the states in a finite Kitaev chain with disorder. You’ll need to get the Hamiltonian of the chain by using <code>syst.hamiltonian_submatrix</code> method, and diagonalize it (check the very beginning of the course if you don’t remember how to diagonalize matrices).</p>
<p>Do so for many disorder realizations, and build a histograph of the density of states for different values of average $m$ and of disorder strengh around the critical point $m=0$.</p>
<p>If all goes well, you should observe different behaviors: the density of states in a finite region around $m=0$ has a weak power law divergence, that eventually turns into an actual gap. Check out this paper for details:</p>
<ul>
<li>arXiv:cond-mat/0011200</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Disorder&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-0908-0881"><a href="#arXiv-0908-0881" class="headerlink" title="arXiv:0908.0881"></a>arXiv:0908.0881</h3><p><strong>Hint:</strong> The topological Anderson insulator.</p>
<h3 id="arXiv-0705-0886"><a href="#arXiv-0705-0886" class="headerlink" title="arXiv:0705.0886"></a>arXiv:0705.0886</h3><p><strong>Hint:</strong> One-parameter scaling in graphene.</p>
<h3 id="arXiv-0705-1607"><a href="#arXiv-0705-1607" class="headerlink" title="arXiv:0705.1607"></a>arXiv:0705.1607</h3><p><strong>Hint:</strong> Scaling with Dirac fermions.</p>
<h3 id="arXiv-1208-3442"><a href="#arXiv-1208-3442" class="headerlink" title="arXiv:1208.3442"></a>arXiv:1208.3442</h3><p><strong>Hint:</strong> The average symmetry and weak transitions.</p>
<h3 id="arXiv-1411-5992"><a href="#arXiv-1411-5992" class="headerlink" title="arXiv:1411.5992"></a>arXiv:1411.5992</h3><p><strong>Hint:</strong> A technical paper about localization in 1D, but you don’t need to follow the calculations.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Disorder&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w9_disorder/topoflow/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">from</span> matplotlib.collections <span class="keyword">import</span> LineCollection</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap, BoundaryNorm</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> la</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the path to a folder containing data files, to work with filters as well.</span></span><br><span class="line">data_folder = (</span><br><span class="line">    <span class="string">&quot;data/&quot;</span> <span class="keyword">if</span> os.path.exists(<span class="string">&quot;data&quot;</span>) <span class="keyword">and</span> os.path.isdir(<span class="string">&quot;data&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;../../data/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_kitaev_chain</span>(<span class="params">L=<span class="number">10</span></span>):</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.disorder:</span><br><span class="line">            <span class="keyword">return</span> (p.m + <span class="number">2</span> * p.t) * pauli.sz</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rand = p.disorder * kwant.digest.gauss(<span class="built_in">str</span>(site.tag), p.salt)</span><br><span class="line">            <span class="keyword">return</span> (p.m + rand + <span class="number">2</span> * p.t) * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz - <span class="number">1j</span> * p.delta * pauli.sy</span><br><span class="line"></span><br><span class="line">    syst[(lat(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>,))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The leads are precalculated.</span></span><br><span class="line">    lead[lat(<span class="number">0</span>)] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    syst = syst.precalculate(</span><br><span class="line">        params=<span class="built_in">dict</span>(p=SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">phase_diagram</span>(<span class="params">L, ms, p, num_average=<span class="number">100</span></span>):</span></span><br><span class="line">    syst = make_kitaev_chain(L)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adjust the reflection phase such that it&#x27;s 0 for trivial system.</span></span><br><span class="line">    trivial = SimpleNamespace(m=<span class="number">10.0</span>, t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0</span>, salt=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    phase = kwant.smatrix(syst, params=<span class="built_in">dict</span>(p=trivial)).data[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    phase /= <span class="built_in">abs</span>(phase)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> p.m <span class="keyword">in</span> ms:</span><br><span class="line">        qt = []</span><br><span class="line">        <span class="keyword">for</span> p.salt <span class="keyword">in</span> <span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(num_average)):</span><br><span class="line">            s = kwant.smatrix(syst, params=<span class="built_in">dict</span>(p=p)).data</span><br><span class="line">            qt.append(((s[<span class="number">0</span>, <span class="number">0</span>] / phase).real, <span class="built_in">abs</span>(s[<span class="number">0</span>, <span class="number">1</span>]) ** <span class="number">2</span>))</span><br><span class="line">        qt = np.mean(qt, axis=<span class="number">0</span>)</span><br><span class="line">        data.append(qt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(data).T</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The scaling flow of topological insulators is introduced by Alexander Altland from the University of Cologne</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;8gkERY6hXTU&quot;</span>, src_location=<span class="string">&quot;9.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="A-toy-model-for-two-parameter-scaling-the-disordered-Kitaev-chain"><a href="#A-toy-model-for-two-parameter-scaling-the-disordered-Kitaev-chain" class="headerlink" title="A toy model for two-parameter scaling: the disordered Kitaev chain"></a>A toy model for two-parameter scaling: the disordered Kitaev chain</h1><p>Before we learn what happens to topological insulators in the presence of disorder, let’s decide on a specific example for concreteness.</p>
<p>Topology makes the behavior of disordered systems richer, however a careful simulation of properties of disordered topological insulators may take weeks, since we need not only to take large system sizes (we need to consider the lengths much larger than mean free path), but also we need to average over disorder.</p>
<p>Luckily, unlike in the non-topological case, a one-dimensional system can already show interesting properties in the presence of disorder, so we can just reuse the familiar Kitaev chain and add disorder to it.</p>
<p>It is nothing but the same 1D tight-binding model that we saw in week one,</p>
<p>$$<br>H = \sum_n (\mu_n + 2t + m) \tau_z\left|n\right\rangle\left\langle n\right|-\sum_n \left[(t\tau_z+i\Delta\tau_y),\left|n\right\rangle\left\langle n!+!!1 \right| + \textrm{h.c.}\right].<br>$$</p>
<p>For convenience, we introduced a mass $m$ that corresponds to the gap in the Dirac equation. The phase transition happens at $m=0$, and $m&lt;0$ corresponds to the topological phase with Majorana modes at the end.</p>
<p>The only difference from what we used before is that now the chemical potential $\mu_n$ varies randomly from site to site. For example, we can sample the values $\mu_n$ from a Gaussian distribution with mean value $\mu_0 $ and standard deviation $U$.</p>
<h1 id="The-simpler-effect-of-disorder"><a href="#The-simpler-effect-of-disorder" class="headerlink" title="The simpler effect of disorder"></a>The simpler effect of disorder</h1><p>In addition to transmission through a finite chain we can now compute its topological invariant $\mathcal{Q}$.</p>
<p>Just as a reminder: $\mathcal{Q} = \det r$, with $r$ is the reflection matrix from one end of a finite Kitaev chain.</p>
<p>We know that $\mathcal{Q}=-1$ in the topological phase and $\mathcal{Q}=+1$ in the trivial phase. Now, in the presence of disorder, the value of $\mathcal{Q}$ in a finite size system can in principle depend on the particular disorder realization. So just like calculating average conductance, we can average the topological invariant over disorder to describe how topological properties depend on it.</p>
<p>Whenever $\langle Q\rangle = \pm 1$, we know that the system is in one of the two insulating phases and there is no reflection whatsoever.</p>
<p>Let’s try the most obvious thing and see what happens to  $\langle Q\rangle$, as we increase disorder strength.</p>
<p>So below we see $\mathcal{Q}$ averaged over 100 different realizations in a disordered Kitaev chain with 30 sites as we gradually increase $U$:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>) <span class="keyword">and</span> os.path.exists(</span><br><span class="line">    data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span></span><br><span class="line">):</span><br><span class="line">    ms = np.loadtxt(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>)</span><br><span class="line">    qs = np.loadtxt(data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># This cell generates data</span></span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>)</span><br><span class="line">    ms = np.linspace(-<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">50</span>)</span><br><span class="line">    qs = [phase_diagram(<span class="number">30</span>, ms, p)[<span class="number">0</span>] <span class="keyword">for</span> p.disorder <span class="keyword">in</span> np.linspace(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">10</span>)]</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;first_plot_data_ms.dat&quot;</span>, ms)</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;first_plot_data_qs.dat&quot;</span>, qs)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">ax.set_prop_cycle(<span class="string">&quot;alpha&quot;</span>, np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(qs)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> qs:</span><br><span class="line">    ax.plot(ms, q)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;$m$&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">r&quot;$\langle Q \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">0.4</span>, <span class="number">0</span>, <span class="number">0.4</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">ax.set_xlim(-<span class="number">0.4</span>, <span class="number">0.4</span>)</span><br><span class="line">ax.set_ylim(-<span class="number">1.1</span>, <span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line">ax.hlines(<span class="number">0</span>, ax.get_xlim()[<span class="number">0</span>], ax.get_xlim()[<span class="number">1</span>], linestyles=<span class="string">&quot;dashed&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>(Darker color corresponds to larger $U$.)</p>
<p>What you see is that far away from the transition, when the gap in the clean limit is very large, disorder does not matter. Around the transition, the average value of $\mathcal{Q}$ changes from $-1$ and $+1$.</p>
<p>Increasing disorder changes two things: </p>
<ul>
<li>It makes the width of the region where the transition happens larger. This we can understand relatively well, in a finite system adding fluctuations just means we can be (un)lucky and get an opposite value of the topological invariant.</li>
<li>It shifts the separation point between trivial and topological phases towards positive $m$. This looks much more curious: if we start with a trivial and insulating system and add disorder, it appears we can make this system topological!</li>
</ul>
<p>The second effect, despite looking mysterious, appears just because the disorder changes the effective values of the Hamiltonian parameters. For small $U$, this can be understood in terms of the <a href="https://en.wikipedia.org/wiki/Born_approximation">Born approximation</a>, which allows to compute <em>effective</em> disorder-averaged band structure parameters, given the properties of disorder. The lowest order correction to $m$ for the disorder Kitaev chain is simply $m_\textrm{eff} - m \sim -U^2$, and weak disorder indeed drives the system to a topologically nontrivial state by lowering the effective value of the mass.</p>
<p>Since this phenomenon appears with disorder, it was initially dubbed “topological Anderson insulator”. This name is certainly not accurate: the band structure parameters approach the effective ones on the length scale of mean free path, and before the Anderson scaling flow begins.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">r&quot;What would happen if instead of $\det r$ we use $sign \det r$ for invariant?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;We would get a step function instead of a smooth curve.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;Not well-defined because $\det r$ becomes complex.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The $Q=\pm 1$ plateaus cancel and give $Q=0$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The curve is qualitatively the same.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">r&quot;Each disorder realization get $\textrm&#123;det&#125; r\sim \pm 1$ except near the transition. So adding sign doesn&#x27;t affect &quot;</span></span><br><span class="line">    <span class="string">&quot;the invariant for most disorder realizations. The intermediate values result from averaging over different &quot;</span></span><br><span class="line">    <span class="string">&quot;realizations.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Two-parameter-scaling-in-one-dimension"><a href="#Two-parameter-scaling-in-one-dimension" class="headerlink" title="Two parameter scaling in one dimension"></a>Two parameter scaling in one dimension</h1><p>Speaking of the scaling flow: the scaling hypothesis appears to be very powerful, does the topology have any impact on it?</p>
<p>We can understand some limits. First of all, if $g\gg 1$, the system is a metal, and there can hardly be any trace of topology left. However when $g \lesssim 1$, the system can become one out of several topologically distinct types of insulators, and we can expect some sort of transition between different insulating phases.</p>
<p>The rational assumption at this point is to assume that the scaling hypothesis still holds, but in addition to $g$ it depends on the average topological invariant of the disordered ensemble $\langle \mathcal{Q} \rangle$.</p>
<p>Just like in the case of the non-topological phases, there is no universal proof that this form of scaling flow is correct. Instead, there is a vast amount of mixed numerical and analytical evidence that this is correct.</p>
<p>Let’s try and verify our hypothesis by constructing the scaling flow of the disordered Kitaev chain. We can do it in the following way:</p>
<ul>
<li><p>Choose a given disorder strength $U$, a given length $L$, and a set of values ${\mu}$ for the chemical potential. For each of these values, we compute $\langle \mathcal{Q} \rangle$ and the average transmission $\langle T \rangle$ over a large number of disorder realizations (as large as possible, in our case 1000). This gives us a set of starting points on the $(\langle \mathcal{Q} \rangle, \langle T \rangle)$ plane.</p>
</li>
<li><p>Increase the chain length $L$, and compute $\langle \mathcal{Q} \rangle, \langle T \rangle$ again for all the values ${\mu}$. We obtain a second set of points on the plane.</p>
</li>
<li><p>Join the points corresponding to the same value of $\mu$.</p>
</li>
<li><p>Increase again the length $L$, and so on…</p>
</li>
</ul>
<p>Here’s what we get:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>) <span class="keyword">and</span> os.path.exists(</span><br><span class="line">    data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span></span><br><span class="line">):</span><br><span class="line">    qs = np.loadtxt(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>)</span><br><span class="line">    ts = np.loadtxt(data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, disorder=<span class="number">0.8</span>)</span><br><span class="line">    Ls = np.array(np.logspace(np.log10(<span class="number">10</span>), np.log10(<span class="number">180</span>), <span class="number">6</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line">    ms = [np.sign(x) * x ** <span class="number">2</span> + <span class="number">0.2</span> <span class="keyword">for</span> x <span class="keyword">in</span> np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">40</span>)]</span><br><span class="line">    qs, ts = <span class="built_in">zip</span>(*[phase_diagram(<span class="built_in">int</span>(L), ms, p, num_average=<span class="number">1000</span>) <span class="keyword">for</span> L <span class="keyword">in</span> Ls])</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;scaling_data_qs.dat&quot;</span>, qs)</span><br><span class="line">    np.savetxt(data_folder + <span class="string">&quot;scaling_data_ts.dat&quot;</span>, ts)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">npoints = qs.shape[<span class="number">0</span>]</span><br><span class="line">X, Y = qs.T, ts.T</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y):</span><br><span class="line">    points = np.array([x, y]).T.reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    segments = np.concatenate([points[:-<span class="number">1</span>], points[<span class="number">1</span>:]], axis=<span class="number">1</span>)</span><br><span class="line">    lc = LineCollection(</span><br><span class="line">        segments, cmap=<span class="string">&quot;gist_heat_r&quot;</span>, norm=matplotlib.colors.Normalize(<span class="number">0</span>, npoints + <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    lc.set_array(np.array(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, npoints + <span class="number">1</span>))))</span><br><span class="line">    ax.add_collection(lc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax.set_xlim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.set_ylim(<span class="number">0</span>, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">r&quot;$\langle Q \rangle$&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">r&quot;$\langle T \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [-<span class="number">1</span>, -<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">0.0</span>, <span class="number">0.25</span>, <span class="number">0.50</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals]);</span><br></pre></td></tr></table></figure>

<p>The lines have a direction, which tells us how $\langle Q \rangle$ and $\langle T \rangle$ change as we increase $L$. In the plot above, $L$ is increasing in going from bright to dark colors.</p>
<p>The first and the most important observation we can make is that the lines do not intersect, which confirms the scaling hypothesis.</p>
<p>Most of the lines tend to one of the two points $(\langle \mathcal{Q} \rangle, \langle T \rangle) = (-1, 0)$ or $(1, 0)$. These correspond to two insulating systems with different topological invariants. We can say that quantized values of $\langle \mathcal{Q} \rangle$ are insulating, and they correspond to <em>attractive fixed points</em> of the flow.</p>
<p>You can also see that the flow is roughly separated around a vertical <em>critical line</em> at $\langle \mathcal{Q} \rangle=0$. All lines which start from a negative value of $\langle \mathcal{Q} \rangle$ end up at $(-1, 0)$, and all the lines which start from a positive value end up at $(1,0)$.</p>
<p>Finally, the point $(0, 0)$ is a saddle point: the flow goes towards it along the vertical axis, and away from it along the horizontal axis.</p>
<p>We now understand better why two parameter scaling is necessary in the presence of a topological invariant. Even in the presence of disorder, there can be topologically distinct insulating phases. Therefore, saying that every system flows to an insulator is not enough anymore. Including the average topological invariant as a second scaling parameter allows to predict towards <em>which</em> insulating phase the system will flow.</p>
<p>The flow, we just calculated is in fact valid for all one-dimensional topological insulators and superconductors. In the case of a $\mathbb{Z}$ invariant, the saddle points are located at $(\langle \mathcal{Q} \rangle, \langle T\rangle) = (n+1/2, 0)$.</p>
<p>It is important to notice that one important result of the standard scaling theory regarding one dimensional system remains true: in the plot above all lines flow to no transmission, or in other words there are no metallic phases in the flow diagram.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What does the 2 parameter flow diagram predict about the infinite size limit?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Always topological for all parameters.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There&#x27;s a localized topological and non-topological phase separated by a transition point.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Always localized for every parameter.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Almost always conducting except at a transition point.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The phase is determined by the long length (i.e. dark part of the figure) which is almost always in small T&quot;</span></span><br><span class="line">    <span class="string">&quot;i.e. supporting localized states. Here the states either flow to $Q=+1$ or $Q=-1$ (non-top or top respectively) &quot;</span></span><br><span class="line">    <span class="string">&quot;except near $Q=0$ has a slower decay.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Critical-point"><a href="#Critical-point" class="headerlink" title="Critical point"></a>Critical point</h1><p>The scaling flow of 1D topological insulators can be solved exactly, and especially for our system we can very easily derive some of its properties.</p>
<p>The behavior of the disordered Kitaev chain close to the phase transition can be understood within an effective Dirac Hamiltonian in the continuum limit. The Hamiltonian is similar to the one, we studied in week one when we were concerned with a domain wall</p>
<p>$$<br>H_\textrm{Dirac} = v,p,\tau_z + m(x),\tau_y,,<br>$$</p>
<p>with $p$ the momentum along the chain, $v$ the velocity of the modes, and $m(x)$ the position dependent gap which couples left-movers and right-movers.</p>
<p>To model the disordered chain, we take $m(x)$ to be a random function of $x$, just like $\mu_n$ was random in the lattice version. The chain is disordered in a segment of finite size $L$, while for $x&lt;0$ and $x&gt;L$ we set $m=0$ so that in this region we have propagating modes and thus a well-defined scattering problem.</p>
<p>We want to compute the transmission probability through the chain at zero energy. As we saw in week one, an eigenstate at zero energy satisfies the relation</p>
<p>$$<br>\Psi(L) =,\exp,(-\tau_x,\alpha),,\Psi(0),,<br>$$</p>
<p>with a parameter</p>
<p>$$\alpha = \frac{1}{v},\int_0^L, m(x), dx,$$</p>
<p>proportional to the average value of the random mass in the chain.</p>
<p>An incoming wave from the left (negative $x$) entering the scattering region is partially transmitted through it and partially reflected. We can find the reflection and transmission amplitudes $r, t$ by substituting $\Psi(0)=(1,r)^T$ and $\Psi(L) = (t,0)^T$ in the equation above. By solving the simple linear system that comes out of the substitution, we get immediately </p>
<p>$$<br>r = \tanh (\alpha),,;;t = \cosh^{-1} (\alpha).<br>$$</p>
<p>The scattering topological invariant $Q$ for the Kitaev chain is the sign of the determinant of $r$. In our case, since $r$ is just a number, we immediately get</p>
<p>$$Q=r = \tanh\alpha,.$$</p>
<p>We see that the topological transition happens when $\alpha=0$. That is, to model the transition, we think of $m(x)$ as a random function of $x$ which can take positive and negative values with equal probabilities. </p>
<p>The details of the probability distribution for $m(x)$ are not very important as long as the distribution is characterized by a finite correlation length $\xi \ll L$ - that is, values of $m$ at points more distant than $\xi$ are statistically uncorrelated. </p>
<p>If this is the case, $\alpha$ is the sum of an order $\sim L/\xi$ of uncorrelated values of $m$. By using the <a href="http://en.wikipedia.org/wiki/Central_limit_theorem">central limit theorem</a>, we can say that $\alpha$ is a normally distributed variable with zero mean and a variance growing linearly in $L$. Since $\alpha$ is a random variable, so is the transmission probability $T=|t^2|=\cosh^{-2}(\alpha)$. From the probability distribution of $\alpha$, we can obtain the scaling behavior of $T$ as</p>
<p>$$<br>\left\langle T \right \rangle \propto 1/\sqrt{L},.<br>$$</p>
<h1 id="Two-parameter-scaling-in-higher-dimensions"><a href="#Two-parameter-scaling-in-higher-dimensions" class="headerlink" title="Two parameter scaling in higher dimensions"></a>Two parameter scaling in higher dimensions</h1><p>Just like the regular scaling flow, the topological one is also richer in $d&gt;1$.</p>
<p>The oldest known example of the two parameter flow is unsurprisingly the quantum Hall effect. The flow looks similar to what we just calculated in 1D, here:</p>
<p><img src="/2021/01/07/src/w9_disorder/topoflow/Three_Dimensional_RG_Flowdiagram_of_the_QHE.png" alt></p>
<p>By Wout Neutkens (Own work) <a href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, via Wikimedia Commons</p>
<p>The axes are the same as before - the horizontal one is the topological invariant given by $\sigma_H$, and the vertical axis the longitudinal conductance. The saddle point separating the different topological phases is now elevated to a finite critical conductance, which is known to be around $0.5-0.6$ conductance quanta.</p>
<p>Metallic phases are the final part that we need to consider. The appearance of those at high conductance is governed by the same rules as without the topological invariant. The reason for this is that the topological effects are all $\mathcal{O}(1)$ corrections to conductance, and are therefore only important at $g\sim 1$.</p>
<p>An extra attractive metallic fixed point can make the flow diagram more complicated. For example, the metallic phase can completely separate the two insulating phases and eliminate the fixed point. What happens in each particular case is not always certain, and is still an open research topic.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;NY6wPiH0E9E&quot;</span>, src_location=<span class="string">&quot;9.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topological scaling&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w9_disorder/scaling/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the path to a folder containing data files, to work with filters as well.</span></span><br><span class="line">data_folder = (</span><br><span class="line">    <span class="string">&quot;data/&quot;</span> <span class="keyword">if</span> os.path.exists(<span class="string">&quot;data&quot;</span>) <span class="keyword">and</span> os.path.isdir(<span class="string">&quot;data&quot;</span>) <span class="keyword">else</span> <span class="string">&quot;../../data/&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Anderson localization is introduced by Piet Brouwer from the Free University of Berlin.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;sbbyL0RDH-o&quot;</span>, src_location=<span class="string">&quot;9.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>At this point, you might be wondering how we got from talking about topological insulators to disordered metals. Well, we told you several times that topological states are supposed to be robust to disorder, and that this is one of the main reasons why they are so interesting.</p>
<p>Based on the arguments we made in previous weeks, you could convince yourselves that certain properties, such as the bulk boundary correspondence, are robust as long as disorder isn’t enough to close the gap. However, many topological properties that we measure could in principle be susceptible to disorder.</p>
<p>For example, we told you that at the edge of a two-dimensional topological insulator, there is a perfectly conducting state that is robust to disorder. Remember however that we made no such claims about the surface states of a three-dimensional topological insulator! In fact, while in three dimensions the conductance is certainly susceptible to disorder, topology forbids it from becoming zero. Such subtle properties require a more detailed understanding of disorder.</p>
<h1 id="Simple-limits-localized-and-extended-states"><a href="#Simple-limits-localized-and-extended-states" class="headerlink" title="Simple limits: localized and extended states"></a>Simple limits: localized and extended states</h1><p>When we speak of disorder in electronic systems, the main distinction we need to keep in mind is that between extended and localized states.</p>
<p>Let’s start by thinking of a three dimensional metal with a low density of impurities, and hence weak disorder. In this limit, electrons moving through the system are only scattered by impurities every now and then, but otherwise they move ballistically between collisions. This picture is known as the <a href="http://en.wikipedia.org/wiki/Drude_model">Drude model</a>, and yields a conductivity given by</p>
<p>$$\sigma=n e^2\tau/m,$$</p>
<p>where $n$ is the electron density, $m$ is the electron mass and $\tau$ the mean free time between collisions. In this limit, the electron wave functions are extended throughout the bulk of the system, much like the plane waves of a clean crystal.</p>
<p>The other extreme is the strong disorder limit, in which there is a strongly fluctuating random potential in the material, for instance due to a high density of impurities. This potential has minima at random positions in the material, where electrons can become trapped. The corresponding wave functions are localized exponentially close to the minima. If the density of impurities is high in the material, all electronic states are of this type. In this situation, the only mechanism for conduction in the material is tunneling between different potential minima. However, the minima may be far apart from each other, which leads to a suppression of conductance and to an insulating state.</p>
<p>Let’s discuss qualitatively the simplest effect of strong disorder on topological states, which are gapped. If we imagine a disorder potential with a Gaussian distribution, there are always “rare regions” where the disorder potential is very deep. Such potentials may thus yield energy levels in the middle of the gap. If disorder is strong, there might even be no energy gap at all! However, the electrons trapped in these rare regions are localized, and do not participate in any of the transport properties of the material.</p>
<blockquote>
<p>Thus, even weak disorder can close the energy gap, which is what protects topology, as discussed so far. However, since these localized states are isolated from each other, and most importantly from the edges, they do not affect any of the topological properties.</p>
</blockquote>
<p>The considerations above make it clear that the presence or absence of an energy gap is not a good criterion to tell whether a system is insulating or not in the presence of strong disorder, and that we need to understand the nature of the electronic states in the system. Our definition of an insulating state must obey a new criterion. As will see next, this criterion can be obtained by studying conductance as a function of the system size.</p>
<h1 id="Conductance-scaling"><a href="#Conductance-scaling" class="headerlink" title="Conductance scaling"></a>Conductance scaling</h1><p>How can we really get away with understanding electrons in disordered potentials without doing any real quantum mechanical calculations? We can only do this in the two aforementioned extreme limits, and actually only in certain dimensions. In principle, to see how the “transition” from extended to localized electrons happens as disorder is increased, one must solve the full quantum mechanical problem. So far, it seems impossible to solve this problem exactly in any dimension other than 1D, so we won’t bother and instead discuss an educated guess, which gives us most of the answer.</p>
<p>To start with, let us be more specific and consider the conductance $G(L)$ of a $d$-dimensional block with sides $L$. The conductance represents the ease with which electrons can propagate through the block, and is has the natural unit $G_0=e^2/h$. Therefore, we can think of the dimensionless conductance $g(L)=G(L)/G_0$ as sort of a higher dimensional analog of the average transmission of electrons between the ends of the system, multiplied by the number of channels. If we take the analogy with transmission seriously, we can guess that the conductance of a combination of blocks, each with conductance $g(L)$, has conductance $g’$ which depends on $g(L)$. This is not very different from what we expect classically. For example, consider a connected pair of metallic blocks of conductivity $g(L)$ each, such that the total conductivity of the connected blocks is $g’$. If the blocks are connected in series, then $g’=g(L)/2$. If they are connected in parallel, then $g’=2 g(L)$. </p>
<p>We can extend the above guess due to Thouless to relate the conductance $g(L)$ of a block of size $L$ to that of a block of size $2L$ i.e. </p>
<p>$$g(2L)=f(g(L)),$$</p>
<p>where $f$ is some function. We can use this equation to relate the conductances at a bunch of different length scales, but not quite at all continuous lengths. We could create a larger set of similar relations by increasing the block size by a factor of $b$ instead of $2$. By choosing $b=1+\delta{\lambda}$, we can write the equation</p>
<p>$$g(b L)=g(L(1+\delta\lambda))=g(L)+g(L)\beta(g(L))\delta\lambda,$$</p>
<p>where $\beta$ is a function called the scaling function or often simply the <em>beta function</em>. Taking the limit $\delta\lambda\rightarrow 0$ we obtain the <em>scaling equation</em></p>
<p>$$\frac{d\textrm{ln}g}{d\textrm{ln}L}=\beta(g).$$</p>
<blockquote>
<p>This is the educated guess known as <em>single parameter scaling</em> that was adopted by  the “Gang of Four” (Abrahams, Anderson, Licciardello and Ramakrishnan) and is essentially an application of the idea of the <a href="http://en.wikipedia.org/wiki/Renormalization_group">renormalization group</a> to the conductance problem. Of course, we don’t quite know the function $\beta$, but as we will see in the next unit, it is possible to guess the form in various limits and this is enough to guess the qualitative behavior of the conductance.</p>
</blockquote>
<p>While the above representation will be useful for understanding the “flow diagram”, the above scaling hypothesis has a simple general solution </p>
<p>$$g(L)=\Phi(L/\xi),$$</p>
<p>where $\Phi$ is a function that is determined entirely by $\beta$, and $\xi$ is a decay length.</p>
<h1 id="Scaling-flow-diagram"><a href="#Scaling-flow-diagram" class="headerlink" title="Scaling flow diagram"></a>Scaling flow diagram</h1><p>Now we are in a position to make use of the scaling hypothesis. We don’t really know $\beta(g)$ in general, but we can compute it for large $g$ i.e. in the metallic/delocalized limit and also in the small $g$ or strongly localized limit. In the strongly localized limit $g\sim g_c e^{-L/\xi}$ so that $\beta(g)=\textrm{ln}(g/g_c)$, while in the weak scattering limit, we can estimate $g$ from the classical Drude formula so that $g\sim L^{(d-2)}$ and $\beta(g)\sim d-2$. In addition, one can calculate “quantum corrections” to the $\beta-$function at large $g$, which turn out to depend on other details such as the symmetry class of the disorder.</p>
<p>The simplest next step is to plot the function $\beta(g)$ using the simplest interpolation between the two limits. The amazing thing is that even the simplest interpolation allows us to guess the physics of the phase diagram. As a side note, this phase diagram is lost in the exact solution we wrote at the end of the last unit in terms of $\Phi$, which may seem counterintuitive to you. But let’s move on to understanding the phase diagram. Below, we plot $\beta(g)$ as a function of $g$:</p>
<p><img src="/2021/01/07/src/w9_disorder/scaling/conductance_scaling.svg" alt></p>
<p>What we see is that for dimensions $d=1,2$ the curve stays below $\beta\leq 0$, while the curve for $d=3$ intersects $\beta=0$. To make it easier to understand the diagram, we’ve turned it into a “flow diagram” by adding arrows along the curve representing how $g$ changes with system size $L$. If $\beta&lt;0$ then the arrow points towards smaller values of $g$, but if $\beta&gt;0$ the arrow points towards larger values of $g$. Thus, the flow diagram tells us that in $d=1,2$ dimensions, $g$ reduces with increasing system size, and therefore the system is insulating.</p>
<p>The situation is different in $d=3$ dimensions. If the conductance $g$ is large enough to begin with, then $\beta &gt; 0$ and the arrow points to larger values of $g$. This means that the conductance grows with increasing system size. On the other hand, if disorder is large enough such that $\beta &lt; 0$ initially, $g$ decreases as the system size increases. The separation point $\beta = 0$ between these two behaviours is the <em>metal-insulator transition</em>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;How is the flow in the diagram above altered if we stack 10 1D systems next to each other and weakly couple them?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Nothing changes.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;$\beta$ is multiplied by 10.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The scaling hypothesis doesn&#x27;t apply since we don&#x27;t have a 1D system anymore.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;$\beta$ is altered in some way, since we have a different disordered system now.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;The scaling hypothesis tells us that the details of the Hamiltonian don&#x27;t matter, so the scaling flow stays the same.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">0</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The 2D case is special: in the classical limit $g \gg 1$, the scaling flow disappears, $\beta \approx 0$. However, there remain <em>quantum corrections</em> to it. These are effects that get weaker with increasing conductance, and they depend on the symmetry class of the Hamiltonian.</p>
<p>Let’s see what happens in the three simplest symmetry classes, those without sublattice or particle-hole symmetry. As we learned last week, these are class A (no symmetries, also called unitary since the matrix of Hamiltonian eigenvalues is unitary), AI ($\mathcal{T}^2 = 1$, orthogonal), and AII ($\mathcal{T} = -1$, symplectic).</p>
<p>A lengthy and technical calculation leads to the following corrections to the scaling flow at $g \gg 1$:</p>
<p><img src="/2021/01/07/src/w9_disorder/scaling/conductance_scaling_2D.svg" alt></p>
<p>So we see that in symmetry classes A and AI the conductance always drops, even though it does so very slowly in the class A, eventually leading to an insulating phase.</p>
<p>The class AII has a critical metal-insulator transition point, and a metallic phase at $g &gt; g_c$, just like a disordered 3D system. The growth of conductance in this system is much slower however: instead of $g \sim L$, in 2D AII we have $g \sim \log L$.</p>
<h1 id="Metal-insulator-transition"><a href="#Metal-insulator-transition" class="headerlink" title="Metal-insulator transition"></a>Metal-insulator transition</h1><p>The most interesting feature of the scaling theory of conductance that we have learned about so far is the existence of a universal critical point at which the behavior of the system changes from insulating (negative $\beta$ function) to metallic (positive $\beta$ function). This is the point $\beta=0$ which appears in 3D and in 2D in class AII. Let’s study such a critical point in more detail.</p>
<p>The first thing to observe is that at the critical point, we have $d\ln g/ d\ln L = 0$, so the conductance takes a <em>scale-invariant</em> value $g=g_c$ which is independent of $L$.</p>
<p>In practice, this behavior can be observed at a fixed $L$ by varying one parameter $\alpha$ appearing in the model under study, typically the disorder strength or the chemical potential. The average conductance $\langle g \rangle$ is then computed as a function of $\alpha$ for different values of $L$. One then obtains a plot like the following:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.loadtxt(data_folder + <span class="string">&quot;data_from_doru.dat&quot;</span>)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">cmap = plt.get_cmap(<span class="string">&quot;gist_heat&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    x, y = data[i::<span class="number">3</span>, <span class="number">0</span>], data[i::<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">    error = data[i::<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">    L = data[i, <span class="number">1</span>]</span><br><span class="line">    color = cmap(np.log(L - <span class="number">26</span>) / np.log(<span class="number">243</span> - <span class="number">26</span>) * <span class="number">0.7</span>)</span><br><span class="line">    ax.errorbar(x, y, yerr=error, label=<span class="string">&quot;$L=%i$&quot;</span> % L, color=color)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;$V$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">r&quot;$\langle G \rangle$&quot;</span>)</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">5.5</span>, <span class="number">5.75</span>, <span class="number">6</span>]</span><br><span class="line">ax.set_xticks(evals)</span><br><span class="line">ax.set_xticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">evals = [<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2</span>]</span><br><span class="line">ax.set_yticks(evals)</span><br><span class="line">ax.set_yticklabels([<span class="string">&quot;$&#123;0&#125;$&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> evals])</span><br><span class="line"></span><br><span class="line">ax.set_xlim(<span class="number">5.5</span>, <span class="number">6.0</span>)</span><br><span class="line">ax.set_ylim(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>(We thank Doru Sticlet for providing the data for this plot)</p>
<p>The plot above was computed for a 2D tight-binding model in class AII, essentially electrons hopping on a square lattice in the presence of a strong Rashba spin-orbit coupling. In this case, the average conductance was computed as a function of onsite disorder strength $V$.</p>
<p>We see that there is a point $V = V_c\simeq 5.8$ which distiguishes two different behaviors. For $V &lt; V_c$, conductance increases with system size: the system is metallic. For $V &gt; V_c$, conductance decreases with system size: the system is insulating. Hence by comparing different curves at fixed $V$ we can easily ‘see’ the sign of the $\beta$ function in our numerical calculations.</p>
<p>At $V = V_c$, all the curves overlap in the same point: we find that $g$ is basically independent of $L$. This is the critical point. In the plot above, the critical value of conductance is $g_c \simeq 1.3$. (Note that in a typical numerical calculations the curves will not cross precisely at the same point because the systems under consideration are too small. This leads to an entire field of study regarding the finite-size corrections to the scaling theory).</p>
<p>Let us study the conductance scaling around this point. The beta function changes sign at $g_c$, and in its vicinity we can consider it to be a linear function of $g$:</p>
<p>$$\beta(g) = \frac{1}{\nu},\frac{g-g_c}{g_c},,$$</p>
<p>where $\nu$ is just a coefficient and $g-g_c\ll g_c$. On the insulating side of the transition, it is convenient to write down $g  = g_c - \delta g$. Using the fact that $\ln g \simeq - \delta g/ g_c + \ln g_c$, and that $g_c$ does not depend on $L$, one obtains the following scaling equation for $\delta g$,</p>
<p>$$ \frac{d \delta g}{d \ln L} = \frac{\delta g}{\nu},.$$</p>
<p>Integrating this equation gives a power law,</p>
<p>$$ \frac{\delta g(L)}{\delta g(L_0)} = \left(\frac{L}{L_0}\right)^{1/\nu},. $$</p>
<p>At a fixed $L_0$, the behavior close to the transition is given by $\delta g(L_0) \simeq a(L_0) (V-V_c)$. So we get</p>
<p>$$ g(L) =  g_c - a(L_0),(V-V_c) , (L/L_0)^{1/\nu} = g_c - a(L_0),(L/\xi)^{1/\nu},.$$</p>
<p>The length $\xi = L_0,(V-V_c)^{-\nu},$ is the localization length, which diverges at the transition point $V=V_c$. The number $\nu$ is known as the <em>critical exponent</em>, and determines the scaling behavior of the conductance close to the critical point.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">r&quot;What would we see if $\beta$ crossed from positive to negative values?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Small conductances would have a metallic phase, where $g$ grows indefinitely, &quot;</span></span><br><span class="line">    <span class="string">&quot;while large $g$ would lead to an insulator.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;We would see a critical phase, where all conductances converge to the same value.&quot;</span>,</span><br><span class="line">    <span class="string">r&quot;This is just the same metal-insulator transition since $\beta(g_c) = 0$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;This is an impossible scaling function.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Both larger conductances and smaller conductances flow towards the critical value, &quot;</span></span><br><span class="line">    <span class="string">&quot;so all systems get the same conductance when their size becomes large enough. &quot;</span></span><br><span class="line">    <span class="string">&quot;This is an attractive critical point.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Absence-of-localization-for-topological-insulators"><a href="#Absence-of-localization-for-topological-insulators" class="headerlink" title="Absence of localization for topological insulators"></a>Absence of localization for topological insulators</h1><p>Finally let’s remark on how the conductance scaling flow is modified on the protected surfaces of topological insulators.</p>
<p>At large conductances we know that the classical scaling must still hold, since this is just Ohm’s law. On the other hand, if we were able to make conductance exactly zero, we would break the bulk-edge correspondence, so $\beta$ cannot be negative at $g \ll 1$.</p>
<p>It turns out, the scaling flow on the surface of a topological insulator is modified by the appearance of an extra term, that vanishes at large conductance, but ensures that there is no localization.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;JdDeBJEBO0s&quot;</span>, src_location=<span class="string">&quot;9.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Anderson localization&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w8_general/w8_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-Gaps-and-invariants"><a href="#Simulations-Gaps-and-invariants" class="headerlink" title="Simulations: Gaps and invariants"></a>Simulations: Gaps and invariants</h1><p>As usual, start by grabbing the notebooks of this week (<code>w8_general</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<h2 id="A-different-analytic-continuation"><a href="#A-different-analytic-continuation" class="headerlink" title="A different analytic continuation"></a>A different analytic continuation</h2><p>You have learned how to map a winding number onto counting the zeros of an eigenproblem in a complex plane. This can be applied to other symmetry classes as well.</p>
<p>Let’s try to calculate the invariant in the 1D symmetry class DIII. If you look in the table, you’ll see it’s the same invariant as the scattering invariant we’ve used for the quantum spin Hall effect,</p>
<p>$$<br>Q = \frac{\textrm{Pf } h(k=0)}{\textrm{Pf } h(k=\pi)} \sqrt{\frac{\det h(k=\pi)}{\det h(k=0)}}<br>$$</p>
<p>In <a href="http://arxiv.org/abs/1106.6351">this paper</a> (around Eq. 4.13), have a look at how to use analytic continuation to calculate the analytic continuation of $\sqrt{h}$, and implement the calculation of this invariant without numerical integration, like we did before.</p>
<p>In order to test your invariant, you’ll need a topologically non-trivial system in this symmetry class. You can obtain it by combining a Majorana nanowire with its time-reversed copy.</p>
<p>This is a hard task; if you go for it, try it out, but don’t hesitate to ask for help in the discussion below.</p>
<h2 id="Finding-gaps"><a href="#Finding-gaps" class="headerlink" title="Finding gaps"></a>Finding gaps</h2><p>The analytic continuation from $e^{ik}$ to a complex plane is also useful in telling if a system is gapped.</p>
<p>Using the mapping of a 1D Hamiltonian to the eigenvalue problem, implement a function which checks if there are propagating modes at a given energy.</p>
<p>Then implement an algorithm which uses this check to find the lowest and the highest energy states for a given 1D Hamiltonian $H = h + t e^{ik} + t^\dagger e^{-ik}$ (with $h$, $t$ arbitrary matrices, of course).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Topological invariants&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1006-0690"><a href="#arXiv-1006-0690" class="headerlink" title="arXiv:1006.0690"></a>arXiv:1006.0690</h3><p><strong>Hint:</strong> The most general classification.</p>
<h3 id="arXiv-1310-5281"><a href="#arXiv-1310-5281" class="headerlink" title="arXiv:1310.5281"></a>arXiv:1310.5281</h3><p><strong>Hint:</strong> Beyond classification.</p>
<h3 id="arXiv-1012-1019"><a href="#arXiv-1012-1019" class="headerlink" title="arXiv:1012.1019"></a>arXiv:1012.1019</h3><p><strong>Hint:</strong> The non-commutative invariants.</p>
<h3 id="arXiv-1106-6351"><a href="#arXiv-1106-6351" class="headerlink" title="arXiv:1106.6351"></a>arXiv:1106.6351</h3><p><strong>Hint:</strong> All about scattering.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;General classification&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w8_general/invariants/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> sla</span><br><span class="line"></span><br><span class="line">randn = np.random.randn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chern_torus</span>(<span class="params">W=<span class="number">5</span>, L=<span class="number">5</span></span>):</span></span><br><span class="line"></span><br><span class="line">    disorder_potential = randn(W, L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; W) * (<span class="number">0</span> &lt;= y &lt; L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        t, mu, dis_amplitude = p.t, p.mu, p.disorder</span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">4</span> * t - mu) * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        t, delta = p.t, p.delta</span><br><span class="line">        <span class="keyword">return</span> -t * pauli.sz + <span class="number">1j</span> * p.delta * pauli.sx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        t, delta = p.t, p.delta</span><br><span class="line">        <span class="keyword">return</span> -t * pauli.sz - <span class="number">1j</span> * p.delta * pauli.sy</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((-W + <span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, -L + <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">projected_operators</span>(<span class="params">syst, p, energy=<span class="number">0</span></span>):</span></span><br><span class="line">    x, y = np.array([i.pos <span class="keyword">for</span> i <span class="keyword">in</span> syst.sites]).T</span><br><span class="line">    <span class="comment"># Double all entries to take orbitals into account.</span></span><br><span class="line">    x = np.resize(x, (<span class="number">2</span>, <span class="built_in">len</span>(x))).T.flatten()</span><br><span class="line">    y = np.resize(y, (<span class="number">2</span>, <span class="built_in">len</span>(y))).T.flatten()</span><br><span class="line">    x *= <span class="number">2</span> * np.pi / (np.<span class="built_in">max</span>(x) + <span class="number">1</span>)</span><br><span class="line">    y *= <span class="number">2</span> * np.pi / (np.<span class="built_in">max</span>(y) + <span class="number">1</span>)</span><br><span class="line">    op_x = np.diag(np.exp(<span class="number">1j</span> * x))</span><br><span class="line">    op_y = np.diag(np.exp(<span class="number">1j</span> * y))</span><br><span class="line"></span><br><span class="line">    ham = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    ham -= <span class="number">0</span> * np.identity(<span class="built_in">len</span>(ham))</span><br><span class="line">    energies, states = np.linalg.eigh(ham)</span><br><span class="line"></span><br><span class="line">    projector = states[:, energies &lt; energy]</span><br><span class="line"></span><br><span class="line">    op_x = projector.T.conj() @ op_x @ projector</span><br><span class="line">    op_y = projector.T.conj() @ op_y @ projector</span><br><span class="line">    <span class="keyword">return</span> op_x, op_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_terminal</span>(<span class="params">L, W</span>):</span></span><br><span class="line">    t = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; W <span class="keyword">and</span> <span class="number">0</span> &lt;= x &lt; L</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; W</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># definition of system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">3</span> * t</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># definition of leads</span></span><br><span class="line">    lead = kwant.Builder(kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">3</span> * t</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># attaching leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diag_time</span>(<span class="params">N</span>):</span></span><br><span class="line">    syst = two_terminal(N, N)</span><br><span class="line"></span><br><span class="line">    start = time()</span><br><span class="line">    ham = syst.hamiltonian_submatrix()</span><br><span class="line">    ev, evec = sla.eigh(ham)</span><br><span class="line">    res = time() - start</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smat_time</span>(<span class="params">N</span>):</span></span><br><span class="line">    syst = two_terminal(N, N)</span><br><span class="line"></span><br><span class="line">    start = time()</span><br><span class="line"></span><br><span class="line">    smat = kwant.smatrix(syst)</span><br><span class="line"></span><br><span class="line">    res = time() - start</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Fabian Hassler from RWTH Aachen will present the topological invariants</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;ceyus0cRBi0&quot;</span>, src_location=<span class="string">&quot;8.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Applications-of-topological-invariants"><a href="#Applications-of-topological-invariants" class="headerlink" title="Applications of topological invariants"></a>Applications of topological invariants</h1><p>Throughout the course we computed several times a topological invariant of different systems. When is calculating a topological invariant useful or necessary?</p>
<p>The toy model Hamiltonians that we considered do not really require a complicated calculation set up to figure out whether they are topological or not. However, there are two types of applications where a heavy duty algorithm is important. These are:</p>
<ul>
<li>Ab-initio band structures calculations</li>
<li>Disordered systems</li>
</ul>
<p>So, we start with a Hamiltonian of some complicated material, and we want to know if it is topological or not. What’s worse is that we don’t even know in advance if it is gapped or not! If the system is disordered (you’ll learn more about those next week), then in addition we can never simulate a truly infinite system. What we can do is to take chunks of finite size  and hope that it behaves correctly like an infinite system once the sample size is large enough.</p>
<p>This Hamiltonian may have many parameters, so it’s a large $N\times N$ matrix. For systems with a complicated band structure, $N$ is fixed to be the number of orbitals we need to faithfully approximate the Hamiltonian, while in disordered systems we would usually simulate a finite system with linear size $L$, and so $N=L^d$, with $d$ the dimensionality of the space.</p>
<p>There’s a simple rule which allows us to guess how large a disordered system should be, in order to correctly reproduce the topology of an infinite system.</p>
<blockquote>
<p>If the typical decay length of the state at the Fermi level of a disordered system is $\xi$, then we need to take a sample with $L \gtrsim \xi$ to correctly calculate its topological properties.</p>
</blockquote>
<p>The reason why this is true is that in a smaller sample the bulk is not ‘insulating enough’.</p>
<p>So now we know that the main problem is that we need to do something with a large matrix.</p>
<h1 id="Computational-costs"><a href="#Computational-costs" class="headerlink" title="Computational costs"></a>Computational costs</h1><p>How expensive are the calculations? If you look in the literature, you’ll see wildly differently looking algorithms bundled together with different claims of performance. There is actually a very simple way to figure out, and it comes down to an almost universally correct empirical rule:</p>
<blockquote>
<p>Whenever you need to do something with a dense matrix of size $M\times M$ in a numerical calculation, the costs of doing it most likely are $\sim M^3$.</p>
</blockquote>
<p>This is true almost no matter what you do: matrix multiplication, inversion, diagonalization, calculation of a determinant, and dozens of other decompositions all cost the same. The specific value of the numerical prefactor does vary.</p>
<p>The things become more complicated when the Hamiltonian becomes sparse, since then one may efficiently use that most entries in the matrix are zero. For example, multiplying two $M\times M$ banded matrices has a cost $~M$, instead of $M^3$.</p>
<p>Part of our intuition stays true. So since after diagonalizing a Hamiltonian we obtain an $M\times M$ matrix of eigenvectors, typically we still need to perform $\sim M^3$ number of operations.</p>
<p>A scattering matrix is smaller than the matrix of all the eigenvectors, and for our sample with a linear size $L$, the size of the scattering matrix is $L^{d-1}$, as opposed to $L^d$, the size of the Hamiltonian. While this fact isn’t <a href="http://en.wikipedia.org/wiki/LU_decomposition#Sparse_matrix_decomposition">trivial</a> at <a href="http://en.wikipedia.org/wiki/Nested_dissection">all</a>, calculation of a scattering matrix still costs the cube of its size, so $L^{3d-3}$.</p>
<p>This difference is most pronounced in 2D systems, where the cost of diagonalization results in more than an order of magnitude difference in the system size. On most modern computers diagonalization works up to system sizes of $\sim 100$, and scattering matrix calculations work up to system sizes of $\sim 1000$. This can be best seen over here (but you can also test for yourself):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Ns_diag = np.logspace(<span class="number">1</span>, np.log10(<span class="number">80</span>), <span class="number">5</span>)[:<span class="number">4</span>]</span><br><span class="line">diag_times = [diag_time(N) <span class="keyword">for</span> N <span class="keyword">in</span> Ns_diag]</span><br><span class="line"></span><br><span class="line">Ns_smat = np.logspace(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>)[:<span class="number">6</span>]</span><br><span class="line">smat_times = [smat_time(N) <span class="keyword">for</span> N <span class="keyword">in</span> Ns_smat]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(Ns_diag, diag_times, <span class="string">&quot;-o&quot;</span>, label=<span class="string">&quot;diagonalization&quot;</span>)</span><br><span class="line">plt.plot(Ns_smat, smat_times, <span class="string">&quot;-o&quot;</span>, label=<span class="string">&quot;scattering matrix&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">plt.yscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;$N$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;$t [s]$&quot;</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span> ** -<span class="number">3</span>, <span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">plt.yticks([<span class="number">1e-3</span>, <span class="number">1</span>, <span class="number">1e3</span>, <span class="number">1e6</span>])</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="Momentum-integration"><a href="#Momentum-integration" class="headerlink" title="Momentum integration"></a>Momentum integration</h2><p>As you saw, unless we’re lucky, a topological invariant is a $d$-dimensional integral of something like winding number density or Berry curvature. If we deal with the scattering matrix, the Brillouin zone is once again reduced by one dimension, and the integral becomes $(d-1)$-dimensional.</p>
<p>How many points in momentum space do we need? If we are integrating Berry curvature, we want the uncertainty of the integral to be $\lesssim .5$, so that we can round it and get the correct answer. That means that if there’s a Dirac point with a small gap, we need to resolve it in momentum space, and the number of points should scale as $\sim(1/\xi)^d$.</p>
<p>If we consider a disordered system, we must consider a finite system of a large enough size $L \gtrsim \xi$, so that every point on the Brillouin zone is representative, and we just need a single point to effectively estimate the value of the integral (you’ll see later how to do this in one of the techniques).</p>
<p>So let’s take a system with $N$ orbitals in a unit cell, and edge state decay length $\xi$. The cost of computing the topological invariant is:</p>
<ul>
<li>$\sim (N/\xi)^{3d}$ for disordered systems using the full spectrum.</li>
<li>$\sim N^3 / \xi^d$ for band structures using the full spectrum.</li>
<li>$\sim (N/\xi)^{3d-3}$ for disordered systems using scattering approach.</li>
<li>$\sim N^3 / \xi^{d-1}$ for band structures using scattering approach.</li>
</ul>
<h1 id="A-special-thing-about-1D"><a href="#A-special-thing-about-1D" class="headerlink" title="A special thing about 1D"></a>A special thing about 1D</h1><p>There is a special feature of topological invariants in 1D, that dramatically speeds up a calculation. It’s a computational trick that is so elegant and universal that we’d like to share it.</p>
<p>You might remember studying the SSH chain back in week one. This is a similar system to the Majorana chain, but it is characterized by chiral symmetry rather than particle-hole symmetry.</p>
<p>A 1D Bloch Hamiltonian $H(k)$ with chiral symmetry has the form</p>
<p>$$<br>H(k) = \begin{pmatrix} 0 &amp; h(k) \<br>h^\dagger(k) &amp; 0\end{pmatrix},<br>$$</p>
<p>with $h(k) = h_0 + t_L e^{ik} + t_R e^{-ik}$ a matrix containing the onsite term $h_0$, the left hopping $t_L$ and the right hopping $t_R$.</p>
<p>If you look up the table, this Hamiltonian is characterized by a $\mathbb{Z}$ topological invariant. This invariant is the  <a href="http://en.wikipedia.org/wiki/Winding_number">winding number</a> that Fabian Hassler discussed in the introductory video. Let’s again describe its meaning.</p>
<p>We need to find an integer quantity which can only change when the gap of $H(k)$ closes. Now, $H(k)$ can only have a zero eigenvalue if $h(k)$ does, that is if $\det [h(k)]=0$. For a gapped Hamiltonian, $\det [h(k)]$ will in general be a complex number other than zero for all values of $k$.</p>
<p>Let us now try to picture the path that $h(k)$ takes in the complex plane as $k$ is varied from $0$ to $2\pi$. This path must be closed, because $\det [h(0)]$ must be equal to $\det [h(2\pi)]$, and avoid the origin. We may therefore ask: how many times does the path go around the origin? This number must be integer, and it cannot change unless we make the path go through zero. It is our $\mathbb{Z}$ topological invariant, because we can distinguish a clockwise path from a counterclockwise path.</p>
<p>The mathematical expression for the winding number is more obscure than its meaning:</p>
<p>$$<br>Q(H) = \frac{1}{2\pi i},\int_0^{2\pi} dk,\frac{d}{dk},\log,\det[h(k)],<br>$$</p>
<p>but it just counts how much the phase of $\det h$ increases as $k$ goes through the Brillouin zone.</p>
<p>How to take this integral? The trick is to use analytic continuation to a complex plane.</p>
<p>As $k$ varies from $0$ to $2\pi$, $e^{ik}$ goes around the unit circle in the complex plane. Let’s now make a substitution $e^{ik},\to,z$, with $z$ a complex number. The determinant $\det[h(k)]$ becomes a polynomial function in $z$, $f(z) = \det[h_0 + z, t_L + z^{-1}, t_R]$. We now need to compute the following integral on the unit circle </p>
<p>$$<br>Q(H) = \frac{1}{2\pi i},\oint dz ,\frac{d}{dz} \log f(z) = \frac{1}{2\pi i},\oint,dz,\frac{f’(z)}{f(z)}.<br>$$</p>
<p>We can now use a nice result from complex analysis, the <a href="http://en.wikipedia.org/wiki/Argument_principle">argument principle</a>. It tells us that each zero of $f(z)$ inside the unit circle contributes $+1$ to the value of $Q(H)$, and each pole contributes $-1$. Hence, by counting the number of zeros and poles of $f(z)$ inside the unit circle we immediately get the winding number. So, we have reduced the calculation of the topological invariant to finding zeros and poles of the expression $\det[h_0 + z, t_L + z^{-1}, t_R]=0$. The poles are trivial to find, and they are all located at $z=0$.</p>
<p>To find the zeros we notice that we need to solve a problem</p>
<p>$$[z h_0 + z^2 t_L + t_R]\psi = 0.$$</p>
<p>This is a <a href="http://en.wikipedia.org/wiki/Nonlinear_eigenproblem">polynomial eigenvalue problem</a>, and it is trivially mapped onto a standard eigenvalue problem.</p>
<p>$$<br>\begin{pmatrix}<br>-t_r &amp; 0\<br>0 &amp; 1<br>\end{pmatrix} \psi’=<br>z\begin{pmatrix}<br>h_0 &amp; t_L \<br>1 &amp; 0<br>\end{pmatrix} \psi’.<br>$$</p>
<p>So by finding all the eigenvalues $z$ we get all the zeros of $h(z)$ inside the unit circle, and immediately obtain the 1D topological invariant:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_sys</span>(<span class="params">N=<span class="number">4</span></span>):</span></span><br><span class="line">    onsite = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    lefthopping = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line">    righthopping = randn(N, N) + <span class="number">1j</span> * randn(N, N)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> onsite, lefthopping, righthopping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_singularities</span>(<span class="params">onsite, lefthopping, righthopping</span>):</span></span><br><span class="line">    <span class="comment"># We will have a generalized eigenvalue problem. The two matrices alone do not have much of a physical meaning,</span></span><br><span class="line">    <span class="comment"># so their names are also meaningless: A, B.</span></span><br><span class="line">    n = <span class="built_in">len</span>(onsite)</span><br><span class="line"></span><br><span class="line">    A = np.bmat([[-righthopping, np.zeros((n, n))], [np.zeros((n, n)), np.eye(n)]])</span><br><span class="line"></span><br><span class="line">    B = np.bmat([[onsite, lefthopping], [np.eye(n), np.zeros((n, n))]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scipy.linalg.eigvals(A, B)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">winding_plot</span>(<span class="params">onsite, lefthopping, righthopping</span>):</span></span><br><span class="line">    singularities = find_singularities(onsite, lefthopping, righthopping)</span><br><span class="line">    winding = <span class="built_in">sum</span>(<span class="built_in">abs</span>(singularities) &lt; <span class="number">1</span>) - <span class="built_in">len</span>(onsite)</span><br><span class="line">    circle = np.exp(<span class="number">1j</span> * np.linspace(-np.pi, np.pi, <span class="number">30</span>))</span><br><span class="line">    title = <span class="string">&quot;Winding number: $&#123;&#125;$&quot;</span>.<span class="built_in">format</span>(winding)</span><br><span class="line">    kdims = [<span class="string">r&quot;$\operatorname&#123;Re&#125;(z)$&quot;</span>, <span class="string">r&quot;$\operatorname&#123;Im&#125;(z)$&quot;</span>]</span><br><span class="line">    pl = holoviews.Path((circle.real, circle.imag), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>, <span class="string">&quot;linestyle&quot;</span>: <span class="string">&quot;--&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    pl *= holoviews.Points((singularities.real, singularities.imag)).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    pl *= holoviews.Points((<span class="number">0</span>, <span class="number">0</span>)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> pl[-<span class="number">2</span>:<span class="number">2</span>, -<span class="number">2</span>:<span class="number">2</span>].relabel(title).opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">3</span>, <span class="string">&quot;yticks&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">30</span>)</span><br><span class="line">onsite, lefthopping, righthopping = random_sys()</span><br><span class="line">winding_scale = <span class="keyword">lambda</span> scale: winding_plot(</span><br><span class="line">    <span class="number">4</span> * onsite * <span class="number">1.2</span> ** -<span class="built_in">abs</span>(scale),</span><br><span class="line">    lefthopping * <span class="number">1.2</span> ** scale,</span><br><span class="line">    righthopping * <span class="number">1.2</span> ** -scale,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;scale: winding_scale(scale) <span class="keyword">for</span> scale <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>, <span class="number">10</span>)&#125;, kdims=[<span class="string">r&quot;$\alpha$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In the graph above, we see the zeros (red) and poles (blue) of $h(z)$ for some randomly generated system, while we tune a parameter $\alpha$ that gradually changes the topology of the system.</p>
<p>The approach of analytic continuation onto a complex plane works whenever we have only one momentum variable, so for any 1D system, or a 2D system where we compute the scattering, and allows to calculate the integral exactly and in one step.</p>
<h1 id="Real-space-methods"><a href="#Real-space-methods" class="headerlink" title="Real space methods"></a>Real space methods</h1><p>There is also a broad class of algorithms that rely on the real space structure of the system, and on the inability to deform the wave functions of the filled state into completely localized orbitals.</p>
<p>The intuition behind these is coming from <a href="http://en.wikipedia.org/wiki/Noncommutative_geometry">non-commutative geometry</a>, and so it is very hard to explain intuitively. Let us try to illustrate the logic behind those.</p>
<p>The real space invariants are known for many different <a href="http://arxiv.org/abs/1012.1019">symmetry classes</a>, but for concreteness let’s see how they work for the Chern insulators (and accordingly how we can compute the Chern number).</p>
<p>First, let’s make a finite but large system in a way that it is fully gapped. Of course if it’s topologically non-trivial, we need to remove the edge states, and we’ll do this by applying periodic boundary conditions in both $x$- and $y$-directions.</p>
<p>We can now define periodic $x$ and $y$ coordinates $0 &lt; x \leq L$, $0 &lt; y \leq W$. We can make continuous variables out of these by studying phase factors $\varphi_x = \exp(2 \pi i x / L)$, and $\varphi_y = \exp(2 \pi i y / W)$.</p>
<p>The rough idea is as follows. All the filled states in a gapped material can be made localized, but if the system is topological this localization of the states is never exact (since fully localized states would correspond to a trivial Hamiltonian).</p>
<p>Fully localized states would have their $x$ and $y$ coordinates commuting, so we could try to check if we can approximate $x$ and $y$ coordinates of the filled states with commuting matrices.</p>
<p>The $\varphi_x$ and $\varphi_y$ phases of the filled states are operators, and we can calculate them by projecting them onto the space of filled states:</p>
<p>$$<br>\varPhi_x = \sum_{ij} |\psi_i\rangle\langle \psi_i | \varphi_x | \psi_j\rangle \langle \psi_j|,<br>$$</p>
<p>$$<br>\varPhi_y = \sum_{ij} |\psi_i\rangle \langle \psi_i | \varphi_y | \psi_j\rangle \langle \psi_j|.<br>$$</p>
<p>We now need to determine if $\varPhi_x$ and $\varPhi_y$ approximately commute. Let’s consider the expression</p>
<p>$$<br>\textrm{tr}\left(\log\left(\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger\right)\right) = 2\pi i ,m + r,.<br>$$</p>
<p>First of all, $m$ is always an integer, because $\text{tr}(\log(A)) = \log(\det(A)),$ and the $\det\left(\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger\right) = \det(\varPhi_x)\det^<em>(\varPhi_x)\det(\varPhi_y)\det^</em>(\varPhi_y)$, so it is real.</p>
<p>If $\varPhi_x$ and $\varPhi_y$ commute, $m = 0$. It can only change if one of the eigenvalues of $\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger$ goes through 0 on a complex plane, which signals appearance of a delocalized mode.</p>
<p>So the <strong>Bott index</strong> $m$ looks like a Chern number, behaves like a Chern number, and it indeed is a Chern number.</p>
<p>To illustrate its behavior let’s plot the cumulative sum of the eigenvalues of $\log\varPhi_x \varPhi_y \varPhi_x^\dagger \varPhi_y^\dagger$, taking a disordered Chern insulator as a sample system:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%opts Points &#123;+framewise&#125;</span><br><span class="line">%%opts Path &#123;+framewise&#125;</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.1</span>, delta=<span class="number">0.1</span>, disorder=<span class="number">0.5</span>)</span><br><span class="line">syst = chern_torus(<span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_m</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    op_x, op_y = projected_operators(syst, p, energy=<span class="number">0.01</span>)</span><br><span class="line">    temp = op_x @ op_y @ op_x.T.conj() @ op_y.T.conj()</span><br><span class="line">    eigs = np.linalg.eigvals(temp)</span><br><span class="line">    <span class="comment"># get rid of the four zero eigenvalues</span></span><br><span class="line">    res = np.<span class="built_in">sum</span>(np.log(eigs))</span><br><span class="line">    res = res.imag / (<span class="number">2</span> * np.pi)</span><br><span class="line">    <span class="comment"># This calculation is only correct to numerical accuracy.</span></span><br><span class="line">    <span class="comment"># When the Chern number is zero the result might be a very small negative number.</span></span><br><span class="line">    <span class="comment"># We make them positive so that the out put is never -0, because that does not look nice.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(res) &lt; <span class="number">0.5</span>:</span><br><span class="line">        res = <span class="built_in">abs</span>(res)</span><br><span class="line"></span><br><span class="line">    xs = np.cumsum(np.log(eigs)).real</span><br><span class="line">    ys = np.cumsum(np.log(eigs)).imag</span><br><span class="line"></span><br><span class="line">    x = np.append([<span class="number">0</span>], xs)</span><br><span class="line">    y = np.append([<span class="number">0</span>], ys)</span><br><span class="line">    title = <span class="string">&quot;$m=&#123;:.2&#125;$, Chern number $=&#123;:1.0f&#125;$&quot;</span>.<span class="built_in">format</span>(p.mu, res)</span><br><span class="line">    window_widening = (<span class="built_in">max</span>(x) - <span class="built_in">min</span>(x)) * <span class="number">0.05</span></span><br><span class="line">    pl = holoviews.Path((x, y)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    pl *= holoviews.Points((x, y)).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    xlim = <span class="built_in">slice</span>(<span class="built_in">min</span>(x) - window_widening, <span class="built_in">max</span>(x) + window_widening)</span><br><span class="line">    ylim = <span class="built_in">slice</span>(-<span class="number">2</span> * np.pi - <span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">2</span>, <span class="string">&quot;yticks&quot;</span>: [(-<span class="number">2</span> * np.pi, <span class="string">r&quot;$-2\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>)]&#125;</span><br><span class="line">    <span class="keyword">return</span> pl[xlim, ylim].relabel(title).opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: evaluate_m(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> np.linspace(-<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">16</span>)&#125;, kdims=[<span class="string">r&quot;$m$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;9qCSXEfSlqE&quot;</span>, src_location=<span class="string">&quot;8.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topological invariants&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w8_general/classification/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> HTML</span><br><span class="line"><span class="keyword">from</span> nbconvert.filters.markdown <span class="keyword">import</span> markdown2html_pandoc</span><br><span class="line"></span><br><span class="line">displaymd = <span class="keyword">lambda</span> markdown: display_html(HTML(markdown2html_pandoc(markdown)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Markdown tables are ugly, and Mathjax doesn&#x27;t support \tabular,</span></span><br><span class="line"><span class="comment"># therefore we use math mode + \array + add a command \T to make</span></span><br><span class="line"><span class="comment"># the \array rows less dense.</span></span><br><span class="line"></span><br><span class="line">table_header = <span class="string">r&quot;&quot;&quot;$$</span></span><br><span class="line"><span class="string">\require&#123;color&#125;</span></span><br><span class="line"><span class="string">colordefs</span></span><br><span class="line"><span class="string">\newcommand\T&#123;\Rule&#123;0pt&#125;&#123;1em&#125;&#123;.3em&#125;&#125;</span></span><br><span class="line"><span class="string">\begin&#123;array&#125;&#123;fmt&#125;</span></span><br><span class="line"><span class="string">\hline</span></span><br><span class="line"><span class="string">body\\</span></span><br><span class="line"><span class="string">\hline</span></span><br><span class="line"><span class="string">\end&#123;array&#125;</span></span><br><span class="line"><span class="string">$$&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">replacements = [</span><br><span class="line">    (<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#123;&#123;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;&#125;&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;colordefs&quot;</span>, <span class="string">&quot;&#123;colordefs&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;fmt&quot;</span>, <span class="string">&quot;&#123;fmt&#125;&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;body&quot;</span>, <span class="string">&quot;&#123;body&#125;&quot;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> replacements:</span><br><span class="line">    table_header = table_header.replace(i, j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Symmetry classes names and their symmetry properties</span></span><br><span class="line">symmetry_classes = (<span class="string">&quot;A&quot;</span>, <span class="string">&quot;AIII&quot;</span>, <span class="string">&quot;AI&quot;</span>, <span class="string">&quot;BDI&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;DIII&quot;</span>, <span class="string">&quot;AII&quot;</span>, <span class="string">&quot;CII&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;CI&quot;</span>)</span><br><span class="line">chiralsym = <span class="number">5</span> * (<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">phs = <span class="number">3</span> * (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;1&quot;</span>,) + (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;-1&quot;</span>,)</span><br><span class="line">trs = <span class="number">2</span> * (<span class="string">&quot;&quot;</span>,) + <span class="number">2</span> * (<span class="string">&quot;1&quot;</span>,) + (<span class="string">&quot;&quot;</span>,) + <span class="number">3</span> * (<span class="string">&quot;-1&quot;</span>,) + (<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Locations of non-empty entries in the periodic table</span></span><br><span class="line">primary_seq = <span class="keyword">lambda</span> n: np.arange(n) % <span class="number">2</span></span><br><span class="line">z_descendant = <span class="keyword">lambda</span> n: np.arange(n) % <span class="number">8</span></span><br><span class="line">z2_descendant = <span class="keyword">lambda</span> n: np.arange(<span class="number">1</span>, n + <span class="number">1</span>) % <span class="number">8</span></span><br><span class="line">z2_descendant2 = <span class="keyword">lambda</span> n: np.arange(<span class="number">2</span>, n + <span class="number">2</span>) % <span class="number">8</span></span><br><span class="line">twoz_descendant = <span class="keyword">lambda</span> n: np.arange(<span class="number">4</span>, n + <span class="number">4</span>) % <span class="number">8</span></span><br><span class="line"></span><br><span class="line">line_end = <span class="string">&quot;\\T\\\\\n&quot;</span></span><br><span class="line">sep = <span class="string">&quot; &amp; &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_table</span>(<span class="params">n=<span class="number">4</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create an array of entries forming the periodic table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    n : int</span></span><br><span class="line"><span class="string">        Number of dimensions to show.</span></span><br><span class="line"><span class="string">    show_symmetries : bool</span></span><br><span class="line"><span class="string">        Show symmetry information for each symmetry class.</span></span><br><span class="line"><span class="string">    sort_order : int array or None</span></span><br><span class="line"><span class="string">        Ordering to apply to the symmetry classes </span></span><br><span class="line"><span class="string">        (can be trivially used to discard entries).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    data : np.ndarray</span></span><br><span class="line"><span class="string">        A string array with the entries of the periodic table.</span></span><br><span class="line"><span class="string">    format_string : str</span></span><br><span class="line"><span class="string">        An alignment string that can be used to feed the resulting</span></span><br><span class="line"><span class="string">        table to a Latex \array environment. </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    dimensions = np.array([[<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]], dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> dimensions.shape[<span class="number">1</span>]:</span><br><span class="line">        dimensions[<span class="number">0</span>, <span class="number">0</span>] = <span class="string">r&quot;d=&quot;</span> + dimensions[<span class="number">0</span>, <span class="number">0</span>].decode(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">    complex_entries = np.zeros((<span class="number">2</span>, n), dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    complex_entries[primary_seq(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    real_entries = np.zeros((<span class="number">8</span>, n), dtype=<span class="string">&quot;S100&quot;</span>)</span><br><span class="line">    real_entries[z_descendant(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line">    real_entries[z2_descendant(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;_2&quot;</span></span><br><span class="line">    real_entries[z2_descendant2(n), np.arange(n)] = <span class="string">r&quot;\mathbb&#123;Z&#125;_2&quot;</span></span><br><span class="line">    real_entries[twoz_descendant(n), np.arange(n)] = <span class="string">r&quot;2\mathbb&#123;Z&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    entries = np.r_[complex_entries, real_entries]</span><br><span class="line"></span><br><span class="line">    sym_classes_rm = <span class="built_in">tuple</span>(<span class="string">r&quot;\textrm&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(cl) <span class="keyword">for</span> cl <span class="keyword">in</span> symmetry_classes)</span><br><span class="line"></span><br><span class="line">    sym = np.array(</span><br><span class="line">        [sym_classes_rm] + show_symmetries * [chiralsym, phs, trs], dtype=<span class="string">&quot;S100&quot;</span></span><br><span class="line">    ).T</span><br><span class="line">    sym_header = np.array(</span><br><span class="line">        [</span><br><span class="line">            [<span class="string">r&quot;\textrm&#123;class&#125;&quot;</span>]</span><br><span class="line">            + show_symmetries * [<span class="string">r&quot;\mathcal&#123;C&#125;&quot;</span>, <span class="string">r&quot;\mathcal&#123;P&#125;&quot;</span>, <span class="string">r&quot;\mathcal&#123;T&#125;&quot;</span>]</span><br><span class="line">        ],</span><br><span class="line">        dtype=<span class="string">&quot;S100&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    header = np.c_[sym_header, dimensions]</span><br><span class="line"></span><br><span class="line">    table = np.c_[sym, entries]</span><br><span class="line">    <span class="keyword">if</span> sort_order <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        table = table[sort_order]</span><br><span class="line"></span><br><span class="line">    format_string = <span class="string">&quot;c|&quot;</span> + show_symmetries * <span class="string">&quot;rrr&quot;</span> + n * show_symmetries * <span class="string">&quot;|&quot;</span> + n * <span class="string">&quot;c&quot;</span></span><br><span class="line">    <span class="keyword">return</span> np.r_[header, table], format_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">color_table</span>(<span class="params">table, color_array</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Apply rgb colors to table entries.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `color_array[i, j]` is the rgb color of the entry `(i, j)`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns the string of color definitions required for coloring the table.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    apply_color = <span class="keyword">lambda</span> text, color: <span class="string">r&quot;\color&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(color, text)</span><br><span class="line"></span><br><span class="line">    colors = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> np.indices(table.shape).reshape(<span class="number">2</span>, -<span class="number">1</span>).T:</span><br><span class="line">        idx = <span class="built_in">tuple</span>(idx)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(color_array[idx]):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        color = <span class="string">&quot;,&quot;</span>.join(<span class="string">&quot;&#123;:1.2&#125;&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> color_array[idx])</span><br><span class="line">        val = <span class="built_in">str</span>(<span class="built_in">abs</span>(<span class="built_in">hash</span>(color)))[:<span class="number">8</span>]</span><br><span class="line">        colors[color] = val</span><br><span class="line">        table[idx] = apply_color(table[idx].decode(<span class="string">&quot;utf-8&quot;</span>), val)</span><br><span class="line"></span><br><span class="line">    defs = []</span><br><span class="line">    <span class="keyword">for</span> color, code <span class="keyword">in</span> <span class="built_in">list</span>(colors.items()):</span><br><span class="line">        defs.append(<span class="string">r&quot;\definecolor&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;rgb&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(code, color))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(defs)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Shinsei Ryu from the University of Illinois will introduce the general classification of topological insulators and superconductors.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;cKzUuQyZjFo&quot;</span>, src_location=<span class="string">&quot;8.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="At-a-glance-periodic-table"><a href="#At-a-glance-periodic-table" class="headerlink" title="At a glance: periodic table"></a>At a glance: periodic table</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">full_table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">False</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line"></span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line">colordefs = <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>Let us now look at all the possible symmetry classes in dimensions from $0$ to $3$, and see what kind of topological insulators are possible.</p>
<p>There are quite a few, here is the full list:</p>
<p>This table has a lot of logic in it, but to you it most likely looks no better than this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">full_table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">False</span>, sort_order=np.random.permutation(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">color_array = np.<span class="built_in">round</span>(np.random.rand(*(full_table.shape + (<span class="number">3</span>,))), <span class="number">2</span>)</span><br><span class="line">colordefs = color_table(full_table, color_array)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>But don’t worry, we are going to learn exactly what these tables mean.</p>
<p>First of all, let’s review the meaning of the entries in the table. Each entry gives the topological classification of a system with a given combination of symmetries and dimensionality. In other words, it gives us the possible values that the topological invariant $Q$ of such a system can take.</p>
<p>An empty entry means that the system does not have a topological phase. In other words, all gapped Hamiltonians with dimension and symmetries corresponding to an empty entry can be deformed into each other, without ever closing the bulk gap and without breaking any existing symmetry.</p>
<p>A $\mathbb{Z}$ entry tells us that the topological invariant is an integer number, $Q=0, \pm 1, \pm 2, \dots$ An example of such a system is the quantum Hall effect, for which the topological invariant is the Chern number. The value of $Q$ specifies the number of chiral edge states and their chirality, which is opposite for opposite signs of $Q$.</p>
<p>A $2\mathbb{Z}$ entry is much like a $\mathbb{Z}$ entry, except that the invariant may only take even numbers, $Q=0,\pm2, \pm4, \dots$, because of some doubling of the degrees of freedom. An example is a quantum dot with spinful time-reversal symmetry, for which the topological invariant is the number of filled energy levels. It may only be an even number because of Kramers degeneracy.</p>
<p>A $\mathbb{Z}_2$ entry means that there are only two distinct topological phases, with $Q=\pm 1$ (or $Q=0, 1$, depending on convention). An example we know is the Majorana chain, with the Pfaffian topological invariant, which distinguishes between the two phases with or without unpaired Majorana modes and the ends. Another example we know are the time-reversal invariant topological insulators in two and three dimensions.</p>
<p>Now that we have attached a meaning to each entry in the table, let’s try to understand the table as a whole. The first thing to do is to understand why it has ten and only ten rows.</p>
<h1 id="Symmetry-classes"><a href="#Symmetry-classes" class="headerlink" title="Symmetry classes"></a>Symmetry classes</h1><p>Each row in the table corresponds to a certain <em>symmetry class</em>, that is to a given combination of the presence or absence of three fundamental discrete symmetries.</p>
<p>You already encountered these three symmetries all the way back in week one. They are time-reversal symmetry ($\mathcal{T}$), particle-hole symmetry ($\mathcal{P}$) and chiral symmetry ($\mathcal{C}$). We previously referred to chiral symmetry $\mathcal{C}$ as sublattice symmetry. This is because in condensed matter physics, a natural realization of chiral symmetry is a system composed of two sublattices, such that sites in one lattice only couple to sites in the other.</p>
<p>Why do we consider these symmetries fundamental, and restrict the periodic table to them only?</p>
<p>As you may recall from week one, and as Shinsei Ryu explained in the introductory video, normal unitary symmetries of a Hamiltonian do not have particularly interesting consequences for topological classification. One may always make the Hamiltonian block-diagonal, reducing the problem to the study of a single block. This procedure can be repeated until one runs out of unitary symmetries and is left with an <em>irreducible</em> block of the Hamiltonian, i.e. one which cannot be block diagonalized.</p>
<p>Time-reversal, particle-hole and chiral symmetries act in a different way. They impose certain constraints on an irreducible Hamiltonian - for instance, by forcing it to be a real matrix, or to be block off-diagonal.</p>
<p>Note, however, that it is possible to extend the periodic table to study the interplay between these three discrete symmetries and other unitary symmetries. For instance, we have already touched upon crystalline symmetries in week seven, and we will return to them in week ten.</p>
<p>But for now, let’s focus on the three fundamental discrete symmetries: $\mathcal{P}$, $\mathcal{T}$ and $\mathcal{C}$. Their basic properties are:</p>
<ul>
<li>$\mathcal{T}$ is an anti-unitary operator which commutes with the Hamiltonian.</li>
<li>$\mathcal{P}$ is an anti-unitary operator which anti-commutes with the Hamiltonian.</li>
<li>$\mathcal{C}$ is a unitary operator which anti-commutes with the Hamiltonian.</li>
</ul>
<p>Recall that an anti-unitary operator can be written as the product of a unitary operator and the complex conjugation operator $\mathcal{K}$. The next important thing to know is that time-reversal and particle-hole symmetry may come in two separate flavors, depending on whether they square to plus or minus one.</p>
<p>For instance, you will recall that for the time-reversal operator acting on electronic states, $\mathcal{T}^2=-1$. This was the crux of Kramers theorem, which in turn was the key to topological insulators. If you go back to week one, you will also remember that we discussed real matrices, which were symmetric under a time-reversal operator $\mathcal{T}=\mathcal{K}$. This operator satisfies $\mathcal{T}^2=1$.</p>
<p>Thus, a system can behave in three ways under time-reversal symmetry $\mathcal{T}$: (1) it does not have time-reversal symmetry, (2) it has it and $\mathcal{T}$ squares to $+1$, (3) it has it and $\mathcal{T}$ squares to $-1$. The same holds for particle-hole symmetry, which can also have $\mathcal{P}^2=\pm 1$. On the other hand, the chiral symmetry only comes in one flavor, $\mathcal{C}^2=1$.</p>
<h2 id="Combining-symmetries"><a href="#Combining-symmetries" class="headerlink" title="Combining symmetries"></a>Combining symmetries</h2><p>How do we arrive to having ten symmetry classes? Let’s count all the possible cases carefully. By combining the three cases for $\mathcal{P}$ and the three cases for $\mathcal{T}$ we arrive at nine possible combinations. </p>
<p>The important thing to notice now is that $\mathcal{C}$ is not completely independent from $\mathcal{T}$ and $\mathcal{P}$. Whenever a system has both $\mathcal{T}$ and $\mathcal{P}$, there is also a chiral symmetry $\mathcal{C}=\mathcal{P\cdot T}$.</p>
<p>This also means that if a system only has either $\mathcal{T}$ or $\mathcal{P}$ but not both, it cannot have a chiral symmetry $\mathcal{C}$. In other words, the presence of any two out of the three symmetries implies that the third is also present.</p>
<p>On the other hand, if both $\mathcal{P}$ and $\mathcal{T}$ are absent, then $\mathcal{C}$ may or may not be present. This gives us two distinct cases.</p>
<p>Adding all the possibilities, we indeed find 10 symmetry classes:</p>
<p>$$(3\times 3 - 1) + 2 = 8 + 2 = 10,.$$</p>
<p>The first term in the sum corresponds to the eight cases where there is at least one anti-unitary symmetry: either $\mathcal{P}$, or $\mathcal{T}$, or both. These eight symmetry classes are called <em>real</em>, because an anti-unitary symmetry always involves the complex conjugation operator. This does not necessarily mean that the Hamiltonian is a real matrix, but it is a reminder that there is a constraint between its real and imaginary parts.</p>
<p>The second term in the sum covers the two cases when there are no anti-unitary symmetries. These symmetry classes are called <em>complex</em>.</p>
<p>Let’s have another look at the 10 rows in the table, this time specifying which combination of the three fundamental symmetries each row has:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">full_table, format_string = make_table(</span><br><span class="line">    n=<span class="number">0</span>, show_symmetries=<span class="literal">True</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> full_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>The somewhat cryptic notations in the leftmost column are just the names of the different symmetry classes. (Also the ‘I’s appearing there are Roman cardinal numbers, so for instance BDI is ‘B D one’, and AIII is “A three”.)</p>
<p>Their names come from an elegant mathematical classification of <a href="http://en.wikipedia.org/wiki/Symmetric_space">symmetric spaces</a> worked out by <a href="http://en.wikipedia.org/wiki/%C3%89lie_Cartan">Elie Cartan</a> in 1926. While it is definitely intriguing that a group theory result from 1926 reappears in a totally different context almost 80 years later, the origin of this nomenclature is not directly relevant to most of the theory done in the field.<br>The two complex classes are A and AIII.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;Which symmetry class do we get if we break Kramers degeneracy in class BDI?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [<span class="string">&quot;D&quot;</span>, <span class="string">&quot;AIII&quot;</span>, <span class="string">&quot;DIII&quot;</span>, <span class="string">&quot;None, class BDI has no Kramers degeneracy&quot;</span>]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;Kramers degeneracy requires that time reversal squares to -1, while it squares to 1 in class BDI.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Finally, let us make an extra observation:</p>
<blockquote>
<p>While the particle-hole symmetry appears in any superconductor, it must satisfy $\mathcal{P}^2 = -\mathcal{T}^2$ due to the way the Bogoliubov quasiparticles are related to the original electrons. This makes the symmetry classes BDI, and CII rely on a fine-tuned Hamiltonian, just like the symmetry class AIII.</p>
</blockquote>
<h1 id="What-we-learned-so-far"><a href="#What-we-learned-so-far" class="headerlink" title="What we learned so far"></a>What we learned so far</h1><p>To get some confidence with the table and these obscure names, it is useful to see where the topological systems that we have studied so far fit into the table.</p>
<p>Every red entry in the table below corresponds to something which we already know and studied in the previous weeks of the course, as you can discover by moving the mouse over it.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tooltips = &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">6</span>): <span class="string">&quot;Chern insulator: no symmetries, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">5</span>): <span class="string">&quot;Majorana wire: spinful particle-hole, d=1&quot;</span>,</span><br><span class="line">    (<span class="number">4</span>, <span class="number">5</span>): <span class="string">&quot;Polyacetilene/SSH chain: sublattice symmetry, d=1&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">6</span>): <span class="string">&quot;QSHE: spinful TRS, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">7</span>): <span class="string">&quot;3D strong TI: spinful TRS, d=3&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">6</span>): <span class="string">&quot;p-wave superconductor: PHS, d=2&quot;</span>,</span><br><span class="line">    (<span class="number">9</span>, <span class="number">4</span>): <span class="string">&quot;Superconducting quantum dot: d=0, PHS&quot;</span>,</span><br><span class="line">    (<span class="number">2</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, spinless TRS&quot;</span>,</span><br><span class="line">    (<span class="number">1</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, no symmetries&quot;</span>,</span><br><span class="line">    (<span class="number">3</span>, <span class="number">4</span>): <span class="string">&quot;Quantum dot: d=0, spinful TRS and Kramers degeneracy&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table, format_string = make_table(</span><br><span class="line">    show_symmetries=<span class="literal">True</span>, sort_order=np.argsort(symmetry_classes)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">colors = np.zeros(shape=table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos <span class="keyword">in</span> tooltips:</span><br><span class="line">    colors[pos] = [<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line"></span><br><span class="line">colordefs = color_table(table, colors)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pos, val <span class="keyword">in</span> <span class="built_in">list</span>(tooltips.items()):</span><br><span class="line">    table[pos] = <span class="string">r&quot;\texttip&#123;&#123;&#123;&#125;&#125;&#125;&#123;&#123;&#123;&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(table[pos].decode(<span class="string">&quot;utf-8&quot;</span>), val)</span><br><span class="line"></span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">HTML(</span><br><span class="line">    markdown2html_pandoc(</span><br><span class="line">        table_header.<span class="built_in">format</span>(</span><br><span class="line">            colordefs=(<span class="string">&quot;\\require&#123;action&#125;\n&quot;</span> + colordefs), fmt=format_string, body=block</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>As you can see, the Majorana wire and the $p$-wave superconductor are in class D, the Chern insulators in class A, and the time-reversal invariant topological insulators in class AII. These names occur quite often in the literature.</p>
<h1 id="Finding-a-periodic-structure"><a href="#Finding-a-periodic-structure" class="headerlink" title="Finding a periodic structure"></a>Finding a periodic structure</h1><p>We have now explained why there are ten rows and the meaning of the symmetry classes, but the table as a whole still does not have a coherent structure. Is there a way that we can connect systems between different symmetry classes and different dimensions?</p>
<p>Given a gapped Bloch Hamiltonian $H_d$ in a certain symmetry class and dimension $d$, there is a systematic procedure by which we can increase its dimensionality. This changes its symmetry class, but makes sure that the topological classification is unvaried. This procedure thus allows us to connect different rows of the table.</p>
<p>The basic idea is to add a new momentum $k_{d+1}$ to the Bloch Hamiltonian in such a way that the gap does not close for any value of $k_{d+1}$ in the Brillouin zone. This means that the new Hamiltonian must have the same value of the topological invariant as the initial one. The tricky (but also beautiful) part is that adding a momentum can change the symmetries of the Hamiltonian, and one has to keep track of that carefully.</p>
<p>This procedure is slightly different depending on whether the initial $H_d$ has chiral symmetry or not. In one case the procedure removes symmetries, in the other it adds them. Let’s start with the first.</p>
<h2 id="Removing-symmetries"><a href="#Removing-symmetries" class="headerlink" title="Removing symmetries"></a>Removing symmetries</h2><p>Let’s first suppose that $H_d$ has chiral symmetry $\mathcal{C}$. The Hamiltonian then has $n$ pairs of energy bands symmetric around zero, which we can denote as $\pm \epsilon_{n,d}$, hiding their dependence on the different momenta appearing in $H_d$.</p>
<p>Then consider the following higher-dimensional Hamiltonian:</p>
<p>$$<br>H_{d+1} = H_d,\cos k_{d+1} + \mathcal{C} \sin k_{d+1}.<br>$$</p>
<p>This Hamiltonian has the same number of bands as $H_d$, even though the bands are higher-dimensional. Given its simple form, every band $\epsilon_{n,d+1}^n$ is directly related to a band $\epsilon_{n,d}$ of $H_d$, </p>
<p>$$<br>\epsilon_{n,d+1} = \pm \sqrt{\epsilon_{n, d}^2,\cos^2 k_{d+1} + \sin^2 k_{d+1}}.<br>$$</p>
<p>This expression guarantees that the gap of $H_{d+1}$ only closes if that of $H_d$ closes. In other words, whatever value of the topological invariant $H_d$ has, $H_{d+1}$ will have the same value.</p>
<p>What are the discrete symmetries of $H_{d+1}$? First of all, note that $H_{d+1}$ has no chiral symmetry since the second term by construction commutes with $\mathcal{C}$, while the chiral symmetry would require anti-commutation. So $H_{d+1}$ and $H_d$ belong to a different symmetry classes. Which symmetry class does $H_d$ belong to?</p>
<p>If $\mathcal{C}$ is the only discrete symmetry of $H_d$, i.e. if $H_d$ belongs to class AIII, then $H_{d+1}$ has no symmetries at all, so it is in class A. We can express this by writing AIII $\to$ A, meaning that the topological classification is the same to the left of the arrow in $d$ dimensions, and to the right of the arrow in $d+1$ dimensions.</p>
<p>If instead $\mathcal{C}$ is not the only discrete symmetry of $H_d$, then $H_d$ must have both $\mathcal{P}$ and $\mathcal{T}$, because we know that two of the symmetries imply the third. Hence $H_d$ must be in one of the symmetry classes BDI, CI, CII, DIII. Because $H_{d+1}$ has no chiral symmetry, it can only have one remaining symmetry, either $\mathcal{P}$ or $\mathcal{T}$. It is therefore in one of the four classes AI, AII, C, D. With some patience, it is possible to work out exactly the symmetry class of $H_{d+1}$ given that of $H_d$ in all four cases.</p>
<p>We won’t do that, but state that the result is that by removing chiral symmetry and adding one dimension, one obtains that BDI $\to$ D, DIII $\to$ AII, CII $\to$ C and CI $\to$ AI.</p>
<h2 id="Adding-symmetries"><a href="#Adding-symmetries" class="headerlink" title="Adding symmetries"></a>Adding symmetries</h2><p>Let’s now start from a Hamiltonian without chiral symmetry. Our procedure this time involves a doubling of the number of bands of $H_d$. That is, we introduce a new set of Pauli matrices $\tau$, not present in $H_d$, and write $H_{d+1}$ as</p>
<p>$$<br>H_{d+1} = H_d,\cos k_{d+1},\tau_x + \sin k_{d+1},\tau_y.<br>$$</p>
<p>Note that just like in our previous argument, the topological invariant of $H_{d+1}$ must be the same as that of $H_d$. Also, by construction, $H_{d+1}$ has a chiral symmetry given by $\mathcal{C}=\tau_z$, which anticommutes with all the terms in the Hamiltonian. </p>
<p>What are the symmetries of $H_{d+1}$ in this case? To begin with, $H_d$ cannot have both anti-unitary symmetries, because then it would have $\mathcal{C}$ as well. It either has none (class A) or just one of them (classes AI, AII, C, or D). We thus have two cases:</p>
<ul>
<li>if $H_d$ has no symmetries at all, meaning that it was in class A, then $H_{d+1}$ only has chiral symmetry, meaning that it is in class AIII. So we obtain A $\to$ AIII.</li>
<li>if $H_d$ has one anti-unitary symmetry, then $H_{d+1}$ must have all three discrete symmetries. Again, we will not work out the details for each case, but one obtains that AI $\to$ BDI, D $\to$ DIII, AII $\to$ CII, and C $\to$ CI.</li>
</ul>
<p>Now that we have learned how to extend the topological classification by adding one dimension to the Hamiltonian and changing its symmetry in an appropriate way, nothing forbids us to repeat the procedure, by going two dimensions higher, three dimensions higher, etc…</p>
<p>So we have made the procedure of finding topological phases systematic.</p>
<h1 id="The-Bott-clock"><a href="#The-Bott-clock" class="headerlink" title="The Bott clock"></a>The Bott clock</h1><p>If you repeat the procedure many times, you will find that it has a period, i.e. at some point you end up in the same symmetry class you started with.</p>
<p>This is easy to see for the two complex classes, which are just interchanged:</p>
<ul>
<li>A $\to$ AIII $\to$ A.</li>
</ul>
<p>But it is also the case for the eight real classes:</p>
<ul>
<li>AI $\to$ BDI $\to$ D $\to$ DIII $\to$ AII $\to$ CII $\to$ C $\to$ CI $\to$ AI.</li>
</ul>
<p>This property is called <strong>Bott periodicity</strong>, and it can be nicely represented in the following table, similar to a clock:</p>
<p><img src="/2021/01/07/src/w8_general/classification/bott_clock.svg" alt></p>
<p>The grey entries in the table are the chiral classes, and the arrows show which classes have the same topological classification when you shift $d\to d+1$. The complex classes are in the centre of the table, and only talk to each other. The eight real classes are disposed around the clock.</p>
<p>Finally, let’s see what the table looks like when we order the rows according to the Bott clock above:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">5</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=<span class="number">8</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.linspace(<span class="number">0.6</span>, <span class="number">1.2</span>, n).reshape(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>) * np.random.rand(<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">palette = np.minimum(palette, <span class="number">1</span>)</span><br><span class="line">colors[primary_seq(n) + <span class="number">1</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">0</span>]</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">1</span>]</span><br><span class="line">colors[z2_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">2</span>]</span><br><span class="line">colors[z2_descendant2(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">3</span>]</span><br><span class="line">colors[twoz_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = palette[<span class="number">4</span>]</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>Finally some order appears!</p>
<p>We have colored the different entries to show how all the topological invariants repeat themselves along the diagonals, as a consequence of the procedure outlined above. The table has overall a period equal to 8, meaning that for instance in $d=8$ the topological classification in all symmetry classes is equal to that in $d=0$, and so on.</p>
<p>In fact, we know another way to change the dimensionality while preserving the topology. It is to go from a Hamiltonian $H$ in $d$ dimensions to the reflection matrix $r$ in $d-1$ dimensions. Whenever $H$ is gapped, $r$ has no zeroes, so both have the same topology. On the other hand, $r$ is a $d-1$-dimensional object, so in going from $H$ to $r$, we go against the Bott clock.</p>
<p>For example, this means that in the SSH chain, which is a $d=1$ dimensional system in symmetry class AIII, the scattering invariant is the same as the Hamiltonian invariant in the $d=0$ symmetry class A, i.e. the number of negative eigenvalues. On the other hand, the scattering invariant of the quantum Hall effect, the winding number of $r$, is the same expression as the Hamiltonian topological invariant of the SSH chain.</p>
<h1 id="Reading-the-table-in-different-ways"><a href="#Reading-the-table-in-different-ways" class="headerlink" title="Reading the table in different ways"></a>Reading the table in different ways</h1><h2 id="Complex-classes-Chern-and-winding-numbers"><a href="#Complex-classes-Chern-and-winding-numbers" class="headerlink" title="Complex classes: Chern and winding numbers"></a>Complex classes: Chern and winding numbers</h2><p>The first thing to observe is that the complex classes only have $\mathbb{Z}$ invariant. We already know what these invariants are in low dimensions: the Chern number, which we encountered in quantum Hall systems (class A, $d=2$), and the winding number of the reflection matrix, which we encountered when we studied reflection from the Thouless pump.</p>
<p>The higher dimensional invariants are simple generalizations of these two. Their mathematical expression can be found in several papers, for instance <a href="http://arxiv.org/abs/1104.1602">this one</a>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=n, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:<span class="number">3</span>, <span class="number">4</span>:] = [<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.8</span>]</span><br><span class="line">colors[<span class="number">1</span>, <span class="number">4</span>:] = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">colors[<span class="number">2</span>, <span class="number">4</span>:] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<h2 id="Reading-the-table-by-columns"><a href="#Reading-the-table-by-columns" class="headerlink" title="Reading the table by columns"></a>Reading the table by columns</h2><p>Another useful feature of the table is that in a given column, all $\mathbb{Z}$ or $2\mathbb{Z}$ entries, which are grouped by the color gradients below, have the same topological invariant.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">15</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=n, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.random.rand(n, <span class="number">3</span>) ** <span class="number">2</span></span><br><span class="line">colors[primary_seq(n) + <span class="number">1</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">0.8</span> * palette</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.6</span> * (<span class="number">1</span> - palette)</span><br><span class="line">colors[twoz_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.6</span> * (<span class="number">1</span> - palette)</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>We can check this statement for some cases we know. For instance, in $d=0$ the $\mathbb{Z}$ topological invariant is the number of filled energy levels, which applies to quantum dots with broken time-reversal symmetry (class A), spinless time-reversal symmetry (class AI) and spinful time-reversal symmetry (class AII, which has $2\mathbb{Z}$ because of Kramers degeneracy). In $d=2$, the $\mathbb{Z}$ topological invariant is the Chern number, and we saw how it applies to both the Chern insulators in class A and the $p$-wave superconductor in class D.</p>
<h2 id="Dimensional-reduction"><a href="#Dimensional-reduction" class="headerlink" title="Dimensional reduction"></a>Dimensional reduction</h2><p>An important pattern visible in the table is the descending sequence $\mathbb{Z} ,\to,\mathbb{Z}_2,\to,\mathbb{Z}_2$ that appears in every symmetry class. That is, starting from the $\mathbb{Z}$ invariant, reducing the dimensionaility twice by one we encounter two $\mathbb{Z}_2$ invariants in a row:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">4</span>)</span><br><span class="line">n = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">periodic_table, format_string = make_table(n=<span class="number">8</span>, show_symmetries=<span class="literal">True</span>, sort_order=<span class="literal">None</span>)</span><br><span class="line">colors = np.zeros(shape=periodic_table.shape + (<span class="number">3</span>,))</span><br><span class="line">colors[<span class="number">1</span>:, <span class="number">4</span>:] = [<span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>]</span><br><span class="line">palette = np.random.rand(n, <span class="number">3</span>)</span><br><span class="line">colors[z_descendant(n) + <span class="number">3</span>, np.arange(n) + <span class="number">4</span>] = <span class="number">0.8</span> * palette</span><br><span class="line">colors[z2_descendant(n - <span class="number">1</span>) + <span class="number">3</span>, np.arange(n - <span class="number">1</span>) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.8</span> * (<span class="number">1</span> - palette[<span class="number">1</span>:])</span><br><span class="line">colors[z2_descendant2(n - <span class="number">2</span>) + <span class="number">3</span>, np.arange(n - <span class="number">2</span>) + <span class="number">4</span>] = <span class="number">1</span> - <span class="number">0.5</span> * (<span class="number">1</span> - palette[<span class="number">2</span>:])</span><br><span class="line">colordefs = color_table(periodic_table, colors)</span><br><span class="line">rows = [sep.join([c.decode(<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> line]) <span class="keyword">for</span> line <span class="keyword">in</span> periodic_table]</span><br><span class="line">rows[<span class="number">1</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">1</span>]</span><br><span class="line">rows[<span class="number">3</span>] = <span class="string">r&quot;\hline &quot;</span> + rows[<span class="number">3</span>]</span><br><span class="line">block = line_end.join(rows)</span><br><span class="line"></span><br><span class="line">displaymd(table_header.<span class="built_in">format</span>(colordefs=colordefs, fmt=format_string, body=block))</span><br></pre></td></tr></table></figure>

<p>Again, this dimensional reduction can best be understood with an example we already know. Consider the symmetry class $D$. In $d=2$ it has a $\mathbb{Z}$ topological phase, the $p$-wave superconductor.</p>
<p>If you take a finite ribbon of a $p$-wave superconductor, it will have an integer number of edge states, as determined by the Chern number. Let’s now imagine that you take a ribbon and roll it up into a thin, long cylinder, by pasting two of its edges together. The two remaining edges at this point form a circle.</p>
<p>You can now view this cylinder as a one-dimensional system whose ends are the two rolled-up edges, and ask: how many zero-energy Majorana modes can there be at the ends? We know the answer from last week’s material: the number of zero-modes can be zero or one, depending on whether the boundary conditions are periodic or anti-periodic. The topological invariant is thus reduced to $\mathbb{Z}_2$. This is no surprise, since the system is topologically in the same class as the Kitaev chain.</p>
<p>We can proceed further with our dimensional reduction. If we take our one dimensional system and make it into a ring, we obtain a zero-dimensional system. Depending on how the two ends are coupled, the two Majorana modes can favour the even or odd fermion parity state, and this quantity cannot change without a Fermi level crossing. This is the $\mathbb{Z}_2$ invariant of zero-dimensional systems in class D.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What sort of topological invariant do we get if we take a 3D TI, and try to make a 4D system with strong invariant, &quot;</span></span><br><span class="line">    <span class="string">&quot;like we did when making a 3D TI out of QSHE?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;We get another $Z_2$ topological invariant&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A 4D system with the Chern number as invariant.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;This construction cannot be repeated anymore.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The topological invariant stays the same.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;A quick check with the table shows that symmetry class AII in 4D has a $Z$ invariant, &quot;</span></span><br><span class="line">    <span class="string">&quot;and it should be the second Chern number.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;nnzPiJ3Q3_8&quot;</span>, src_location=<span class="string">&quot;8.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Periodic table&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w7_defects/w7_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-Majorana-defects"><a href="#Simulations-Majorana-defects" class="headerlink" title="Simulations: Majorana defects"></a>Simulations: Majorana defects</h1><p>As usual, start by grabbing the notebooks of this week (<code>w7_defects</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<h2 id="Quantum-spin-Hall-junction"><a href="#Quantum-spin-Hall-junction" class="headerlink" title="Quantum spin Hall junction"></a>Quantum spin Hall junction</h2><p>Let us study the spectrum of a Josephson junction on a quantum spin Hall edge in more detail. As in the lecture, we can add a magnet in the middle of the junction, which adds a Zeeman energy term to the Hamiltonian.</p>
<p>First, make such a junction. The code from week 2 for making a Josephson junction may be useful.</p>
<p>We are interested in the spectrum below the gap. There are two interesting parameters to vary: the Zeeman energy and the length of the junction. What happens to the energy levels as you increase the length of the junction. In particular, what happens when the junction is very long? What if you turn off the magnet?</p>
<p>Compare your results to the following paper, particularly Fig. 2.</p>
<ul>
<li>arXiv:0804.4469</li>
</ul>
<h2 id="Majorana-in-a-crystalline-defect"><a href="#Majorana-in-a-crystalline-defect" class="headerlink" title="Majorana in a crystalline defect"></a>Majorana in a crystalline defect</h2><p>Following Taylor Hughes suggestion from the summary of the lecture about crystalline defects, create an edge dislocation carrying a Majorana mode in an array of weakly coupled Kitaev chains.</p>
<p>Then try to split the dislocation into two disclinations. What happens to the Majorana mode?</p>
<p>Note that Kwant only supports regular lattices, so crystallographic defects can be implemented by altering some hoppings, as was done in the simulations in the lecture.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Topological defects&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-0707-1692"><a href="#arXiv-0707-1692" class="headerlink" title="arXiv:0707.1692"></a>arXiv:0707.1692</h3><p><strong>Hint:</strong> In detail, how to create and manipulate Majoranas on the 3D TI surface.</p>
<h3 id="arXiv-1112-3527"><a href="#arXiv-1112-3527" class="headerlink" title="arXiv:1112.3527"></a>arXiv:1112.3527</h3><p><strong>Hint:</strong> The Josephson effect on a 3D TI, in real life.</p>
<h3 id="arXiv-1208-6303"><a href="#arXiv-1208-6303" class="headerlink" title="arXiv:1208.6303"></a>arXiv:1208.6303</h3><p><strong>Hint:</strong> Disclinations.</p>
<h3 id="arXiv-1105-4351"><a href="#arXiv-1105-4351" class="headerlink" title="arXiv:1105.4351"></a>arXiv:1105.4351</h3><p><strong>Hint:</strong> How weak is weak?</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Topological defects&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w7_defects/ti_majoranas/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> scipy.sparse.linalg <span class="keyword">as</span> sl</span><br><span class="line"></span><br><span class="line">my = <span class="number">0.5</span> * (pauli.sys0 + pauli.sysz)</span><br><span class="line">s0s0sz = np.kron(pauli.s0s0, pauli.sz)</span><br><span class="line">s0szsz = np.kron(pauli.s0sz, pauli.sz)</span><br><span class="line">mys0 = np.kron(my, pauli.s0)</span><br><span class="line">s0s0sx = np.kron(pauli.s0s0, pauli.sx)</span><br><span class="line">s0s0sy = np.kron(pauli.s0s0, pauli.sy)</span><br><span class="line">szsxsz = np.kron(pauli.szsx, pauli.sz)</span><br><span class="line">s0sysz = np.kron(pauli.s0sy, pauli.sz)</span><br><span class="line">sxsxsz = np.kron(pauli.sxsx, pauli.sz)</span><br><span class="line">sysxsz = np.kron(pauli.sysx, pauli.sz)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qshe_sc</span>(<span class="params">l=<span class="number">40</span>, w=<span class="number">10</span>, lead=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.M - <span class="number">4</span> * p.B) * s0szsz</span><br><span class="line">            - <span class="number">4</span> * p.D * s0s0sz</span><br><span class="line">            + p.gaps(x, y)[<span class="number">1</span>] * mys0</span><br><span class="line">            + p.gaps(x, y)[<span class="number">0</span>] * s0s0sx</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz + <span class="number">0.5j</span> * p.A * szsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz - <span class="number">0.5j</span> * p.A * s0sysz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lead:</span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        lead = kwant.Builder(sym)</span><br><span class="line">        lead[lat(<span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1.5</span> * p.B * s0szsz</span><br><span class="line">        lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = -p.B * s0szsz</span><br><span class="line">        syst.attach_lead(lead)</span><br><span class="line">        syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qshe_sc_ribbon</span>(<span class="params">w=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= x &lt; w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.M - <span class="number">4</span> * p.B) * s0szsz</span><br><span class="line">            - <span class="number">4</span> * p.D * s0s0sz</span><br><span class="line">            + p.gaps(x, y)[<span class="number">1</span>] * mys0</span><br><span class="line">            + p.gaps(x, y)[<span class="number">0</span>] * s0s0sx</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz + <span class="number">0.5j</span> * p.A * szsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.B * s0szsz + p.D * s0s0sz - <span class="number">0.5j</span> * p.A * s0sysz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_2d_pwave</span>(<span class="params">w, l</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        (x1, y1) = site1.pos</span><br><span class="line">        (x2, y2) = site2.pos</span><br><span class="line">        phi = p.phase(<span class="number">0.5</span> * (x1 + x2), <span class="number">0.5</span> * (y1 + y2))</span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz + <span class="number">1j</span> * p.delta * (</span><br><span class="line">            np.cos(phi) * pauli.sx + np.sin(phi) * pauli.sy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        (x1, y1) = site1.pos</span><br><span class="line">        (x2, y2) = site2.pos</span><br><span class="line">        phi = p.phase(<span class="number">0.5</span> * (x1 + x2), <span class="number">0.5</span> * (y1 + y2))</span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz - <span class="number">1j</span> * p.delta * (</span><br><span class="line">            np.cos(np.pi / <span class="number">2</span> + phi) * pauli.sx + np.sin(np.pi / <span class="number">2</span> + phi) * pauli.sy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site1, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">4</span> * p.t - p.mu) * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (w / <span class="number">2</span> - <span class="number">1</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_slab</span>(<span class="params">l, w, h</span>):</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; h) <span class="keyword">and</span> (<span class="number">1.0</span> * y ** <span class="number">2</span> / l ** <span class="number">2</span> + <span class="number">1.0</span> * x ** <span class="number">2</span> / w ** <span class="number">2</span>) &lt;= <span class="number">0.25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y, z) = site.pos</span><br><span class="line">        phi = p.phase(x, y)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * s0s0sz</span><br><span class="line">            + (p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2) * s0szsz</span><br><span class="line">            + p.delta * (np.cos(phi) * s0s0sx + np.sin(phi) * s0s0sy)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * s0s0sz - p.B2 * s0szsz + p.A2 * <span class="number">0.5j</span> * sxsxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * s0s0sz - p.B2 * s0szsz + p.A2 * <span class="number">0.5j</span> * sysxsz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * s0s0sz - p.B1 * s0szsz + p.A1 * <span class="number">0.5j</span> * szsxsz</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_energies</span>(<span class="params">syst, p, num_orbitals, num_states</span>):</span></span><br><span class="line">    ham = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p), sparse=<span class="literal">True</span>).tocsc()</span><br><span class="line">    energies, states = sl.eigsh(ham, sigma=<span class="number">0</span>, k=num_states)</span><br><span class="line">    densities = (</span><br><span class="line">        np.linalg.norm(states.reshape(-<span class="number">1</span>, num_orbitals, num_states), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> energies, states, densities</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>We have a returning lecturer for the first chapter of this week’s lectures: Carlo Beenakker from Leiden University, who will tell us more about different ways to create Majoranas in superconducting vortices.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;YVGlfejNH90&quot;</span>, src_location=<span class="string">&quot;7.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Different-types-of-bulk-edge-correspondence"><a href="#Different-types-of-bulk-edge-correspondence" class="headerlink" title="Different types of bulk-edge correspondence"></a>Different types of bulk-edge correspondence</h1><p>By now, we have seen examples of how the topological properties of the bulk of a material can give birth to new physical properties at its edges, and how these edge properties cannot exist without a bulk. This is the essence of bulk-edge correspondence. For example, the unpaired Majorana bound states at the edges of a Kitaev chain exist because they are separated by the bulk of the chain.</p>
<p>Observe that the systems we have studied so far all had something in common: the topologically protected edge states were separated by a bulk that is one dimension higher than the dimension of the edge states. For example, the 0D Majorana bound states are separated by the 1D bulk of a Kitaev chain, and 1D chiral edge modes are separated by a 2D Chern insulator.</p>
<p>In this week, we will see that this does not need to be the case.</p>
<blockquote>
<p>The dimension of the bulk does not need to be one higher than the dimension of the topologically protected edge. Any dimension higher than the dimension of the edge works equally well.</p>
</blockquote>
<p>We will see how this simple insight opens new avenues in the hunt for topological protection.</p>
<h1 id="Turning-the-helical-edge-into-a-topological-superconductor"><a href="#Turning-the-helical-edge-into-a-topological-superconductor" class="headerlink" title="Turning the helical edge into a topological superconductor"></a>Turning the helical edge into a topological superconductor</h1><p>In the past weeks, we have studied two systems that appear very different, but where topology showed up in a very similar way.</p>
<p>First, let’s consider the quantum spin-Hall insulator. As we saw two weeks ago, it is characterized by a fermion parity pump: if you take a Corbino disk made out of a quantum spin-Hall insulator and change the flux by half a normal flux quantum, that is by $h/2e$, one unit of fermion parity is transferred from one edge of the sample to the other.</p>
<p>Secondly, let us consider a one-dimensional topological superconductor, like we studied in weeks two and three. If such a system is closed into a Josephson ring, and the flux through the ring is advanced by one superconducting flux quantum $h/2e$, the fermion parity at the Josephson junction connecting the two ends changes from even to odd, or viceversa. This is the $4π$ Josephson effect, one of the main signatures of topological superconductivity.</p>
<p>Note that the change in flux is equal to $h/2e$ in both cases, since a superconducting flux quantum $h/2e$ is half of the normal flux quantum $h/e$.</p>
<p>This suggest that once you have a quantum-spin Hall insulator, you are only one small step away from topological superconductivity and Majoranas. The only ingredient that is missing is to introduce superconducting pairing on the quantum spin-Hall edge.</p>
<p>But this is easy to add, for instance by putting a superconductor on top of the outer edge of our quantum spin-Hall Corbino disk:</p>
<p><img src="/2021/01/07/src/w7_defects/ti_majoranas/qsh_josephson_ring.svg" alt></p>
<p>The superconductor covers the entire quantum spin-Hall edge except for a small segment, which acts as a Josephson junction with a phase difference given by $\phi = 2e\Phi/\hbar$, where $\Phi$ is the magnetic flux through the center of the disk. We imagine that the superconductor gaps out the helical edge by proximity, which means that Cooper pairs can tunnel in and out from the superconductor into the edge. In order for this to happen, a conventional $s$-wave superconductor is enough.</p>
<p>We will not repeat our pumping experiment, that is increasing the flux $\Phi$ by $h/2e$. We know that one unit of fermion parity must be transferred from the inner edge of the disk to the outer edge. However, the only place where we can now find a zero-energy state is the Josephson junction, because the rest of the edge is gapped.</p>
<p>From the point of view of the superconducting junction, this means that advancing the phase difference $\phi$ by $2\pi$, the ground state fermion parity of the junction changes. Recalling what we learned in the second and third weeks, we can say that the Josephson effect is $4\pi$-periodic.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;What happens to the Josephson current in the setup shown above if you remove the inner edge of the Corbino disk?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The pumping argument fails and the Josephson effect becomes $2\pi$ periodic.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Then you can no longer apply a flux through the disk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Josephson effect remains $4\pi$ periodic, but the fermion parity becomes fixed.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Nothing changes if the inner edge of the Corbino disk is removed.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Josephson current is a local effect, so it cannot be affected by a removal of the inner edge. &quot;</span></span><br><span class="line">    <span class="string">&quot;When you insert a superconducting flux quantum into the ring, the fermion parity of the edge becomes odd. &quot;</span></span><br><span class="line">    <span class="string">&quot;The extra fermion comes from the gapped bulk of QSHE, which now acquires one broken &quot;</span></span><br><span class="line">    <span class="string">&quot;Kramers pair. That is allowed since there is half a normal flux quantum penetrating the bulk, &quot;</span></span><br><span class="line">    <span class="string">&quot;and Kramers theorem doesn&#x27;t apply anymore.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Majoranas-on-the-quantum-spin-Hall-edge"><a href="#Majoranas-on-the-quantum-spin-Hall-edge" class="headerlink" title="Majoranas on the quantum spin-Hall edge"></a>Majoranas on the quantum spin-Hall edge</h2><p>We know that the $4\pi$-periodicity of the Josephson effect can always be associated with the presence of Majorana zero modes at the two superconducting interfaces of the Josephson junction.</p>
<p>However, if you compare the system above with the Josephson ring studied in week three, you will notice an important difference. In that case, the Josephson junction was formed by an insulating barrier. Now on the other hand, the two superconducting interfaces are connected by the quantum spin-Hall edge.</p>
<p>This means that our Majoranas are connected by a gapless system, and therefore always strongly coupled. In order to see unpaired Majoranas, or at least weakly coupled ones, we need to gap out the segment of the edge forming the Josephson junction.</p>
<p>To gap it out, we can try to place another superconductor in the gap. Unfortunately, this doesn’t really help us, because it results in the formation of two Josephson junctions connected in series, and we only want one.</p>
<p>However, we know that the edge modes of the quantum spin-Hall insulator are protected from backscattering by time-reversal symmetry. To gap them out, we need to break time-reversal symmetry. Since a magnetic field breaks time-reversal symmetry, we can gap out the edge modes by placing a magnet on the segment of the edge between the two superconductors:</p>
<p><img src="/2021/01/07/src/w7_defects/ti_majoranas/qsh_majoranas.svg" alt></p>
<p>In the sketch above, you see two Majoranas drawn, one at each interface between the magnet and the superconductor. Their wavefunctions decay as we move away from the interfaces. As Carlo Beenakker mentioned in the introductory video, these Majoranas are quite similar to those we found at the ends of quantum wires.</p>
<p>To understand them in more detail, note that the magnet and the superconductor both introduce a gap in the helical edge, but through a completely different physical mechanism. The magnet flips the spin of an incoming electron, or hole, while the superconductor turns an incoming electron with spin up into an outgoing hole with spin down. These two different types of reflection processes combine together to form a Majorana bound state.</p>
<p>We can capture this behavior with the following Bogoliubov-de Gennes Hamiltonian for the edge:</p>
<p>$$H_\textrm{BdG}=(-iv\sigma_x \partial_x-\mu)\tau_z+m(x),\sigma_z+\Delta(x),\tau_x.$$</p>
<p>The first term is the edge Hamiltonian of the quantum spin-Hall effect, describing spin up and down electrons moving in opposite direction, together with a chemical potential $\mu$. The matrix $\tau_z$ acts on the particle-hole degrees of freedom, doubling the normal state Hamiltonian as usual. The second term is the Zeeman term due to the presence of the magnet. Finally, the last term is the superconducting pairing.</p>
<p>The strength of the Zeeman field $m(x)$ and the pairing $\Delta(x)$ both depend on position. At a domain wall between the superconductor and the magnet, when the relevant gap for the edge changes between $m$ and $\Delta$, the Hamiltonian above yields a Majorana mode.</p>
<p>This is shown below in a numerical simulation of a quantum spin-Hall disk. The left panel shows the edge state of the disk without any superconductor or magnet. In the right panel we cover one half of the disk by a superconductor and the other by a magnet, and obtain two well-separated Majoranas:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = <span class="number">60</span></span><br><span class="line">w = <span class="number">60</span></span><br><span class="line">sys2 = make_qshe_sc(l, w)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(A=<span class="number">0.5</span>, B=<span class="number">1.00</span>, D=<span class="number">0.1</span>, M=<span class="number">0.5</span>)</span><br><span class="line">p.gaps = <span class="keyword">lambda</span> x, y: [(y &lt; <span class="number">0</span>) * <span class="number">0.0</span>, (y &gt;= <span class="number">0</span>) * <span class="number">0.0</span>]</span><br><span class="line">energies0, states0, densities0 = calc_energies(sys2, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line">p.gaps = <span class="keyword">lambda</span> x, y: [(y &lt; <span class="number">0</span>) * <span class="number">0.2</span>, (y &gt;= <span class="number">0</span>) * <span class="number">0.3</span>]</span><br><span class="line">energies, states, densities = calc_energies(sys2, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">phi = np.linspace(-np.pi, np.pi, <span class="number">51</span>)</span><br><span class="line">x = (w + <span class="number">0.5</span>) / <span class="number">2</span> * np.cos(phi)</span><br><span class="line">y = (l + <span class="number">0.5</span>) / <span class="number">2</span> * np.sin(phi)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">9</span>, <span class="number">3.5</span>))</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">122</span>)</span><br><span class="line">gap_B = ax1.fill_between(x[:<span class="number">26</span>], <span class="number">0</span>, y[:<span class="number">26</span>], facecolor=<span class="string">&quot;gold&quot;</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">gap_Sc = ax1.fill_between(x[<span class="number">26</span>:], <span class="number">0</span>, y[<span class="number">26</span>:], facecolor=<span class="string">&quot;blue&quot;</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(sys2, densities[:, <span class="number">0</span>], colorbar=<span class="literal">False</span>, ax=ax1, cmap=<span class="string">&quot;gist_heat_r&quot;</span>)</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;k-&quot;</span>, lw=<span class="number">2</span>)</span><br><span class="line">text_style = <span class="built_in">dict</span>(fontsize=<span class="number">16</span>, arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">&quot;-&quot;</span>, facecolor=<span class="string">&quot;black&quot;</span>, lw=<span class="number">0</span>))</span><br><span class="line">plt.annotate(<span class="string">&quot;$E_Z$&quot;</span>, xytext=(-w / <span class="number">20</span>, l / <span class="number">5</span>), xy=(<span class="number">0</span>, l / <span class="number">3</span>), **text_style)</span><br><span class="line">plt.annotate(<span class="string">&quot;$\Delta$&quot;</span>, xytext=(-w / <span class="number">20</span>, -l / <span class="number">4</span>), xy=(<span class="number">0</span>, -l / <span class="number">3</span>), **text_style)</span><br><span class="line">ax1.set_yticks([])</span><br><span class="line">ax1.set_xticks([])</span><br><span class="line">ax1.set_ylim(-l / <span class="number">2</span> - <span class="number">3</span>, l / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax1.set_xlim(-w / <span class="number">2</span> - <span class="number">3</span>, w / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">pot = np.log(<span class="built_in">abs</span>(energies0[<span class="number">0</span>])) // np.log(<span class="number">10.0</span>) - <span class="number">1</span></span><br><span class="line">fac = <span class="built_in">abs</span>(energies0[<span class="number">0</span>]) * <span class="number">10</span> ** (-pot)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Majoranas, $E = $&quot;</span> + scientific_number(<span class="built_in">abs</span>(energies[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line">ax0 = fig.add_subplot(<span class="number">121</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(sys2, densities0[:, <span class="number">0</span>], colorbar=<span class="literal">False</span>, ax=ax0, cmap=<span class="string">&quot;gist_heat_r&quot;</span>)</span><br><span class="line">ax0.set_yticks([])</span><br><span class="line">ax0.set_xticks([])</span><br><span class="line">ax0.set_ylim(-l / <span class="number">2</span> - <span class="number">3</span>, l / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax0.set_xlim(-w / <span class="number">2</span> - <span class="number">3</span>, w / <span class="number">2</span> + <span class="number">3</span>)</span><br><span class="line">ax0.set_title(<span class="string">&quot;Edge state, $E = $&quot;</span> + scientific_number(<span class="built_in">abs</span>(energies0[<span class="number">0</span>])))</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;k-&quot;</span>, lw=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>The density of states plot of the lowest energy state reveals one Majorana mode at each of the two interfaces between the magnet and the superconductor.</p>
<p>This clearly shows how is it possible to obtain 0D topologically protected states (the Majorana modes) from a $2D$ bulk topological phase (the quantum spin Hall insulator). All we had to do was to add the appropriate ingredients (the superconductor and the magnet).</p>
<h1 id="Two-dimensional-p-wave-superconductors"><a href="#Two-dimensional-p-wave-superconductors" class="headerlink" title="Two-dimensional $p$-wave superconductors"></a>Two-dimensional $p$-wave superconductors</h1><p>Let us now move on to Majoranas in vortices, as discussed by Carlo Beenakker in the introductory video. We will need a model for a 2D topological superconductor. How do we obtain it?</p>
<p>It turns out that the method we used to construct 2D Chern insulators in week 4, namely stacking 1D Kitaev chains and coupling them, can also be used to construct 2D topological superconductors.</p>
<p>That isn’t very surprising though, is it? Remember that back then, we told you to forget that the Kitaev model was really a superconductor. Bearing that in mind, it comes as no surprise that stacking 1D superconductors gives us a 2D superconductor.</p>
<p>So let’s look back at the Hamiltonian we obtained for a Chern insulator by coupling a stack of Kitaev chains: </p>
<p>$$H_\textrm{2D}(\mathbf{k})=-(2t\cos{k_x}+\mu),\tau_z+\Delta\sin{k_x}\tau_y-2\gamma,(\cos{k_y}\tau_z+\sin{k_y},\tau_x).$$ </p>
<p>Those of us who are careful would want to check that the above Hamiltonian is indeed a superconductor, in particular that the terms coupling different chains do not spoil particle-hole symmetry.</p>
<p>And indeed if we consider the operator $\mathcal{P}=\tau_x \mathcal{K}$ with $\mathcal{K}$ the complex conjugation operator, we find that the Bloch Hamiltonian obeys $H_\textrm{2D}(\mathbf{k}) = -\tau_x H^*_\textrm{2D}(-\mathbf{k}) \tau_x$, precisely the symmetry obeyed by the Kitaev chain, extended to two dimensions (if you do not remember how to apply an anti-unitary symmetry in momentum space, you can go back to week 1 and look at the original derivation).</p>
<p>The Hamiltonian above is quite anisotropic - it looks different in the $x$ and $y$ directions, a consequence of the way we derived it in week four. For our purposes, however, it is convenient to make it look isotropic. Thus, we tweak the coefficients in $H$ to make it look similar in the $x$ and $y$ directions. This is fine as long as we do not close the gap, because the topological properties of $H$ remain unchanged.</p>
<p>In this way we arrive at the canonical Hamiltonian of a so-called $p$-wave superconductor:</p>
<p>$$H(k_x,k_y)=-[2t,(\cos{k_x}+\cos{k_y})+\mu],\tau_z+\Delta,(\sin{k_x}\tau_y-\sin{k_y}\tau_x).$$</p>
<p>Apart from looking more symmetric between the $x$ and $y$ directions, the Hamiltonian clearly separates normal hopping, which is proportional to $t$, and superconducting pairing, which is proportional to $\Delta$. This superconductor is $p$-wave because the pairing is linear in momentum, just like in the Kitaev chain. This can be seen explicitly by expanding $H$ around $\mathbf{k}=\mathbf{0}$, which gives</p>
<p>$$H(k_x,k_y)\approx [t,(k_x^2+k_y^2)-\mu+4 t]\tau_z+[i \Delta(k_x+i k_y)\tau_++\textrm{h.c.}],$$</p>
<p>where $\tau_+=(\tau_x+i\tau_y)/2$. Note that the pairing is proportional to $k_x+ik_y$, and it breaks both time-reversal and inversion symmetries.</p>
<p>Even though we have reinterpreted the Hamiltonian $H$ as a superconductor, it is still originally a Chern insulator. This means that the system is still characterized by a bulk Chern number, which determines the presence of chiral edge states.<br>A chiral edge state can be described by a simple effective Hamiltonian, equivalent to that of a quantum Hall edge:</p>
<p>$$H_\textrm{edge}=\hbar v k$$</p>
<p>with $v$ the velocity and $k$ the momentum along the edge. Note that the edge Hamiltonian maintains the particle-hole symmetry of the bulk: for every state with energy $E$ and momentum $k$ there is a state with energy $-E$ and momentum $-k$.</p>
<p>We are now ready to see how unpaired Majoranas can appear in a 2D $p$-wave superconductor.</p>
<h1 id="Vortices-in-2D-p-wave-superconductors"><a href="#Vortices-in-2D-p-wave-superconductors" class="headerlink" title="Vortices in 2D p-wave superconductors"></a>Vortices in 2D p-wave superconductors</h1><p>So far we have considered a uniform superconducting pairing $\Delta$, with constant amplitude and phase. This is an idealized situation, which corresponds to a perfect superconductor with no defects.</p>
<p>If you apply a small magnetic field to a superconducting film, or if there are defects in the material, a <a href="http://en.wikipedia.org/wiki/Abrikosov_vortex"><strong>vortex</strong></a> of supercurrent can form to lower the free energy of the system.<br>In a vortex, there is a supercurrent circulating in a small area around the defect or the magnetic field lines penetrating the superconductor. The magnetic flux enclosed by the vortex supercurrent is equal to a superconducting flux quantum $h/2e$.</p>
<p>The amplitude $\Delta$ of the superconducting pairing is suppressed in the core of the vortex, going to zero in its center, and the superconducting phase winds by $2\pi$ around a closed path surrounding it. The situation is sketched below:</p>
<p><img src="/2021/01/07/src/w7_defects/ti_majoranas/vortex.svg" alt></p>
<p>Because the pairing $\Delta$ goes to zero in the middle of the vortex, there can be states with an energy smaller than $\Delta$ which are localized at the vortex core. We now want to see whether it is possible to have a non-degenerate zero energy solution in the vortex - because of particle-hole symmetry, this would be an unpaired Majorana mode!</p>
<p>To compute the spectrum of the vortex we could introduce a position dependent-phase for $\Delta$ in the Hamiltonian of the superconductor, and solve it for the energy spectrum by going through quite some algebra. But as usual in this course, we will take a shortcut.</p>
<p>Our shortcut comes from answering the following question: how is the spectrum of the chiral edge states affected by introducing a vortex in the middle of the superconductor?</p>
<p>From week one, we know that changing the flux through a superconducting ring by a flux quantum changes the boundary condition from periodic to antiperiodic, or viceversa.</p>
<p>A vortex has precisely the same effect on the chiral edge states. Therefore, in the presence of a vortex, the allowed values $k_n$ of momentum in a disk shift by $\pi/L$, with $L$ the length of the edge. The energy levels depend linearly on momentum and are shifted accordingly,</p>
<p>$$<br>E_n,\to, E_n + \hbar v \pi / L.<br>$$</p>
<p>Now, with or without the vortex, the spectrum must be symmetric around $E=0$ because of particle-hole symmetry. The energy levels $E_n$ correspond to standing waves and are equally spaced, with spacing given by $2\hbar v \pi / L$. There are only two such spectra consistent with particle-hole symmetry, $E_n = 2\pi,n, \hbar v / L$ and $E_n = 2\pi,(n+1/2), \hbar v / L$.</p>
<p>Which one of the two spectra correspond to the presence of a vortex?</p>
<p>To answer this question, observe that the energy spectrum $E_n = 2 \pi,n,\hbar v / L$ includes a zero-energy solution, which is an unpaired Majorana mode at the edge! This is impossible unless there is somewhere a place to have a second zero-energy solution. And the only other possible place where we could have a zero-energy solution is the core of the vortex.</p>
<blockquote>
<p>Just by looking at the edge state momentum quantization, we have thus demonstrated that a vortex in a $p$-wave superconductor must come with a Majorana.</p>
</blockquote>
<p>Below, we plot the wave function of the lowest energy state in a $p$-wave disk with a vortex in the middle. The lowest energy wavefunction is an equal superposition of the two Majorana modes. Here you can see that half of it is localized close to the vortex core and half of it close to the edge.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.cm</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"></span><br><span class="line">colors = matplotlib.cm.gist_heat_r(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>) ** <span class="number">0.25</span>)</span><br><span class="line">gist_heat_r_rescaled = mcolors.LinearSegmentedColormap.from_list(</span><br><span class="line">    <span class="string">&quot;gist_heat_r_rescaled&quot;</span>, colors</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.4</span>, delta=<span class="number">0.5</span>, phase=<span class="keyword">lambda</span> x, y: np.angle(x + <span class="number">1j</span> * y))</span><br><span class="line">l = <span class="number">60</span></span><br><span class="line">w = <span class="number">60</span></span><br><span class="line">syst = make_2d_pwave(w, l)</span><br><span class="line">energies, states, densities = calc_energies(syst, p, num_orbitals=<span class="number">2</span>, num_states=<span class="number">10</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(</span><br><span class="line">    syst, densities[:, <span class="number">0</span>], cmap=gist_heat_r_rescaled, show=<span class="literal">False</span>, colorbar=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>The wave function is not zero in the bulk between the edge and the vortex because of the relatively small size of the system. The separation between edge and vortex, or between different vortices, plays the same role as the finite length of a Kitaev chain, i.e. it splits the Majorana modes away from zero energy by an exponentially small amount.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens if you add a second vortex to the superconductor? &quot;</span></span><br><span class="line">    <span class="string">&quot;Imagine that the vortices and edge are all very far away from each other&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The second vortex has no Majorana.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Both vortices have a Majorana, and the edge has two Majoranas.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Majorana mode at the edge goes away, and each vortex has its own Majorana.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Vortices can only be added in pairs because Majoranas only come in pairs.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The energy spectrum of the edge is shifted by $\hbar v \pi/L$ by the addition of a second vortex, &quot;</span></span><br><span class="line">    <span class="string">&quot;so the edge has no Majoranas now. The first vortex is not affected, and we know that it has a Majorana. &quot;</span></span><br><span class="line">    <span class="string">&quot;And so, of course, the second vortex must have a Majorana as well.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Vortices-in-3D-topological-insulator"><a href="#Vortices-in-3D-topological-insulator" class="headerlink" title="Vortices in 3D topological insulator"></a>Vortices in 3D topological insulator</h1><p>Unfortunately, superconductors with $p$-wave pairing are very rare, with mainly <a href="http://en.wikipedia.org/wiki/Strontium_ruthenate">one material</a> being a good candidate. But instead waiting for nature to help us, we can try to be ingenious.</p>
<p>As Carlo mentioned, Fu and Kane <a href="http://arxiv.org/abs/0707.1692">realized</a> that one could obtain an effective $p$-wave superconductor and Majoranas on the surface of a 3D TI.</p>
<p>We already know how to make Majoranas with a 2D topological insulator. Let us now consider an interface between a magnet and a superconductor on the surface of a 3D topological insulator. Since the surface of the 3D TI is two dimensional, such an interface will be a one dimensional structure and not a point defect as in the quantum spin-Hall case.</p>
<p>The Hamiltonian of the surface is a very simple extension of the edge Hamiltonian,  $\sigma_x k_x + \sigma_y k_y$ instead of just $\sigma_x k_x$. We can imagine that $k_y$ is the momentum along the interface between the magnet and the superconductor, and it is conserved. The effective Bogoliubov-de Gennes Hamiltonian is</p>
<p>$$H_\textrm{BdG}=(-i\sigma_x \partial_x+ \sigma_y k_y-\mu)\tau_z+m(x),\sigma_z+\Delta(x) \tau_x.$$</p>
<p>What is the dispersion $E(k_y)$ of states along the interface resulting from this Hamiltonian? Well, for $k_y=0$ we have exactly the Hamiltonian of the magnet/superconductor interface in the quantum spin-Hall case, which had a zero mode. So we know that the interface is gapless. The magnet breaks time-reversal symmetry, so we will have a chiral edge state, with energy $E$ proportional to $k_y$. Just like in the $p$-wave superconductor case!</p>
<p>At this point, analyzing the case of a vortex is very simple. We just have to reproduce the geometry we analyzed before. That is, we imagine an $s$-wave superconductor disk with a vortex in the middle, surrounded by a magnetic insulator, all on the surface of a 3D topological insulator:</p>
<p><img src="/2021/01/07/src/w7_defects/ti_majoranas/3d_ti_vortex.svg" alt></p>
<p>The introduction of a vortex changes the boundary conditions for the momentum at the edge, like in the $p$-wave case, and thus affects the spectrum of the chiral edge states going around the disk.</p>
<blockquote>
<p>Following the same argument as in the $p$-wave case, particle-hole symmetry dictates that there is a Majorana mode in the vortex core on a 3D TI. Interestingly, the vortex core is spatially separated from the magnet - so the vortex should contain a Majorana mode irrespective of the magnet that was used to create the chiral edge mode.</p>
</blockquote>
<p>In fact, the magnet was only a crutch that we used to make our argument. We can now throw it away and consider a vortex in a superconductor which covers the entire surface of the topological insulator.</p>
<p>To confirm this conclusion, below we show the result of a simulation of a 3D BHZ model in a cube geometry, with a vortex line passing through the middle of the cube. To make things simple, we have added superconductivity everywhere in the cube, and not just on the surface (nothing prevents us from doing this, even though in real life materials like Bi$_2$Te$_3$ are not naturally superconducting).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.cm</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"></span><br><span class="line">colors = matplotlib.cm.gist_heat_r(np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>))</span><br><span class="line">colors[:, <span class="number">3</span>] = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">128</span>)</span><br><span class="line">gist_heat_r_transparent = mcolors.LinearSegmentedColormap.from_list(</span><br><span class="line">    <span class="string">&quot;gist_heat_r_transparent&quot;</span>, colors</span><br><span class="line">)</span><br><span class="line">l, w, h = <span class="number">10</span>, <span class="number">10</span>, <span class="number">25</span></span><br><span class="line">syst = bhz_slab(l, w, h)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(</span><br><span class="line">    A1=<span class="number">0.5</span>,</span><br><span class="line">    A2=<span class="number">0.5</span>,</span><br><span class="line">    B1=<span class="number">0.5</span>,</span><br><span class="line">    B2=<span class="number">0.5</span>,</span><br><span class="line">    C=-<span class="number">0.2</span>,</span><br><span class="line">    D1=<span class="number">0.1</span>,</span><br><span class="line">    D2=<span class="number">0.0</span>,</span><br><span class="line">    M=-<span class="number">0.2</span>,</span><br><span class="line">    delta=<span class="number">0.15</span>,</span><br><span class="line">    phase=<span class="keyword">lambda</span> x, y: np.angle(x + <span class="number">1j</span> * y),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">energies, states, densities = calc_energies(syst, p, num_orbitals=<span class="number">8</span>, num_states=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">9</span>, <span class="number">3.5</span>))</span><br><span class="line"></span><br><span class="line">ax0 = fig.add_subplot(<span class="number">121</span>, projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line">kwant.plot(syst, ax=ax0, site_size=<span class="number">0.3</span>)</span><br><span class="line">ax0.set_xlim(-w / <span class="number">2</span> - <span class="number">2</span>, w / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax0.set_ylim(-l / <span class="number">2</span> - <span class="number">2</span>, l / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax0.set_yticks([])</span><br><span class="line">ax0.set_xticks([])</span><br><span class="line">ax0.set_zlim3d([<span class="number">0</span>, h])</span><br><span class="line">ax0.set_zticks([<span class="number">0</span>, h])</span><br><span class="line">ax0.set_zticklabels([<span class="string">&quot;$0$&quot;</span>, <span class="string">&quot;$%d$&quot;</span> % h])</span><br><span class="line">densities /= np.<span class="built_in">max</span>(densities, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">122</span>, projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line">kwant.plotter.plot(</span><br><span class="line">    syst,</span><br><span class="line">    site_color=densities[:, <span class="number">0</span>],</span><br><span class="line">    ax=ax1,</span><br><span class="line">    cmap=gist_heat_r_transparent,</span><br><span class="line">    colorbar=<span class="literal">False</span>,</span><br><span class="line">    site_lw=<span class="number">0</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ax1.set_xlim(-w / <span class="number">2</span> - <span class="number">2</span>, w / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax1.set_ylim(-l / <span class="number">2</span> - <span class="number">2</span>, l / <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">ax1.set_yticks([])</span><br><span class="line">ax1.set_xticks([])</span><br><span class="line">ax1.set_zlim3d([<span class="number">0</span>, h])</span><br><span class="line">ax1.set_zticks([<span class="number">0</span>, h])</span><br><span class="line">ax1.set_zticklabels([<span class="string">&quot;$0$&quot;</span>, <span class="string">&quot;$%d$&quot;</span> % h])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>In the right panel, you can see a plot of the wavefunction of the lowest energy state. You see that it is very well localized at the end points of the vortex line passing through the cube. These are precisely the two Majorana modes that Carlo Beenakker explained at the end of his introductory video.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;B7lMz-NrKec&quot;</span>, src_location=<span class="string">&quot;7.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Majoranas in topological insulators&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w7_defects/crystalline_defects/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">&quot;ignore&quot;</span>, UserWarning)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hoppings terms for BHZ and QAH model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_BHZ</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (p.M - <span class="number">4</span> * p.B) * pauli.s0sz</span><br><span class="line">        - <span class="number">4</span> * p.D * pauli.s0s0</span><br><span class="line">        + p.field * site.pos[<span class="number">1</span>] * pauli.s0s0</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_BHZ</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 + <span class="number">0.5j</span> * p.A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_BHZ</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 - <span class="number">0.5j</span> * p.A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weak_hopping_BHZ</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.t_inter * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_QAH</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (p.mu - <span class="number">4</span> * p.B) * pauli.sz + p.field * site.pos[<span class="number">1</span>] * pauli.s0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_QAH</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.sz + <span class="number">0.5j</span> * p.A * pauli.sx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_QAH</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.sz + <span class="number">0.5j</span> * p.A * pauli.sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weak_hopping_QAH</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.t_inter * np.eye(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Systems</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_screw_system</span>(<span class="params">L, W, H, xs=<span class="literal">None</span>, ys=<span class="literal">None</span>, ye=<span class="literal">None</span>, pbc=<span class="literal">True</span>, model=<span class="string">&quot;BHZ&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create system with screw dislocation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Function creates system with a screw dislocation. </span></span><br><span class="line"><span class="string">    L, W, H are dimension of scattering region.</span></span><br><span class="line"><span class="string">    L, W are dimension of cross section. </span></span><br><span class="line"><span class="string">    Leads are attached from top and bottom (0,0,1) direction.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xs, ys, ye describes where disloaction is placed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">&quot;BHZ&quot;</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_BHZ,</span><br><span class="line">            hopx_BHZ,</span><br><span class="line">            hopy_BHZ,</span><br><span class="line">            weak_hopping_BHZ,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">&quot;QAH&quot;</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_QAH,</span><br><span class="line">            hopx_QAH,</span><br><span class="line">            hopy_QAH,</span><br><span class="line">            weak_hopping_QAH,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; H)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># calling kwant</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># scattering system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lead system</span></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># defining dislocation</span></span><br><span class="line">    <span class="keyword">if</span> xs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(ys, ye):</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                <span class="keyword">del</span> syst[lat(xs + <span class="number">1</span>, y, z), lat(xs, y, z)]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">del</span> lead[lat(xs + <span class="number">1</span>, y, <span class="number">0</span>), lat(xs, y, <span class="number">0</span>)]</span><br><span class="line">            lead[lat(xs + <span class="number">1</span>, y, z + <span class="number">1</span>), lat(xs, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y, z <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(ys, ye), <span class="built_in">range</span>(H - <span class="number">1</span>)):</span><br><span class="line">            syst[lat(xs + <span class="number">1</span>, y, z + <span class="number">1</span>), lat(xs, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding periodic boundary conditions</span></span><br><span class="line">    <span class="keyword">if</span> pbc:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            lead[lat(x, <span class="number">0</span>, <span class="number">0</span>), lat(x, W - <span class="number">1</span>, <span class="number">0</span>)] = hopy</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                syst[lat(x, <span class="number">0</span>, z), lat(x, W - <span class="number">1</span>, z)] = hopy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(W):</span><br><span class="line">            lead[lat(<span class="number">0</span>, y, <span class="number">0</span>), lat(L - <span class="number">1</span>, y, <span class="number">0</span>)] = hopx</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                syst[lat(<span class="number">0</span>, y, z), lat(L - <span class="number">1</span>, y, z)] = hopx</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized(), lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_edge_dislocation_system</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    L, W, H, xs=<span class="literal">None</span>, ys=<span class="literal">None</span>, ye=<span class="literal">None</span>, pbc=<span class="literal">True</span>, model=<span class="string">&quot;BHZ&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Create system with edge dislocation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Function creates system with an edge dislocation. </span></span><br><span class="line"><span class="string">    L, W, H are dimension of scattering region.</span></span><br><span class="line"><span class="string">    L, W are dimension of cross section. </span></span><br><span class="line"><span class="string">    Leads are attached from top and bottom (0,0,1) direction.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xs, ys, ye describes where disloaction is placed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">&quot;BHZ&quot;</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_BHZ,</span><br><span class="line">            hopx_BHZ,</span><br><span class="line">            hopy_BHZ,</span><br><span class="line">            weak_hopping_BHZ,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">&quot;QAH&quot;</span>:</span><br><span class="line">        onsite, hopx, hopy, weak_hopping = (</span><br><span class="line">            onsite_QAH,</span><br><span class="line">            hopx_QAH,</span><br><span class="line">            hopy_QAH,</span><br><span class="line">            weak_hopping_QAH,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; H)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; L) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Calling kwant</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># scattering system</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = weak_hopping</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lead system</span></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = weak_hopping</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopx</span><br><span class="line"></span><br><span class="line">    <span class="comment"># defining disclocation</span></span><br><span class="line">    <span class="keyword">if</span> xs != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(ys, ye):</span><br><span class="line">            <span class="keyword">del</span> lead[lat(xs, y, <span class="number">0</span>)]</span><br><span class="line">            lead[lat(xs + <span class="number">1</span>, y, <span class="number">0</span>), lat(xs - <span class="number">1</span>, y, <span class="number">0</span>)] = weak_hopping</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                <span class="keyword">del</span> syst[lat(xs, y, z)]</span><br><span class="line">                syst[lat(xs + <span class="number">1</span>, y, z), lat(xs - <span class="number">1</span>, y, z)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># periodic boundary conditions</span></span><br><span class="line">    <span class="keyword">if</span> pbc:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">            lead[lat(x, <span class="number">0</span>, <span class="number">0</span>), lat(x, W - <span class="number">1</span>, <span class="number">0</span>)] = hopy</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                syst[lat(x, <span class="number">0</span>, z), lat(x, W - <span class="number">1</span>, z)] = hopy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(W):</span><br><span class="line">            lead[lat(<span class="number">0</span>, y, <span class="number">0</span>), lat(L - <span class="number">1</span>, y, <span class="number">0</span>)] = weak_hopping</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(H):</span><br><span class="line">                syst[lat(<span class="number">0</span>, y, z), lat(L - <span class="number">1</span>, y, z)] = weak_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># attaching leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst.finalized(), lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_densities</span>(<span class="params">lead, momentum, p, model, sorting_mid=<span class="number">0.0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Calculate density of states in the lead at a given momentum. &quot;&quot;&quot;</span></span><br><span class="line">    coord = np.array([i.pos <span class="keyword">for</span> i <span class="keyword">in</span> lead.sites])</span><br><span class="line">    xy = coord[coord[:, <span class="number">2</span>] == <span class="number">0</span>][:, :-<span class="number">1</span>]</span><br><span class="line">    indxs_xy = np.lexsort(xy.T)</span><br><span class="line">    xy = xy[indxs_xy, :]</span><br><span class="line"></span><br><span class="line">    h, t = lead.cell_hamiltonian(params=<span class="built_in">dict</span>(p=p)), lead.inter_cell_hopping(params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    h_k = <span class="keyword">lambda</span> k: h + t * np.exp(-<span class="number">1j</span> * k) + t.T.conj() * np.exp(<span class="number">1j</span> * k)</span><br><span class="line"></span><br><span class="line">    vals, vecs = np.linalg.eigh(h_k(momentum))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">&quot;BHZ&quot;</span>:</span><br><span class="line">        num_orbital = <span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">&quot;QAH&quot;</span>:</span><br><span class="line">        num_orbital = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    densities = np.linalg.norm(vecs.reshape(-<span class="number">1</span>, num_orbital, <span class="built_in">len</span>(vecs)), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    indxs = np.argsort(<span class="built_in">abs</span>(vals - sorting_mid))</span><br><span class="line">    vals = vals[indxs]</span><br><span class="line">    densities = densities[:, indxs]</span><br><span class="line">    densities = densities[indxs_xy, :]</span><br><span class="line"></span><br><span class="line">    L, W = <span class="built_in">int</span>(np.<span class="built_in">max</span>(xy[:, <span class="number">0</span>]) + <span class="number">1</span>), <span class="built_in">int</span>(np.<span class="built_in">max</span>(xy[:, <span class="number">1</span>]) + <span class="number">1</span>)</span><br><span class="line">    twod_densities = np.zeros((W, L, densities.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> coord, val <span class="keyword">in</span> <span class="built_in">zip</span>(xy, densities):</span><br><span class="line">        i, j = np.array(coord, dtype=<span class="built_in">int</span>)</span><br><span class="line">        twod_densities[j, i, :] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> twod_densities, vals</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_spectrum_and_densities</span>(<span class="params">sys_func, p, model, momentum, kwargs</span>):</span></span><br><span class="line">    syst, lead = sys_func(L=<span class="number">11</span>, W=<span class="number">21</span>, H=<span class="number">5</span>, xs=<span class="number">4</span>, ys=<span class="number">5</span>, ye=<span class="number">16</span>, model=model)</span><br><span class="line">    spect = spectrum(lead, p, **kwargs)</span><br><span class="line">    densities = get_densities(syst.leads[<span class="number">0</span>], momentum, p, model)</span><br><span class="line">    <span class="keyword">return</span> spect, densities</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_hm</span>(<span class="params">sys_func, momentum, kwargs</span>):</span></span><br><span class="line">    parameters = &#123;</span><br><span class="line">        <span class="string">&quot;BHZ&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">0.8</span>&#125;,</span><br><span class="line">        <span class="string">&quot;QAH&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;mu&quot;</span>: <span class="number">0.8</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p_BHZ = SimpleNamespace(field=<span class="number">0.005</span>, t_inter=-<span class="number">0.1</span>, **parameters[<span class="string">&quot;BHZ&quot;</span>])</span><br><span class="line">    p_QAH = SimpleNamespace(field=<span class="number">0.01</span>, t_inter=-<span class="number">0.1</span>, **parameters[<span class="string">&quot;QAH&quot;</span>])</span><br><span class="line"></span><br><span class="line">    spectrum_QAH, densities_QAH = get_spectrum_and_densities(</span><br><span class="line">        sys_func, p_QAH, <span class="string">&quot;QAH&quot;</span>, momentum, kwargs</span><br><span class="line">    )</span><br><span class="line">    spectrum_BHZ, densities_BHZ = get_spectrum_and_densities(</span><br><span class="line">        sys_func, p_BHZ, <span class="string">&quot;BHZ&quot;</span>, momentum, kwargs</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    hm_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> model, density, spect <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">            [<span class="string">&quot;BHZ&quot;</span>, <span class="string">&quot;QAH&quot;</span>], [densities_BHZ, densities_QAH], [spectrum_BHZ, spectrum_QAH]</span><br><span class="line">        ):</span><br><span class="line">            hm_dict[n, model] = (</span><br><span class="line">                spect</span><br><span class="line">                * holoviews.Points((momentum, density[<span class="number">1</span>][n]))</span><br><span class="line">                * holoviews.VLine(momentum)</span><br><span class="line">            ).relabel(<span class="string">&quot;Bandstructure&quot;</span>) + holoviews.Raster(</span><br><span class="line">                density[<span class="number">0</span>][:, :, n], label=<span class="string">r&quot;$\left|\psi\right|^2$&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> holoviews.HoloMap(hm_dict, kdims=[<span class="string">&quot;n&quot;</span>, <span class="string">&quot;model&quot;</span>])</span><br></pre></td></tr></table></figure>

<h1 id="Introduction-weak-topological-phases"><a href="#Introduction-weak-topological-phases" class="headerlink" title="Introduction: weak topological phases"></a>Introduction: weak topological phases</h1><p>Taylor Hughes from the University of Illinois at Urbana-Champaign will describe the interplay between defects in crystals and weak topological insulators.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;k3ZKCg7jtTs&quot;</span>, src_location=<span class="string">&quot;7.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>As you can see, there is a simple and universal connection between weak topological phases and the ability of defects to carry topologically protected states. The topological invariant $\mathcal{Q}$ of a dislocation is the number of protected states that it carries. It can be determined from the vector of weak topological invariants, $\mathbf{\mathcal{Q}}_\textrm{weak}$, and the Burgers vector of the dislocation $\mathbf{B}$:</p>
<p>$$\mathcal{Q} = \mathbf{\mathcal{Q}}_\textrm{weak}\cdot\mathbf{B}$$</p>
<p>Let us now go through the main points that lead to this conclusion, and argue for why it has to be that way.</p>
<h1 id="Crystallographic-defects-and-topology"><a href="#Crystallographic-defects-and-topology" class="headerlink" title="Crystallographic defects and topology"></a>Crystallographic defects and topology</h1><p>There are many different types of <a href="http://en.wikipedia.org/wiki/Crystallographic_defect">defects in crystals</a>: vacancies, substitutions, grain boundaries, dislocations, and many more.</p>
<p>What kinds of defects are important for topology? Consider a vacancy for example:<br><img src="/2021/01/07/src/w7_defects/crystalline_defects/Formation_Point_Defect.png" alt><br>(By Safe cracker (Own work) [CC BY 3.0 (<a href="http://creativecommons.org/licenses/by/3.0)]">http://creativecommons.org/licenses/by/3.0)]</a>, via Wikimedia Commons)</p>
<p>To create a vacancy, we need to remove a single atom (or all the atoms following one line). Can this type of defect carry a topologically protected state?</p>
<p>We already know that topological protection requires a Hamiltonian that cannot be created locally. For example, in order to create a single Majorana bound state at a phase boundary, another Majorana must appear elsewhere. Removing an atom or a line of atoms only changes the system locally, so the <em>other</em> topologically protected state cannot appear anywhere.</p>
<p>A simple vacancy is therefore not interesting from a topological point of view. What kinds of topological defects would work then? Crystallographic defects leave nothing different since they leave the bulk Hamiltonian unchanged far away from the defect core. This means we need to do something nontrivial to the crystal so that it cannot be removed locally.</p>
<p>Examples of such defects are dislocations:</p>
<p><img src="/2021/01/07/src/w7_defects/crystalline_defects/burgers_vectors.png" alt><br>(By David Gabriel García Andrade (Own work) [Public domain], via Wikimedia Commons)</p>
<p>In order to create a dislocation we need to cut a crystal along one plane and displace all the atoms along that plane by the <em>Burgers vector</em>. This has to be done all the way to the crystal boundary (or infinity in an infinite crystal), so the dislocation affects the entire system. This means that a dislocation cannot be removed locally.</p>
<p>As Taylor Hughes explained, a dislocation can be detected infinitely far from its core by going around it and verifying that we don’t return to the point of origin. We cannot simply remove a dislocation by locally replacing some atoms. Therefore, it may carry a topologically protected mode.</p>
<p>Unsurprisingly, crystallographic defects that cannot be removed locally are called “topological”, which brings us to the first important conclusion:</p>
<blockquote>
<p><em>Topological</em> crystallographic defects are the ones that may carry topologically protected modes.</p>
</blockquote>
<p>This is a non-trivial observation, even though it sounds tautological. There are two different types of topology involved: the topology of the electronic modes and the topology of the crystal.</p>
<h1 id="The-role-of-defect-dimensionality"><a href="#The-role-of-defect-dimensionality" class="headerlink" title="The role of defect dimensionality"></a>The role of defect dimensionality</h1><p>When do topological defects carry protected edge states?</p>
<p>Far away from the defect, the bulk is homogeneous. Hence, the appearance of an edge state must be encoded both in the properties of the defect and in the bulk Hamiltonian. Of course, the appearance of this state must also be controlled by a topological invariant, since the protected state cannot disappear without the closing of the bulk gap.</p>
<p>What kind of topological invariant can this be? Can a strong topological invariant create a protected edge state at a defect?</p>
<p>In a sense we already know that it does. We can think of the crystal surface as a defect that breaks translational symmetry, and so it is a crystallographic defect. The strong topological invariant is the quantity that tells us whether or not the bulk can be continuously deformed into vacuum, or equivalently, whether or not the surface can be smoothly removed without closing the bulk gap.</p>
<p>In a $d$-dimensional bulk, the strong invariant is responsible for the appearance of a $d-1$-dimensional topologically protected state. This state can only be bound to a surface, which is the only $d-1$-dimensional topological defect. Defects of lower dimensionality can not be impacted by the strong invariant. An example of such a defect of lower dimensionality is precisely a dislocation, as in the previous figure. It is a one-dimensional defect in a three-dimensional crystal.</p>
<p>This is where the weak invariants come into play.</p>
<p>First of all, we know that the dimensionality $d_\textrm{egde}$ of a protected state at a defect must match the dimensionality of the defect. Secondly, we know the dimensionality of the topological invariant that controls this protected state: it is the topological invariant in the dimension $d_\textrm{edge}+1$.</p>
<p>The topological invariants with dimensionality $d_{edge}+1$ form a vector or a tensor of the weak indices. The last thing we need to figure out is how to extract information about what happens at the defect from the weak indices.</p>
<h1 id="The-defect-topological-invariant"><a href="#The-defect-topological-invariant" class="headerlink" title="The defect topological invariant"></a>The defect topological invariant</h1><p>We have almost arrived at the criterion for the appearance of protected states in dislocations.</p>
<p>To see how the weak topological invariant relates to the number of states in the dislocation, we start by deforming a weak topological insulator into a set of disconnected planes, each carrying protected states. If there is a single state approaching the dislocation, as is shown in the figure below, it cannot backscatter and must therefore continue through the dislocation core.</p>
<p><img src="/2021/01/07/src/w7_defects/crystalline_defects/dislocation_helical.svg" alt></p>
<p>(adapted from Cdang (Own work), via Wikimedia Commons, <a href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>.)</p>
<p>Counting the number and the orientation of the crystal planes approaching the core of the dislocation is just the Burgers vector. Hence, the number of edge states entering the dislocation core is the Burgers vector times the number of states per crystal plane. This brings us to the conclusion:</p>
<p>$$\mathcal{Q} = \mathbf{\mathcal{Q}}_\textrm{weak}\cdot\mathbf{B}.$$</p>
<p>Let’s now test this idea and see if we can observe the protected dislocation states.</p>
<h1 id="Electronic-states-in-dislocations"><a href="#Electronic-states-in-dislocations" class="headerlink" title="Electronic states in dislocations"></a>Electronic states in dislocations</h1><p>Now that we know the main concepts, let’s apply them to concrete examples. Let’s take two models for topological insulators that we already know and apply them to lattice systems with dislocations.</p>
<p>We will create a 3D weak topological insulators by stacking many layers of 2D topological insulators along the $z$ direction. For the individual layers, we will use the BHZ model (by the way, note that the lecture today was given by the H of BHZ!) for a time-reversal invariant topological insulator, and the square lattice model for the quantum Hall effect that we used in week 4. In this way, we can study dislocations both with and without time reversal symmetry. In both cases, we take the hoppings between different layers to be relatively weak compared to those within the same layer.</p>
<p>Let’s start with a screw dislocation connecting two layers. The system looks like this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># System parameters</span></span><br><span class="line">L = <span class="number">6</span></span><br><span class="line">W = <span class="number">7</span></span><br><span class="line">ws = <span class="number">3</span></span><br><span class="line">xs = <span class="number">2</span></span><br><span class="line">syst, lead = create_screw_system(</span><br><span class="line">    L, W, <span class="number">2</span>, xs=xs, ys=<span class="number">0</span>, ye=W - ws, pbc=<span class="literal">False</span>, model=<span class="string">&quot;BHZ&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line">kwant.plot(syst, site_size=<span class="number">0.0</span>, site_lw=<span class="number">0.01</span>, hop_lw=<span class="number">0.025</span>, ax=ax, num_lead_cells=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">ax.set_zticks(())</span><br><span class="line">ax.view_init(<span class="number">50</span>, -<span class="number">110</span>)</span><br></pre></td></tr></table></figure>

<p>The Burgers’ vector is parallel to $z$ and has unit length - the dislocation connects neighboring layers.</p>
<p>The figure above only shows two layers, but we imagine that the system is repeated identically along the $z$ direction. Along the $x$ and $y$ directions it has periodic boundary conditions. Above we only show half of the dislocation.</p>
<p>Let’s look at the band structure along the $z$ direction, and the wave functions of the corresponding states.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%opts Raster(cmap=<span class="string">&#x27;gist_heat_r&#x27;</span> interpolation=<span class="literal">None</span>) &#123;+framewise&#125;</span><br><span class="line">%opts Points(s=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(np.pi - np.pi / <span class="number">4</span>, np.pi + np.pi / <span class="number">4</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.6</span>, <span class="number">0.95</span>],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [</span><br><span class="line">        (np.pi - np.pi / <span class="number">4</span>, <span class="string">r&quot;$\pi-\pi/4$&quot;</span>),</span><br><span class="line">        (np.pi, <span class="string">r&quot;$\pi$&quot;</span>),</span><br><span class="line">        (np.pi + np.pi / <span class="number">4</span>, <span class="string">r&quot;$\pi+\pi/4$&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create_hm(create_screw_system, momentum=np.pi + <span class="number">0.1</span>, kwargs=kwargs).collate()</span><br></pre></td></tr></table></figure>

<p>You see that the band structure is gapless: because of the presence of the dislocation, there are states dispersing below the bulk gap along the $z$ direction.</p>
<p>A look at their wave functions in the right panel shows that in the $x$-$y$ plane, these low-energy states are localized around the end points of the dislocation (we show the wave function corresponding to the blue dot in the band structure plot). On the other hand, when you look at the wave function of states above the gap, you see that they are spread out the whole $x$-$y$ plane.</p>
<p>Here, the fundamental difference between the BHZ model and the quantum anomalous Hall case is that in the former, the gapless states at the dislocation are helical, while in the latter they are chiral.</p>
<p>We can also look at an edge dislocation:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># System parameters</span></span><br><span class="line">L = <span class="number">7</span></span><br><span class="line">W = <span class="number">7</span></span><br><span class="line">ws = <span class="number">3</span></span><br><span class="line">xs = <span class="number">3</span></span><br><span class="line">syst, lead = create_edge_dislocation_system(</span><br><span class="line">    L, W, <span class="number">2</span>, xs=xs, ys=<span class="number">0</span>, ye=W - ws, pbc=<span class="literal">False</span>, model=<span class="string">&quot;BHZ&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, projection=<span class="string">&quot;3d&quot;</span>)</span><br><span class="line"></span><br><span class="line">kwant.plot(syst, site_size=<span class="number">0.0</span>, site_lw=<span class="number">0.01</span>, hop_lw=<span class="number">0.025</span>, ax=ax, num_lead_cells=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xticks(())</span><br><span class="line">ax.set_yticks(())</span><br><span class="line">ax.set_zticks(())</span><br><span class="line">ax.view_init(<span class="number">50</span>, -<span class="number">110</span>)</span><br></pre></td></tr></table></figure>

<p>The Burgers vector is now along the $y$ direction, and it still has unit length. The band structure and the wave function plots show similar behavior.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%opts Raster(cmap=<span class="string">&#x27;gist_heat_r&#x27;</span> interpolation=<span class="literal">None</span>) &#123;+framewise&#125;</span><br><span class="line">%opts Points(s=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi / <span class="number">4</span>, np.pi / <span class="number">4</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.6</span>, <span class="number">0.95</span>],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [(-np.pi / <span class="number">4</span>, <span class="string">r&quot;$-\pi/4$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>), (np.pi / <span class="number">4</span>, <span class="string">r&quot;$\pi/4$&quot;</span>)],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create_hm(create_edge_dislocation_system, momentum=<span class="number">0.1</span>, kwargs=kwargs).collate()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What would happen in both simulations above if we changed the dislocation, &quot;</span></span><br><span class="line">    <span class="string">&quot;making the Burgers vector twice as long?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The wave function would just spread out a bit more because the dislocation is larger.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The number of gapless states would double for both models.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The gapless states would be gapped out for both models.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The dislocation would only have gapless states in the quantum anomalous Hall case, not for the BHZ model.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Doubling the Burgers vector doubles the topological invariant in the $\mathbb&#123;Z&#125;$ case, &quot;</span></span><br><span class="line">    <span class="string">&quot;and changes it from non-trivial to trivial in the $\mathbb&#123;Z&#125;_2$ case.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;MvcvJiZYSSk&quot;</span>, src_location=<span class="string">&quot;7.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Crystalline defects&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w6_3dti/w6_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-more-Chern-insulators"><a href="#Simulations-more-Chern-insulators" class="headerlink" title="Simulations: more Chern insulators"></a>Simulations: more Chern insulators</h1><p>As usual, start by grabbing the notebooks of this week (<code>w6_3dti</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<p>Simulations of the three-dimensional systems are hard, mostly because they take a lot of computational power. That’s why we’ll do something relatively simple this time.</p>
<h3 id="Breaking-time-reversal"><a href="#Breaking-time-reversal" class="headerlink" title="Breaking time-reversal"></a>Breaking time-reversal</h3><p>One mechanism of opening the gap on the surface of a topological insulator is to bring it into contact with a ferromagnet, which creates an effective Zeeman field.</p>
<ul>
<li>By calculating dispersion of a slab of 3D TI, observe the effect of Zeeman field pointing in different directions on the surface state dispersion. Find out which direction of the Zeeman field opens the gap in the surface state.</li>
<li>Make a domain wall between different orientations of Zeeman field. Are there any modes in this domain wall?</li>
</ul>
<h3 id="Many-invariants"><a href="#Many-invariants" class="headerlink" title="Many invariants"></a>Many invariants</h3><p>The BHZ model is rather rich and allows to produce every possible topological invariant. Can you find the parameter values that produce all the desired values of the invariants? (Hint: you need to make the model anisotropic).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;3DTI&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1410-0655"><a href="#arXiv-1410-0655" class="headerlink" title="arXiv:1410.0655"></a>arXiv:1410.0655</h3><p><strong>Hint:</strong> What enters the measurement of a Dirac point conductance.</p>
<h3 id="arXiv-0811-1303"><a href="#arXiv-0811-1303" class="headerlink" title="arXiv:0811.1303"></a>arXiv:0811.1303</h3><p><strong>Hint:</strong> Consequences of magneto-electric effect.</p>
<h3 id="arXiv-1401-7461"><a href="#arXiv-1401-7461" class="headerlink" title="arXiv:1401.7461"></a>arXiv:1401.7461</h3><p><strong>Hint:</strong> Weak and strong topological insulators with disorder.</p>
<h3 id="arXiv-1311-1758"><a href="#arXiv-1311-1758" class="headerlink" title="arXiv:1311.1758"></a>arXiv:1311.1758</h3><p><strong>Hint:</strong> Topological, but not insulator.</p>
<h3 id="arXiv-1005-3762"><a href="#arXiv-1005-3762" class="headerlink" title="arXiv:1005.3762"></a>arXiv:1005.3762</h3><p><strong>Hint:</strong> Threading flux through a topological insulator.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;3DTI&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w6_3dti/bhz/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">X=<span class="literal">None</span>, Y=<span class="literal">None</span>, Z=<span class="literal">None</span>, system_type=<span class="string">&quot;infinite&quot;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A cuboid region of BZZ material with two leads attached.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    parameters for leads and scattering region can be defined separately</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Onsite and hoppings matrices used for building BZZ model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * pauli.s0s0 + (</span><br><span class="line">            p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2</span><br><span class="line">        ) * pauli.s0sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sxsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sysx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * pauli.s0s0 - p.B1 * pauli.s0sz + p.A1 * <span class="number">0.5j</span> * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx_phase</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1, z1 = site1.pos</span><br><span class="line">        x2, y2, z2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_slab</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= z &lt; Z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_lead</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= y &lt; Y) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; Z)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_cube</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; X) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; Y) <span class="keyword">and</span> (<span class="number">0</span> &lt;= z &lt; Z)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>), norbs=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">&quot;slab&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]))</span><br><span class="line">        syst[lat.shape(shape_slab, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">&quot;lead&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[lat.shape(shape_lead, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">&quot;cuboid&quot;</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line">        syst[lat.shape(shape_cube, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">&quot;infinite&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx_phase</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">r&quot;$M=&#123;:.3&#125;$&quot;</span>.<span class="built_in">format</span>(p.M)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lead</span>():</span></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>), norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder(</span><br><span class="line">        kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)), time_reversal=<span class="number">1j</span> * pauli.sys0</span><br><span class="line">    )</span><br><span class="line">    syst[lat(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)] = <span class="number">1.5</span> * pauli.s0sz</span><br><span class="line">    syst[kwant.HoppingKind((-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = -<span class="number">1</span> * pauli.s0sz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_scatter_sys</span>():</span></span><br><span class="line">    syst = kwant.wraparound.wraparound(bhz(Z=<span class="number">1</span>, system_type=<span class="string">&quot;slab&quot;</span>))</span><br><span class="line">    syst.attach_lead(make_lead())</span><br><span class="line">    syst.attach_lead(kwant.wraparound.wraparound(bhz(), keep=<span class="number">0</span>))</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scattering_det_pfaff</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pfaffian</span>(<span class="params">syst, p, k_x, k_y</span>):</span></span><br><span class="line">        smat = kwant.smatrix(</span><br><span class="line">            syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p, k_x=k_x, k_y=k_y, k_z=<span class="number">0</span>)</span><br><span class="line">        ).data</span><br><span class="line">        <span class="comment"># since we get relatively large numerical errors we project the matrix on</span></span><br><span class="line">        <span class="comment"># the space of antisymmetric matrices</span></span><br><span class="line">        smat = <span class="number">0.5</span> * (smat - smat.T)</span><br><span class="line">        <span class="keyword">return</span> pf.pfaffian(smat)</span><br><span class="line"></span><br><span class="line">    xdim, ydim = <span class="string">&quot;$k_y$&quot;</span>, <span class="string">&quot;phase&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plot_k_x</span>(<span class="params">syst, p, k_x, label, col</span>):</span></span><br><span class="line">        pfaff = [pfaffian(syst, p, k_x, <span class="number">0</span>), pfaffian(syst, p, k_x, np.pi)]</span><br><span class="line">        ks = np.linspace(<span class="number">0.0</span>, np.pi, <span class="number">50</span>)</span><br><span class="line">        det = [</span><br><span class="line">            np.linalg.det(</span><br><span class="line">                kwant.smatrix(</span><br><span class="line">                    syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p, k_x=k_x, k_y=k_y, k_z=<span class="number">0</span>)</span><br><span class="line">                ).data</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">for</span> k_y <span class="keyword">in</span> ks</span><br><span class="line">        ]</span><br><span class="line">        det = np.array(det)</span><br><span class="line">        phase = np.angle(pfaff[<span class="number">0</span>]) + <span class="number">0.5</span> * np.cumsum(np.angle(det[<span class="number">1</span>:] / det[:-<span class="number">1</span>]))</span><br><span class="line">        kdims = [xdim, ydim]</span><br><span class="line">        plot = holoviews.Path((ks[<span class="number">1</span>:], phase), kdims=kdims, label=label).opts(</span><br><span class="line">            style=&#123;<span class="string">&quot;color&quot;</span>: col&#125;</span><br><span class="line">        )</span><br><span class="line">        plot *= holoviews.Points(([<span class="number">0</span>, np.pi], np.angle(pfaff)), kdims=kdims).opts(</span><br><span class="line">            style=&#123;<span class="string">&quot;color&quot;</span>: col&#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> plot</span><br><span class="line"></span><br><span class="line">    plot = plot_k_x(syst, p, <span class="number">0</span>, <span class="string">r&quot;$k_x=0$&quot;</span>, <span class="string">&quot;g&quot;</span>) * plot_k_x(</span><br><span class="line">        syst, p, np.pi, <span class="string">r&quot;$k_x=\pi$&quot;</span>, <span class="string">&quot;b&quot;</span></span><br><span class="line">    )</span><br><span class="line">    xlims, ylims = (-<span class="number">0.2</span>, np.pi + <span class="number">0.2</span>), (-np.pi - <span class="number">0.2</span>, np.pi + <span class="number">0.2</span>)</span><br><span class="line">    pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">    style_overlay = &#123;</span><br><span class="line">        <span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">&quot;$\pi$&quot;</span>)],</span><br><span class="line">        <span class="string">&quot;yticks&quot;</span>: pi_ticks,</span><br><span class="line">        <span class="string">&quot;show_legend&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;legend_position&quot;</span>: <span class="string">&quot;top&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    style_path = &#123;<span class="string">&quot;show_legend&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;xdim: xlims, ydim: ylims&#125;).opts(</span><br><span class="line">        plot=&#123;<span class="string">&quot;Overlay&quot;</span>: style_overlay, <span class="string">&quot;Path&quot;</span>: style_path&#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Joel Moore from the University of California, Berkeley will introduce this week’s topic, by telling us how the idea of a two-dimensional topological insulator was generalized to three dimensions.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;NIhMjm7cyug&quot;</span>, src_location=<span class="string">&quot;6.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Making-3D-topological-invariants-out-of-2D-ones"><a href="#Making-3D-topological-invariants-out-of-2D-ones" class="headerlink" title="Making  3D topological invariants out of 2D ones"></a>Making  3D topological invariants out of 2D ones</h1><p>Let us follow the direction explained by Joel Moore and construct a three-dimensional topological state from the two-dimensional topological state. This time, we’ll do this by studying the system in momentum space rather than in real space as we did before. As with two dimensional systems, time-reversal invariant momenta (TRIMs) play an important role in three dimensions. </p>
<p>For illustrative purposes, consider the three dimensional irreducible Brillouin Zone (i.e. $k_j\in [0,\pi]$) of a cubic system shown below. Fixing one of the three momenta $k_{x,y,z}$ to a TRIM, say $k_x=0$ without loss of generality, we can think of the Hamiltonian in the $(k_y,k_z)$ plane as a two dimensional Hamiltonian, which may either be topologically trivial ($\mathbb{Z}_2$-index $=0$) or non-trivial ($\mathbb{Z}_2$-index $=1$).</p>
<p><img src="/2021/01/07/src/w6_3dti/bhz/3dbz.svg" alt></p>
<p>So for every side of the cube shown above we can compute a QSHE topological invariant, which gives us 6 numbers. However not all of them are independent. Specifically, there is a constraint $Q(k_x=0),Q(k_x=\pi) \equiv Q(k_y=0),Q(k_y=\pi) \equiv Q(k_z=0),Q(k_z=\pi)$.</p>
<p>This product is called <em>the strong topological invariant</em>. Accordingly, the topological insulators where this invariant is non-trivial are called strong topological insulators. For the remaining three invariants, we can choose  $Q(k_x=\pi),,Q(k_y=\pi),,Q(k_z=\pi)$.</p>
<p>Very frequently the topological invariants of a compound are written as $(1;010)$, where the first number corresponds to the strong invariant, and the remaining three to the weak invariants along each axis. For example, the first predicted topological insulator, the alloy Bi$<em>x$Sb$</em>{1-x}$ is $(1;111)$, and the second generation topological insulators Bi$_2$Te$_3$ and Bi$_2$Se$_3$ are $(1;000)$.</p>
<p>Just by using the bulk-edge correspondence for $Q$ we know that the strong topological invariant means that there is an odd number of helical states going in each direction on each facet of the topological insulator. We will see later why this is special, but before that let’s construct a model for a 3D TI.</p>
<h1 id="BHZ-model-of-a-3D-topological-insulator"><a href="#BHZ-model-of-a-3D-topological-insulator" class="headerlink" title="BHZ model of a 3D topological insulator"></a>BHZ model of a 3D topological insulator</h1><p>Our goal in this unit is to derive an effective three-dimensional Hamiltonian $H(\mathbf{k})$ for a strong topological insulator.</p>
<p>We follow the same logic that led us to defining the three-dimensional topological invariant in the previous unit, building up on our knowledge of 2D topological insulators. Our first step is therefore to set $k_z=0$ and start from a two-dimensional Bloch Hamiltonian which describes a non-trivial 2D topological insulator. Of course, we choose a model we already know for this 2D Hamiltonian, the Bernevig-Hughes-Zhang (BHZ) model.</p>
<p>Let’s recapitulate what we said about the BHZ model last week. It is a four band model, which has two electron bands (spin up and spin down) and two hole bands (spin up and down). It has inversion symmetry, with electron and hole bands having opposite parity. We will not need more bands for our 3D topological insulator model.</p>
<p>Copying the BHZ Hamiltonian of last week, at $k_z=0$ we have </p>
<p>$$<br>H(k_z=0) = \epsilon(\mathbf{k})\cdot\mathbb{1} +<br>\begin{pmatrix}<br>M_0(\mathbf{k}) &amp; A k_+ &amp; 0 &amp; 0 \<br>A k_- &amp; -M_0(\mathbf{k}) &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; M_0(\mathbf{k}) &amp; -Ak_- \<br>0 &amp; 0 &amp; -Ak_+ &amp; -M_0(\mathbf{k})<br>\end{pmatrix},,<br>$$</p>
<p>where $k_\pm = k_x \pm i k_y$. This Hamiltonian is written in a basis given by the states $\left|E\uparrow\right\rangle$, $\left|H\uparrow\right\rangle$, $\left|E\downarrow\right\rangle$, $\left|H\downarrow\right\rangle$, in that order. The block structure of the Hamiltonian reminds you that it is a doubled version of a Chern insulator, with two diagonal blocks for up and down spins. The particular form of $\epsilon(\mathbf{k})$ can be important to describe the band structure of a given material, but will not play a role in what follows. The effective mass is given by $M_0(\mathbf{k}) = M - B(k_x^2+k_y^2)$, and the transition between the topological and trivial insulating phases in this 2D model happens when $M$ changes sign.</p>
<p>To get a strong topological insulator, we would like the two-dimensional $\mathbb{Z}_2$ invariant applied to the $(k_x, k_y)$ plane to take different values at $k_z=0$ and $k_z=\pi$. It is easy to achieve this by adding a $k_z$-dependent term to the effective mass, for instance in the following way</p>
<p>$$<br>M_0(\mathbf{k}),\to,M(\mathbf{k}) = M - B(k_x^2+k_y^2+k_z^2),.<br>$$</p>
<p>Compared to the 2D model above, we can make the sign of the ‘new’ mass $M-Bk_z^2$ effectively change at fixed $k_x$ and $k_y$ by choosing $k_z$ large enough.</p>
<p>There is now a problem, however. Looking at the Hamiltonian at different values of $k_z$, we see that if we fix $k_z$ it still has time-reversal symmetry. Since it is topologically nontrivial at $k_z=0$ and becomes trivial at $k_z = \pi$, it should have a topological phase transition somewhere in between.</p>
<p>In other words, if we just add the $B k_z^2$ term, the Hamiltonian becomes gapless! Of course, we would like to have a gapped Hamiltonian in the whole 3D Brillouin zone instead.</p>
<p>How can we avoid the gap closing? We definitely need to couple the two spin blocks in $H(\mathbf{k})$, since otherwise each block is undergoing a Chern insulator transition. Recall that spin is odd under time-reversal, so to couple the spins we need a coupling which is odd in momentum, in order to maintain time-reversal invariance in the system. The simplest thing is to pick a coupling that is linear in $k_z$.</p>
<p>We then arrive at the following 3D Hamiltonian,</p>
<p>$$<br>H(\mathbf{k}) = \epsilon(\mathbf{k})\cdot\mathbb{1} +<br>\begin{pmatrix}<br>M(\mathbf{k}) &amp; A k_+ &amp; 0 &amp; \tilde{A}k_z \<br>A k_- &amp; -M(\mathbf{k}) &amp; \tilde{A}k_z &amp; 0 \<br>0 &amp; \tilde{A}k_z &amp; M(\mathbf{k}) &amp; -Ak_- \<br>\tilde{A}k_z &amp; 0 &amp; -Ak_+ &amp; -M(\mathbf{k})<br>\end{pmatrix},.<br>$$</p>
<p>This Hamiltonian is known as the <strong>3D BHZ model</strong>. It is gapped at finite $M$, and a transition between the trivial and strong topological insulator phases is achieved by changing the sign of $M$. Just like its two-dimensional counterpart, the 3D BHZ model can be used as a prototype for a strong topological insulator, as well as a starting point to model real materials. </p>
<p>The above derivation makes one important point evident: a necessary ingredient to have a strong topological insulator is to break spin conservation. Above, we achieved this by adding coupling between the spins, to avoid the undesirable gap closing at finite $k_z$</p>
<h1 id="Dirac-surface-states"><a href="#Dirac-surface-states" class="headerlink" title="Dirac surface states"></a>Dirac surface states</h1><p>What is the dispersion of the surface state of the $3D$ topological insulator?</p>
<p>We know that if we fix one momentum (say $k_x$) to zero, the Hamiltonian of the remaining system is that of a quantum spin Hall insulator. For this system we know that the Hamiltonian of the edge states is just that of a pair of counter-propagating modes, so</p>
<p>$$H = v \sigma_y k_y.$$</p>
<p>Here, the matrix $\sigma_y$ acts on the degrees of freedom of these two surface modes, and doesn’t correspond to particle spin.</p>
<p>Since time-reversal symmetry changes the sign of $k_y$, it must also change the sign of $\sigma_y$, so the time-reversal operator must be $\mathcal{T} = i \sigma_y K$.</p>
<p>What if we consider a nonzero $k_x$? Generically, the two modes are then coupled by an extra term in the Hamiltonian. This term should be proportional to $k_x$, and since it couples the modes it must also include a Pauli matrix, which we can just choose to be $\sigma_x$.</p>
<p>So if the surface of the topological insulator is isotropic, its Hamiltonian is merely</p>
<p>$$H=v \mathbf{\sigma} \cdot \mathbf{k}.$$</p>
<p>Let’s have a quick look at it to get a more concrete understanding:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1.5</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=<span class="literal">None</span>, Bz=<span class="number">0</span>)</span><br><span class="line">syst = bhz(Z=<span class="number">5</span>, system_type=<span class="string">&quot;slab&quot;</span>)</span><br><span class="line">k = np.linspace(-np.pi, np.pi)</span><br><span class="line">Ms = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;</span><br><span class="line">        p.M: spectrum(syst, p, k_x=k, k_y=k, k_z=<span class="number">0</span>, title=title, num_bands=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms</span><br><span class="line">    &#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$M$&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>What you see here is the dispersion of the two lowest energy bands of a thin slice of a 3D BHZ model.</p>
<p>The system is topological when $M&lt;0$. As expected, the lowest energy state then has a Dirac dispersion, and surface states are formed.</p>
<p>The distinguishing feature of the strong topological insulator is that it has an odd number of Dirac cones in total.<br>In fact, the reason why it is called “strong” is also the reason why an odd number of Dirac cones is special.</p>
<p>To see what is unique, let us add an infinitesimal magnetic field and compute the Chern number of the surface state. We know that the number of Dirac cones is odd. From our study of Chern insulators, we know that the <em>change</em> in the Chern number between $B = -\varepsilon$ and $B = +\varepsilon$ is just the number of the Dirac cones. This is because we open a gap at each of them.</p>
<p>Since the Chern number is odd under time reversal, we come to a paradoxical conclusion: if we break time reversal, we end up with a half-integer Hall conductance $\sigma_{xy} = e^2/h (n + 1/2)$ on a surface of a topological insulator.</p>
<p>This is of course not possible in any purely 2D system, since the Hall conductance must be an integer, and therefore the surface state of a strong topological insulator cannot be created without the topological bulk.</p>
<blockquote>
<p>The statement that it is impossible to have a tight-binding Hamiltonian with time-reversal symmetry and a single Dirac cone is known as the “fermion doubling theorem”. There are several tricks that one can perform to work around this limitation in a numerical simulation, but we won’t cover them in the course.</p>
</blockquote>
<h1 id="Weak-invariants"><a href="#Weak-invariants" class="headerlink" title="Weak invariants"></a>Weak invariants</h1><p>Now that we understand what is special about the strong invariant, let’s deal with the weak invariants.</p>
<p>From their definition, we know that the weak invariants don’t change the parity of the number of Dirac cones on any surface.<br>Furthermore, there is a very good reason why the weak invariants are called ‘weak’. Imagine we keep the Hamiltonian the same, but instead we double the unit cell in each direction. This folds the Brillouin zone onto itself such that $k=\pi$ is mapped to $k=0$. This doesn’t impact the strong invariant, but all the weak invariants become 0.</p>
<p>As a final illustration of the relation between weak and strong invariants, let’s see how the invariants change as a function of $M$ as we vary $M$ on a scale comparable with the band width.</p>
<p>We determine the topological invariant in the same way as for QSHE: we see if the phase of the reflection matrix connects the Pfaffians of $r(k_y=0)$ and $r(k_y=\pi)$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">0.2</span>, C=<span class="number">0</span>, D1=<span class="number">0.1</span>, D2=<span class="number">0</span>, M=<span class="literal">None</span>, Bz=<span class="number">0</span>)</span><br><span class="line">syst = bhz(Z=<span class="number">15</span>, system_type=<span class="string">&quot;slab&quot;</span>)</span><br><span class="line">fsyst = make_scatter_sys()</span><br><span class="line">k = np.linspace(-np.pi, np.pi)</span><br><span class="line">Ms = np.linspace(-<span class="number">2.75</span>, <span class="number">0.75</span>, <span class="number">11</span>)</span><br><span class="line">hm1 = holoviews.HoloMap(</span><br><span class="line">    &#123;</span><br><span class="line">        p.M: spectrum(syst, p, k_x=k, k_y=k, k_z=<span class="number">0</span>, title=title, num_bands=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms</span><br><span class="line">    &#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$M$&quot;</span>],</span><br><span class="line">)</span><br><span class="line">hm2 = holoviews.HoloMap(</span><br><span class="line">    &#123;p.M: scattering_det_pfaff(fsyst, p) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>]</span><br><span class="line">)</span><br><span class="line">hm1 + hm2</span><br></pre></td></tr></table></figure>

<p>We see the values of the invariants change several times:</p>
<ul>
<li>Initially, when $M&gt;0$, the system is trivial.</li>
<li>Then, as $M$ is lowered, the topological invariants become $\mathcal{Q}(k_x=0) = 1$ and $\mathcal{Q}(k_x=\pi) = 0$, and there’s a Dirac cone at $k=0$.</li>
<li>When $M$ is lowered further, two new Dirac cones appear at $k = (0,\pi)$ and $k = (\pi, 0)$. This changes the invariants to $\mathcal{Q}(k_x=0) = 0$ and $\mathcal{Q}(k_x=\pi) = 1$.</li>
<li>Finally one more Dirac cone appears at $k = (\pi, \pi)$, accompanied by both invariants becoming trivial.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;Suppose you have a $(0;100)$ weak topological insulator. Which one of the following statements is correct?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;There is an even number of Dirac cones for both $k_x=0$ and $k_x=\pi$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There is an even number of Dirac cones for $k_x=0$ and an odd one for $k_x=\pi$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There is an odd number of Dirac cones for $k_x=0$ and an even one for $k_x=\pi$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There is an odd number of Dirac cones for both $k_x=0$ and $k_x=\pi$.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;We know that the strong invariant $Q(k_x=0)Q(k_x=\pi)=0$, so there must be an even number of Dirac cones in total. &quot;</span></span><br><span class="line">    <span class="string">&quot;The number at $k_x=\pi$ is odd because $Q(k_x=\pi)=1$, so the number at $k_x=0$ must also be odd.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Quantum-Hall-conductance-and-the-magneto-electric-effect"><a href="#Quantum-Hall-conductance-and-the-magneto-electric-effect" class="headerlink" title="Quantum Hall conductance and the magneto-electric effect"></a>Quantum Hall conductance and the magneto-electric effect</h1><p>So, what happens if we measure the Hall conductance of a 3D topological insulator? Will we actually obtain a half-integer? If you followed the course closely, you will know that the answer is negative, and that the Hall conductance is always quantized to an integer. So what is going on when we measure the Hall conductance?</p>
<p>To answer this question we need to remember that we cannot just consider one surface on its own. Each surface is connected to the sides and other surfaces. Let’s consider a part of a 3D TI in magnetic field:</p>
<p><img src="/2021/01/07/src/w6_3dti/bhz/3d_ti_slab.svg" alt></p>
<p>The top surface has the quantum Hall conductance $(n + 1/2)e^2/h$, but it is not the only part of the material. The bottom surface is also subject to a magnetic field and hence contributes a half-integer Hall conductance as well.</p>
<p>In total we thus get $\sigma_{xy} = (2n + 1) e^2/h$: an integer, which resolves the apparent paradox. While this statement sounds relatively simple, there are entire papers dedicated to the question whether it’s possible to measure a half-integer Hall conductance (the answer is ‘not really’).</p>
<p>Finally, let’s look at the dispersion of the Landau levels and edge states:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output size=<span class="number">150</span></span><br><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=-<span class="number">1</span>, Bz=<span class="number">0.125</span>)</span><br><span class="line">lead = bhz(Y=<span class="number">20</span>, Z=<span class="number">10</span>, system_type=<span class="string">&quot;lead&quot;</span>)</span><br><span class="line">k = np.linspace(-<span class="number">3.5</span>, <span class="number">1.5</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.8</span>, <span class="number">0.8</span>], <span class="string">&quot;yticks&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">spectrum(lead, p, k_x=k, **kwargs)</span><br></pre></td></tr></table></figure>

<p>We see that the Landau levels come in pairs. In each such pair, one level comes from the top surface, and one from the bottom surface. The magnetic field is parallel to the side surfaces, so there is no gap there. The edge states propagate freely along the side surfaces and are reflected by the magnetic field as they try to enter either the top or the bottom surfaces.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Suppose that you take the 3D TI slab above, and connect the left and right surfaces, making it into &quot;</span></span><br><span class="line">    <span class="string">&quot;a very thick Corbino disk. &quot;</span></span><br><span class="line">    <span class="string">&quot;You then apply to it a strong perpendicular field in the same direction as in the figure, perpendicular to the top &quot;</span></span><br><span class="line">    <span class="string">&quot;and bottom surfaces. &quot;</span></span><br><span class="line">    <span class="string">&quot;What happens if you throw an additional flux quantum through the inner hole of the disk?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;A half-integer number of electron charges is transferred from the inner to the outer surface of the disk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;An integer number of electron charges is transferred from the inner to the outer surface of the disk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;An integer number of charges is transferred from the top to the bottom surface of the disk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The bulk gap closes.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The top and bottom surfaces combined form an integer quantum Hall state. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence the whole system acts like a Laughlin pump, exactly like in the purely 2D case.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Conclusion-integers-half-integers-and-two-types-of-electromagnetic-response"><a href="#Conclusion-integers-half-integers-and-two-types-of-electromagnetic-response" class="headerlink" title="Conclusion: integers, half-integers, and two types of electromagnetic response"></a>Conclusion: integers, half-integers, and two types of electromagnetic response</h1><p>Before we move on to the next lecture, Joel Moore will tell us more about the origins of the peculiar electromagnetic response of topological insulators, and a fascinating connection to high energy physics.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;s7H6oLighOM&quot;</span>, src_location=<span class="string">&quot;6.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;3DTI invariants&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w6_3dti/3dti_signatures/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">import</span> scipy.linalg <span class="keyword">as</span> sla</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">&quot;ignore&quot;</span>, UserWarning)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">L, W, H, system_type</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A cuboid region of BHZ material with two leads attached.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    parameters for leads and scattering region can be defined separately</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Onsite and hoppings matrices used for building BHZ model</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (p.C + <span class="number">2</span> * p.D1 + <span class="number">4</span> * p.D2) * pauli.s0s0 + (</span><br><span class="line">            p.M + <span class="number">2</span> * p.B1 + <span class="number">4</span> * p.B2</span><br><span class="line">        ) * pauli.s0sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sxsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D2 * pauli.s0s0 - p.B2 * pauli.s0sz + p.A2 * <span class="number">0.5j</span> * pauli.sysx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.D1 * pauli.s0s0 - p.B1 * pauli.s0sz + p.A1 * <span class="number">0.5j</span> * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_lead</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; H) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape_syst</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &lt; H) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; W) <span class="keyword">and</span> (<span class="number">0</span> &lt;= x &lt; L)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx_phase</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1, z1 = site1.pos</span><br><span class="line">        x2, y2, z2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.identity(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> system_type == <span class="string">&quot;sys&quot;</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line">        syst[lat.shape(shape_syst, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_scat * np.eye(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">&quot;lead&quot;</span>:</span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        syst = kwant.Builder(sym)</span><br><span class="line">        syst[lat.shape(shape_lead, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> system_type == <span class="string">&quot;infinite&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: onsite(</span><br><span class="line">            site, p</span><br><span class="line">        ) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx_phase</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_scatter</span>(<span class="params">L, W, H</span>):</span></span><br><span class="line">    syst = bhz(L, W, H, <span class="string">&quot;sys&quot;</span>)</span><br><span class="line">    lead = bhz(L, W, H, <span class="string">&quot;lead&quot;</span>)</span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cond_mu</span>(<span class="params">p, L, W, H</span>):</span></span><br><span class="line">    p.mu_lead = <span class="number">0.7</span></span><br><span class="line">    syst = bhz_scatter(L, W, H)</span><br><span class="line">    sys_leads_fixed = syst.finalized().precalculate(energy=<span class="number">0</span>, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    mus = np.linspace(-<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">40</span>)</span><br><span class="line">    cond = [</span><br><span class="line">        kwant.smatrix(</span><br><span class="line">            sys_leads_fixed, energy=<span class="number">0</span>, params=<span class="built_in">dict</span>(p=p.update(mu_scat=mu))</span><br><span class="line">        ).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> mu <span class="keyword">in</span> mus</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> np.array(cond), mus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_cond_mu</span>(<span class="params">cond, mus</span>):</span></span><br><span class="line">    xdim, ydim = [<span class="string">r&quot;$\mu$&quot;</span>, <span class="string">r&quot;$G\,[e^2/h]$&quot;</span>]</span><br><span class="line">    kwargs = &#123;<span class="string">&quot;kdims&quot;</span>: [xdim, ydim]&#125;</span><br><span class="line">    plot = holoviews.Path((mus, cond), **kwargs).opts(</span><br><span class="line">        plot=&#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">3</span>, <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]&#125;, style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;xdim: (-<span class="number">0.4</span>, <span class="number">0.4</span>), ydim: (<span class="number">0</span>, <span class="number">8</span>)&#125;).relabel(<span class="string">&quot;Conductance&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_bands</span>(<span class="params">p, L, W, H</span>):</span></span><br><span class="line">    lead = bhz(L, W, H, <span class="string">&quot;lead&quot;</span>)</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">101</span>),</span><br><span class="line">        <span class="string">&quot;ylims&quot;</span>: [-<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        <span class="string">&quot;yticks&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;xticks&quot;</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r&quot;$-\pi/3$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>), (np.pi / <span class="number">3</span>, <span class="string">r&quot;$\pi/3$&quot;</span>)],</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu_lead = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> spectrum(lead, p, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_cond_spect</span>(<span class="params">mu, cond_plot, bands_plot</span>):</span></span><br><span class="line">    <span class="keyword">return</span> cond_plot * holoviews.VLine(mu).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    ) + bands_plot.relabel(<span class="string">&quot;Spectrum&quot;</span>) * holoviews.HLine(mu).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_warping</span>(<span class="params">A=<span class="number">1.2</span>, B=<span class="number">1.8</span>, C=<span class="number">1.5</span>, Kmax=<span class="number">1.0</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate_on_grid</span>(<span class="params">X, Y, func</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; X, Y should be in np.meshgrid form. It&#x27;s enough for func to work on floats. &quot;&quot;&quot;</span></span><br><span class="line">        data = []</span><br><span class="line">        <span class="keyword">for</span> xx, yy <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y):</span><br><span class="line">            data.append([func(i, j) <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(xx, yy)])</span><br><span class="line">        data = np.array(data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_energy_function</span>(<span class="params">A, B, C</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Used for plotting of hexagonal warping. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">kx, ky</span>):</span></span><br><span class="line">            matrix = (</span><br><span class="line">                A * (kx ** <span class="number">2</span> + ky ** <span class="number">2</span>) * pauli.s0</span><br><span class="line">                + B * (kx * pauli.sy - ky * pauli.sx)</span><br><span class="line">                + C * <span class="number">0.5</span> * ((kx + <span class="number">1j</span> * ky) ** <span class="number">3</span> + (kx - <span class="number">1j</span> * ky) ** <span class="number">3</span>) * pauli.sz</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> sla.eigh(matrix)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">    zmin, zmax = -<span class="number">1.0</span>, <span class="number">3.5</span></span><br><span class="line">    xylims = (-<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">    zlims = (-<span class="number">1.0</span>, <span class="number">3.5</span>)</span><br><span class="line">    kdims = [<span class="string">r&quot;$k_x$&quot;</span>, <span class="string">r&quot;$k_y$&quot;</span>]</span><br><span class="line">    vdims = [<span class="string">r&quot;E&quot;</span>]</span><br><span class="line">    <span class="comment"># Generate a circular mesh</span></span><br><span class="line">    N = <span class="number">100</span></span><br><span class="line">    r = np.linspace(<span class="number">0</span>, Kmax, N)</span><br><span class="line">    p = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, N)</span><br><span class="line">    r, p = np.meshgrid(r, p)</span><br><span class="line">    x, y = r * np.cos(p), r * np.sin(p)</span><br><span class="line">    energies = evaluate_on_grid(x, y, func=get_energy_function(A, B, C))</span><br><span class="line"></span><br><span class="line">    xy_ticks = [-<span class="number">1.2</span>, <span class="number">0</span>, <span class="number">1.2</span>]</span><br><span class="line">    zticks = [-<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">    style = &#123;<span class="string">&quot;xticks&quot;</span>: xy_ticks, <span class="string">&quot;yticks&quot;</span>: xy_ticks, <span class="string">&quot;zticks&quot;</span>: zticks&#125;</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">&quot;extents&quot;</span>: (xylims[<span class="number">0</span>], xylims[<span class="number">0</span>], zlims[<span class="number">0</span>], xylims[<span class="number">1</span>], xylims[<span class="number">1</span>], zlims[<span class="number">1</span>]),</span><br><span class="line">        <span class="string">&quot;kdims&quot;</span>: kdims,</span><br><span class="line">        <span class="string">&quot;vdims&quot;</span>: vdims,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hex_cmap colormap is defined below.</span></span><br><span class="line">    plot = holoviews.Overlay(</span><br><span class="line">        [</span><br><span class="line">            holoviews.TriSurface(</span><br><span class="line">                (x.flat, y.flat, energies[:, :, i].flat), **kwargs</span><br><span class="line">            ).opts(style=<span class="built_in">dict</span>(cmap=hex_cmap, linewidth=<span class="number">0</span>), plot=style)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(energies.shape[-<span class="number">1</span>])</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=&#123;<span class="string">&quot;Overlay&quot;</span>: &#123;<span class="string">&quot;fig_size&quot;</span>: <span class="number">350</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom colormap for the hexagonal warping plot</span></span><br><span class="line">cmap_list = [</span><br><span class="line">    ((value + <span class="number">1</span>) / <span class="number">4.0</span>, colour)</span><br><span class="line">    <span class="keyword">for</span> value, colour <span class="keyword">in</span> <span class="built_in">zip</span>([-<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">3.0</span>], [<span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;White&quot;</span>, <span class="string">&quot;Red&quot;</span>])</span><br><span class="line">]</span><br><span class="line">hex_cmap = matplotlib.colors.LinearSegmentedColormap.from_list(<span class="string">&quot;custom&quot;</span>, cmap_list)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction-searching-the-periodic-table-for-topological-materials"><a href="#Introduction-searching-the-periodic-table-for-topological-materials" class="headerlink" title="Introduction: searching the periodic table for topological materials"></a>Introduction: searching the periodic table for topological materials</h1><p>How do we find a topological insulator? In the first video of today, David Vanderbilt from Rutgers University will tell us more about the material science aspects of topological insulators research.</p>
<p>This is an expertise that no one from the course team has, so pay close attention to it: this material stands apart from the rest.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;62ZObitJ4DM&quot;</span>, src_location=<span class="string">&quot;6.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>In the rest of the lecture, we will instead discuss the experimental signatures of 3D topological insulators, similarly to what we did in the previous week for their 2D counterparts.</p>
<p>All the figures showing the experimental data are copyright of the Zahid Hasan lab, Princeton, 2015. They are available under CC-BY-NC-SA 4.0 International license.</p>
<h1 id="Conductance-of-a-3D-topological-insulator"><a href="#Conductance-of-a-3D-topological-insulator" class="headerlink" title="Conductance of a 3D topological insulator"></a>Conductance of a 3D topological insulator</h1><p>Both the quantum Hall and quantum spin Hall states have striking conductance quantization properties, thanks to the presence of perfectly transmitting one-dimensional transport channels.</p>
<p>The 3D topological insulators do not posses similar striking conductance properties. In a slab geometry, the surface states contribute with a finite density of propagating states. This density has a minimum at the Dirac point. The conductance increases roughly with a hyperbolic shape if the chemical potential is tuned away from the Dirac point as shown in the plot below:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(A1=<span class="number">1</span>, A2=<span class="number">1</span>, B1=<span class="number">1</span>, B2=<span class="number">1</span>, C=<span class="number">0</span>, D1=<span class="number">0</span>, D2=<span class="number">0</span>, M=-<span class="number">1</span>, Bz=<span class="number">0</span>, mu_scat=<span class="number">0</span>)</span><br><span class="line">L, W, H = <span class="number">10</span>, <span class="number">30</span>, <span class="number">6</span></span><br><span class="line">cond, mus = cond_mu(p, L, W, H)</span><br><span class="line">cond_plot = plot_cond_mu(cond, mus)</span><br><span class="line">bands_plot = plot_bands(p, L, W, H)</span><br><span class="line">mus = np.linspace(-<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;mu: plot_cond_spect(mu, cond_plot, bands_plot) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>]</span><br><span class="line">).collate()</span><br></pre></td></tr></table></figure>

<p>It is also the behavior that is observed experimentally. In the figure below, you see that the resistance of a 3D TI slab reaches a maximum and then decreases as the chemical potential difference between its top and bottom surfaces is varied.</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/zero_field_Rxx.png" alt></p>
<p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>Note that in such a measurement, you cannot separate contributions of states coming from the different surfaces, or potentially also from the sides or the sample, or even from the bulk - we’ll discuss this issue soon in more detail.</p>
<p>Nevertheless, the observed maximum in resistance corresponds to the minimum in conductance computed just above, and it demonstrates the presence of a Dirac point between the conduction and valence bands.</p>
<p>This behavior discussed above is not very striking. For instance, the same behavior is observed in graphene. The conductance is not sensitive to degeneracies in the electron spectrum in a qualitative way, so just from it, we cannot demonstrate that the surface of a 3D TI has a single Dirac cone, unlike graphene which has four. Hence, while the measurement above is a signature of a surface state, it is not a particularly striking one.</p>
<p>Perhaps we will be more lucky with topological signatures of 3D topological insulators, if we look at the Hall conductance?</p>
<h1 id="Landau-levels"><a href="#Landau-levels" class="headerlink" title="Landau levels"></a>Landau levels</h1><p>In last chapter, we saw that one single surface of a 3D topological insulator is characterized by a Hall conductance of $ (n+1/2), e^2/h$. We also pointed out that there are always two surfaces, say the top and bottom one of a slab, which gives a total Hall conductance of $(2n+1),e^2/h$ and makes it hard to observe the half-integer Hall conductance.</p>
<p>You may say - OK, we can live with this and be happy with our $(2n+1)$ sequence. After all, it looks almost as unique as the $(n+1/2)$ sequence. Sure, it does not allow us to see directly the half-integer value, but it gives a step between plateaus which is twice the usual one, and no plateau with $n=0$. After all, measuring <em>twice</em> that sequence was a good enough probe for graphene.</p>
<p>So let’s look at a Hall conductance measurements performed on a slab of a 3D TI, focusing for instance on the blue trace.</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/LL_spectroscopy.png" alt></p>
<p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>You see a sequence of plateaus with integer steps of a normal height $e^2/h$. Nothing special. Why did our prediction of a $(2n+1)$ sequence fail?</p>
<p>The reason is that there is no symmetry at all between top and bottom surfaces, they are really independent. For instance, they might have different doping, and hence be characterized by different values $n_\textrm{top}$ and $n_\textrm{bottom}$ of the Chern integer.</p>
<p>Therefore, rather than observing a sequence $e^2/h,(2n+1)$, we observe a more conventional sequence given by $e^2/h,(n_\textrm{top}+n_\textrm{bottom}+1)$, with the usual $e^2/h$ steps between different plateaus.</p>
<p>So, even by studying the Landau levels experimentally, we do not get a topological signature. But do not despair, luckily there is a much better thing that we can do rather than just measuring conductance: looking at the energy spectrum of the surface states directly.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;Which control parameter can remove the 0th plateau in the QHE measurement? &quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Increasing the magnetic field.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gate voltage difference (which controls difference in electron density) between the surfaces.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Increasing topological mass.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Adding an in-plane magnetic field.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Gate voltage difference changes the filling of the individual states without shifting the total density of electrons. &quot;</span></span><br><span class="line">    <span class="string">&quot;This can therefore shift the plateaus of each surface. Magnetic field and topological mass are part of generating the &quot;</span></span><br><span class="line">    <span class="string">&quot; $0^&#123;th&#125;$ plateau to begin with so cannot eliminate it. &quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Spectroscopy-of-the-surface-of-a-3D-topological-insulator"><a href="#Spectroscopy-of-the-surface-of-a-3D-topological-insulator" class="headerlink" title="Spectroscopy of the surface of a 3D topological insulator"></a>Spectroscopy of the surface of a 3D topological insulator</h1><p>Amazingly, the surface states of a 3D topological insulator can be directly imaged experimentally using the technique of Angle Resolved Photo Emission Spectroscopy - or, in short, <a href="http://en.wikipedia.org/wiki/Angle-resolved_photoemission_spectroscopy">ARPES</a>.</p>
<p>In ARPES, X-ray photons are shot vertically into a metal surface in order to eject electrons out of it. Due to energy and momentum conservation, the emitted electrons have the same momentum (parallel to the surface) that they had in the crystal, and an energy which is related to their band energy in the crystal. Hence, ARPES is the ideal tool to measure the energy dispersion of the surface states of a solid, i.e. $E(k_x, k_y)$ as a function of momenta $\hbar k_x$ and $\hbar k_y$.</p>
<p>Below, we see an example of ARPES spectra for the surface states of a strong topological insulator Bi$_2$ Se$_3$:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/arpes_fig1.png" alt></p>
<p>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>ARPES can only eject electrons - so only occupied states below the Fermi level are visible in the experiment, but of course one can still map out the Fermi surface at different energies by changing the chemical potential in the crystal. In the ARPES results above we see the results for different dopings of the crystal.</p>
<p>In the top panel of the figure above, we see that by changing the chemical potential, the Fermi surface shrinks from a circle to a point, exactly what you would expect for electrons with a Dirac-like dispersion.</p>
<p>While the top panels shows where the occupied states lie in the $(k_x, k_y)$ plane, in the second and third rows we see a cross-section of the energy as a function of momentum, where the Dirac cone is clearly visible, emerging from a bulk valence band filled with electrons.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;Why do you think ARPES observes surface states even if there is conductance through the bulk?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;ARPES can only observe occupied states and therefore bulk conductance is not an issue. &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since ARPES measures the spectrum in a momentum resolved way, it can separate out surface and bulk states.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ARPES does not measure conductance and therefore bulk electronic states are not an issue.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since ARPES measures the spectrum in an energy resolved way, it can selectively choose the surface states in the bulk gap.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The surface states live within the energy gap of the bulk. Since ARPES directly measure $E(k)$, it separates out &quot;</span></span><br><span class="line">    <span class="string">&quot;surface states from bulk states, which are in different energy ranges. &quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Quasiparticle-interference-QPI"><a href="#Quasiparticle-interference-QPI" class="headerlink" title="Quasiparticle interference (QPI)"></a>Quasiparticle interference (QPI)</h1><p>Scanning tunneling microscopy (STM) is another tool to image surface states in a topological insulator. In the process of STM we tunnel electrons into the surface from a metallic tip. In contrast to ARPES, the electrons are not going into free space, so we don’t have momentum resolution. On the other hand, we do trade momentum resolution for nearly atomic spatial resolution. We know where exactly on the surface the electron came from.</p>
<p>Tunneling into a uniform surface can tell us a little bit about which orbital on an atom, the electrons at a certain energy come from. Otherwise, we’d see a uniform surface, which wouldn’t have much information.  We can make things more interesting and, strangely enough, get more information by sprinkling some impurities on the surface. The impurities scatter the surface electrons and produce a standing wave pattern on the surface, which depends on the Fermi surface momenta of the electrons at the particular tunneling energy (Note: in this unit we refer to the equal energy surface in momentum space at the tunneling energy as Fermi surface for convenience). The resulting pattern is referred to QPI. Specifically, Fourier transforming the QPI pattern directly maps out the momentum transfer across the Fermi-surface of the surface state.</p>
<p>Clearly, we can expect to map out some properties of the momentum space scattering on the surface of the topological insulator.</p>
<p>In the simulation below. we see that the Fourier transform shows an interesting pattern:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/QPI_pic_adapted.png" alt><br>(adapted, copyright Hasan lab, Princeton, see license in the beginning of the chapter)  </p>
<p>By comparing the QPI patterns showing spin-dependent and spin-independent scattering (respectively on the left and right column on the right side of the arrow), we see that the intensity at momenta connecting opposite points on the Fermi surface is suppressed in the case of spin-independent scattering.</p>
<p>In fact, by comparing the fourier transform of the QPI on the right with the Fermi surface on the left, we begin to see that the absence of back-scattering, which is one of the key properties of the topological insulator surface state plays a key role. As you might remember from the quantum spin hall systems - elastic backscattering of electrons is forbidden between states at $\bf k$ and $-\bf k$ because of Kramers’ theorem. Looking at the QPI pattern from spin-independent impurities and comparing it with the Fermi surface confirms this.</p>
<h1 id="The-issue-of-bulk-conductivity"><a href="#The-issue-of-bulk-conductivity" class="headerlink" title="The issue of bulk conductivity"></a>The issue of bulk conductivity</h1><p>One of the central issues that has plagued the experimental progress with topological insulators is the presence of bulk doping or conductance in most naturally grown crystals. You can see this simply by looking at the ARPES plots below:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/bulk_conductance_TI.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>What you see is that the Fermi-energy, which is the highest energy till which you can eject electrons in ARPES intersects the conduction band. This means that in the native state the conduction band of the electrons is occupied and the fermi level is not in the gap. In the figure above, the situation is worst for pure Antimony in the extreme left panel, which is really a semimetal with overlapping electron and hole bands. In this case, independent of fermi level position, the system would remain metallic. Moving from pure Sb to $Bi_2 Se_3$ improves this somewhat, but still does not make this an insulator. Theoretically, we do expect pure $Bi_2 Se_3$ to be an insulator - but in reality, the system typically have Se vacancies, which make it metallic.</p>
<p>Being metallic really ruins a lot of interesting properties of the topological insulators. So a lot of effort is going in to fixing it up. Below, we see some of the results from these attempts:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/insulating_TI.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>where various combinations of $Bi$, $Se$ and $Te$ have been combined to drive the system insulating. By looking at the ARPES spectra, it should look convincing that by varying different conditions, the fermi level is indeed shifting in to the interior of the gap. The experimental tricks used to get this working range between changing the pressure of various elements in the growth condition to counter doping the surface etc.  But the resistance results seem to be improving quite a bit.</p>
<h1 id="Hexagonal-warping"><a href="#Hexagonal-warping" class="headerlink" title="Hexagonal warping"></a>Hexagonal warping</h1><p>ARPES measurements on the surface of topological materials in the bismuth family also demonstrated an interesting (even though non-topological) feature of the surface states.</p>
<p>The effective Dirac Hamiltonian is linear in momentum and has a full rotational symmetry in the $(x,y)$ plane of the surface, making the Fermi surface circular. However, moving away in energy from the Dirac point, experimentalists observed a different shape of the Fermi surface, similar to a snowflake:</p>
<p><img src="/2021/01/07/src/w6_3dti/3dti_signatures/warping.png" alt><br>(copyright Hasan lab, Princeton, see license in the beginning of the chapter)</p>
<p>It’s clear that this shape cannot be explained by the Dirac Hamiltonian with its rotational invariance. In order to take into account this deformation of the Fermi surface, we have to think about the crystal symmetries of the surface. In BiSe and BiTe compounds, there is no full rotational symmetry, but only a lower three-fold rotation symmetry. We can take into account this effect by adding a correction to the effective Dirac Hamiltonian.</p>
<p>This is exactly what was done in this article:</p>
<ul>
<li>arXiv:0908.1418</li>
</ul>
<p>There Liang Fu made a relatively simple theoretical exercise. He listed all the terms in the Hamiltonian allowed by time-reversal and crystalline symmetries, that are proportional to $k^3.$ This is the result:</p>
<p>$$<br>H(\mathbf{k}) = E_0(k) + v, (1+\alpha \mathbf{k}^2),(k_x\sigma_y - k_y\sigma_x) + \frac{\lambda}{2},(k^3_++k^3_-),\sigma_z.<br>$$</p>
<p>You see a correction to the Dirac velocity proportional to $\alpha \mathbf{k}^2$, which doesn’t break the rotational symmetry, as well as the term with $\lambda$, which is responsible for the warping.</p>
<p>Let’s plot the spectrum of this extended effective Hamiltonian:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line"></span><br><span class="line">plot_warping()</span><br></pre></td></tr></table></figure>

<p>This Hamiltonian reproduces correctly the <em>hexagonal warping</em> of the Fermi surface. In particular, independently of the parameters $\lambda$ and $\alpha$, the vertices of the hexagon are always aligned with the $x$ crystal axis, as is observed experimentally.</p>
<p>In addition to modifying the shape of the Fermi surface, we see that the extra term is proportional to $\sigma_z$, and rotates the spin of the surface state out of plane. This strongly affects the scattering properties of the surface state.</p>
<h1 id="Outlook-from-basic-science-to-potential-applications"><a href="#Outlook-from-basic-science-to-potential-applications" class="headerlink" title="Outlook: from basic science to potential applications"></a>Outlook: from basic science to potential applications</h1><p>David Vanderbilt will conclude this week’s lectures by offering a perspective on the future of the field.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;WZmNeEwM1N4&quot;</span>, src_location=<span class="string">&quot;6.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;3DTI materials and signatures&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w5_qshe/w5_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h1><p>As usual, start by grabbing the notebooks of this week (<code>w5_qshe</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<h3 id="Kane-Mele-model"><a href="#Kane-Mele-model" class="headerlink" title="Kane-Mele model"></a>Kane-Mele model</h3><p>The first known implementation of quantum spin Hall effect is the Kane-Mele model, introduced in <a href="http://arxiv.org/abs/cond-mat/0411737">this paper</a>. It is a doubled copy of the Haldane model (get that one from the previous week’s notebooks), with spin up and spin down having next-nearest neighbor hoppings complex conjugate of each other due to spin-orbit coupling.</p>
<p>Implement the Kane-Mele model and add a staggered onsite potential to also be able to create a trivial gap. Calculate the scattering matrix topological invariant of that model.</p>
<p>How would you add disorder and calculate the topological invariant? (Hint: you need to add disorder to the scattering region, and make leads on both sides conducting)</p>
<h3 id="Quantum-Hall-regime"><a href="#Quantum-Hall-regime" class="headerlink" title="Quantum Hall regime"></a>Quantum Hall regime</h3><p>The helical edge states of quantum spin Hall effect survive for some time when a magnetic field is added. Make a Hall bar out of the BHZ model. Can you reproduce the experimental results? What do you see? Are the inversion symmetry breaking terms important?</p>
<p>What about conductance in a two terminal geometry: can you see the crossover from quantum spin Hall regime to quantum Hall regime?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Quantum spin Hall effect&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1306-1925"><a href="#arXiv-1306-1925" class="headerlink" title="arXiv:1306.1925"></a>arXiv:1306.1925</h3><p><strong>Hint:</strong> A better material?</p>
<h3 id="arXiv-0808-1723"><a href="#arXiv-0808-1723" class="headerlink" title="arXiv:0808.1723"></a>arXiv:0808.1723</h3><p><strong>Hint:</strong> What happens when edge states meet.</p>
<h3 id="arXiv-1104-3282"><a href="#arXiv-1104-3282" class="headerlink" title="arXiv:1104.3282"></a>arXiv:1104.3282</h3><p><strong>Hint:</strong> A completely different approach.</p>
<h3 id="arXiv-1312-2559"><a href="#arXiv-1312-2559" class="headerlink" title="arXiv:1312.2559"></a>arXiv:1312.2559</h3><p><strong>Hint:</strong> Adding superconductors.</p>
<h3 id="arXiv-1303-1766"><a href="#arXiv-1303-1766" class="headerlink" title="arXiv:1303.1766"></a>arXiv:1303.1766</h3><p><strong>Hint:</strong> Sources of back-scattering in QSHE edge.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Quantum spin Hall effect&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w5_qshe/qshe_experiments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.simplefilter(<span class="string">&quot;ignore&quot;</span>, UserWarning)</span><br><span class="line"></span><br><span class="line">bhz_parameters = &#123;</span><br><span class="line">    <span class="string">&quot;topo&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">0.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;topo2&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;triv&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: -<span class="number">0.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;lead&quot;</span>: &#123;<span class="string">&quot;A_lead&quot;</span>: <span class="number">1.5</span>, <span class="string">&quot;B_lead&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D_lead&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M_lead&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hopping functions for the BHZ model.</span></span><br><span class="line"><span class="comment"># Sometimes, we use different BHZ parameters in the</span></span><br><span class="line"><span class="comment"># scattering region and leads, so we treat them</span></span><br><span class="line"><span class="comment"># separately.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_onsite</span>(<span class="params">site, p, is_lead=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        B, D, M = p.B_lead, p.D_lead, p.M_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        B, D, M = p.B, p.D, p.M</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        (M - <span class="number">4</span> * B) * pauli.s0sz</span><br><span class="line">        - <span class="number">4</span> * D * pauli.s0s0</span><br><span class="line">        + p.ez_y * np.kron(pauli.sy, (pauli.s0 + pauli.sz) / <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _onsite(site, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite_lead</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _onsite(site, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_hopx</span>(<span class="params">site1, site2, p, is_lead=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        A, B, D = p.A_lead, p.B_lead, p.D_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A, B, D = p.A, p.B, p.D</span><br><span class="line">    <span class="keyword">return</span> B * pauli.s0sz + D * pauli.s0s0 + <span class="number">1j</span> * A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _hopx(site1, site2, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx_lead</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _hopx(site1, site2, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_hopy</span>(<span class="params">site1, site2, p, is_lead=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> is_lead:</span><br><span class="line">        A, B, D = p.A_lead, p.B_lead, p.D_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        A, B, D = p.A, p.B, p.D</span><br><span class="line">    <span class="keyword">return</span> B * pauli.s0sz + D * pauli.s0s0 - <span class="number">1j</span> * A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _hopy(site1, site2, p, is_lead=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy_lead</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> _hopy(site1, site2, p, is_lead=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_terminal</span>(<span class="params">L, w</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Make a two terminal system with the BHZ model. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w <span class="keyword">and</span> <span class="number">0</span> &lt;= x &lt; L</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_two_term</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> onsite(site, p) - p.mu * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_two_term_lead</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> onsite_lead(site, p) - p.mu_lead * np.eye(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Scattering region</span></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite_two_term</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Leads</span></span><br><span class="line">    lead = kwant.Builder(kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite_two_term_lead</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx_lead</span><br><span class="line">    lead[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy_lead</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attach leads</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">w=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Translationally invariant BHZ system with a infinite or fixed width w.&quot;&quot;&quot;</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    <span class="keyword">if</span> w <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">            (x, y) = pos</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        syst = kwant.Builder(sym)</span><br><span class="line">        syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G_mu_plot</span>(<span class="params">p, mus, color</span>):</span></span><br><span class="line">    syst = two_terminal(<span class="number">40</span>, <span class="number">40</span>).finalized()</span><br><span class="line">    G = [</span><br><span class="line">        kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus</span><br><span class="line">    ]</span><br><span class="line">    ydim = <span class="string">r&quot;G $[e^2/h]$&quot;</span></span><br><span class="line">    kdims = [<span class="string">r&quot;$\mu$&quot;</span>, ydim]</span><br><span class="line">    plot = holoviews.Path((mus, np.array(G)), kdims=kdims, label=<span class="string">&quot;Conductance&quot;</span>)</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [-<span class="number">0.8</span>, -<span class="number">0.4</span>, <span class="number">0</span>, <span class="number">0.4</span>, <span class="number">0.8</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;ydim: (<span class="number">0</span>, <span class="number">10</span>)&#125;).opts(plot=ticks, style=&#123;<span class="string">&quot;color&quot;</span>: color&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G_Ez_plot</span>(<span class="params">p, E_zs</span>):</span></span><br><span class="line">    syst = two_terminal(<span class="number">40</span>, <span class="number">20</span>).finalized()</span><br><span class="line">    G = [</span><br><span class="line">        kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).transmission(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> p.ez_y <span class="keyword">in</span> E_zs</span><br><span class="line">    ]</span><br><span class="line">    ydim = <span class="string">r&quot;G $[e^2/h]$&quot;</span></span><br><span class="line">    kdims = [<span class="string">r&quot;$E_z$&quot;</span>, ydim]</span><br><span class="line">    plot = holoviews.Path((E_zs, np.array(G)), kdims=kdims, label=<span class="string">&quot;Conductance&quot;</span>)</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">0.10</span>, <span class="number">0.15</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>]&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;ydim: (<span class="number">0</span>, <span class="number">2</span>)&#125;).opts(plot=ticks)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;-HRBuCgOUvs&quot;</span>, src_location=<span class="string">&quot;5.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>This topic is special, since in order to meaningfully discuss experimental progress we need to do something we didn’t do before in the course: we will show you the measurements and compare them with the <em>simple</em> theoretical expectations. Like this we will see what agrees and what doesn’t.</p>
<p>All the figures showing the experiments are copyright Physical Society of Japan (2008), published in <a href="http://journals.jps.jp/doi/abs/10.1143/JPSJ.77.031007"><br>J. Phys. Soc. Jpn. 77, 031007 (2008)</a> by  Markus König, Hartmut Buhmann, Laurens W. Molenkamp, Taylor Hughes, Chao-Xing Liu, Xiao-Liang Qi, and Shou-Cheng Zhang. They are available under CC-BY-NC-SA 4.0 International license.</p>
<h1 id="Two-limits-Mexican-hat-and-weak-pairing"><a href="#Two-limits-Mexican-hat-and-weak-pairing" class="headerlink" title="Two limits: Mexican hat and weak pairing"></a>Two limits: Mexican hat and weak pairing</h1><p>We just learned that topological insulators with inversion symmetry were simpler to think about. We will now use the  topological invariant to find a simple recipe for finding topological insulators. All we need to do is somehow vary the parity of the occupied states. One fact of nature that comes to our aid in this is that electrons in semiconductors typically occupy even parity $s$-orbitals and odd parity $p$-orbitals.</p>
<p>If we look up the bandstructure of a typical “non-topological” semiconductor, the highest valence-band is of odd parity and the lowest conduction band is even parity. As one moves down the periodic table to heavier elements with larger spin-orbit coupling the odd parity orbital switches spots with the even parity orbital. This <em>band inversion</em> is the domain where we can hope to find topological insulators.</p>
<p>Now you might think that all we have to do is go down the periodic table to heavier elements and just pick some material like HgTe (actually used in the creation of QSHE), but that’s not all yet. We still need to make a quantum well out of this semiconductor to make the system two-dimensional. This leads to two dimensional bands derived from the three dimensional band structure.</p>
<p>By carefully choosing the widths, it is possible to invert the odd and even parity bands. We saw from the last unit, that such a band-inversion leads to a topologically non-trivial value of the parity invariant. Right around the topological transition, the even and odd parity bands are degenerate. Thus, we can follow the discussion in the last unit to derive domain wall states at the edges.</p>
<p>We can write down the simplest Hamiltonian for an even and an odd parity band in a basis $|e,\sigma\rangle$ and $|o,\sigma\rangle$ in a block form </p>
<p>$$H({\bf k})=\left(\begin{array}{cc}\epsilon_e({\bf k})&amp;\Delta({\bf k})\\Delta^\dagger({\bf k})&amp;\epsilon_o({\bf k})\end{array}\right),$$</p>
<p>where $\Delta({\bf k})$ is the $2\times 2$ hybridization matrix. Inversion and time-reversal symmetries imply that $\Delta({\bf k})=-\Delta(-{\bf k})$ is odd under inversion and even under time-reversal.  Here we will focus on one such model, $\Delta({\bf k})=\alpha\sigma_z(k_x+i k_y)$, which we call the Bernevig-Hughes-Zhang model. </p>
<p>Since the even band is electron-like, we approximate the even-band dispersion $\epsilon_e({\bf k})$<br>as $\epsilon_e({\bf k}) = \delta_e + m_e k^2$, while we take the odd parity dispersion to be $\epsilon_o({\bf k})= \delta_o - m_o k^2$ for simplicity. The band inversion happens when $\delta_e &lt; \delta_o$.</p>
<p>The spectrum of this Hamiltonian is very similar to that of a Chern insulator (after all we essentially just doubled the degrees of freedom). Just like in most topological systems, the shape of the band structure depends on the relative strength of band inversion and inter-band coupling.</p>
<p>So below we see a qualitative band structure of one of the QSHE insulators, HgTe/CdTe quantum well, compared with the band structure of InAs/GaSb quantum well.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p_triv = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">0.0</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=-<span class="number">0.1</span>, M=-<span class="number">0.2</span>)</span><br><span class="line">p_topo = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">0.0</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=-<span class="number">0.1</span>, M=<span class="number">1.5</span>)</span><br><span class="line">syst = bhz()</span><br><span class="line">kwargs = &#123;<span class="string">&quot;zticks&quot;</span>: [-<span class="number">8</span>, -<span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>]&#125;</span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p_triv, **kwargs).relabel(<span class="string">&quot;Trivial&quot;</span>)</span><br><span class="line">    + spectrum(syst, p_topo, **kwargs).relabel(<span class="string">&quot;Topological&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In the last unit, we understood the nature of the edge modes near the topological phase transition, where a doubled Dirac model was appropriate. Deep in the strongly band-inverted topological regime, the bulk band structure has a mexican hat structure with the gap proportional to $\alpha$. </p>
<p>The edge modes in this regime are quite different in structure from those near the topological transition. To see this, let us first set $k_y=0$ in the Hamiltonian. If we set $\alpha=0$ then there are two fermi points where the dispersion is roughly linear - let us label these points by $\tau_z=\pm 1$. We can describe the edge of the system, by assigning boundary conditions to the $k_x=\pm k_F$ modes in terms of time-reversal invariant phase-shifts. </p>
<p>The bulk solutions near $k_x\sim\pm k_F$ can be written as $\psi_\pm(x)=e^{-x/\xi}\psi_\pm(0)$. Matching boundary conditions, we find that a zero energy pair of edge solutions exists in the case of inverted bands. These solutions differ from the ones in the Dirac limit by the presence of the oscillating part of the wave function.</p>
<h1 id="Quantized-conductance-and-length-dependence"><a href="#Quantized-conductance-and-length-dependence" class="headerlink" title="Quantized conductance and length dependence"></a>Quantized conductance and length dependence</h1><p>Unlike in the case of Majoranas, not much thinking is required to figure out the relevant signature of the quantum spin Hall effect. There is a pair of modes on each edge of the sample that is protected from backscattering. All the other modes are gapped or backscattered, so the edge states are the only ones to carry current. This current will not suffer from backscattering.</p>
<p>If we consider the simplest case, a sample with only two terminals, then Landauer’s formula together with the absence of backscattering gives the conductance $G_0=2 e^2/h$.</p>
<p>When we move the Fermi level outside of the bulk gap, the bulk becomes conducting, and so the conductance increases.</p>
<p>We end up with this situation:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p_topo = SimpleNamespace(</span><br><span class="line">    mu=<span class="literal">None</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">1.5</span>, A=<span class="number">0.5</span>, B=<span class="number">1.0</span>, D=<span class="number">0.0</span>, M=<span class="number">0.2</span>, **bhz_parameters[<span class="string">&quot;lead&quot;</span>]</span><br><span class="line">)</span><br><span class="line">p_triv = SimpleNamespace(</span><br><span class="line">    mu=<span class="literal">None</span>,</span><br><span class="line">    ez_y=<span class="number">0.0</span>,</span><br><span class="line">    mu_lead=<span class="number">1.5</span>,</span><br><span class="line">    A=<span class="number">0.5</span>,</span><br><span class="line">    B=<span class="number">1.0</span>,</span><br><span class="line">    D=<span class="number">0.0</span>,</span><br><span class="line">    M=-<span class="number">0.2</span>,</span><br><span class="line">    **bhz_parameters[<span class="string">&quot;lead&quot;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r&quot;$-\pi/3$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi / <span class="number">3</span>, <span class="string">r&quot;$\pi/3$&quot;</span>)],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">1.5</span>, -<span class="number">1.0</span>, -<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: (-<span class="number">1.5</span>, <span class="number">1.5</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syst = bhz(w=<span class="number">20</span>)</span><br><span class="line">spec_topo = spectrum(syst, p_topo, **kwargs).relabel(<span class="string">&quot;spectrum (topo)&quot;</span>)</span><br><span class="line">spec_triv = spectrum(syst, p_triv, **kwargs).relabel(<span class="string">&quot;spectrum (triv)&quot;</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">50</span>)</span><br><span class="line">HLines = holoviews.HoloMap(&#123;mu: holoviews.HLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br><span class="line">VLines = holoviews.HoloMap(&#123;mu: holoviews.VLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br><span class="line">G_triv = G_mu_plot(p_triv, mus, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">G_topo = G_mu_plot(p_topo, mus, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">(G_triv * (G_topo * VLines) + spec_topo * HLines + spec_triv * HLines)</span><br></pre></td></tr></table></figure>

<p>Here on the left we see a comparison between the conductances of a trivial (blue curve) and a topological (red curve) insulator as a function of chemical potential. The other two panels show the spectra of a quantum spin Hall insulator in the topological and trivial phases. As we expected, conductance is quantized when the chemical potential is inside the band gap of a topological system.</p>
<p>Let’s now see what can be measured experimentally.</p>
<p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig13.png" alt></p>
<p>(copyright JPS, see license in the beginning of the chapter)</p>
<p>What you notice is that the maximum resistance for the 4.5 nm thick quantum well is much higher than for the 8 nm thick well. Given that theory predicts that the HgTe quantum wells described by Michael Wimmer in his video are topological when their thickness is between 6.3 nm and 12 nm, this measurement suggests that the lower resistance of the 8 nm thick well might be due to edge conductance. But even though it is the lower of the two, you might complain that the resistance of the 8 nm well is closer to $100$ $k\Omega$ than the predicted $12$ $k\Omega$ from the quantum of conductance.</p>
<p>The black curve here is the resistance of a trivial insulator, and the red one should be that of a topological one. The resistance of a trivial insulator becomes very high as expected, and there is a plateau-like feature in the topological regime.</p>
<p>Fortunately, it was revealed in further experiments by the Wurzburg group, that by reducing the length of the sample from length $L=20$ $\mu m$ to $L=1$ $\mu m$, the conductance maximum rises to about $12.9$ $k\Omega$:</p>
<p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig14.png" alt></p>
<p>(copyright JPS, see license in the beginning of the chapter)</p>
<p>We see something different from what we expected: the average resistance value at the plateau is correct, but only within 10% precision, very different from the $10^{-8}$ accuracy of the quantum Hall effect.</p>
<p>This difference most likely originates from backscattering. In the quantum Hall effect, backscattering is prohibited by the absence of modes going in the other direction. In the quantum spin Hall effect however, the protection is much weaker and is merely due to Kramers theorem.</p>
<p>The exact origin of the backscattering is hard to understand. It could be inelastic scattering that does not preserve energy, or it could also be some residual magnetic impurities, which break time reversal symmetry. In both cases, Kramers theorem does not hold. One of the papers that we suggest for review proposes an interesting theory for the origin of the backscattering, while another reports measurements of InAs/GaSb quantum well, where conductance seems much better quantized.</p>
<p>Regardless of the exact origin of backscattering, at any finite temperature, there is an inelastic scattering length $l_\phi$ beyond which we do not expect any protection from scattering. When the edge length $L$ is larger than $l_\phi$, we expect the edge to turn into an incoherent conductor with resistance of $(e^2/h) l_\phi/L$. </p>
<p>In principle, this allows us to measure $l_\phi$ for the quantum spin hall edges by looking at the length dependence of the conductance. Indeed, experiments find that small samples have conductance close to $G_0$, while in large samples the conductance is suppressed.</p>
<h1 id="Landau-levels"><a href="#Landau-levels" class="headerlink" title="Landau levels"></a>Landau levels</h1><p>We learned that the key ingredient to obtain an inversion symmetric topological insulator is band inversion - an electron-like band with a positive effective mass and a hole-like band with a negative effective mass are inverted.</p>
<p>The standard way to distinguish electrons from holes is to measure the sign of the Hall resistance, which is positive for electrons and negative for holes. Hence, we expect to measure a change in the sign of the Hall conductance as we change the position of the Fermi level from being above to being below the band gap.</p>
<p>In the first plot below, you see traces of the Hall resistance of a quantum spin Hall sample as a function of the applied magnetic field, for several values of the gate voltage, given by different colors. You see that for $V_g=-1$ V the Hall resistance is positive, while for $V_g = -2 V$ the resistance is negative. These are the two black traces. They both exhibit a very well formed $\nu=1$ quantum Hall plateau for high enough fields, and a vanishing Hall resistance for zero magnetic field. This is the standard, expected behavior.</p>
<p>For some traces between these two values, the resistance shoots up to very high values. This is because the Fermi level is in the middle of the band gap. As expected, we thus observe insulating behavior.</p>
<p>However, you may notice something interesting. Let’s focus for instance on the green and red traces taken for two very close values of $V_g$. Because these correspond to Fermi levels in the middle of the band gap, they show a very high resistance, except for a range of magnetic field values, where they also exhibit a quantum Hall plateau!</p>
<p>This proves what we hoped to find: there is a Landau level of electrons that crosses with a Landau level of holes.</p>
<p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig11.png" alt></p>
<p>(copyright JPS, see license in the beginning of the chapter)</p>
<p>As shown in the lower panel, this particular feature is due to the unique structure of Landau levels which you obtain in the presence of a band inversion.</p>
<p>The Landau levels of an electron-like band have a positive slope as a function of magnetic field, while those of a hole-like band have a negative slope. In a trivial bandstructure, all negative energy levels would bend down as a function of magnetic field, while all positive energy levels would bend up. As a consequence, if you place the Fermi level in the middle of the band gap and increase the magnetic field, no Landau level will ever cross the Fermi level.</p>
<p>However, in the presence of a band inversion, you obtain what is shown in the figure: the lowest Landau levels coming from the inverted bands go in the “wrong” direction. At some value of the magnetic field, they must cross. Furthemore, they will both cross the Fermi level if it is in the middle of the zero-field band gap.</p>
<p>Due to this fact, one observes a Hall effect in a certain range of fields, even when the Fermi level is placed in the middle of the zero-field band gap. And indeed, by comparing the experimental results with the expected behavior of the Landau levels, you see that the positions of the Fermi-level crossings coincide with the re-entrant Hall plateaus of the experimental traces - as marked by the green and red arrows.</p>
<p>As a further confirmation that this effect is due to band inversion, this behavior was only observed in samples with a thickness above the expected threshold value to obtain a quantum spin Hall phase, and never in samples with a smaller thickness.</p>
<h1 id="Localization-of-the-edge-states-by-magnetic-field"><a href="#Localization-of-the-edge-states-by-magnetic-field" class="headerlink" title="Localization of the edge states by magnetic field"></a>Localization of the edge states by magnetic field</h1><p>Theoretically, the hallmark of the topological insulator is the quantized conductance of the edge states that are protected from elastic backscattering. In the last unit, we learned that the key to this protection is time-reversal symmetry. Therefore, breaking time reversal symmetry by for example applying a magnetic field, should suppress the quantized conductance.</p>
<p>We can think about this more explicitly by considering a simple model for the helical edge states with a magnetic field $\bf B$:</p>
<p>$$H=v_F k_x\sigma_z+{\bf B}\cdot {\bf \sigma},$$</p>
<p>where $\bf \sigma$ are Pauli matrices representing the spin degree of freedom at the edge. This is what we get from the BHZ model, which conserves spin. For more general models we would interpret $\bf \sigma$ as a pseudo-spin degree of freedom, which is odd under time-reversal.</p>
<p>If we consider the simple case of a magnetic field ${\bf B}=B {\bf x}$ along the x-direction, we find that the edge spectrum $E=\pm\sqrt{v_F^2 k_x^2+B^2}$ becomes gapped. Clearly, the edge becomes insulating if we set the chemical potential at $E=0$.</p>
<p>We can very easily calculate that this is the case if we plot the conductance of the QSHE model as a function of magnetic field:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(mu=<span class="number">0</span>, ez_y=<span class="number">0.0</span>, mu_lead=<span class="number">1.5</span>, **bhz_parameters[<span class="string">&quot;topo2&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> bhz_parameters[<span class="string">&quot;topo2&quot;</span>].items():</span><br><span class="line">    <span class="comment"># setting the parameters for the lead the same as the scattering system</span></span><br><span class="line">    p.__dict__[key + <span class="string">&quot;_lead&quot;</span>] = value</span><br><span class="line"></span><br><span class="line">syst = bhz(w=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi / <span class="number">3</span>, np.pi / <span class="number">3</span>, <span class="number">51</span>),</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: (-<span class="number">1.5</span>, <span class="number">1.5</span>),</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [(-np.pi / <span class="number">3</span>, <span class="string">r&quot;$-\pi/3$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>), (np.pi / <span class="number">3</span>, <span class="string">r&quot;$\pi/3$&quot;</span>)],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">1.5</span>, -<span class="number">1.0</span>, -<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="keyword">lambda</span> p: <span class="string">&quot;Band structure&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E_zs = np.linspace(<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">50</span>)</span><br><span class="line">VLines = holoviews.HoloMap(</span><br><span class="line">    &#123;ez_y: holoviews.VLine(ez_y) <span class="keyword">for</span> ez_y <span class="keyword">in</span> E_zs&#125;, kdims=[<span class="string">r&quot;$E_z$&quot;</span>]</span><br><span class="line">)</span><br><span class="line">spectra = holoviews.HoloMap(</span><br><span class="line">    &#123;p.ez_y: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.ez_y <span class="keyword">in</span> E_zs&#125;, kdims=[<span class="string">r&quot;$E_z$&quot;</span>]</span><br><span class="line">)</span><br><span class="line">G_Ez_plot(p, E_zs) * VLines + spectra * holoviews.HLine(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>However, even if we consider energies $E&gt;B$ above the gap, the eigenstates at $\pm k_x$ are no longer Kramers’ pairs, i.e. related by time-reversal symmetry. Therefore, any mechanism which changes momentum by $2 k_x$ can backscatter electrons from left movers to right movers. </p>
<p>Edges of semiconductors are typically quite disordered - so we expect the random potential at the edge to provide “elastic backscattering” that can change the momentum without changing the energy. Such backscattering, in addition to any other “inelastic backscattering” by phonons etc, would decrease the conductance of the edge from the ideal quantized value. If we set $B=0$, elastic back-scattering that can occur at finite $B$ is forbidden, so we generally expect the application of a magnetic field to reduce conductance of the edge.</p>
<p>We see below that indeed the conductance of the $L=20,\mu m$ device is strongly reduced by the application of a magnetic field: </p>
<p><img src="/2021/01/07/src/w5_qshe/qshe_experiments/konig_fig15.png" alt></p>
<p>(copyright JPS, see license in the beginning of the chapter)</p>
<p>However, we notice that this effect seems to work only when the magnetic field is perpendicular to the sample. In-plane magnetic fields do not seem to do a whole lot (there is an effect, but much larger fields are required). According to our model Hamiltonian, an in-plane field should have opened a gap, while a perpendicular field which adds a term proportional to $\sigma_z$ should have not done anything.</p>
<p>So, while the experiment sees something similar to what we hoped to find using a simple theory, the effect of the magnetic field seems reversed. There may be several explanations for this phenomenon, such as a presence of extra terms in the Hamiltonian that rotate the spins of the edge states without breaking time-reversal symmetry.</p>
<p>You might be worried that the suppression of conductance is only shown for the long device, which does not show quantized conductance. If you are, then you are absolutely right in worrying about this :-)</p>
<p>Localization of QSHE edge states by magnetic field is relatively poorly understood, and we are not aware of a final experiment that would prove its existence or tell us in details what it is that happens at the QSHE edge in a magnetic field. As you will learn in two weeks, opening the gap by magnetic field opens new pathways for the creation of Majoranas, and so it is still a very important direction of research.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Why did we not see a similar suppression of conductance with magnetic field in the case of  &quot;</span></span><br><span class="line">    <span class="string">&quot;the quantum Hall effect in week 3?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The quantum Hall effect appeared in much higher quality samples.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There was no spin in the quantum Hall effect, so the magnetic field could not couple to anything.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The topological protection of quantum Hall edges does not rely on time-reversal, unlike quantum spin &quot;</span></span><br><span class="line">    <span class="string">&quot;Hall edges.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The suppression here arises from inelastic scattering, which could not arise in the quantum Hall case.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The magnetic field dependence here arises from the fact that B breaks time-reversal symmetry, which is  &quot;</span></span><br><span class="line">    <span class="string">&quot;required for the protection of edge states in the quantum spin Hall effect. &quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;Kop4zXWQ1Zc&quot;</span>, src_location=<span class="string">&quot;5.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;QSHE - experiments&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w5_qshe/fermion_parity_pump/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line">bhz_parameters = &#123;</span><br><span class="line">    <span class="string">&quot;topo&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;triv&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.0</span>, <span class="string">&quot;M&quot;</span>: -<span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;topo2&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.5</span>, <span class="string">&quot;B&quot;</span>: <span class="number">1.00</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.3</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1.0</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.0</span>&#125;,</span><br><span class="line">    <span class="string">&quot;slowed&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>: <span class="number">0.05</span>, <span class="string">&quot;B&quot;</span>: <span class="number">0.08</span>, <span class="string">&quot;D&quot;</span>: <span class="number">0.15</span>, <span class="string">&quot;M&quot;</span>: -<span class="number">0.3</span>, <span class="string">&quot;del_z&quot;</span>: <span class="number">0.5</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Onsite and hoppings for bhz model</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (p.M - <span class="number">4</span> * p.B) * pauli.s0sz - <span class="number">4</span> * p.D * pauli.s0s0 + p.del_z * pauli.sysy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 + <span class="number">1j</span> * p.A * pauli.szsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> p.B * pauli.s0sz + p.D * pauli.s0s0 - <span class="number">1j</span> * p.A * pauli.s0sy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz</span>(<span class="params">w=<span class="number">20</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Make ribbon system with bhz model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    slowed parameters are used on the edge for finite size system.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_x</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    slowed_par = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;slowed&quot;</span>])</span><br><span class="line">    <span class="keyword">if</span> w <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[(lat(<span class="number">0</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(w))] = onsite</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">        syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>, -<span class="number">1</span>)] = <span class="keyword">lambda</span> site, p: onsite(site, slowed_par)</span><br><span class="line">        syst[lat(<span class="number">1</span>, -<span class="number">1</span>), lat(<span class="number">0</span>, -<span class="number">1</span>)] = <span class="keyword">lambda</span> site1, site2, p: hopping_x(</span><br><span class="line">            site1, site2, slowed_par</span><br><span class="line">        )</span><br><span class="line">        syst[lat(<span class="number">0</span>, <span class="number">0</span>), lat(<span class="number">0</span>, -<span class="number">1</span>)] = hopy</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>, w)] = <span class="keyword">lambda</span> site, p: onsite(site, slowed_par)</span><br><span class="line">        syst[lat(<span class="number">1</span>, w), lat(<span class="number">0</span>, w)] = <span class="keyword">lambda</span> site1, site2, p: hopping_x(</span><br><span class="line">            site1, site2, slowed_par</span><br><span class="line">        )</span><br><span class="line">        syst[lat(<span class="number">0</span>, w), lat(<span class="number">0</span>, w - <span class="number">1</span>)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bhz_cylinder</span>(<span class="params">w=<span class="number">3</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Make cylinder system with bhz model. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_x</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopx(site1, site2, p) * np.exp(-<span class="number">0.5j</span> * p.Bz * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy_phase</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> hopy(site1, site2, p) * np.exp(<span class="number">1j</span> * p.ky)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopping_x</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, -w + <span class="number">1</span>), lat)] = hopy_phase</span><br><span class="line"></span><br><span class="line">    syst[lat(<span class="number">0</span>, <span class="number">0</span>)] = onsite</span><br><span class="line">    syst[lat(<span class="number">0</span>, w - <span class="number">1</span>)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lead</span>(<span class="params">t, trs=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym, time_reversal=<span class="number">1j</span> * pauli.sys0)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">1.8</span> * t * pauli.s0sz</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = -t * pauli.s0sz</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_scatter_sys</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        x, y = pos</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="number">0</span>) * (<span class="number">0</span> &lt;= y &lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square(norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    lead_cylinder = bhz_cylinder()</span><br><span class="line">    lead = make_lead(<span class="number">1.0</span>)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line">    syst.attach_lead(lead_cylinder)</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scattering_det_pfaff</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pfaffian</span>(<span class="params">syst, p, ky</span>):</span></span><br><span class="line">        p.ky = ky</span><br><span class="line">        smat = kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).data</span><br><span class="line">        <span class="comment"># since we get relatively large numerical errors we project the matrix on</span></span><br><span class="line">        <span class="comment"># the space of antisymmetric matrices</span></span><br><span class="line">        smat = <span class="number">0.5</span> * (smat - smat.T)</span><br><span class="line">        <span class="keyword">return</span> pf.pfaffian(smat)</span><br><span class="line"></span><br><span class="line">    pfaff = [pfaffian(syst, p, <span class="number">0</span>), pfaffian(syst, p, np.pi)]</span><br><span class="line"></span><br><span class="line">    ks = np.linspace(<span class="number">0.0</span>, np.pi, <span class="number">50</span>)</span><br><span class="line">    det = [np.linalg.det(kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).data) <span class="keyword">for</span> p.ky <span class="keyword">in</span> ks]</span><br><span class="line">    det = np.array(det)</span><br><span class="line"></span><br><span class="line">    phase = np.angle(pfaff[<span class="number">0</span>]) + <span class="number">0.5</span> * np.cumsum(np.angle(det[<span class="number">1</span>:] / det[:-<span class="number">1</span>]))</span><br><span class="line">    kdims = [<span class="string">&quot;$k_y$&quot;</span>, <span class="string">&quot;phase&quot;</span>]</span><br><span class="line">    plot = holoviews.Path((ks[<span class="number">1</span>:], phase), kdims=kdims).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;)</span><br><span class="line">    plot *= holoviews.Points(([<span class="number">0</span>, np.pi], np.angle(pfaff)), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;g&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    xlims, ylims = <span class="built_in">slice</span>(-<span class="number">0.2</span>, np.pi + <span class="number">0.2</span>), <span class="built_in">slice</span>(-np.pi - <span class="number">0.2</span>, np.pi + <span class="number">0.2</span>)</span><br><span class="line">    pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">&quot;$\pi$&quot;</span>)], <span class="string">&quot;yticks&quot;</span>: pi_ticks&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.relabel(<span class="string">&quot;Winding&quot;</span>, depth=<span class="number">1</span>)[xlims, ylims].opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$A=&#123;:.2&#125;$, $B=&#123;:.2&#125;$, $D=&#123;:.2&#125;$, $M=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    <span class="keyword">return</span> title.<span class="built_in">format</span>(p.A, p.B, p.D, p.M)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Charles Kane from the University of Pennsylvania will introduce today’s lecture on two dimensional topological insulators with time-reversal symmetry.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;n5oUQvvsYd0&quot;</span>, src_location=<span class="string">&quot;5.1-intro&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Adding-symmetry-to-a-topological-insulator"><a href="#Adding-symmetry-to-a-topological-insulator" class="headerlink" title="Adding symmetry to a topological insulator"></a>Adding symmetry to a topological insulator</h1><p>In general, there are different approaches to discover new types of topological systems.</p>
<p>We have already used a very powerful method to make a Kitaev chain and the Chern insulator model. We started from guessing what kind of model to use for the edge, such that it is impossible to obtain without the bulk. Then we combined many such edges (dots for the Kitaev chain and wires for the Chern insulator) and tailored the coupling between them to leave exactly the type of model that we want on one edge.</p>
<p>A very skilled researcher in topology (or more specifically <a href="https://en.wikipedia.org/wiki/K-theory">K-theory</a>) may also just calculate the expected topological classification of a system starting only from its dimensionality and symmetries. This is also a powerful method, but often it’s too hard and requires a very high skills in math.</p>
<p>Another approach that we can undertake is to start with one topological Hamiltonian and see what happens if we force the Hamiltonian to have some extra symmetry. This is the approach we will use in this chapter.</p>
<p>Let’s start from a simple example involving something which we already know, a quantum dot with the Hamiltonian $H_0$. We know that there is a topological invariant, the number of filled energy levels.</p>
<p>Now we can ask what happens if we force the dot to have a particle-hole symmetry. The Hamiltonian becomes</p>
<p>$$<br>H_\textrm{BdG} =<br>\begin{pmatrix}<br>H_0 &amp; 0\<br>0 &amp; -H_0^*<br>\end{pmatrix}.<br>$$</p>
<p>This model is clearly topologically trivial from the point of view of the old invariant, since the number of filled states is constant. However, there are still level crossings that appear. We may ask if these crossings stay protected if we also include a finite superconducting pairing $\Delta$ in the Hamiltonian, which couples the two blocks $H_0$ and $-H_0^*$.</p>
<p>Of course we know the answer: the crossings stay protected due to the change in the Pfaffian invariant. So what we did was to construct a topologically non-trivial superconducting dot by adding particle-hole symmetry to a topological Hamiltonian with a lower symmetry.</p>
<p>Let’s now apply the same logic to a new system. Specifically, let’s add time-reversal symmetry to a Chern insulator. The Chern insulator has chiral edge states whose direction of propagation is flipped by time-reversal symmetry $\mathcal{T}$. So let’s consider a Hamiltonian of the form</p>
<p>$$<br>H =<br>\begin{pmatrix}<br>H_0 &amp; 0\<br>0 &amp; \mathcal{T}H_0\mathcal{T}^{-1}<br>\end{pmatrix},.<br>$$</p>
<p>If $H_0$ is the Hamiltonian of a Chern insulator with $N$ edge states, then $H$ will have $N$ pairs of counterpropagating edge states that transform into each other by time-reversal symmetry. Moreover, the full $H$ obeys time-reversal symmetry, which merely exchanges the two blocks.</p>
<p>The following sketch describes the situation in the case $N=1$:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_insulator.svg" alt></p>
<p>The next task which we now face is to understand if such edges stay topologically protected once we add coupling between the two blocks.</p>
<h1 id="A-perfectly-transmitted-channel-and-Kramers-degeneracy"><a href="#A-perfectly-transmitted-channel-and-Kramers-degeneracy" class="headerlink" title="A perfectly transmitted channel and Kramers degeneracy"></a>A perfectly transmitted channel and Kramers degeneracy</h1><p>We could try to see if all the edge states can be removed by adding some terms to the Hamiltonian, but instead we will use a closely related fact.</p>
<p>Let’s study transport through such edge states as a function of their total number and let’s only use the fact that time-reversal symmetry is present. Imagine, there is a total of $N$ states going in each direction along the edge, and that the edge is composed of a disordered region sandwiched between two clean regions. Again, let’s represent the situation for the case $N=1$.</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_scattering.svg" alt></p>
<h2 id="Scattering-states"><a href="#Scattering-states" class="headerlink" title="Scattering states"></a>Scattering states</h2><p>We label incoming states on the left and right with $\left|n,\textrm{L}\right\rangle$ and $\left|n,\textrm{R}\right\rangle$. The index $n$ goes from $1$ to $N$. The outgoing states are the time-reversed partners of the incoming states, so they are given by $\mathcal{T}\left|n,\textrm{L}\right\rangle$ and $\mathcal{T}\left|n,\textrm{R}\right\rangle$. Scattering states in the left and right regions are superpositions of incoming and outgoing states,</p>
<p>$$<br>\left|\Psi,\textrm{L}\right\rangle = \sum_{n=1}^N \alpha_{n,\textrm{L}},\left|n,\textrm{L}\right\rangle + \beta_{n,\textrm{L}},\mathcal{T}\left|n,\textrm{L}\right\rangle,,<br>$$<br>$$<br>\left|\Psi,\textrm{R}\right\rangle = \sum_{n=1}^N \alpha_{n,\textrm{R}},\left|n,\textrm{R}\right\rangle + \beta_{n,\textrm{R}},\mathcal{T}\left|n,\textrm{R}\right\rangle,.<br>$$</p>
<p>We can form vectors out of all the coefficients in the superposition, for instance $\alpha_\textrm{L} = (\alpha_{1,\textrm{L}},\dots,\alpha_{N,\textrm{L}})^T$ for the incoming states on the left side. Incoming and outgoing modes are then related by the scattering matrix $S$ of the disordered region,</p>
<p>$$<br>\begin{pmatrix} \beta_\textrm{L} \ \beta_\textrm{R} \end{pmatrix} = S \begin{pmatrix} \alpha_\textrm{L} \ \alpha_\textrm{R} \end{pmatrix}.<br>$$</p>
<p>There are a total of $2N$ incoming and $2N$ outgoing modes, so $S$ is a $2N\times 2N$ matrix. Since we are including all possible initial and final states, $S$ is also unitary, $S=S^\dagger$. It can be split into reflection and transmission blocks of dimension $N\times N$,</p>
<p>$$<br>S =<br>\begin{pmatrix}<br>r &amp; t\<br>t’ &amp; r’<br>\end{pmatrix},.<br>$$</p>
<p>If we can gap out the edges by adding some extra terms to the Hamiltonian, or backscatter them by adding disorder, then we should be able to achieve the situation where there is no transmission at all, $t = t’ = 0$. In this case, all modes must be reflected back, so the reflection blocks of the scattering matrix become unitary, $r^\dagger r = r’^\dagger r’ = 1$.</p>
<p>To see whether this is possible at all, we first have to understand the constraints that time-reversal symmetry imposes on $S$.</p>
<h2 id="Scattering-matrices-with-time-reversal-symmetry"><a href="#Scattering-matrices-with-time-reversal-symmetry" class="headerlink" title="Scattering matrices with time-reversal symmetry"></a>Scattering matrices with time-reversal symmetry</h2><p>Let’s recall some basic facts about time-reversal symmetry, which we already studied in the first week. Time-reversal symmetry has an antiunitary operator $\mathcal{T}$ which commutes with the Hamiltonian. Being antiunitary, $\mathcal{T}$ may come in two flavors - either $\mathcal{T}^2=1$ or $\mathcal{T}^2=-1$. The first case applies to systems with no or integer spin, such that $\mathcal{T}=\mathcal{K}$ in the simplest case, where $\mathcal{K}$ is the complex conjugation operator. The second case applies to systems with half-integer spin, and in the simplest case we have $\mathcal{T}=i\sigma_y\mathcal{K}$.</p>
<p>Let’s apply the time-reversal operator to our scattering states. We get</p>
<p>$$<br>\mathcal{T}\left|\Psi,\textrm{L}\right\rangle = \sum_{n=1}^N \alpha^<em>_{n,\textrm{L}},\mathcal{T}\left|n,\textrm{L}\right\rangle + \beta^</em><em>{n,\textrm{L}},\mathcal{T}^2\left|n,\textrm{L}\right\rangle,,<br>$$<br>$$<br>\mathcal{T}\left|\Psi,\textrm{R}\right\rangle = \sum</em>{n=1}^N \alpha^<em>_{n,\textrm{R}},\mathcal{T}\left|n,\textrm{R}\right\rangle + \beta^</em>_{n,\textrm{R}},\mathcal{T}^2\left|n,\textrm{R}\right\rangle,.<br>$$</p>
<p>Now, since time-reversal symmetry does not change the energy of a state, $\mathcal{T}\left|\Psi,\textrm{R}\right\rangle$ and $\mathcal{T}\left|\Psi,\textrm{L}\right\rangle$ are scattering states with the same energy as $\left|\Psi,\textrm{R}\right\rangle$ and $\left|\Psi,\textrm{L}\right\rangle$. Hence, the coefficients of incoming and outgoing modes are still related by the same scattering matrix $S$ as before. Note, however, that applying $\mathcal{T}$ exchanged the role of the $\alpha$’s and $\beta$’s, such that the $\alpha$’s now correspond to outgoing states and the $\beta$’s to incoming states. Hence, we have</p>
<p>$$<br> S\mathcal{T}^2 \begin{pmatrix}\beta^<em>_\textrm{L} \ \beta^</em>_\textrm{R} \end{pmatrix} = \begin{pmatrix} \alpha^<em>_\textrm{L} \ \alpha^</em>_\textrm{R} \end{pmatrix},.<br>$$</p>
<p>Multiplying both sides by $\mathcal{T}^2S^\dagger$ and taking the complex conjugate gives</p>
<p>$$<br>\begin{pmatrix} \beta_\textrm{L} \ \beta_\textrm{R} \end{pmatrix} = \mathcal{T}^2,S^T  \begin{pmatrix} \alpha_\textrm{L} \ \alpha_\textrm{R} \end{pmatrix}.<br>$$</p>
<p>By comparing this equation with the one a few lines above, we finally obtain</p>
<p>$$<br>S = \mathcal{T}^2 S^T.<br>$$</p>
<p>So if $\mathcal{T}^2=1$, the scattering matrix is symmetric ($S=S^T$), while if $\mathcal{T}^2=-1$, it is antisymmetric ($S=-S^T$).</p>
<p>What does this imply if we try to set $t=t’=0$?</p>
<p>If $S=S^T$, it turns out there is really nothing special we can tell. However, if $S=-S^T$ and $t=t’=0$, the $N\times N$ reflection matrix must be both unitary, $r^\dagger r=1$, and antisymmetric, $r=-r^T$.</p>
<p>If $N$ is odd, this isn’t possible at all, since any odd-dimensional antisymmetric matrix <a href="https://en.wikipedia.org/wiki/Skew-symmetric_matrix#Spectral_theory">must have</a> a single zero eigenvalue, while unitary matrices only have eigenvalues with unit norm!</p>
<p>We are forced to conclude that it is impossible to have $r$ unitary, and therefore it is impossible to have $t=0$ in this case. Furthermore, this zero eigenvalue of $r$ means that there is always a single mode that is transmitted with unit probability.</p>
<p>This is the discovery that Charles Kane described in the introductory video. We can quickly check it by randomly selecting an antisymmetric scattering matrix with odd $N$, like the following one with $N=3$,</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = <span class="number">3</span></span><br><span class="line">np.random.seed(<span class="number">12</span>)</span><br><span class="line">S = kwant.rmt.circular(N * <span class="number">2</span>, sym=<span class="string">&quot;AII&quot;</span>)</span><br><span class="line"></span><br><span class="line">pprint_matrix(S)</span><br></pre></td></tr></table></figure>

<p>and looking at the eigenvalues of $r^\dagger r$ and $t^\dagger t$:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = S[:N, :N]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reflection eigenvalues&quot;</span>)</span><br><span class="line">pprint_matrix(np.linalg.eigvalsh(r @ r.T.conj()))</span><br><span class="line"></span><br><span class="line">t = S[:N, N:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Transmission eigenvalues&quot;</span>)</span><br><span class="line">pprint_matrix(np.linalg.eigvalsh(t @ t.T.conj())[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>We conclude that if $\mathcal{T}^2=-1$ and the number of edge states going in one direction is odd, they cannot be gapped out, and the system is topological. On the other hand, if there is an even number of such edge states, they can be gapped out. Since these are the only two options, the integer invariant of a Chern insulator is reduced to a $\pm 1$ invariant in the presence of time reversal symmetry. These topologically protected, counterpropagating edge states are often referred to as <strong>helical edge states</strong>.</p>
</blockquote>
<h1 id="Helical-edge-states-are-Kramers-pairs"><a href="#Helical-edge-states-are-Kramers-pairs" class="headerlink" title="Helical edge states are Kramers pairs"></a>Helical edge states are Kramers pairs</h1><p>You might ask yourself what makes $\mathcal{T}^2=-1$ special, leading to the topological protection of the helical edge states.</p>
<p>As was mentioned in the first week, if $\mathcal{T}^2=-1$ then Kramers’ theorem applies. Kramers’ theorem tells us that given an eigenstate $|\Psi\rangle$ of the Hamiltonian with energy $E$, its time-reversed partner $|\Psi_\mathcal{T}\rangle\equiv\mathcal{T}|\Psi\rangle$ has the same energy, and the two states are orthogonal, $\langle \Psi | \Psi_\mathcal{T}\rangle=0$. These two states form a so-called <strong>Kramers pair</strong>. As we already know, this leads to the fact that Hamiltonians with spinful time-reversal symmetry have two-fold degenerate energy levels - <strong>Kramers degeneracy</strong>.</p>
<p>Now, the two counterpropagating helical modes are time-reversed partners of each other, so they form precisely such a Kramers pair. The condition $\langle \Psi | \Psi_\mathcal{T}\rangle=0$ implies that it is impossible to introduce any backscattering between the two states, unless we break time-reversal symmetry. This is the origin of the unit transmission and of the topological protection of helical edge states.</p>
<p>To gain a more intuitive understanding of this fact at a more microscopic level, we can assume that the projection of the electrons’ spin along a given axis is conserved, say the axis $z$ perpendicular to the plane. Then at the edge you have, say, a right-moving mode with spin up and a left-moving mode with spin down, and no other modes if $N=1$. Let’s draw again the picture of a helical edge state entering the disordered region:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/spin_flip.svg" alt></p>
<p>Thus, an electron moving to the right must have spin up by assumption. In order to be reflected, its spin must also be flipped.  However, this spin-flip scattering process is forbidden, and again we conclude that the electron is transmitted with probability one.</p>
<p>In the case $\mathcal{T}^2=1$, there is no Kramers’ theorem. As a consequence, even though you can construct models which have counterpropagating edge states, you will find that they have no topological protection and can be gapped out without breaking the time-reversal symmetry.</p>
<h1 id="The-quantum-spin-Hall-effect"><a href="#The-quantum-spin-Hall-effect" class="headerlink" title="The quantum spin Hall effect"></a>The quantum spin Hall effect</h1><p>There is no really precise name for the 2D topological insulator with time-reversal symmetry. It is often called “$\mathbb{Z}_2$ topological insulator.” However, this simply indicates that there are only two values of the topological invariant, and so it isn’t a very specific name.</p>
<p>The most commonly used name for this system is “quantum spin Hall insulator.” To understand why, let’s analyse a Hall bar made of such a non-trivial insulator. We will only need a Hall bar with four terminals, as shown below:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_hallbar.svg" alt></p>
<p>We have a finite voltage applied to terminal 1, so electrons are injected into the system from there. You can see that because of the helical edge states, there are as many modes connecting terminal 1 to terminal 3 as there are to terminal 4. A moment of thought, or otherwise a quick calculation, should convince you that in this case there is no net current flowing orthogonal to the applied voltage. The Hall conductance is zero, which is the expected result if time-reversal symmetry is preserved, as it is in our system.</p>
<p>However, counterpropagating edge states have to have exactly opposite spin due to Kramers degeneracy. This means that there may be a net spin current across the sample, orthogonal to the applied voltage.</p>
<p>In particular, let’s again make the simple assumption that the spin projection along some axis is conserved. Then, in the figure above, all modes colored in red have spin up, and all modes colored in blue have spin down. So terminal 1 distributes electrons coming out of it according to their spin: all electrons with spin up end up in terminal 4, and all those with spin down in terminal 3. The system has a quantized spin current between terminals 3 and 4, hence the name “quantum spin Hall effect”.</p>
<p>However, the quantized spin Hall current is not a general property of a quantum spin Hall insulator. Here, it arises because we have combined time reversal symmetry with a spin conservation law, and as we learned in the first week, conservation laws are boring from a topological point of view.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider the simple case where spin is conserved. &quot;</span></span><br><span class="line">    <span class="string">&quot;In the quantum spin Hall bar system above, what happens if, instead of applying a voltage between terminals 1 and 2, &quot;</span></span><br><span class="line">    <span class="string">&quot;you manage to apply a *spin-polarized* current between terminals 1 and 2?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The system will develop an opposite spin-polarized current to compensate the effect.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A spin-polarized current will develop between terminals 3 and 4.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A voltage difference will develop between terminals 3 and 4.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is impossible to apply such a current unless the bulk gap closes.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The spin-polarized current will create an electron population imbalance between terminals 3 and 4. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence, similar to the Hall effect, a voltage will develop orthogonal to the current.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="A-model-for-the-quantum-spin-Hall-insulator"><a href="#A-model-for-the-quantum-spin-Hall-insulator" class="headerlink" title="A model for the quantum spin Hall insulator"></a>A model for the quantum spin Hall insulator</h1><p>There is an important model which can be used to describe quantum spin Hall insulators, known as the <strong>Bernevig-Hughes-Zhang model</strong> or, in short, BHZ model. In essence, this model is equivalent to two copies of the Chern insulator Hamiltonian on the square lattice that we studied in the fourth week.</p>
<p>The BHZ Hamiltonian takes the form</p>
<p>$$<br>H_\textrm{BHZ}(\mathbf{k}) = \begin{pmatrix} h(\mathbf{k}) &amp; 0 \ 0 &amp; h^*(-\mathbf{k}) \end{pmatrix},,<br>$$</p>
<p>with</p>
<p>$$<br>h(\mathbf{k}) = \epsilon(\mathbf{k}) + \mathbf{d}(\mathbf{k})\cdot \pmb{\sigma},.<br>$$</p>
<p>Here $\pmb\sigma = (\sigma_x, \sigma_y, \sigma_z)$ is a vector of Pauli matrices acting on the electron/hole degree of freedom (the original two bands of the Chern insulator), $\epsilon(\mathbf{k}) = C - D(k_x^2+k_y^2)$, the vector $\mathbf{d} = [A k_x, -A k_y, M(\mathbf{k})]$, and<br>$M(\mathbf{k}) = M - B(k_x^2+k_y^2)$.</p>
<p>You can see that it is basically two copies of the massive Dirac Hamiltonian we used to study Chern insulators. In particular, there is a linear coupling in momentum between the holes and the electrons. The gap in the Hamiltonian is given by the term $M(\mathbf{k})$, a momentum-dependent effective mass.</p>
<p>By changing the sign of $M$ from negative to positive, you get a gap closing at $\mathbf{k}=\pmb{0}$:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(Bz=<span class="number">0.0</span>, **bhz_parameters[<span class="string">&quot;topo2&quot;</span>])</span><br><span class="line">syst = bhz(w=<span class="literal">None</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;k_x&quot;</span>: k, <span class="string">&quot;k_y&quot;</span>: k, <span class="string">&quot;title&quot;</span>: title&#125;</span><br><span class="line">Ms = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.M: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>This gap closing turns your trivial insulator into a topologically non-trivial quantum spin Hall insulator.</p>
<p>In the rest of this lecture, we will use the BHZ model as a toy-model to illustrate the behavior of a quantum spin Hall insulator using numerical examples. The BHZ model, however, is more than a toy-model, and it can be used to capture the behavior of some real semiconducting materials. For this reason, the BHZ model will be a main protagonist in the next chapter, where we will discuss real materials and the experimental evidence for the quantum spin Hall effect.</p>
<h1 id="Alternative-point-of-view-fermion-parity-pump"><a href="#Alternative-point-of-view-fermion-parity-pump" class="headerlink" title="Alternative point of view: fermion parity pump"></a>Alternative point of view: fermion parity pump</h1><p>In the previous cases of the Kitaev chain and the quantum Hall effect, the bulk topological invariant that we eventually obtained was characterized by the response to some adiabatic experiment.</p>
<p>Since the time-reversal invariant topological insulator is two dimensional like a quantum Hall system, it is reasonable to put the system in a Corbino geometry and change the flux through the system, creating an azimuthal electric field:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_corbino.svg" alt></p>
<p>However, because of time-reversal symmetry, the system is forbidden from having a Hall conductance and therefore there cannot be any charge transfer between the two edges of the disk. For instance, if we consider two copies of the Haldane model with opposite spin, there will be two quantum Hall pumps working in opposite directions (one transferring charge from the inner edge to the outer edge, the other one from the outer edge to the inner one). So the net charge transferred is zero.</p>
<p>Because the two pumps act on electrons with opposite spin, you might be tempted to define a spin current, which would flow in response to the electric field, orthogonal to it. However, as we just discussed, the spin along a given direction may not be conserved, so generally this is not a good way to define a robust pumping effect.</p>
<p>To understand what exactly happens in the pumping process, let’s look at the energy spectrum of the edge states for the BHZ model in the cylinder geometry. As we discussed in the quantum Hall lectures, the cylinder geometry is really equivalent to the Corbino disk, except that it is easier to study.</p>
<p>You also learned that in a cylinder of finite circumference $L$, the momenta of the allowed edge states are quantized at values determined by the flux.</p>
<p>To make things more simple, you may actually imagine that the circumference of the cylinder is just a single unit cell long. We then have only one allowed value of the momentum $k$ along the edge, which is exactly proportional to the flux threaded through the cylinder, $k = 2\pi \Phi/\Phi_0$.</p>
<p>So let’s look at the energy spectrum of a cylinder as a function of $k$ (or equivalently $\Phi$), and compare a cylinder in the quantum spin Hall phase with a cylinder in the trivial insulating phase.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">half_pi_ticks = [(<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi / <span class="number">2</span>, <span class="string">r&quot;$\pi/2$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">style = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(<span class="number">0</span>, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: half_pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>),</span><br><span class="line">    <span class="string">&quot;xlims&quot;</span>: [<span class="number">0</span>, np.pi],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syst = bhz(<span class="number">20</span>)</span><br><span class="line">p1 = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;topo&quot;</span>])</span><br><span class="line">p2 = SimpleNamespace(Bz=<span class="number">0</span>, **bhz_parameters[<span class="string">&quot;triv&quot;</span>])</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p1, **style).relabel(<span class="string">&quot;Topological&quot;</span>) * holoviews.HLine(<span class="number">0</span>)</span><br><span class="line">    + spectrum(syst, p2, **style).relabel(<span class="string">&quot;Trivial&quot;</span>) * holoviews.HLine(<span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In both cases you see that at $k=0$ there are isolated pairs of states with degenerate energies, between the valence and conduction bands. The Fermi energy is set at $E=0$, in the middle of the gap between conduction and valence bands. These states are the Kramers pairs at the edges - one pair for the topological case, two for the trivial case.<br>You also see the splitting of Kramers pairs as soon as $k$ goes away from zero. This is because $k = 0$ is a time-reversal invariant point, a point in momentum space that is mapped to itself by time-reversal symmetry.</p>
<p>The plot ends at $k=\pi$ (that is, $\Phi=h/2e$), which is another time-reversal invariant point. Indeed, time-reversal symmetry sends $\Phi\to-\Phi$, but for $\Phi=h/2e$ this corresponds exactly to adding or subtracting a flux quantum. Hence, all the physical properties of the system remain unchanged under the action of time-reversal for this value of the flux. And indeed you can see that all levels meet again and form Kramers pairs.</p>
<blockquote>
<p>We now see an interesting difference though. In the topological case, the Kramers pairs at $k=\pi$ are not the same as those at $k=0$. In the trivial case however, the pairs are the same. As a consequence, in the topological case there is an odd number of levels crossing zero-energy, while in the trivial cases there is an even number of them. Therefore changing the flux by $h/2e$ in the topological case changes the fermion parity at the edge, while it does nothing in the trivial case. We have thus obtained a <strong>fermion parity pump</strong>.</p>
</blockquote>
<p>Strangely, this reminds us of the topological superconducting ring that we studied in the second week of the course. There we also had a fermion parity change in response to a flux. It turns out that this is not a coincidence, as we will see when we discuss how to realize topological superconductors using topological insulators.</p>
<p>You may appreciate that our argument did not rely on spin being a good quantum number, or on any other detail of the system, but only on Kramers theorem. And in fact it holds very generally. Deforming the dispersion of Kramers pairs does not break the fermion parity pump, as long as the way states combine to form Kramers pairs at $k=0$ and $k=\pi$ is unchanged.</p>
<h1 id="Pumping-expression-for-the-topological-invariant"><a href="#Pumping-expression-for-the-topological-invariant" class="headerlink" title="Pumping expression for the topological invariant"></a>Pumping expression for the topological invariant</h1><p>At this point, following the same path we followed for Chern insulator, we would like to find an expression for a topological bulk invariant which characterizes the quantum spin Hall effect.</p>
<p>However, we now encounter a problem: for complicated topological systems in higher dimensions, it is hard to evaluate the topological invariant. We know when the system is topological, and we know which values the topological invariant can take (for now just two: trivial and non-trivial), but it becomes hard to find and evaluate the correct expression for it.</p>
<p>We were able to calculate the Chern number using Berry curvature. The analogous computation for the topological invariant of the quantum spin Hall insulator is too involved, and so we will not present it in our course.</p>
<p>The scattering formulation of the topological invariant, however, is easy to implement and utilize. We can apply it by taking the cylinder threaded by a flux and connecting it to leads in the following geometry:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_pumping.svg" alt></p>
<p>Let us now study what happens when we try to inject electrons into the edges of the cylinder. Since we have “rolled-up” our system along one direction, we have a one-dimensional scattering problem. Similar to a Thouless pump, we expect to be able to find a topological signature in the reflection matrix $r$ for an electron coming in from the left.</p>
<p>As we vary the flux, the reflection properties may change, leading to a $k$-dependent reflection matrix $r(k)$. We assume that the bulk is gapped, so transmission is suppressed, and therefore $r$ is unitary. Moreover, at $k=0$ and $k=\pi$, $r$ is also antisymmetric because of time-reversal symmetry.</p>
<p>It turns out that the topological invariant has a relatively simple form:</p>
<p>$$<br>Q = \frac{\textrm{Pf}[r(0)]}{\textrm{Pf}[r(\pi)]}\sqrt{\frac{\det[r(\pi)]}{\det[r(0)]}}<br>$$</p>
<p>This expression relies on the antisymmetry of $r$ at $k=0$ and $k=\pi$. At these values we can compute the Pfaffian. The eigenvalues of $r$ come in pairs of opposite sign $e^{i\alpha}$, $-e^{i\alpha}$, which correspond to the Kramers pairs formed by the helical edge states. This means we can calculate the Pfaffian at these momentum values, but its phase is arbitrary.</p>
<p>We can however compute $\sqrt{\det[r(k)]}$ for all the intermediate values of $k$. To get rid of the sign ambiguity of the square root, we require that $\sqrt{\det[r(k)]}$ is continuous for all $k$, and that $\sqrt{\det[r(0)]} = \textrm{Pf}[r(0)]$. This only gives a unique answer if $\det r \neq 0$ for all $k$.</p>
<p>This gives us a curve which starts at $\textrm{Pf}[r(0)]$ and ends at either $\textrm{Pf}[r(\pi)]$ or $-\textrm{Pf}[r(\pi)]$. These two cases distinguish the trivial and nontrivial systems.</p>
<p>In the plot below, we show how this trajectory changes for our cylinder geometry as the BHZ model is driven through the topological phase transition. In the right panel, the green dots give you the phase of $\textrm{Pf}[r(0)]$ and $\textrm{Pf}[r(\pi)]$, and the blue line the phase of $\det[r(k)]$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(a=<span class="number">1.0</span>, Bz=<span class="number">0.0</span>, ky=<span class="literal">None</span>, **bhz_parameters[<span class="string">&quot;topo2&quot;</span>])</span><br><span class="line">syst = bhz(w=<span class="literal">None</span>)</span><br><span class="line">scat_syst = make_scatter_sys()</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;k_x&quot;</span>: k, <span class="string">&quot;k_y&quot;</span>: k, <span class="string">&quot;title&quot;</span>: title&#125;</span><br><span class="line">Ms = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">(</span><br><span class="line">    holoviews.HoloMap(&#123;p.M: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>])</span><br><span class="line">    + holoviews.HoloMap(</span><br><span class="line">        &#123;p.M: scattering_det_pfaff(scat_syst, p) <span class="keyword">for</span> p.M <span class="keyword">in</span> Ms&#125;, kdims=[<span class="string">r&quot;$M$&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>We now have a quantity equal to $\pm 1$, which cannot change continuously unless there’s a gap closing (when there’s a gap closing, $\det r$ becomes equal to $0$). It is relatively hard to prove that this invariant counts the pumping of fermion parity, but if you’re interested, check out this paper:</p>
<ul>
<li>arXiv:1107.2215</li>
</ul>
<p>From reading the paper, or just from the above discussion, you see that it takes a lot of effort to derive an explicit expression for a topological invariant. Even though it is a hard task, sometimes one can guess the right result (one of us was indeed able to guess the above expression for $Q$ before it was known). Other times, one can invoke some simplification and obtain some important insight. This is what we will do in the next unit.</p>
<h1 id="A-simplification-inversion-symmetry"><a href="#A-simplification-inversion-symmetry" class="headerlink" title="A simplification: inversion symmetry"></a>A simplification: inversion symmetry</h1><p>As just mentioned, topological invariants in higher dimensions are often difficult to write down and evaluate in the general case. Luckily, in the presence of <a href="http://en.wikipedia.org/wiki/Parity_%28physics%29#Effect_of_spatial_inversion_on_some_variables_of_classical_physics">inversion symmetry</a> - which reverses the lattice coordinates with respect to a symmetry center - the topological condition can be stated in rather simple terms.<br>This turns out to be quite useful to describe most topological materials, which happen to have crystal structure with inversion symmetry.</p>
<p>From our earlier discussion, we know that a system is a time-reversal invariant topological insulator if it has an odd number of helical edge states. We will now see how we can find an expression for the bulk topological invariant, using inversion symmetry and bulk-boundary correspondence.</p>
<p>So let’s consider a two-dimensional Bloch Hamiltonian $H(\mathbf{k})$ with both inversion and time-reversal symmetry. Inversion symmetry has a unitary operator $\mathcal{P}$ which maps $\mathbf{k}\rightarrow -\mathbf{k}$ and satisfies $\mathcal{P}^2=1$. If we have both inversion symmetry $\mathcal{P}$ and time-reversal $\mathcal{T}$, we get an anti-unitary symmetry $\mathcal{T}\otimes\mathcal{P}$, which preserves $\mathbf{k}$ and squares to $-1$.</p>
<blockquote>
<p>These are precisely the conditions needed for Kramers theorem to apply - only this time, every point $\mathbf{k}$ is mapped to itself because inversion symmetry is included as well. We conclude that every eigenstate at any $\mathbf{k}$ is two-fold degenerate.  We may label these two eigenstates with an index $\sigma=\pm$. If spin is a good quantum number, $\sigma$ labels two states with opposite spin. However, this may not be the case so we will just refer to it as a pseudospin associated with Kramers degeneracy.</p>
</blockquote>
<p>Note that the simplification obtained by adding inversion symmetry is that the spectrum is two-fold degenerate at all $\mathbf{k}$ in the Brillouin zone. Time-reversal symmetry alone cannot guarantee that, because it maps $\mathbf{k}$ to $-\mathbf{k}$.</p>
<p>Our next step is to calculate the effective description of helical edge states at a domain wall between a topological phase and a non-topological phase. This is something we already know how to do thanks to our experience with domain walls in the Kitaev chain and in Chern insulators. It will give us insight into the topological transition and the bulk topological invariant.</p>
<h2 id="Study-of-a-domain-wall"><a href="#Study-of-a-domain-wall" class="headerlink" title="Study of a domain wall"></a>Study of a domain wall</h2><p>Let’s imagine that the helical edge runs along the $y$ direction, and that the domain wall is described by a mass profile $M(x)$ along the $x$ direction, which is zero at the domain wall:</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_domain_wall.svg" alt></p>
<p>In this configuration, $k_y$ is still a good quantum number, and we can study the energy dispersion of states bound to the domain wall as a function of $k_y$. If the edge is gapless there must be a momentum, say $\bar{k}_y$, where counterpropagating modes cross at the Fermi level. Let’s fix $k_y=\bar{k}_y$, and write down an effective Hamiltonian for the motion transverse to the domain wall.</p>
<p>We have in total four states, distinguished by two quantum numbers: their direction of propagation, which we denote with $b=\pm$, and their pseudospin $\sigma$. Inversion symmetry $\mathcal{P}$ flips the direction of propagation $b$, while the pseudo-spin degeneracy $\sigma$ is related to the combination of inversion and time-reversal $\mathcal{T}\otimes\mathcal{P}.$ To lowest order in the momentum $k_x$ perpendicular to the domain wall, the states at the transition point disperse linearly with $k_x$, and are two-fold degenerate. In fact, as we noted from Kramers degeneracy, the Hamiltonian must be chosen such that none of the terms break the two-fold degeneracy associated with the pseudospin $\sigma$. This means that the domain wall cannot couple states with different values of $\sigma$, which leads us to an effective Hamiltonian</p>
<p>$$<br>H(\bar{k}<em>y)=\sum</em>{\sigma,b},k_x b,|b,\sigma\rangle\langle b,\sigma|+M(x)(|+,\sigma\rangle\langle -,\sigma|+h.c.)],.<br>$$</p>
<p>where the factor $b$ is odd under time-reversal symmetry so that $k_x b$ is even under time-reversal symmetry.</p>
<p>We are back to an old friend, the one dimensional Dirac Hamiltonian with a position-dependent mass $M(x)$. Adapting our arguments from the first week, we can immediately say that the domain-wall hosts a pair of zero modes only if $M(x)$ changes sign.</p>
<p>As interesting as this sounds, we must remember that this pair of zero modes is present for $k_y=\bar{k}_y$. Because of inversion symmetry, there is necessarily an identical pair at $-\bar{k}_y$. So we get a total of 4 degenerate domain wall states from this type of gap closing - an even number of pairs. As we know form before, such pairs of gap closings do not affect the value of the topological invariant on the two sides of the domain walls. To change the value of the topological invariant, we would need an odd number of pairs crossing zero energy.</p>
<p>However, there are points in momentum space which are mapped onto each other by time-reversal symmetry, up to a reciprocal lattice vector. For these values, the above counting does not hold. People refer to these momenta as “time-reversal invariant momenta” or TRIMs. In the simple case of a square Brillouin zone, they are the points $(k_x, k_y) = (0,0), (0,\pi), (\pi,0),(\pi,\pi)$.</p>
<p>Since TRIMs are their own time-reversed partners, it is still possible for a gap closing at $\bar{k}_y=0$ or $\bar{k}_y=\pi$ to change the topology of the system. In this case, our doubling problem in momentum space is solved, and we can produce just one pair of edge modes at the domain wall. If we move the momentum $k_y$ slightly away from $\bar{k}_y$, the degenerate pair of modes splits linearly to form a single helical mode that produces a non-trivial fermion parity pump.</p>
<p>To make the distinction clear between a gap closing at a finite $\bar{k}_y$ and at a time-reversal invariant point, let’s draw a sketch of the edge dispersion in the two cases.</p>
<p><img src="/2021/01/07/src/w5_qshe/fermion_parity_pump/qsh_edge_dispersions.svg" alt></p>
<p>Kramers pairs are colored in red and blue and have the same linestyle. On the left, you have two pairs of Kramers partners, which however never meet at zero energy. On the right, there is a single Kramers pair meeting at zero energy. This argument summarizes the simplification that inversion symmetry brings to time-reversal invariant topological insulators.</p>
<blockquote>
<p>We can determine the topological invariant for the inversion symmetric topological insulators entirely from the bulk Hamiltonian at time-reversal invariant momenta, since gap closings at any other point can only add domain wall states in multiples of four.</p>
</blockquote>
<p>Does this mean that any gap closing at a TRIM is a topological transition? The states $|b,\sigma\rangle$ are Bloch states with definite values of $k_y$. We are considering a time-reversal invariant value of $k_y$, and since $b$ is flipped by inversion symmetry, we can apply inversion symmetry to conclude that the states $|\pm,\sigma\rangle$<br>transform into each other under inversion i.e. $\mathcal{P}|\pm,\sigma\rangle= |\mp,\sigma\rangle$. By combining these states<br>into symmetric and anti-symmetric superpositions</p>
<p>$$|e,\sigma\rangle=\frac{1}{\sqrt{2}}\left[|+,\sigma\rangle, + ,|-,\sigma\rangle\right],,\quad |o,\sigma\rangle=\frac{i}{\sqrt{2}}\left[|+,\sigma\rangle, - ,|-,\sigma\rangle\right],$$</p>
<p>we obtain states that are even ($e$) and odd ($o$) under inversion—they are eigenstates of $\mathcal{P}$ with eigenvalue $+1$ or $-1$. They are also eigenstates of $M$ at $k_x=k_y=0$. The factor of $i$ in $|o,\sigma\rangle$ ensures a consistency under the time-reversal transformation, such that $\mathcal{T}|(e,o),\sigma\rangle=\sigma|(e,o),\sigma\rangle$.</p>
<p>Every gap closing at a TRIM is an even parity state crossing with an odd parity state. The effective Hamiltonian of such a gap closing must also add an extra Kramers pair of states at the domain wall, and therefore indeed every gap closing at a TRIM is a topological phase transition, while gap closings at all the other momenta are unimportant due to inversion symmetry.</p>
<p>This leads to a simplified way of computing a topological invariant of quantum spin Hall insulators with inversion symmetry:</p>
<blockquote>
<p>To compute a bulk topological invariant for a two-dimensional topological state with time reversal and inversion symmetry we need to keep track of the parity $P$ of all the occupied eigenstates of $H(\mathbf{k})$ at the different time-reversal invariant momenta in the Brillouin zone. We may write such a bulk topological invariant as a product</p>
</blockquote>
<blockquote>
<p>$$Q=\prod_{n,j}P_{n,j},,$$</p>
</blockquote>
<blockquote>
<p>where $P_{n,j}$ is the parity, $n$ runs over the occupied bands of $H(\mathbf{k})$ and $j$ over the time-reversal invariant momenta.</p>
</blockquote>
<p>You might now worry whether this definition of the invariant relied on having a smooth domain wall. From the fermion parity pump argument, bulk-edge correspondence implies that the bulk must be topologically non-trivial once you have edge states for any termination. Reversing this argument, we know that once we have a topologically non-trivial bulk, we must have helical edge states for any termination.</p>
<p>Thus, by looking at smooth domain walls we are able to establish a connection between the topological invariant in the presence of time-reversal and inversion symmetry, and the existence of helical edge states and fermion-parity pumping that characterizes the two dimensional topological insulator.</p>
<p>As a bonus, thanks to the previous arguments we can begin to understand how to look for two-dimensional topological insulators among real materials, or how to create them. The main idea is to generate a “band-inversion” between an even and an odd parity band at a TRIM.</p>
<p>Such a band inversion is not impossible to achieve in real materials, and can be captured using the BHZ model. But let’s leave this to the next lecture.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What is the value of the parity invariant $Q$ if you stack together two quantum spin Hall systems  &quot;</span></span><br><span class="line">    <span class="string">&quot;in the topological phase (i.e., both with $Q=-1$)?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The system has edge states and is therefore topologically non-trivial.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The total number of odd parity occupied orbitals must be even, so you get $Q=1$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It depends on whether the helical states in the two layers have same &quot;</span></span><br><span class="line">    <span class="string">&quot;or opposite spin for a given direction.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The invariant depends on the number of edge Dirac points at $k$ away from 0.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Both layers have $Q=-1$ and hence an odd number of odd parity orbitals. Therefore, by combining the layers  &quot;</span></span><br><span class="line">    <span class="string">&quot;we get an even number of odd parity orbitals. Hence $Q$, which is the parity of odd parity orbitals must be &quot;</span></span><br><span class="line">    <span class="string">&quot;$Q=1$.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;ft9ppqqLhH4&quot;</span>, src_location=<span class="string">&quot;5.1-summary&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;QSHE - theory&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w4_haldane/w4_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-more-Chern-insulators"><a href="#Simulations-more-Chern-insulators" class="headerlink" title="Simulations: more Chern insulators"></a>Simulations: more Chern insulators</h1><p>As usual, start by grabbing the notebooks of this week (<code>w4_haldane</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<h3 id="Yet-another-Chern-insulator"><a href="#Yet-another-Chern-insulator" class="headerlink" title="Yet another Chern insulator"></a>Yet another Chern insulator</h3><p>One more tight binding of a Chern insulator that you can encounter in the wild is a regular square lattice with half a flux quantum of magnetic field per unit cell. If you made the Hofstadter butterfly assignment from the previous week, it’s just in the middle of the butterfly. Half a flux quantum per unit cell means that the hoppings in one direction are purely imaginary, and different rows have alternating signs</p>
<p>$$t_y = t,\quad t_x = (-1)^y it.$$</p>
<p>This model has a dispersion very similar to graphene: it has two Dirac cones without a gap. Like graphene it also has two sites per unit cell, and sublattice symmetry.</p>
<p>Simulate this model. Think which parameters you need to add to it to make it a Chern insulator. Check that the edge states appear, and calculate the Berry curvature.</p>
<h3 id="Back-to-the-winding"><a href="#Back-to-the-winding" class="headerlink" title="Back to the winding"></a>Back to the winding</h3><p>Integration of Berry curvature is just another way to calculate the same quantity: the topological invariant. Verify that the winding of reflection phase gives the same results. To do that, make the pumping geometry out of a Chern insulator rolled into a cylinder, thread flux through it, and check that the topological invariant obtained through Berry curvature integration is the same as that obtained from winding.</p>
<p>We know that Berry curvature is concentrated close to the Dirac points. Do you notice anything similar for the pumped charge?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Chern insulators&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1012-4723"><a href="#arXiv-1012-4723" class="headerlink" title="arXiv:1012.4723"></a>arXiv:1012.4723</h3><p><strong>Hint:</strong> The hunt for flat bands.</p>
<h3 id="arXiv-1409-6715"><a href="#arXiv-1409-6715" class="headerlink" title="arXiv:1409.6715"></a>arXiv:1409.6715</h3><p><strong>Hint:</strong> Making a Chern insulator more like quantum Hall effect.</p>
<h3 id="arXiv-1208-4579"><a href="#arXiv-1208-4579" class="headerlink" title="arXiv:1208.4579"></a>arXiv:1208.4579</h3><p><strong>Hint:</strong> A Chern insulator without lattice.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Chern insulators&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w4_haldane/haldane_model/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> scipy</span><br><span class="line"></span><br><span class="line">%output size=<span class="number">150</span> fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haldane</span>(<span class="params">w=<span class="number">20</span>, boundary=<span class="string">&quot;zigzag&quot;</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape_zigzag</span>(<span class="params">pos</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0.5</span> / np.sqrt(<span class="number">3</span>) - <span class="number">0.1</span> &lt;= pos[<span class="number">1</span>] &lt; np.sqrt(<span class="number">3</span>) * w / <span class="number">2</span> + <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape_armchair</span>(<span class="params">pos</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> &lt;= pos[<span class="number">0</span>] &lt; w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> site.family == a:</span><br><span class="line">            <span class="keyword">return</span> p.m</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -p.m</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nn_hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.t</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nnn_hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1j</span> * p.t_2</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.honeycomb()</span><br><span class="line">    a, b = lat.sublattices</span><br><span class="line">    nnn_hoppings_a = (((-<span class="number">1</span>, <span class="number">0</span>), a, a), ((<span class="number">0</span>, <span class="number">1</span>), a, a), ((<span class="number">1</span>, -<span class="number">1</span>), a, a))</span><br><span class="line">    nnn_hoppings_b = (((<span class="number">1</span>, <span class="number">0</span>), b, b), ((<span class="number">0</span>, -<span class="number">1</span>), b, b), ((-<span class="number">1</span>, <span class="number">1</span>), b, b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> boundary == <span class="string">&quot;zigzag&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">        syst[lat.shape(ribbon_shape_zigzag, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">elif</span> boundary == <span class="string">&quot;armchair&quot;</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">0</span>, np.sqrt(<span class="number">3</span>))))</span><br><span class="line">        syst[lat.shape(ribbon_shape_armchair, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[lat.neighbors()] = nn_hopping</span><br><span class="line">    syst[</span><br><span class="line">        [kwant.builder.HoppingKind(*hopping) <span class="keyword">for</span> hopping <span class="keyword">in</span> nnn_hoppings_a]</span><br><span class="line">    ] = nnn_hopping</span><br><span class="line">    syst[</span><br><span class="line">        [kwant.builder.HoppingKind(*hopping) <span class="keyword">for</span> hopping <span class="keyword">in</span> nnn_hoppings_b]</span><br><span class="line">    ] = nnn_hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Qi_Wu_Zhang</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.mu * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0.5j</span> * p.delta * pauli.sy - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1j</span> * p.gamma * pauli.sx - p.gamma * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">    syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">berry_curvature</span>(<span class="params">syst, p, ks, num_filled_bands=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Berry curvature of a system.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    sys : kwant.Builder</span></span><br><span class="line"><span class="string">        A 2D infinite system.</span></span><br><span class="line"><span class="string">    p : SimpleNamespace</span></span><br><span class="line"><span class="string">        The arguments expected by the system.</span></span><br><span class="line"><span class="string">    ks : 1D array-like</span></span><br><span class="line"><span class="string">        Values of momentum grid to be used for Berry curvature calculation.</span></span><br><span class="line"><span class="string">    num_filled_bands : int</span></span><br><span class="line"><span class="string">        The number of filled bands.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    bc : 2D array</span></span><br><span class="line"><span class="string">        Berry curvature on each square in a `ks x ks` grid.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Calculate an array of eigenvectors.</span></span><br><span class="line">    B = np.array(syst.symmetry.periods).T</span><br><span class="line">    A = B @ np.linalg.inv(B.T @ B)</span><br><span class="line"></span><br><span class="line">    syst = kwant.wraparound.wraparound(syst).finalized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">energy</span>(<span class="params">kx, ky</span>):</span></span><br><span class="line">        k = np.array([kx, ky])</span><br><span class="line">        kx, ky = np.linalg.solve(A, k)</span><br><span class="line">        H = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p, k_x=kx, k_y=ky), sparse=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> scipy.linalg.eigh(H)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    vectors = np.array(</span><br><span class="line">        [[energy(kx, ky)[:, :num_filled_bands] <span class="keyword">for</span> kx <span class="keyword">in</span> ks] <span class="keyword">for</span> ky <span class="keyword">in</span> ks]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The actual Berry curvature calculation</span></span><br><span class="line">    vectors_x = np.roll(vectors, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    vectors_xy = np.roll(vectors_x, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    vectors_y = np.roll(vectors, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    shifted_vecs = [vectors, vectors_x, vectors_xy, vectors_y]</span><br><span class="line"></span><br><span class="line">    v_shape = vectors.shape</span><br><span class="line"></span><br><span class="line">    shifted_vecs = [i.reshape(-<span class="number">1</span>, v_shape[-<span class="number">2</span>], v_shape[-<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> shifted_vecs]</span><br><span class="line"></span><br><span class="line">    dets = np.ones(<span class="built_in">len</span>(shifted_vecs[<span class="number">0</span>]), dtype=<span class="built_in">complex</span>)</span><br><span class="line">    <span class="keyword">for</span> vec, shifted <span class="keyword">in</span> <span class="built_in">zip</span>(shifted_vecs, np.roll(shifted_vecs, <span class="number">1</span>, <span class="number">0</span>)):</span><br><span class="line">        dets *= [np.linalg.det(a.T.conj() @ b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(vec, shifted)]</span><br><span class="line">    bc = np.angle(dets).reshape(<span class="built_in">int</span>(np.sqrt(<span class="built_in">len</span>(dets))), -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    bc = (bc + np.pi / <span class="number">2</span>) % (np.pi) - np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_berry_curvature</span>(<span class="params">syst, p, ks=<span class="literal">None</span>, title=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> ks <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ks = np.linspace(-np.pi, np.pi, <span class="number">150</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">    bc = berry_curvature(syst, p, ks)[<span class="number">1</span>:-<span class="number">1</span>, <span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    vmax = <span class="built_in">max</span>(np.<span class="built_in">abs</span>(bc).<span class="built_in">min</span>(), np.<span class="built_in">abs</span>(bc).<span class="built_in">max</span>())</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">&quot;bounds&quot;</span>: (ks.<span class="built_in">min</span>(), ks.<span class="built_in">min</span>(), ks.<span class="built_in">max</span>(), ks.<span class="built_in">max</span>()),</span><br><span class="line">        <span class="string">&quot;kdims&quot;</span>: [<span class="string">r&quot;$k_x$&quot;</span>, <span class="string">r&quot;$k_y$&quot;</span>],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>(title):</span><br><span class="line">        kwargs[<span class="string">&quot;label&quot;</span>] = title(p)</span><br><span class="line"></span><br><span class="line">    plot = &#123;<span class="string">&quot;xticks&quot;</span>: pi_ticks, <span class="string">&quot;yticks&quot;</span>: pi_ticks&#125;</span><br><span class="line">    style = &#123;<span class="string">&quot;clims&quot;</span>: [-vmax, vmax]&#125;</span><br><span class="line">    <span class="keyword">return</span> holoviews.Image(bc, **kwargs).opts(plot=plot, style=style)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$t=&#123;:.2&#125;$, $t_2=&#123;:.2&#125;$, $M=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    <span class="keyword">return</span> title.<span class="built_in">format</span>(p.t, p.t_2, p.m)</span><br></pre></td></tr></table></figure>

<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Duncan Haldane from Princeton University will teach us about an interesting two dimensional toy-model which he <a href="http://faculty.washington.edu/cobden/papers/haldane88.pdf">introduced</a> in 1988, and which has become a prototype for the anomalous quantum Hall effect.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;7nVO4uMm-do&quot;</span>, src_location=<span class="string">&quot;4.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>We will now study the model in detail, starting from the beginning.  Along the way, we will also learn about the Chern number, the bulk topological invariant of a quantum Hall state.</p>
<h1 id="Dirac-cones-in-graphene"><a href="#Dirac-cones-in-graphene" class="headerlink" title="Dirac cones in graphene"></a>Dirac cones in graphene</h1><p>In the last chapter we saw how it is possible to obtain a quantum Hall state by coupling one-dimensional systems. At the end, our recipe was to first obtain a Dirac cone, add a mass term to it and finally to make this mass change sign. Following this recipe we were able to obtain chiral edge states without applying an external magnetic field.</p>
<p>There is a real (and a very important) two-dimensional system which has Dirac cones: <a href="http://en.wikipedia.org/wiki/Graphene">graphene</a>. So in this chapter we will take graphene and make it into a topological system with chiral edge states.</p>
<p>Graphene is a single layer of carbon atoms arranged in a honeycomb lattice. It is a triangular lattice with two atoms per unit cell, type $A$ and type $B$, represented by red and blue sites in the figure:</p>
<p><img src="/2021/01/07/src/w4_haldane/haldane_model/graphene.svg" alt></p>
<p>Hence, the wave function in a unit cell can be written as a vector $(\Psi_A, \Psi_B)^T$ of amplitudes on the two sites $A$ and $B$. Taking a simple tight-binding model where electrons can hop between neighboring sites with hopping strength $t$, one obtains the Bloch Hamiltonian:</p>
<p>$$<br>H_0(\mathbf{k})= \begin{pmatrix} 0 &amp; h(\mathbf{k}) \ h^\dagger(\mathbf{k}) &amp; 0 \end{pmatrix},,<br>$$</p>
<p>with $\mathbf{k}=(k_x, k_y)$ and</p>
<p>$$h(\mathbf{k}) = t_1,\sum_i,\exp,\left(i,\mathbf{k}\cdot\mathbf{a}_i\right),.$$</p>
<p>Here $\mathbf{a}_i$ are the three vectors in the figure, connecting nearest neighbors of the lattice [we set the lattice spacing to one, so that for instance $\mathbf{a}_1=(1,0)$].  Introducing a set of Pauli matrices $\sigma$ which act on the sublattice degree of freedom, we can write the Hamiltonian in a compact form as</p>
<p>$$H_0(\mathbf{k}) = t_1,\sum_i,\left[\sigma_x,\cos(\mathbf{k}\cdot\mathbf{a}_i)-\sigma_y ,\sin(\mathbf{k}\cdot\mathbf{a}_i)\right],.$$</p>
<p>The energy spectrum $E(\mathbf{k}) = \pm ,\left|h(\mathbf{k})\right|$ gives rise to the famous band structure of graphene, with the two bands touching at the six corners of the Brillouin zone:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, t_2=<span class="number">0.0</span>, m=<span class="number">0.0</span>, phi=np.pi / <span class="number">2</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">&quot;infinite&quot;</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">150</span>)</span><br><span class="line">spectrum(syst, p, k_x=k, k_y=k, title=title)</span><br></pre></td></tr></table></figure>

<p>Only two of these six Dirac cones are really distinct, the ones at $\mathbf{K}=(2\pi/3, 2\pi/3\sqrt{3})$ and $\mathbf{K}’=(2\pi/3, -2\pi/3\sqrt{3})$. All the others can be obtained by adding some reciprocal lattice vector to $\mathbf{K}$ and $\mathbf{K}’$.</p>
<h1 id="Discrete-symmetries-of-graphene"><a href="#Discrete-symmetries-of-graphene" class="headerlink" title="Discrete symmetries of graphene"></a>Discrete symmetries of graphene</h1><p>The symmetries of graphene were discussed intensively in the video, so let’s review them.</p>
<p>As we already said in our first week, graphene is the prototype of a system with sublattice symmetry, which makes the Hamiltonian block off-diagonal with respect to the two sublattices. The sublattice symmetry reads</p>
<p>$$\sigma_z,H_0(\mathbf{k}),\sigma_z = -H_0(\mathbf{k}),.$$</p>
<p>Sublattice symmetry is only approximate, and it is consequence of the nearest neighbor tight-binding model. Just like the inversion symmetry mentioned in the video, it protects the Dirac points and needs to be broken in order to open a gap.</p>
<p>In addition to sublattice and inversion symmetry, the honeycomb lattice also has a three-fold rotation symmetry around the center of the unit cell. This symmetry is important to make the Dirac cones appear in the first place, but it will not play a role in all that follows.</p>
<p>Finally, there is time-reversal symmetry, which at the moment is perfectly preserved in our tight-binding model. Since we are not considering the spin degree of freedom of the electrons, the time-reversal symmetry operator in real space is just complex conjugation. In momentum space representation, time-reversal symmetry reads</p>
<p>$$ H_0(\mathbf{k}) = H_0^*(-\mathbf{k}),.$$</p>
<p>It’s important to note that time-reversal symmetry sends $\mathbf{K}$ into $\mathbf{K}’$ and therefore it exchanges the two Dirac cones.</p>
<p>The product of (approximate) sublattice and time-reversal symmetries yields a further discrete symmetry, a particle-hole symmetry $\sigma_z H^*(-\mathbf{k}),\sigma_z = -H_0(\mathbf{k})$.</p>
<h1 id="Making-graphene-topological"><a href="#Making-graphene-topological" class="headerlink" title="Making graphene topological"></a>Making graphene topological</h1><p>Let’s recall that our goal is to make our graphene sheet enter a quantum Hall state, with chiral edge states. The first necessary step is to make the bulk of the system gapped. </p>
<p>How can we open a gap in graphene? The Dirac points are protected by both sublattice (inversion) and time-reversal symmetry. So there are many ways we can think of to open an energy gap at $\mathbf{K}$ and $\mathbf{K}’$.</p>
<h2 id="First-try"><a href="#First-try" class="headerlink" title="First try"></a>First try</h2><p>The easiest way to break sublattice symmetry is to assign an opposite onsite energy $M$ or $-M$ to the $A$ or $B$ sites respectively. The Hamiltonian is then given by</p>
<p>$$ H_0(\mathbf{k}) + M,\sigma_z,.$$</p>
<p>This leads to a gapped spectrum,</p>
<p>$$E(\mathbf{k})=\pm \sqrt{\left|h(\mathbf{k})\right|^2 + M^2},.$$</p>
<p>However, we quickly realize that by doing this we end up in a rather boring situation. Taking the limit $\left|M\right| \gg t_1$, we obtain electronic states which are localized in one of the two sublattices $A$ or $B$, independent of the sign of $M$. Most importantly, there is no trace of edge states.</p>
<p>It’s easy to see why this mass term is hopeless: it preserves time-reversal symmetry. And with the time-reversal symmetry present, it is definitely impossible to obtain chiral edge states.</p>
<h2 id="Second-try"><a href="#Second-try" class="headerlink" title="Second try"></a>Second try</h2><p>There is another, more ingenious way to gap out the Dirac cones in graphene, which is the essence of today’s model. It involves adding imaginary second-nearest neighbor hoppings, with the following distinctive pattern:</p>
<p><img src="/2021/01/07/src/w4_haldane/haldane_model/haldane_hoppings.svg" alt></p>
<p>With the direction of the arrow, we denote the direction in which the hopping is $+it_2$ (it is $-it_2$ in the opposite direction).</p>
<p>Note the following things about these hoppings:</p>
<ul>
<li>they are purely imaginary and, furthermore, they all have the same chirality, in the sense that they all follow the orientation of your right hand, if the thumb points out from the screen.</li>
<li>they couple sites of same type: $A$ with $A$ and $B$ with $B$.</li>
</ul>
<p>These characteristics tell us that the new hoppings break both time-reversal symmetry and sublattice symmetry. Now the full Hamiltonian becomes</p>
<p>$$<br>H(\mathbf{k}) = H_0(\mathbf{k})+ M\sigma_z + 2t_2\sum_i,\sigma_z,\sin(\mathbf{k}\cdot\mathbf{b}_i),.<br>$$</p>
<p>The last term changes sign under time-reversal symmetry, breaking it. This is the Hamiltonian of the Haldane model.</p>
<p>Let’s see what happens to the system when these special second neighbor hoppings are turned on:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>, t_2=<span class="literal">None</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">&quot;infinite&quot;</span>)</span><br><span class="line">k = (<span class="number">4</span> / <span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">101</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;k_x&quot;</span>: k, <span class="string">&quot;k_y&quot;</span>: k, <span class="string">&quot;title&quot;</span>: title&#125;</span><br><span class="line">t_2s = np.linspace(<span class="number">0</span>, <span class="number">0.10</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.t_2: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.t_2 <span class="keyword">in</span> t_2s&#125;, kdims=[<span class="string">r&quot;$t_2$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>When $t_2=0$ and at a finite $M$, the system is in a boring gapped phase, generically without zero energy states. As you heard in the video, there might be zero energy states for some specific termination of the lattice, but these are not particularly interesting.</p>
<p>Adding a small $t_2$ initially does not change the situation, but when $t_2$ passes through a value $\pm M/3\sqrt{3}$ the gap closes and changes sign. Importantly, the gap closes <em>only at one of the two Dirac points</em>: at $\mathbf{K}’$ for $t_2=M/3\sqrt{3}$ and at $\mathbf{K}$ for $t_2=-M/3\sqrt{3}$.</p>
<p>And when it does, chiral edge states appear! We can see this by looking at the one-dimensional band structure of a ribbon of graphene. To convince you that they are of topological origin, let’s look at the bandstructure for ribbons with two different lattice terminations: armchair and zigzag. In a zigzag ribbon, $\mathbf{K}$ and $\mathbf{K}’$ correspond to different momenta parallel to the ribbon direction, while in an armchair one they correspond to the same one.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;svg&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ribbon_bandstructure</span>(<span class="params">t_2, boundary</span>):</span></span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1.0</span>, t_2=t_2, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> boundary == <span class="string">&quot;zigzag&quot;</span>:</span><br><span class="line">        syst = haldane(w=<span class="number">20</span>, boundary=<span class="string">&quot;zigzag&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> boundary == <span class="string">&quot;armchair&quot;</span>:</span><br><span class="line">        syst = haldane(w=<span class="number">20</span>, boundary=<span class="string">&quot;armchair&quot;</span>,)</span><br><span class="line"></span><br><span class="line">    style = &#123;</span><br><span class="line">        <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">        <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E/t$&quot;</span>,</span><br><span class="line">        <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">        <span class="string">&quot;yticks&quot;</span>: [-<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">        <span class="string">&quot;ylims&quot;</span>: [-<span class="number">3.2</span>, <span class="number">3.2</span>],</span><br><span class="line">        <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> spectrum(syst, p, **style)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t_2s = np.linspace(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">20</span>)</span><br><span class="line">boundaries = [<span class="string">&quot;zigzag&quot;</span>, <span class="string">&quot;armchair&quot;</span>]</span><br><span class="line">plots = &#123;</span><br><span class="line">    (t_2, boundary): ribbon_bandstructure(t_2, boundary)</span><br><span class="line">    <span class="keyword">for</span> t_2 <span class="keyword">in</span> t_2s</span><br><span class="line">    <span class="keyword">for</span> boundary <span class="keyword">in</span> boundaries</span><br><span class="line">&#125;</span><br><span class="line">holoviews.HoloMap(plots, kdims=[<span class="string">r&quot;$t_2$&quot;</span>, <span class="string">&quot;Boundary&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>The appearance of edge states means that graphene has entered a topological phase after the gap closing. This phase is akin to the quantum Hall phase - the edge states are of the same kind. However, as Duncan Haldane explained in the introduction, it is realized without a strong magnetic field.</p>
<p>As you know, this means we have created a <strong>Chern insulator</strong>. The reason for this name will become obvious in the second part of the lecture.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens if we take a Haldane model in the topological phase and turn &quot;</span></span><br><span class="line">    <span class="string">&quot;on a weak magnetic field?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Magnetic field introduces Landau levels, which change the number of edge states.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since the magnetic field is weak, nothing changes as long as it doesn&#x27;t close the gap&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The bulk gap closes and there are no edge states anymore.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The gap doesn&#x27;t close but the edge states may change direction &quot;</span></span><br><span class="line">    <span class="string">&quot;of propagation, depending on the sign of magnetic field.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;Topological robustness is still present, so the number of edge states cannot change unless the gap closes.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Pumping-in-terms-of-Berry-phase"><a href="#Pumping-in-terms-of-Berry-phase" class="headerlink" title="Pumping in terms of Berry phase"></a>Pumping in terms of Berry phase</h1><p>Last week we understood the quantum Hall effect in terms of a pumping argument that we attributed to Laughlin.</p>
<p>Our pumping argument involved putting our system on a cylinder and adiabatically pumping a magnetic flux $\Phi$ through the cylinder so that the Hamiltonian returns to itself. The flux enters the Hamiltonian through minimal substitution as $H(\mathbf{k})\rightarrow H(\mathbf{k}+e\mathbf{A})$ where ${\bf A}=\hat{\mathbf{y}},\Phi/L$.</p>
<p>Thus we can understand the effects of flux pumping on the Hamiltonian in terms of a change in momentum. When the flux is changed by the appropriate number of quanta, the momentum $\mathbf{k}$ changes by a reciprocal lattice vector and, hence the Bloch Hamiltonian returns to its original value. To simplify the discussion, in the following we will use a square Brillouin zone, with $k_x$ and $k_y$ defined in an interval $[0, 2\pi]$, but all our arguments also apply for the hexagonal Brillouin zone of graphene.</p>
<p>Let’s imagine the adiabatic time-evolution of an eigenstate $\left|\psi(\mathbf{k})\right\rangle$ of this Hamiltonian, with energy $E(\mathbf{k})$, as $\mathbf{k}$ is changed slowly. Suppose the Hamiltonian is such that $\left|\psi(\mathbf{k})\right\rangle$ remains non-degenerate as in the case of the Haldane model.  We can then adiabatically explore an energy band by moving $\mathbf{k}$, without the risk of encountering a level crossing. After a while, let’s say a time $T$, we bring $\mathbf{k}$ back to its initial value after going around the entire Brillouin Zone. For instance, we can consider the following closed path $C$, where $k_y$ changes by $2\pi$ at a fixed $k_x$, starting from $k_y=0$:</p>
<p><img src="/2021/01/07/src/w4_haldane/haldane_model/bz_path.svg" alt></p>
<p>We then ask: what is the final quantum state at the time $T$? For a long time people guessed that it would just be given by the initial state $\left|\psi(k_x, k_y+2\pi)\right\rangle\equiv\left|\psi(k_x, k_y)\right\rangle$ times  the usual phase $\exp\left(-i \int_0^T E[\mathbf{k}(t)],d t\right)$, which an eigenstate of the Hamiltonian accumulates with time. </p>
<p>This would be rather boring. Berry instead realized that for a closed loops there is an additional phase $\gamma$, which in our case may depend on $k_x$:</p>
<p>$$\gamma(C) = \oint_C,\mathbf{A}(\mathbf{k}),\cdot d\mathbf{k},.$$</p>
<p>Here, $\mathbf{A}(\mathbf{k})=i\left\langle,\psi(\mathbf{k}) ,|,\nabla_\mathbf{k},\psi(\mathbf{k})\right\rangle$ is a vector with two complex entries, which are obtained by taking the derivatives of $\left|\psi(\mathbf{k})\right\rangle$ with respect to $k_x$ and $k_y$ and then taking the inner product with $\left\langle\psi(\mathbf{k})\right|$. This vector goes by the rather obscure name of Berry connection. In our example, the final quantum state at the end of the cycle is thus</p>
<p>$$\exp,\left[i\gamma(k_x)\right],\exp,\left(-i \int_0^T E[\mathbf{k}(t)],d t\right),\left|\psi(\mathbf{k})\right\rangle,.$$</p>
<p>We have made explicit the fact that $\gamma$ in our case may depend on $k_x$. We will not derive the formula for the Berry phase, something which can be done directly from the Schrödinger equation, see for instance <a href="http://arxiv.org/abs/0907.2021">here</a>. What is important to know about $\gamma$ is that it is a <strong>geometric phase</strong>: its value depends on the path $C$ but not on how the path is performed in time, so not on the particular expression for $\mathbf{k}(t)$. We’ll soon see that sometimes it can have an even stronger, topological character.  </p>
<h2 id="Flux-pumping"><a href="#Flux-pumping" class="headerlink" title="Flux pumping"></a>Flux pumping</h2><p>The phase $\gamma(k_x)$ must bear information about the charge pumped during an adiabatic cycle over $k_y$. Now we take advantage of pumped charge being invariant as long as the energy gap is preserved. This means that we have the freedom to change the energy dispersion $E(k_x,k_y)$ arbitrarily, as long as we do not close the gap.</p>
<p>It is convenient to make the energy dispersion completely flat along the $k_x$ direction for $k_y=0$, analogous to the case of Landau levels. In this way, since at fixed $k_y$ all the wave functions have the same energy, we can choose our initial quantum state to be localized in a single unit cell in the $x$ direction,</p>
<p>$$\left|\psi(n,t=0)\right\rangle=\int_0^{2\pi} dk_x, e^{i k_x n},\left|\psi(k_x, k_y=0)\right\rangle,.$$</p>
<p>Starting from this state, after one adiabatic cycle we obtain</p>
<p>$$\left|\psi(n,t=T)\right\rangle=\int_0^{2\pi} dk_x, e^{i k_x n},\exp,\left[i\gamma(k_x)-i\theta(k_x)\right],\left|\psi(k_x, k_y=2\pi)\right\rangle,$$</p>
<p>where $\theta(k_x)=\int_0^T E[k_x, k_y(t)],d t$ is the dynamical phase. Now we notice something strange. While $\theta(k_x)$ is a truly periodic function of $k_x$ because $E(k_x)=E(k_x+2\pi)$, the only restriction on the Berry phase $\gamma(k_x)$ is to be periodic modulo $2\pi$. That is, we can have $\gamma(k_x+2\pi)=\gamma(k_x)+2\pi W$ with $W$ an integer number.</p>
<p>Let’s try to deform the dispersion along $k_y$ in order to make the combination $\gamma(k_x)-\theta(k_x)$ as large as possible (just like before, this is allowed as long as we do not close the gap). The best we can do is choose $\theta(k_x)$ so that </p>
<p>$$\gamma(k_x)-\theta(k_x)=W k_x.$$</p>
<p>Plugging this in to the form of the wave-function we see that </p>
<p>$$\left|\psi(n,t=T)\right\rangle=\int dk_x e^{i k_x (n+W)},\left|\psi(k_x, k_y=0)\right\rangle,$$</p>
<p>which means that every wave function is shifted over by $W$ unit cells. Thus the system with the wave functions $\left|\psi(\mathbf{k})\right\rangle$ pumps $W$ units of charge if the Berry phase satisfies </p>
<p>$$\gamma(k_x+2\pi)-\gamma(k_x)=2\pi W.$$</p>
<blockquote>
<p>The quantity $W$ is called the <strong>Chern number</strong> and is the topological invariant characterizing the bandstructure of two dimensional quantum Hall systems. Because it is an integer, it cannot be changed by any continuous deformation of the Hamiltonian, provided the gap does not close. The Chern number is in fact the bulk topological invariant for all insulators with broken time-reversal symmetry. If $W=0$, we have a topologically trivial insulator with no chiral edge states. If $W=n$ there are $n$ chiral edge states at the boundary of the insulator.</p>
</blockquote>
<h1 id="Compact-form-of-the-Chern-number-as-Berry-curvature"><a href="#Compact-form-of-the-Chern-number-as-Berry-curvature" class="headerlink" title="Compact form of the Chern number as Berry curvature"></a>Compact form of the Chern number as Berry curvature</h1><p>We did not denote the Berry connection as $\mathbf{A}(\mathbf{k})$ just by chance. We picked that letter because this vector reminds us a lot of the vector potential $\mathbf{A}(\mathbf{r})$ that is used in electromagnetism.</p>
<p>Just like the vector potential, the definition of $\mathbf{A}(\mathbf{k})$ depends on a particular choice of the person making the calculation. If you decide to multiply the quantum state by a phase, $\left|\psi(\mathbf{k})\right\rangle,\to \exp,[i\lambda(\mathbf{k})],\left|\psi(\mathbf{k})\right\rangle$, then you get that the Berry connection transforms as $\mathbf{A}(\mathbf{k}),\to,\mathbf{A}(\mathbf{k})+\nabla_\mathbf{k} ,\lambda$. However, when you take the integral of $\mathbf{A}(\mathbf{k})$ on a closed path, the result is independent of $\lambda$. That’s why the Berry phase is only meaningful for closed paths. </p>
<p>Now that we have established an analogy with the vector potential, we cannot avoid the idea of taking the curl of the Berry connection, which is known as the <strong>Berry curvature</strong>:</p>
<p>$$\mathbf{\Omega}(\mathbf{k}) = \nabla_\mathbf{k} \times \mathbf{A}(\mathbf{k})=i\left[\left\langle \frac{\partial \psi(\mathbf{k})}{\partial k_x},\Bigg|,\frac{\partial,\psi(\mathbf{k})}{\partial k_y}\right\rangle-\left\langle \frac{\partial \psi(\mathbf{k})}{\partial k_y},\Bigg|,\frac{\partial,\psi(\mathbf{k})}{\partial k_x}\right\rangle\right],.$$</p>
<p>The Berry curvature is like a <em>magnetic field in momentum space</em>. Just like the magnetic field $\mathbf{B}(\mathbf{r})=\nabla_\mathbf{r}\times\mathbf{A}(\mathbf{r})$ in electromagnetism, it is a local quantity which does not suffer from the ambiguities of the vector potential (it is gauge independent).</p>
<p>The main advantage of introducing the analogy with the magnetic field is that it motivates us to use Stokes theorem. The Brillouin Zone has the shape of a torus. Therefore the curve $k_x=0$ and $k_x=2\pi$ on the torus bounds the entire Brillouin zone. Using Stokes theorem on this curve we can conclude that </p>
<p>$$2\pi W=\gamma(2\pi)-\gamma(0)=\iint_{\textrm{BZ}} \mathbf{\Omega}(\mathbf{k}),\cdot,d\mathbf{S},,$$</p>
<p>where the integral extends over the entire Brillouin Zone.</p>
<blockquote>
<p>As a result of this formalism, we have established two things. First, there is a Chern number which is defined entirely in terms of the momentum space wave functions. Second, the analogy with the magnetic field allows us to obtain an explicit expression for the Chern number in terms of derivatives of the wave functions.</p>
</blockquote>
<p>Loosely speaking, a situation with a non-zero Chern number is a bit like having a magnetic monopole, because we have a finite flux coming out of a closed surface. Now, you probably know that experimentally a magnetic monopole was never observed. For our Chern number in the Brillouin zone the situation is more exciting, as situations where it is non-zero are realized in nature.</p>
<p>To see how this can happen, we first have to understand the following: if there is Berry curvature in the Brillouin zone, what are its sources?</p>
<h1 id="Gap-closings-are-sources-of-Berry-curvature"><a href="#Gap-closings-are-sources-of-Berry-curvature" class="headerlink" title="Gap closings are sources of Berry curvature"></a>Gap closings are sources of Berry curvature</h1><p>The Berry phase can only be computed if the Hamiltonian has a gap. For a Hamiltonian $H(\mathbf{k})$ with many bands $E_n(\mathbf{k})$, this means that we can compute the Chern number only for an isolated band $E_n(\mathbf{k})$ which does not touch any other band. If there is a band touching, the Berry phase is undefined.</p>
<p>Now let’s go back to our analogy with electromagnetism. We know that we cannot compute the electric or magnetic flux through a surface if there are electric or magnetic charges sitting exactly on it. That’s because the electric or magnetic fields are <em>not defined</em> at the points where their sources are.</p>
<p>This analogy suggests the following: that the sources for Berry flux in momentum space are points where two bands touch, just like the Dirac points at the $\mathbf{K}$ and $\mathbf{K}’$ points of the Brillouin zone in graphene.</p>
<p>This may sound a bit abstract and confusing: where are these points located? We are used to thinking about sources of flux in real space, not in momentum space. In fact, just like you do with a two-dimensional sphere surrounding a charge in three-dimensional space, you can think of the Brillouin zone as lying in a three-dimensional space, with two directions given by $k_x$ and $k_y$ and the third given by the <strong>magnitude of the energy gap</strong>. </p>
<p>The situation is explained by the following sketch, which also gives a bird’s-eye view of the phase diagram of the Haldane model as a function of the ratio $t_2/M$:</p>
<img src="/2021/01/07/src/w4_haldane/haldane_model/phasediagram.svg" alt="Phase diagram" style="width: 70%">

<p>What you see in the sketch above is a schematic illustration of the energy spectrum close to the Dirac points in the Brillouin zone, for some representative values of $t_2/M$ (for simplicity we drew the Brillouin zone as a square and not a hexagon, but that’s not essential). The two massless Dirac cones appearing for $t_2=\pm M/(3\sqrt{3})$ are the sources of the Berry curvature, which then “spreads“ along the vertical axis, passing through the Brillouin zones of the gapped phases.</p>
<p>The $t_2=0$ Brillouin zone is “sandwiched“ between the two gap closings: it has opposite curvature for the two Dirac points, and a total Chern number of zero.</p>
<p>The Brillouin zones for $|t_2|&gt;M/(3\sqrt{3})$, on the other hand, have Berry curvature with the same sign for both Dirac points, and a total Chern number equal to $\pm 1$.</p>
<p>To see this more clearly, we can compute the Berry curvature numerically and plot it over the whole Brillouin zone as a function of $t_2$:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, m=<span class="number">0.2</span>, phi=np.pi / <span class="number">2</span>, t_2=<span class="literal">None</span>)</span><br><span class="line">syst = haldane(boundary=<span class="string">&quot;infinite&quot;</span>)</span><br><span class="line">kwargs = &#123;<span class="string">&quot;title&quot;</span>: title, <span class="string">&quot;ks&quot;</span>: np.linspace(-<span class="number">2</span> * np.pi, <span class="number">2</span> * np.pi, <span class="number">150</span>, endpoint=<span class="literal">False</span>)&#125;</span><br><span class="line">t_2s = np.linspace(-<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.t_2: plot_berry_curvature(syst, p, **kwargs) <span class="keyword">for</span> p.t_2 <span class="keyword">in</span> t_2s&#125;, kdims=[<span class="string">r&quot;$t_2$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;How does time-reversal symmetry influence the Berry curvature?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The Berry curvature breaks time-reversal, so it must be zero if time-reversal is present.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Time reversal symmetry doesn&#x27;t constrain Berry curvature at all.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There is no constraint, only the integral of Berry curvature (Chern number) should be zero.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Berry curvature and momentum change sign under time-reversal, so that the Berry curvature &quot;</span></span><br><span class="line">    <span class="string">&quot;at one momentum becomes opposite to the Berry curvature at opposite momentum.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(question=question, answers=answers, correct_answer=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>You can see that the Berry curvature is really located around the Dirac points. Around $t_2=0$, the two Dirac points give canceling contributions. After a gap closing however, the contribution of one of the two Dirac points changes sign, so that the two add to $\pm 1$ instead of canceling each other.</p>
<p>From both the plots above, you can also infer that each Dirac point always contributes a Berry curvature equal to $\pm 1/2$, depending on the sign of the mass in the effective Dirac Hamiltonian. We always obtain an integer number because the number of Dirac points in the Brillouin zone is even. It also implies that when the gap changes sign at a Dirac point, the Chern number changes by exactly one!</p>
<p>At the same time it’s important to know that the particular distribution of the Berry curvature depends on all the details of the eigenstates of the Hamiltonian, so it changes a lot from model to model. And in fact, it is a special feature of the Haldane model that the Berry curvature is focused around two distinct points in the Brillouin zone.</p>
<p>For instance, here is a slider plot for the Berry curvature for the quantum Hall lattice model studied in the previous chapter.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>, gamma=-<span class="number">0.5</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = Qi_Wu_Zhang()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title_Qi</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$t=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$, $\gamma=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    <span class="keyword">return</span> title.<span class="built_in">format</span>(p.t, p.mu, p.delta, p.gamma)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kwargs = &#123;<span class="string">&quot;title&quot;</span>: title_Qi&#125;</span><br><span class="line">mus = np.linspace(-<span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: plot_berry_curvature(syst, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>You can see that for $\mu &lt; -2t - 2\gamma$ there is a net curvature, and that when $\mu = -2t - 2\gamma$ some flux of opposite sign appears at $k_x = k_y=0$, the Dirac point, which leaves no net curvature and leads to a change in the Chern number. This is the signature of the topological transition seen from the Berry curvature.</p>
<h1 id="Summary-extending-the-model-to-spinful-electrons-and-photons"><a href="#Summary-extending-the-model-to-spinful-electrons-and-photons" class="headerlink" title="Summary: extending the model to spinful electrons and photons"></a>Summary: extending the model to spinful electrons and photons</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;0gxE68kvdmw&quot;</span>, src_location=<span class="string">&quot;4.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Haldane model&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w4_haldane/ComputingChern/</url>
    <content><![CDATA[<h2 id="Additional-notes-on-computing-Chern-number"><a href="#Additional-notes-on-computing-Chern-number" class="headerlink" title="Additional notes on computing Chern number"></a>Additional notes on computing Chern number</h2><p>Computing the Chern number from the Berry connection  $\bf{a}(\bf {k})=i\langle u(\bf{k})|\bf{\nabla}(|u(\bf{k})\rangle)$ is annoying because one needs to find a gauge where the Bloch wave-functions $u_n({\bf k})$ are continuous.</p>
<p>On the other hand, the Chern number is really the integral of the Berry curvature </p>
<p>$${\bf{b}(k)}={\bf\nabla\times a(k)}$$ </p>
<p>as</p>
<p>$$\Phi=\oint d^2\bf{k}\bf{z}\cdot \bf{b}(\bf{k}).$$</p>
<p>Numerically it is more convenient to compute the integral $\Phi$ by breaking them down into small plaquettes. So that </p>
<p>$$\Phi=\sum_n \oint_{\Gamma_n} d^2\bf{k}\bf{z}\cdot \bf{b}(\bf{k})=\sum_n \oint_{\Gamma_n} d{\bf k}\cdot {\bf a(k)},$$<br>is broken down into chunks<br>$$\Phi_n=i\oint_{\Gamma_n} d{\bf k}\cdot {\langle u(\bf{k})|\bf{\nabla}(|u(\bf{k})\rangle)}.$$</p>
<p>For sufficiently small chunks $\Phi_n$ is small and one can get away with computing the exponential </p>
<p>$$e^{i\Phi_n}=e^{\oint_{\Gamma_n} d{\bf k}\cdot {\langle u(\bf{k})|\bf{\nabla}(|u(\bf{k})\rangle)}}=\prod_p e^{\delta{\bf k}<em>{n,p}\cdot {\langle u(\bf{k}</em>{n,p})|\bf{\nabla}(|u(\bf{k}<em>{n,p})\rangle)}}\approx \prod_p (1+\delta k</em>{n,p}\langle u(\bf{k}<em>{n,p})|\bf{\nabla}(|u(\bf{k}</em>{n,p})\rangle)\approx \prod_p \langle u(\bf{k}<em>{n,p})|u(\bf{k}</em>{n,p+1})\rangle.$$</p>
<p>The flux on the small plaquette can be computed as </p>
<p>$$\Phi_n=\textrm{Arg}(\prod_p \langle u({\bf k}<em>{n,p})|u({\bf k}</em>{n,p+1})\rangle).$$</p>
<p>What is nice about this product is that it is gauge invariant as can be checked by multiplying each wave-function $|u({\bf k}<em>{n,p})\rangle\rightarrow e^{i\varphi({\bf k}</em>{n,p})}|u({\bf k}_{n,p})\rangle$.</p>
<p>The nice thing about this expression is that one can also generalize this to multiband systems to calculate the total Chern number so that the contribution from each plaquette </p>
<p>$$e^{i\Phi_n}\approx \prod_p\prod_s \langle u_s(\bf{k}<em>{n,p})|u_s(\bf{k}</em>{n,p+1})\rangle=\prod_p Det[\langle u_s(\bf{k}<em>{n,p})|u_s(\bf{k}</em>{n,p+1})\rangle],$$<br>where $s$ labels the band index.</p>
<p>What Vanderbilt and coworkers pointed out is that this expression can be written as<br>$$e^{i\Phi_n}=\prod_p Det[\langle u_s(\bf{k}<em>{n,p})|u</em>{s’}(\bf{k}<em>{n,p+1})\rangle],$$<br>is related to determinants of a bunch of matrices $\langle u_s(\bf{k}</em>{n,p})|u_{s’}(\bf{k}_{n,p+1})\rangle$, which in the diagonal basis of eigenstates is nearly diagonal, which takes us back to the previous expression.</p>
<p>The main advantage of this expression is that it is actually $U(N)$ invariant for any unitary transformation of the $N$ occupied eigenstates.</p>
<h2 id="Final-recipe"><a href="#Final-recipe" class="headerlink" title="Final recipe"></a>Final recipe</h2><p>So the final recipe to compute the Chern number is as follows:</p>
<ul>
<li><p>grid up the BZ into small plaquettes labelled by $n$</p>
</li>
<li><p>Compute the flux through each plaquette $$\Phi_n=Arg[\prod_p Det[\langle u_s(\bf{k}<em>{n,p})|u</em>{s’}(\bf{k}<em>{n,p+1})\rangle]],$$<br>where ${\bf k}</em>{n,p}$ are momenta on the corners of the lattice.</p>
</li>
<li><p>The Chern number is calculated as $$\nu=(2\pi)^{-1}\sum_n \Phi_n.$$</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w4_haldane/QHE_lattice/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size=<span class="number">150</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Qi_Wu_Zhang</span>(<span class="params">w=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.mu * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0.5j</span> * p.delta * pauli.sy - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1j</span> * p.gamma * pauli.sx - p.gamma * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> w == <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= pos[<span class="number">1</span>] &lt; w</span><br><span class="line"></span><br><span class="line">        sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        syst = kwant.Builder(sym)</span><br><span class="line">        syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    title = <span class="string">r&quot;$t=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$, $\gamma=&#123;:.2&#125;$&quot;</span></span><br><span class="line">    title = title.<span class="built_in">format</span>(p.t, p.mu, p.delta, p.gamma)</span><br><span class="line">    <span class="keyword">return</span> title</span><br></pre></td></tr></table></figure>

<h1 id="Introduction-stacking-wires"><a href="#Introduction-stacking-wires" class="headerlink" title="Introduction: stacking wires"></a>Introduction: stacking wires</h1><p>Looking back at the material from the past weeks, you might have the impression that the quantum Hall effect and one dimensional topological superconductors are really different topics, and not connected at all.</p>
<p>Xiaoliang Qi from Stanford University will now explain that this is not the case, and will also introduce this week’s topic - Chern insulators.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;osKP6x0Ewbo&quot;</span>, src_location=<span class="string">&quot;4.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Pairs-of-chiral-edges-in-a-1D-wire"><a href="#Pairs-of-chiral-edges-in-a-1D-wire" class="headerlink" title="Pairs of chiral edges in a 1D wire"></a>Pairs of chiral edges in a 1D wire</h1><p>Last week, we started with a phenomenological description of the quantum Hall effect. We learned that one way to get a quantum Hall state is to place electrons in an external magnetic field.</p>
<p>However, we still don’t have a simple lattice Hamiltonian describing the quantum Hall effect - we’d like to have something like the Kitaev chain model, which was very useful to understand Majoranas in the first two weeks of the course. An added benefit of finding this tight binding model is that it would not need an external magnetic field to exhibit the unique properties of quantum Hall effect.</p>
<p>These models exist, and they are referred to as <em>Chern insulators</em>. The quantum Hall effect without an external magnetic field is also referred to as the <em>quantum anomalous Hall effect</em>. Duncan Haldane, from who we will hear in the next chapter, invented the first model of a Chern insulator now known as <em>Haldane model</em>. However, in this chapter, we will use a more natural route that fits better into the context of our course so far.</p>
<h2 id="General-strategy-to-construct-a-lattice-model-for-the-Quantum-Hall-Effect"><a href="#General-strategy-to-construct-a-lattice-model-for-the-Quantum-Hall-Effect" class="headerlink" title="General strategy to construct a lattice model for the Quantum Hall Effect"></a>General strategy to construct a lattice model for the Quantum Hall Effect</h2><p>What we will do to get a model for a Chern insulator is to follow a “domino prescription”, as we did to get the Kitaev model in week 1. Our strategy will have two key aspects:</p>
<ul>
<li><p>Focusing on the unique property of the quantum Hall edge that cannot exist in isolation from a bulk, and can only be present because of bulk-boundary correspondence. For the Kitaev chain, this property was the presence of unpaired Majorana modes. In the quantum Hall effect, it is the chiral edge states.</p>
</li>
<li><p>Finding a lower dimensional building block, from which we can somehow “extract“ in a clever way the exotic object we are interested in. In the Kitaev chain, these were the fermionic sites, which we could think of as a pair of Majorana modes.</p>
</li>
</ul>
<p>So we need to find a one-dimensional system which can host a pair of chiral edge states. Since they are one-dimensional, these states will necessarily be spatially on top of each other, essentially a pair of propagating modes with opposite velocity. Once we have this building block, we can follow the domino prescription: couple the counter-propagating states in pairs, just like we did with Majorana modes. We then end up with a pair of spatially separated chiral edge states, and so a quantum Hall insulator without magnetic field.</p>
<p>So our plan is to turn the system on the left into the system on the right:</p>
<p><img src="/2021/01/07/src/w4_haldane/QHE_lattice/coupled_chains.svg" alt></p>
<p>Voilà - we have a lattice model for the 2D quantum Hall state!</p>
<h2 id="Getting-a-one-dimensional-wire-with-a-pair-of-edge-states"><a href="#Getting-a-one-dimensional-wire-with-a-pair-of-edge-states" class="headerlink" title="Getting a one dimensional wire with a pair of edge states"></a>Getting a one dimensional wire with a pair of edge states</h2><p>Let’s focus on the first essential step of our plan: finding a one dimensional system with a pair of counter-propagating chiral states.</p>
<p>You might guess that the easiest way to get a pair of states moving in opposite directions is to take the usual one dimensional single electron Hamiltonian with an effective mass. Such a system has a parabolic dispersion and the low energy excitations at a finite Fermi wave-vector $k=\pm k_F$ move in opposite directions. The catch is that these two states have different momenta, and it is tricky (though not impossible) to deal with momentum conservation when pairing the edges. So we will avoid this approach.</p>
<p>The more educated guess we make a model that we have already encountered, the Dirac model $H= \Delta,k, \tau_y$ of the Kitaev chain at the topological phase transition.</p>
<p>More specifically, in the first week we wrote the Kitaev Hamiltonian in momentum space as $H(k)=-(2 t\cos{k}+\mu),\tau_z+\Delta \sin{k}\tau_y$.  At the critical point $\mu=-2t$, we found the Kitaev Hamiltonian to become</p>
<p>$$H=-2t(\cos{k}-1),\tau_z+\Delta\sin{k},\tau_y.$$</p>
<p>We see that at $k\approx 0$ we have a pair of states with wave functions the eigenvalues $\pm 1$ of $\tau_y$, and with opposite and equal velocities.</p>
<p>At this point you might worry that the Kitaev model has superconductivity, and so the $\tau$ matrices refer to particle and hole degrees of freedom. Indeed, these ingredients should not enter in the description of the quantum Hall effect. But this is not a real issue, because we can just interpret the $\tau$ matrices as acting in the space of left- and right-movers. This flexibility in interpreting the Hamiltonian terms in different ways, depending on the context, is part of the advantage of thinking in terms of toy models.</p>
<p>Finally, before we go on with our plan, keep in mind that considering the phase transition point of a lower dimensional model turns out to be a fairly generic strategy to construct higher dimensional topological models.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;It seems that both a quantum Hall bar and a Kitaev chain can have chiral states. &quot;</span></span><br><span class="line">    <span class="string">&quot;Apart from the two systems having different dimensionality&quot;</span></span><br><span class="line">    <span class="string">&quot;, what&#x27;s the fundamental difference between the two cases?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The quantum Hall edge states go in opposite directions, while the Kitaev states go in the same direction.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The quantum Hall edge states go in the same direction, while the Kitaev states go in opposite directions.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The quantum Hall edges always cross zero energy at zero momentum while the Kitaev states don&#x27;t.&quot;</span>,</span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;The Kitaev chiral states exist only at specific parameter values, &quot;</span></span><br><span class="line">        <span class="string">&quot;while the quantum Hall edge states don&#x27;t.&quot;</span></span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The pair of chiral states in the Kitaev model only exists at &quot;</span></span><br><span class="line">    <span class="string">&quot;the phase transition point, when the chain becomes gapless. &quot;</span></span><br><span class="line">    <span class="string">&quot;On the other hand, chiral edge states are a topological property of the quantum Hall state. &quot;</span></span><br><span class="line">    <span class="string">&quot;They are separated by a gapped bulk which protects them, and they exist for a full range of parameter values.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="QHE-without-a-magnetic-field"><a href="#QHE-without-a-magnetic-field" class="headerlink" title="QHE without a magnetic  field"></a>QHE without a magnetic  field</h1><h2 id="Deriving-the-model-Hamiltonian"><a href="#Deriving-the-model-Hamiltonian" class="headerlink" title="Deriving the model Hamiltonian"></a>Deriving the model Hamiltonian</h2><p>Let us now couple the wires to get the quantum Hall system as promised. We take a stack of chains all extending along the horizontal $x$ direction, like in the figure above. We stack them one next to the other along the $y$ direction, so that we form a square lattice. If we take a large (ideally infinite) stack of chains we have a truly two-dimensional system.</p>
<p>Now let us make this formal by first labeling the chains by an index $n_y$, which takes integer values. Let us also replace $k\rightarrow k_x$ to denote the wave-vector along a chain. Hence a single chain has the Hamiltonian $\left[-(2 t\cos{k_x}+\mu),\tau_z+\Delta \sin{k_x}\tau_y\right],\otimes,\left|,n_y\right\rangle\left\langle n_y\right|$. The projector $\left|,n_y\right\rangle\left\langle n_y\right|$ is needed to single out one chain from the stack. </p>
<p>Now all that we have to do is to couple the $\tau_y=-1$ branch of one chain to the $\tau_y=+1$ branch of a neighboring chain,  and we will have a quantum Hall state.</p>
<p>A term coupling opposite movers from different chains is $\left|,n_y\right\rangle\left\langle n_y+1\right|\otimes (\tau_z+i\tau_x)$. The first part couples neighboring chains and the matrix $(\tau_z+i\tau_x)$ turns a right mover into a left mover, which is what we want. Let’s call the strength of this coupling $\gamma$.</p>
<p>To obtain the complete Hamiltonian of the stack of chains we just need to sum over $n_y$, and we obtain</p>
<p>$$H=\sum_{n_y},\left[-(2 t\cos{k_x}+\mu)\tau_z+\Delta \sin{k_x}\tau_y\right],\otimes,\left|,n_y\right\rangle\left\langle n_y\right|,-,\gamma,\sum_{n_y},\left[\left|,n_y\right\rangle\left\langle n_y+1\right|\otimes (\tau_z+i\tau_x),+,\textrm{h.c.}\right].$$</p>
<p>This Hamiltonian should in principle suffice to produce a quantum Hall state.</p>
<h2 id="Gap-and-edge-states"><a href="#Gap-and-edge-states" class="headerlink" title="Gap and edge states"></a>Gap and edge states</h2><p>Let’s first consider a finite number of chains $n_y=1,\dots,N$. If you tune each chain individually to the point $\mu = -2t$, it’s easy to check that at $k_x \approx 0$ the above Hamiltonian has one right-moving edge eigenstate for $n_y=1$ with eigenvalue $\approx \Delta , k_x$, and a left-moving edge eigenstate for $n_y=N$  with eigenvalue $\approx -\Delta,k_x$.</p>
<p>The next thing we need to check is that these are the only eigenstates close to zero energy. In other words, is the system gapped in the two-dimensional bulk?  To see this, let’s switch to an infinite stack of chains along the $y$ direction. We then have full translational invariance, so we can go to momentum space in the $y$ direction.</p>
<p>This leads us to the two-dimensional Bloch Hamiltonian </p>
<p>$$H(k_x,k_y)=[-(2t\cos{k_x}+\mu)\tau_z+\Delta\sin{k_x}\tau_y]-2\gamma,[\cos{k_y}\tau_z+\sin{k_y}\tau_x].$$ </p>
<p>Since this Hamiltonian is a sum of three Pauli matrices, the energy spectrum can be written down as </p>
<p>$$E(k_x,k_y)=\pm\sqrt{\Delta^2\sin^2{k_x}+(2\gamma\cos{k_y}+\mu+2t\cos{k_x}))^2+4\gamma^2\sin^2{k_y}}.$$ </p>
<p>Aside from special points, this spectrum is gapped, just like we wanted. For instance it is gapped if $\mu&lt;-2t-2\gamma$. If we start from this point and increase the value of $\mu$, the gap closes at the point $\mu = -2t-2\gamma$ and then reopens:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.3</span>, gamma=-<span class="number">0.5</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = Qi_Wu_Zhang()</span><br><span class="line">mus = np.linspace(-<span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: spectrum(syst, p, zticks=[-<span class="number">4</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>], title=title) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$\mu$&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>As a check that everything worked, let’s look at the dispersion of a ribbon with finite width along the $y$ direction. If there are edge states, we should see a Dirac-like crossing around $k_x=0$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.3</span>, gamma=-<span class="number">0.5</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = Qi_Wu_Zhang(w=<span class="number">15</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">2</span>, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">style = &#123;</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E/t$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">2.2</span>, <span class="number">2.2</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(&#123;p.mu: spectrum(syst, p, **style) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>We see that the crossing is there, and it disappears when the gap closes. So we can identify the point $\mu=-2t-2\gamma$ as a critical point at which the quantum Hall state becomes topologically trivial.</p>
<p>While details such as the bulk spectrum and edge dispersion are different from the case with a magnetic field, the bulk-edge correspondence tells us that the edge states are as robust as those of the quantum Hall effect we studied last week.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;How does our lattice model with no magnetic field differ from the original quantum Hall effect?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Since there is no magnetic field the quantum Hall effect on a lattice preserves time reversal symmetry.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Quantum Hall effect in a magnetic field has Landau levels &quot;</span></span><br><span class="line">    <span class="string">&quot;that do not disperse in k while they disperse in the lattice.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Quantum Hall effect in the lattice has no chiral edge states, which arise from skipping orbits in a magnetic field.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;In a magnetic field the filling fraction is fixed to integer per flux quantum, while in the &quot;</span></span><br><span class="line">    <span class="string">&quot;lattice the filling fraction per unit cell is arbitrary.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = <span class="string">&quot;In a lattice one gets a non-constant bandstructure which forms a Dirac cone near the phase transition.&quot;</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Dirac-equation-at-the-phase-transition"><a href="#Dirac-equation-at-the-phase-transition" class="headerlink" title="Dirac equation at the phase transition"></a>Dirac equation at the phase transition</h1><p>Back in week 1, we saw with the Kitaev chain that the “domino argument” led to two distinct phases. The same is true for our model, even though the parameter space is larger than before, with three distinct parameters $\mu, t, \gamma$, which we have not explored fully. But let’s not worry about establishing the full phase diagram. For now it’s more interesting to study the transition point we have found.</p>
<p>The two phases around this point are easy to understand. One is the quantum Hall phase with chiral edge states, which was our initial goal. The other one is a topologically trivial phase. The trivial phase can be understood by first taking $\mu$ very positive and large, and then taking $\gamma\to 0$. Then we just have a bunch of gapped 1D chains next to each other without any tunneling between them, a trivial phase with no edge states.</p>
<p>It is once again useful to write down the effective Hamiltonian near to the transition point at $k_x\approx 0$ and $k_y\approx 0$. It is given by a 2D Dirac Hamiltonian:</p>
<p>$$H_{\textrm{Dirac}}=[\Delta k_x\tau_y-2\gamma k_y\tau_x+m\tau_z],$$ </p>
<p>The combination $m=-(\mu +2t+2\gamma)$ serves as the ‘mass’ in this Dirac model. As before, we see that the gapless phase transition point at $m=0$ is described by a massless Dirac Hamiltonian. The phase transition separates the topological from the trivial phase, and the two phases are characterized by a different sign of the mass (in this case $m&gt;0$ in the topological phase and $m&lt;0$ in the trivial phase).</p>
<p>As with Kitaev chains, the Dirac model gives us another way to construct chiral edge states at the domain wall between topological and non-topological phases. Back in week 1, we saw that for a one dimensional Dirac model, a domain wall in the mass $m$ supports a non-degenerate zero mode. Fixing  $k_y=0$, we see that the one dimensional Dirac Hamiltonian here is identical to the one we saw in week 1, where the zero mode at the domain wall between $m&lt;0$ and $m&gt;0$ was an eigenstate of $\tau_x$ with eigenvalue $+1$. </p>
<p>Unlike the one-dimensional case, the zero mode is not stationary in the two dimensional case. By adding $2\gamma k_y\tau_x$ as a perturbation, we see that the energy of the state increases as </p>
<p>$$\epsilon(k_y)\approx 2\gamma k_y,,$$</p>
<p>so it has a velocity $v=2\gamma$, the direction of which depends on the sign of $\gamma$. So we see how we can get the chiral edge modes analytically.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;CXgAcOOVlag&quot;</span>, src_location=<span class="string">&quot;4.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Chern insulators&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w3_pump_QHE/w3_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-Disorder-butterflies-and-honeycombs"><a href="#Simulations-Disorder-butterflies-and-honeycombs" class="headerlink" title="Simulations: Disorder, butterflies, and honeycombs"></a>Simulations: Disorder, butterflies, and honeycombs</h1><p>As usual, start by grabbing the notebooks of this week (<code>w3_pump_QHE</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<p>There are really plenty of things that one can study with the quantum Hall effect and pumps. Remember, that you don’t need to do everything at once (but of course all of the simulations are quite fun!)</p>
<h3 id="Pumping-with-disorder"><a href="#Pumping-with-disorder" class="headerlink" title="Pumping with disorder"></a>Pumping with disorder</h3><p>Grab the simulations of the Thouless pump, and see what happens to the pump when you add disorder. Try both the winding in a pump with reservoirs attached, and the spectrum of a closed pump. Can you explain what you observe?</p>
<h3 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h3><p>Take a look at how we calculate numerically the spectrum of Landau levels in the Laughlin argument chapter.<br>We were always careful to only take weak fields so that the flux per unit cell of the tight binding lattice is small.<br>This is done to avoid certain <a href="http://en.wikipedia.org/wiki/Hofstadter%27s_butterfly">notorious insects</a>, but nothing should prevent you from cranking up the magnetic field and seeing this beautiful phenomenon.</p>
<p>Plot the spectrum of a quantum Hall layer rolled into a cylinder at a fixed momentum as a function of $B$ as $B$ goes to one flux quantum per unit cell, so in lattice units $B = 2\pi$. Bonus (requires more work): attach a lead to the cylinder, calculate pumping, and color the butterfly according to the pumped charge.</p>
<h3 id="Graphene"><a href="#Graphene" class="headerlink" title="Graphene"></a>Graphene</h3><p>Take a look at how to implement a honeycomb lattice in Kwant <a href="http://kwant-project.org/doc/1.0/tutorial/tutorial4">tutorials</a>, and modify the Hall bar from the Laughlin argument notebook to be made of graphene. Observe the famous <a href="http://arxiv.org/abs/cond-mat/0602565">unconventional quantum Hall effect</a>.</p>
<p>Bonus: See what happens to the edge states as you introduce a constriction in the middle of the Hall bar. This is an extremely useful experimental tool used in making quantum Hall interferometers (also check out the density of states using the code from the edge states notebook).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Quantum Hall effect&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><p>For the third week we have these papers:</p>
<h3 id="arXiv-1109-5983"><a href="#arXiv-1109-5983" class="headerlink" title="arXiv:1109.5983"></a>arXiv:1109.5983</h3><p><strong>Hint:</strong> Topological pumping can be used to characterize quasicrystals too!<br>Whether this is really unique to quasicrystals is debated though arXiv:1307.2577.</p>
<h3 id="arXiv-cond-mat-0602645"><a href="#arXiv-cond-mat-0602645" class="headerlink" title="arXiv:cond-mat/0602645"></a>arXiv:cond-mat/0602645</h3><p><strong>Hint:</strong> Quantum Hall effect applies beyond parabolic dispersions with interesting twists.<br>Figure out what different features arise from other cases.</p>
<h3 id="arXiv-1201-4167"><a href="#arXiv-1201-4167" class="headerlink" title="arXiv:1201.4167"></a>arXiv:1201.4167</h3><p><strong>Hint:</strong> An experiment detecting the interesting consequences of coexistence of quantum Hall and ferromagnetism in graphene.</p>
<h3 id="arXiv-0710-2806"><a href="#arXiv-0710-2806" class="headerlink" title="arXiv:0710.2806"></a>arXiv:0710.2806</h3><p><strong>Hint:</strong> Aharonov-Bohm interference using quantum hall edge quasiparticles.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Quantum Hall effect&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w3_pump_QHE/pumps/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">from</span> holoviews.core.options <span class="keyword">import</span> Cycle</span><br><span class="line"></span><br><span class="line">%output size=<span class="number">120</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ts_modulated_wire</span>(<span class="params">L=<span class="number">50</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create an infinite wire with a periodic potential</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Chain lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, A, phase</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The period of the potential is 2*pi/L.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    omega = <span class="number">2</span> * np.pi / L</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        x = site.pos[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * p.t - p.mu + p.A * (np.cos(omega * x + p.phase) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry([-L])</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    syst[(lat(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modulated_wire</span>(<span class="params">L=<span class="number">50</span>, dL=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a pump. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Chain lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    L is the length of the pump,</span></span><br><span class="line"><span class="string">    dL is the length of the clean regions next to the pump,</span></span><br><span class="line"><span class="string">            useful for demonstration purposes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, A, omega, phase</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        x = site.pos[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * p.t - p.mu + p.A * (np.cos(p.omega * x + p.phase) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    lead_onsite = <span class="keyword">lambda</span> site, p: <span class="number">2</span> * p.t - p.mu_lead</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[(lat(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry([-<span class="number">1</span>])</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line">    lead[lat(<span class="number">0</span>)] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total_charge</span>(<span class="params">value_array</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate the pumped charge from the list of reflection matrices.&quot;&quot;&quot;</span></span><br><span class="line">    determinants = [np.linalg.det(r) <span class="keyword">for</span> r <span class="keyword">in</span> value_array]</span><br><span class="line">    charge = np.cumsum(np.angle(np.roll(determinants, -<span class="number">1</span>) / determinants))</span><br><span class="line">    charge = charge - charge[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> charge / (<span class="number">2</span> * np.pi)</span><br></pre></td></tr></table></figure>

<h1 id="Thouless-pumps"><a href="#Thouless-pumps" class="headerlink" title="Thouless pumps"></a>Thouless pumps</h1><p>Dganit Meidan from Ben Gurion University will introduce Thouless pumps,.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;gKZK9IGY9wo&quot;</span>, src_location=<span class="string">&quot;3.1-intro&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Hamiltonians-with-parameters"><a href="#Hamiltonians-with-parameters" class="headerlink" title="Hamiltonians with parameters"></a>Hamiltonians with parameters</h1><p>Previously, when studying the topology of systems supporting Majoranas (both the Kitaev chain and the nanowire), we were able to calculate topological properties by studying the bulk Hamiltonian $H(k)$.</p>
<p>There are two points of view on this Hamiltonian. We could either consider it a Hamiltonian of an infinite system with momentum conservation</p>
<p>$$H = H(k) |k\rangle\langle k|,$$</p>
<p>or we could equivalently study a finite system with only a small number of degrees of freedom (corresponding to a single unit cell), and a Hamiltonian which depends on some continuous periodic parameter $k$.</p>
<p>Of course, without specifying that $k$ is the real space momentum, there is no meaning in bulk-edge correspondence (since the edge is an edge in real space), but the topological properties are still well-defined.</p>
<p>Sometimes we want to know how a physical system changes if we slowly vary some parameters of the system, for example a bias voltage or a magnetic field. Because the parameters change with time, the Hamiltonian becomes time-dependent, namely</p>
<p>$$H = H(t).$$</p>
<p>The slow <a href="https://en.wikipedia.org/wiki/Adiabatic_theorem">adiabatic</a> change of parameters ensures that if the system was initially in the ground state, it will stay in the ground state, so that the topological properties are useful.</p>
<p>A further requirement for topology to be useful is the <em>periodicity</em> of time evolution:</p>
<p>$$H(t) = H(t+T).$$</p>
<p>The period can even go to $\infty$, in which case $H(-\infty) = H(+\infty)$. The reasons for the requirement of periodicity are somewhat abstract. If the Hamiltonian has parameters, we’re studying the topology of a <em>mapping</em> from the space of parameter values to the space of all possible gapped Hamiltonians. This mapping has nontrivial topological properties only if the space of parameter values is compact.</p>
<p>For us, this simply means that the Hamiltonian has to be periodic in time.</p>
<p>Of course, if we want systems with bulk-edge correspondence, then in addition to $t$ our Hamiltonian must still depend on the real space coordinate, or the momentum $k$.</p>
<h1 id="Quantum-pumps"><a href="#Quantum-pumps" class="headerlink" title="Quantum pumps"></a>Quantum pumps</h1><p>In the image below (source: Chambers’s Encyclopedia, 1875, via Wikipedia) you see a very simple periodic time-dependent system, an Archimedes screw pump.</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/pumps/Archimedes_screw.jpg" alt></p>
<p>The changes to the system are clearly periodic, and the pump works the same no matter how slowly we use it (that is, change the parameters), so it is an adiabatic tool.</p>
<p>What about a quantum analog of this pump? Turns out it is just as simple as you would think.</p>
<p>Let’s take a one-dimensional region, coupled to two electrodes on both sides, and apply a strong sine-shaped confining potential in this region. As we move the confining potential, we drag the electrons captured in it.</p>
<p>So our system now looks like this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Plot of the potential in the pumping system as a function of coordinate.</span></span><br><span class="line"><span class="comment"># Some part of the leads is shown with a constant potential.</span></span><br><span class="line"><span class="comment"># Regions with E &lt; 0 should be shaded to emulate Fermi sea.</span></span><br><span class="line">A = <span class="number">0.6</span></span><br><span class="line">L = <span class="number">10</span></span><br><span class="line">lamb = (<span class="number">10</span> / <span class="number">5.3</span>) / (<span class="number">2</span> * np.pi)</span><br><span class="line">mu = -<span class="number">0.4</span></span><br><span class="line">mu_lead = -<span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0.0</span>:</span><br><span class="line">        <span class="keyword">return</span> mu_lead</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0.0</span> <span class="keyword">and</span> x &lt;= L:</span><br><span class="line">        <span class="keyword">return</span> mu + A * (<span class="number">1.0</span> - np.cos(x / lamb))</span><br><span class="line">    <span class="keyword">if</span> x &gt; L:</span><br><span class="line">        <span class="keyword">return</span> mu_lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">15</span>, <span class="number">1000</span>)</span><br><span class="line">y = [f(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;k&quot;</span>, lw=<span class="number">1.2</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">2.5</span>, <span class="number">12.5</span>)</span><br><span class="line">plt.ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">y = [i <span class="keyword">if</span> i &lt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> y]</span><br><span class="line">plt.fill_between(</span><br><span class="line">    x, y, <span class="number">0</span>, color=<span class="string">&quot;r&quot;</span>, where=np.array(y) &lt; <span class="number">0.0</span>, alpha=<span class="number">0.5</span>, edgecolor=<span class="string">&quot;k&quot;</span>, lw=<span class="number">1.5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">plt.arrow(<span class="number">2.0</span>, <span class="number">1.25</span>, <span class="number">5</span>, <span class="number">0</span>, head_width=<span class="number">0.15</span>, head_length=<span class="number">1.0</span>, fc=<span class="string">&quot;k&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;$x$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;$U(x)$&quot;</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>It is described by the Hamiltonian</p>
<p>$$H(t) = \frac{k^2}{2m} + A [1 - \cos(x/\lambda + 2\pi t/T)].$$</p>
<p>As we discussed, if we change $t$ very slowly, the solution will not depend on how fast $t$ varies.</p>
<p>When $A \gg 1 /m \lambda^2$ the confining potential is strong, and additionally if the chemical potential $\mu \ll A$, the states bound in the separate minima of the potential have very small overlap.</p>
<p>The potential near the bottom of each minimum is approximately quadratic, so the Hamiltonian is that of a simple Harmonic oscillator. This gives us discrete levels of the electrons with energies $E_n = (n + \tfrac{1}{2})\omega_c$, with $\omega_c = \sqrt{A/m\lambda^2}$ the oscillator frequency.</p>
<p>We can quickly check how continuous bands in the wire become discrete evenly spaced bands as we increase $A$:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.0</span>, phase=<span class="number">0.0</span>, A=<span class="literal">None</span>)</span><br><span class="line">syst = ts_modulated_wire(L=<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Band structure, $A=&#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(p.A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.2</span>, <span class="number">1.3</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>],</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.A: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.A <span class="keyword">in</span> np.linspace(<span class="number">0</span>, <span class="number">0.8</span>, <span class="number">10</span>)&#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$A$&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>So unless $\mu = E_n$ for some $n$, each minimum of the potential contains an integer number of electrons $N$.</p>
<p>Electron wave functions from neighboring potential minima do not overlap, so when we change the potential by one time period, we move exactly $N$ electrons.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;Why are some levels in the band structure flat while some are not?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The flat levels are the ones whose energies are not sensitive to the offset of confining potential.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Destructive interference of the wave functions in neighboring minima suppresses the dispersion.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The flat levels are localized deep in the potential minima, &quot;</span></span><br><span class="line">    <span class="string">&quot;so the bandwidth is exponentially small.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The flat levels correspond to filled states, and the rest to empty states.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The dispersion of the bands in a perodic potential appears &quot;</span></span><br><span class="line">    <span class="string">&quot;when the wave functions from neighboring minima overlap.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Quantization-of-pumped-charge"><a href="#Quantization-of-pumped-charge" class="headerlink" title="Quantization of pumped charge"></a>Quantization of pumped charge</h1><p>As we already learned, integers are important, and they could indicate that something topological is happening.</p>
<p>At this point we should ask ourselves these questions: Is the number of electrons $N$ pumped per cycle topological, or can we pump any continuous amount of charge? How important is it that the potential well of the pump is deep?</p>
<h3 id="Thought-experiment"><a href="#Thought-experiment" class="headerlink" title="Thought experiment"></a>Thought experiment</h3><p>To simplify the counting let’s “dry out” the pump: We can define a procedure that empties the middle region, and pushes $n_L$ extra electrons to the left and $n_R$ electrons to the right.</p>
<p>For example, we can do this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Same plot as above, but now with an extra rectangular barrier in the</span></span><br><span class="line"><span class="comment"># middle, and with arrows both ways showing that the barrier widens.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot of the potential in the pumping system as a function of coordinate.</span></span><br><span class="line"><span class="comment"># Some part of the leads is shown with a constant potential.</span></span><br><span class="line"><span class="comment"># Regions with E &lt; 0 should be shaded to emulate Fermi sea.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot of the potential in the pumping system as a function of coordinate.</span></span><br><span class="line"><span class="comment"># Some part of the leads is shown with a constant potential.</span></span><br><span class="line"><span class="comment"># Regions with E &lt; 0 should be shaded to emulate Fermi sea.</span></span><br><span class="line">A = <span class="number">0.6</span></span><br><span class="line">L = <span class="number">10</span></span><br><span class="line">lamb = (<span class="number">10</span> / <span class="number">5.3</span>) / (<span class="number">2</span> * np.pi)</span><br><span class="line">mu = -<span class="number">0.4</span></span><br><span class="line">mu_lead = -<span class="number">0.8</span></span><br><span class="line">a = <span class="number">4.5</span></span><br><span class="line">b = <span class="number">6.5</span></span><br><span class="line">top = <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0.0</span>:</span><br><span class="line">        <span class="keyword">return</span> mu_lead</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0.0</span> <span class="keyword">and</span> x &lt;= a:</span><br><span class="line">        <span class="keyword">return</span> mu + A * (<span class="number">1.0</span> - np.cos(x / lamb))</span><br><span class="line">    <span class="keyword">if</span> x &gt; a <span class="keyword">and</span> x &lt; b:</span><br><span class="line">        <span class="keyword">return</span> top</span><br><span class="line">    <span class="keyword">if</span> x &gt;= b <span class="keyword">and</span> x &lt;= L:</span><br><span class="line">        <span class="keyword">return</span> mu + A * (<span class="number">1.0</span> - np.cos(x / lamb))</span><br><span class="line">    <span class="keyword">if</span> x &gt; L:</span><br><span class="line">        <span class="keyword">return</span> mu_lead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">15</span>, <span class="number">1000</span>)</span><br><span class="line">y = [f(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(x, y, <span class="string">&quot;k&quot;</span>, lw=<span class="number">1.2</span>)</span><br><span class="line">plt.xlim(-<span class="number">2.5</span>, <span class="number">12.5</span>)</span><br><span class="line">plt.ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">y = [i <span class="keyword">if</span> i &lt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> y]</span><br><span class="line">plt.fill_between(</span><br><span class="line">    x, y, <span class="number">0</span>, color=<span class="string">&quot;r&quot;</span>, where=np.array(y) &lt; <span class="number">0.0</span>, alpha=<span class="number">0.5</span>, edgecolor=<span class="string">&quot;k&quot;</span>, lw=<span class="number">1.5</span>,</span><br><span class="line">)</span><br><span class="line">plt.arrow(a, <span class="number">1.05</span>, -<span class="number">1</span>, <span class="number">0</span>, head_width=<span class="number">0.1</span>, head_length=<span class="number">0.4</span>, fc=<span class="string">&quot;k&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.arrow(b, <span class="number">1.05</span>, +<span class="number">1</span>, <span class="number">0</span>, head_width=<span class="number">0.1</span>, head_length=<span class="number">0.4</span>, fc=<span class="string">&quot;k&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;$x$&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;$U(x)$&quot;</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>A reverse of this procedure does the reverse of course, so it reduces the number of charges on the left and right sides.</p>
<p>Now here comes the trick:</p>
<ol>
<li><p>When the middle region is emptied, the two sides are completely disconnected, and so the number of electrons on either side must be integer for every eigenstate of the Hamiltonian.</p>
</li>
<li><p>Next, if we performed the manipulation adiabatically, then if we start in an eigenstate of the Hamiltonian, we will also end in an eigenstate of the Hamiltonian. This is a consequence of the adiabatic theorem.</p>
</li>
<li><p>In light of 1. and 2., we conclude that in the process of drying the middle out, we pumped an integer number of charges.</p>
</li>
<li><p>Finally, adiabatic manipulation is only possible if the Hamiltonian stays gapped at all times.</p>
</li>
</ol>
<p>Bonus: In our argument we didn’t use the shape or the strength of the potential, so it applies universally to any possible pump.</p>
<p>So without doing any calculations, we can conclude that:</p>
<blockquote>
<p>The number of electrons pumped per cycle of a quantum pump is an integer as long as<br>the bulk of the pump is gapped. Therefore it is a <strong>topological invariant</strong>.</p>
</blockquote>
<h1 id="Counting-electrons-through-reflection"><a href="#Counting-electrons-through-reflection" class="headerlink" title="Counting electrons through reflection."></a>Counting electrons through reflection.</h1><p>The expression for the pumped charge in terms of the bulk Hamiltonian $H(k, t)$ is complicated.</p>
<p>It’s an integral over both $k$ and $t$, called a <strong>Chern number</strong> or in other sources a TKNN integer. Its complexity is beyond the scope of our course, but is extremely important, so we will have to study it… next week.</p>
<p>There is a much simpler way to calculate the same quantity using scattering formalism. From the previous two weeks, recall that we may infer the presence or absence of Majoranas at an end of a system by calculating either $Q = \textrm{sign}[\textrm{Pf},H(0),\textrm{Pf},H(\pi)]$ or $Q=\textrm{sign}\det r$, where $r$ is the reflection matrix from one end of the Majorana wire.</p>
<p>In order to derive the scattering expression, we need to understand how the pumped charge manifests in the reflection matrix.</p>
<p>Let’s start from the case when there’s just one mode in the reservoir. We’ll count the charge pumped by making the reservoir finite but very large.</p>
<p>Now all the levels in the reservoir are quantized, and are standing waves, so they are equal weight superpositions of waves going to the left $\psi_L$ and to the right $\psi_R$,</p>
<p>$$<br>\psi_n = \psi_L(x) + \psi_R(x) \propto \exp(ik_n x) + \exp(-ik_n x + i\phi),<br>$$</p>
<p>where the wave number $k_n$ is of course a function of energy. The relative phase shift $\phi$ is necessary to satisfy the boundary condition at $x=0$, where $\psi_L = r \psi_R$, and so $\exp(i \phi) = r$. The energies of the levels are determined by requiring that the phases of $\psi_L$ and $\psi_R$ also match at $x = -L$.</p>
<p>Now, what happens when we pump one extra charge into the reservoir? All the energy levels are shifted up by one, that is $E_n \rightarrow E_{n+1}$, and accordingly the wave functions also change $\psi_n \rightarrow \psi_{n+1}$.</p>
<blockquote>
<p>We conclude that the charge can only be pumped as the reflection phase $\phi$ advances by $2\pi$.</p>
</blockquote>
<p>It’s very easy to generalize our argument to many modes. For that we just need to sum all of the reflection phase shifts, which means we need to look at the phase of $\det r$.</p>
<p>We conclude that there’s a very compact relation between charge $dq$ pumped by an infinitesimal change of an external parameter and the change in reflection matrix $dr$:</p>
<p>$$<br>dq = \frac{d \log \det r}{2\pi i} = \operatorname{Tr}\frac{r^\dagger dr }{ 2 \pi i}.<br>$$</p>
<p>While we derived this relation only for the case when all incoming particles reflect, and $r$ is unitary, written in form of trace it also holds if there is transmission.<a href="https://arxiv.org/abs/cond-mat/9808347">¹</a></p>
<p>Let’s check if this expression holds to our expectations. If $||r||=1$, this is just the number of times the phase of $\det r$ winds around zero, and it is certainly an integer, as we expected.</p>
<h1 id="Applying-the-topological-invariant"><a href="#Applying-the-topological-invariant" class="headerlink" title="Applying the topological invariant"></a>Applying the topological invariant</h1><p>We’re left with a simple exercise.</p>
<p>We know now how to calculate the pumped charge during one cycle, so let’s just see how it works in practice.</p>
<p>The scattering problem in 1D can be solved quickly, so let’s calculate the pumped charge as a function of time for different values of the chemical potential in the pump.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%opts Path.Q (color=Cycle(values=[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]))</span><br><span class="line">%%opts HLine (color=Cycle(values=[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]) linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_charge</span>(<span class="params">mu</span>):</span></span><br><span class="line">    energy = <span class="number">0.0</span></span><br><span class="line">    phases = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">100</span>)</span><br><span class="line">    p = SimpleNamespace(t=<span class="number">1</span>, mu=mu, mu_lead=mu, A=<span class="number">0.6</span>, omega=<span class="number">0.3</span>)</span><br><span class="line">    syst = modulated_wire(L=<span class="number">100</span>).finalized()</span><br><span class="line">    rs = [</span><br><span class="line">        kwant.smatrix(syst, energy, params=<span class="built_in">dict</span>(p=p)).submatrix(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> p.phase <span class="keyword">in</span> phases</span><br><span class="line">    ]</span><br><span class="line">    wn = -total_charge(rs)</span><br><span class="line">    title = <span class="string">&quot;$\mu=&#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(mu)</span><br><span class="line">    kdims = [<span class="string">r&quot;$t/T$&quot;</span>, <span class="string">r&quot;$q/e$&quot;</span>]</span><br><span class="line">    plot = holoviews.Path(</span><br><span class="line">        (phases / (<span class="number">2</span> * np.pi), wn), kdims=kdims, label=title, group=<span class="string">&quot;Q&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;<span class="string">r&quot;$q/e$&quot;</span>: (-<span class="number">0.5</span>, <span class="number">3.5</span>)&#125;).opts(</span><br><span class="line">        plot=&#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.2</span>, <span class="number">1.3</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>],</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="keyword">lambda</span> p: <span class="string">&quot;Band structure, $A=&#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(p.A),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.0</span>, phase=<span class="number">0.0</span>, A=<span class="number">0.6</span>)</span><br><span class="line">syst = ts_modulated_wire(L=<span class="number">17</span>)</span><br><span class="line">mus = [<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0.9</span>]</span><br><span class="line">HLines = holoviews.Overlay([holoviews.HLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus])</span><br><span class="line">spectrum(syst, p, **kwargs) * HLines + holoviews.Overlay(</span><br><span class="line">    [plot_charge(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus]</span><br><span class="line">).relabel(<span class="string">&quot;Pumped charge&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>In the left plot, we show the band structure, where the different colors correspond to different chemical potentials. The right plot shows the corresponding pumped charge. During the pumping cycle the charge may change, and the relation between the offset $\phi$ of the potential isn’t always linear. However we see that after a full cycle, the pumped charge exactly matches the number of filled levels in a single potential well.</p>
<p>As a final mental exercise about pumps, let’s think about what happens if we disconnect the leads and consider the spectrum of a closed system.</p>
<p>As the periodic potential moves, it tries to increase the energies of all the states at the right of the system and reduce the energy of all the states to the left (that’s what pumping does after all).</p>
<p>So there should be states crossing the bulk band gap. Let’s see if it’s true.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.0</span>, mu_lead=<span class="number">0</span>, A=<span class="number">0.6</span>, omega=<span class="number">0.3</span>, phase=<span class="literal">None</span>)</span><br><span class="line">syst = modulated_wire(L=<span class="number">110</span>).finalized()</span><br><span class="line">phases = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">251</span>)</span><br><span class="line">en = [np.linalg.eigvalsh(syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p))) <span class="keyword">for</span> p.phase <span class="keyword">in</span> phases]</span><br><span class="line">en = np.array(en)</span><br><span class="line">ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>]&#125;</span><br><span class="line">kdims = [<span class="string">r&quot;$t/T$&quot;</span>, <span class="string">r&quot;$E$&quot;</span>]</span><br><span class="line">holoviews.Path((phases / (<span class="number">2</span> * np.pi), en), kdims=kdims)[:, <span class="number">0</span>:<span class="number">1.2</span>].opts(plot=ticks)</span><br></pre></td></tr></table></figure>

<p>Indeed, the levels in the bulk stay flat and have a high degeneracy, but we see that there are also single levels that get pushed across the gap. Since the bulk is homogeneous, these states have to be localized at the edge.</p>
<p>Of course, since we have a finite system, the charge cannot be pumped forever from one end into the other. So the pumping breaks down when you see the edge states crossing the bulk bands. At these moments the charge can flow back through the bulk.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What happens to the dependence of the reflection phase shift on time if we &quot;</span></span><br><span class="line">    <span class="string">&quot;remove one of the reservoirs and leave the other one?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;It becomes constant.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;For most of the cycle it stays the same, but there appear &quot;</span></span><br><span class="line">    <span class="string">&quot;sharp jumps such that the total winding becomes zero.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Nothing changes, since the two ends of the pump are &quot;</span></span><br><span class="line">    <span class="string">&quot;far apart from each other, and the pump is not conducting.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The reflection phase gets a new time dependence with zero winding, unrelated to the original one.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The total pumped charge must become equal to zero since there&#x27;s nowhere to place the charge, but &quot;</span></span><br><span class="line">    <span class="string">&quot;since the pump is insulating, the phase cannot change &quot;</span></span><br><span class="line">    <span class="string">&quot;for most of the cycle unless a sharp resonance appears&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Quantized-charge-and-scattering-invariant"><a href="#Quantized-charge-and-scattering-invariant" class="headerlink" title="Quantized charge and scattering invariant"></a>Quantized charge and scattering invariant</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;6lXRAZ7hv7E&quot;</span>, src_location=<span class="string">&quot;3.1-summary&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Quantum pumps&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w3_pump_QHE/QHEedgestates/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size=<span class="number">150</span></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_hall_bar</span>(<span class="params">L=<span class="number">50</span>, W=<span class="number">10</span>, w_lead=<span class="number">10</span>, w_vert_lead=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a hall bar system. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns finalized kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    L = <span class="number">2</span> * (L // <span class="number">2</span>)</span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line">    w_lead = <span class="number">2</span> * (w_lead // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> w_vert_lead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        w_vert_lead = w_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        w_vert_lead = <span class="number">2</span> * (w_vert_lead // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bar shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (x &gt;= -L / <span class="number">2</span> <span class="keyword">and</span> x &lt;= L / <span class="number">2</span>) <span class="keyword">and</span> (y &gt;= -W / <span class="number">2</span> <span class="keyword">and</span> y &lt;= W / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ax</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        xt, yt = site1.pos</span><br><span class="line">        xs, ys = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (xt + xs) * (yt - ys))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_lead_hop_y</span>(<span class="params">x0</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ay</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">            xt, yt = site1.pos</span><br><span class="line">            xs, ys = site2.pos</span><br><span class="line">            <span class="keyword">return</span> -p.t * np.exp(-<span class="number">1j</span> * p.B * x0 * (yt - ys))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hopping_Ay</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_hop_vert</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(bar, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping_Ax</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt;= y &lt;= w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_onsite = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line"></span><br><span class="line">    sym_lead_vertical = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead_vertical1 = kwant.Builder(sym_lead_vertical)</span><br><span class="line">    lead_vertical2 = kwant.Builder(sym_lead_vertical)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical1</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= -L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical2</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> +L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= +L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_vertical1[lat.shape(lead_shape_vertical1, (-L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical1[lat.neighbors()] = lead_hop_vert</span><br><span class="line">    lead_vertical2[lat.shape(lead_shape_vertical2, (L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical2[lat.neighbors()] = lead_hop_vert</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1)</span><br><span class="line">    syst.attach_lead(lead_vertical2)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1.<span class="built_in">reversed</span>())</span><br><span class="line">    syst.attach_lead(lead_vertical2.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (-<span class="number">1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(-L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line"></span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line">    lead[lat.shape(lead_shape, (-<span class="number">1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_ribbon</span>(<span class="params">W, periodic=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Creates a ribbon with magnetic field through it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If we have periodic boundary conditions, the flux through a single </span></span><br><span class="line"><span class="string">    unit cell is quantized.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -W / <span class="number">2</span> &lt;= y &lt;= W / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        xt, yt = site1.pos</span><br><span class="line">        xs, ys = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (xt - xs) * (yt + ys))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_periodic</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        xt, yt = site1.pos</span><br><span class="line">        xs, ys = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(</span><br><span class="line">            -<span class="number">0.5j</span> * <span class="built_in">int</span>(p.B) * <span class="number">2</span> * np.pi / (W + <span class="number">1</span>) * (xt - xs) * (yt + ys)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym_syst = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym_syst)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line">        syst[lat.neighbors()] = hopping_periodic</span><br><span class="line">        syst[lat(<span class="number">0</span>, -W / <span class="number">2</span>), lat(<span class="number">0</span>, +W / <span class="number">2</span>)] = hopping_periodic</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_corbino</span>(<span class="params">r_out=<span class="number">100</span>, r_in=<span class="number">65</span>, w_lead=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create corbino disk. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, B, phi</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ring shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ring</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        rsq = x ** <span class="number">2</span> + y ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> r_in ** <span class="number">2</span> &lt; rsq &lt; r_out ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crosses_branchcut</span>(<span class="params">hop</span>):</span></span><br><span class="line">        xt, yt = hop[<span class="number">0</span>].pos</span><br><span class="line">        xs, ys = hop[<span class="number">1</span>].pos</span><br><span class="line">        <span class="keyword">return</span> yt &lt; <span class="number">0</span> <span class="keyword">and</span> xt &gt; <span class="number">0.5</span> <span class="keyword">and</span> xs &lt; <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        xt, yt = site1.pos</span><br><span class="line">        xs, ys = site2.pos</span><br><span class="line">        <span class="comment"># Check for correctness!</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (xt - xs) * (yt + ys))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">branchcut_hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hopping(site1, site2, p) * np.exp(<span class="number">1j</span> * p.phi)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ring, (<span class="number">0</span>, r_in + <span class="number">1</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding special hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hops_across_cut</span>(<span class="params">syst</span>):</span></span><br><span class="line">        <span class="keyword">for</span> hop <span class="keyword">in</span> kwant.builder.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat, lat)(syst):</span><br><span class="line">            <span class="keyword">if</span> crosses_branchcut(hop):</span><br><span class="line">                <span class="keyword">yield</span> hop</span><br><span class="line"></span><br><span class="line">    syst[hops_across_cut] = branchcut_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt; y &lt; w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line">    lead[lat.neighbors()] = <span class="keyword">lambda</span> site1, site2, p: -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attach the leads and return the system.</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead, origin=lat(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br></pre></td></tr></table></figure>

<h1 id="Where-do-the-pumped-electrons-come-from-and-go-to"><a href="#Where-do-the-pumped-electrons-come-from-and-go-to" class="headerlink" title="Where do the pumped electrons come from and go to?"></a>Where do the pumped electrons come from and go to?</h1><p>You have just seen that Laughlin’s argument explains the quantization of the Hall conductance in terms of a pump which moves electrons through the bulk of a Hall cylinder, from one edge to the other of the cylinder.</p>
<p>Compare the situation with the simple electron pump which you studied earlier in the lecture. There, the pump moved electrons from one metallic lead to the other. Clearly the pump worked thanks to the availability of electronic states at the Fermi level in the two metallic leads. Otherwise, it would have no electrons to take and no place to drop them. Without the metallic leads, the pump would be like an empty carousel.</p>
<p>When applied to the Hall cylinder, this simple reasoning shows that Laughlin’s argument necessarily implies the presence of <strong>electronic states localized at the edges</strong> of the sample.</p>
<p>It is in fact very easy to convince ourselves that such states must exist. We just need to think again about the classical trajectory of an electron with velocity $v$ moving in a perpendicular magnetic field $B$. This trajectory is a circular orbit with radius given by the cyclotron radius.</p>
<p>What happens to the classical trajectory of an electron when the center of the orbit is too close to the edge of the cylinder, say closer than a cyclotron radius? It is easier drawn than said:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/QHEedgestates/skipping_orbits.svg" alt></p>
<p>The electrons cannot exit the sample, and need to bounce back inside. This creates a so-called <strong>skipping orbit</strong>. In a real sample, there will be a confining electrostatic potential which keeps the electrons inside the Hall bar, or cylinder. The combination of a strong magnetic field in the bulk and a confining potential creates trajectories at the edges which are not closed, but travel along the full extent of the edges.</p>
<blockquote>
<p>On the lower edge there are only left-moving states, and on the upper edge only right moving ones. On each edge there are only states moving in one direction, and the direction is opposite for opposite edges. These strange states obtained at the edges are often referred to as <strong>chiral edge states</strong>.</p>
</blockquote>
<p>The chirality of the edges is determined by the orientation of the magnetic field (out of the plane vs. into the plane), and it would be reversed at both edges if the magnetic field were reversed.</p>
<p>The cartoon above is purely based on classical physics, and needs to be supplemented with quantum considerations before it can give quantitative predictions. We will soon see that the quantum version of the cartoon above can give an explanation of the quantized Hall effect, complementary to Laughlin’s argument.</p>
<p>But before we move on to that, we should realize that the picture above is in fact a manifestation of the <strong>bulk-boundary correspondence</strong>. Chiral edge states could not exist without the bulk of the quantum Hall sample.</p>
<h1 id="A-closer-look-at-the-chiral-edge-states"><a href="#A-closer-look-at-the-chiral-edge-states" class="headerlink" title="A closer look at the chiral edge states"></a>A closer look at the chiral edge states</h1><p>So let’s look at the edges of a Hall system in more detail. Let’s think about the ribbon geometry, that we used when we discussed the Laughlin pump in a Hall cylinder. This time, we will take into account explicitly that the ribbon has a finite width $W$ in the $y$ direction.</p>
<p>In practice, in order to confine the electrons in this region there must be a potential barrier $V(y)$, which has to be added to the Hamiltonian:</p>
<p>$$H=p_y^2+(\hbar k-e B y-\Phi)^2,+V(y).$$</p>
<p>Let’s recall that $k=2\pi n/L$ because of periodic boundary conditions over $x$. We do not really care about the particular shape of the potential. Generically, it will be very flat in the middle of the ribbon and very steep right at its boundaries:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/QHEedgestates/confining_potential.svg" alt></p>
<p>How does the potential affect the energy eigenvalues of $H$? In the bulk of the ribbon, away from the edges, the potential is flat, so we can safely set $V(y)=0$ there. In the bulk, we still get flat Landau levels, with energy $E$ independent of $k$. These are the states corresponding to the cyclotron orbits in the classical sketch shown above.</p>
<p>But let’s now move closer to the edges. That is, let’s consider states which are centered at a position $y_0 = \hbar c k/eB$ which is not more than a few magnetic lengths away from the edges. These states are very sensitive to the confining potential, so their energies will be affected. The precise form of the spectrum is not universal and depends on the particular shape of $V(y)$. In general, however, we expect the energy $E(y_0)$ to increase by an amount proportional to $V(y_0)$ with respect to the original Landau level.</p>
<p>Because $y_0$ is proportional to $k$, this means the states close to the edge will acquire a dependence on $k$. Let’s see if this is true, by plotting $E(k)$ for our ribbon:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.5</span>, B=<span class="number">0.15</span>)</span><br><span class="line">syst = qhe_ribbon(W=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: pi_ticks,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">0.5</span>, <span class="number">0.5</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spectrum(syst, p, **kwargs) * holoviews.HLine(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>You can see that, as a consequence of this bending of the Landau levels, even if the Fermi level is placed in the middle of a bulk gap as in the figure, there are states crossing it. We can associate the levels at negative $k$ with states localized at the bottom edge of the ribbon, and those at positive $k$ with states localized at the top edge. For each edge, there are as many edge states as there are filled Landau levels in the bulk of the system.</p>
<p>The particular shape of the dispersion $E(k)$ will depend on the details of the confining potential (which in this case was an infinite square well). However, close to the Fermi level we can always approximate the dispersion $E(k)$ of the edge states as a straight line. We then obtain, for each edge state, a linear relation between energy and momentum,</p>
<p>$$E = \hbar v (k-k_F).$$</p>
<p>Here $k_F$ is the Fermi momentum, which in the case of our ribbon is equal to $k_F = 2\pi N / L$, with $N$ the number of electrons in the system.</p>
<p>Because the slope of the potential is just the local electric field $\mathcal{E}_y=-\partial_y V(y)$ perpendicular to the edge of the sample, the velocity $v$ of the edge states can be simply interpreted as the <a href="http://en.wikipedia.org/wiki/Guiding_center">drift velocity</a> of a skipping state,</p>
<p>$$v = \mathcal{E}_y/B,.$$</p>
<p>The velocity is opposite at the two edges because the local electric field $\mathcal{E}$ created by the confining potential always points towards the interior of the sample.</p>
<p>An important thing to note is that the presence of edge states does not depend in any way on the particular shape of the sample as well. You can cut a quantum Hall system in any way you want, but as long as it has edges, it will have edge states. To demonstrate this, let’s take a “picture” of the edge states by plotting the local density of states at the Fermi level in a Hall bar.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.6</span>, mu_lead=<span class="number">0.6</span>, B=<span class="number">0.15</span>, phi=<span class="number">0.0</span>)</span><br><span class="line">syst = qhe_hall_bar(L=<span class="number">200</span>, W=<span class="number">100</span>).finalized()</span><br><span class="line">ldos = kwant.ldos(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=[<span class="number">20</span>, <span class="number">20</span>])</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(syst, ldos, num_lead_cells=<span class="number">20</span>, colorbar=<span class="literal">False</span>, ax=ax)</span><br></pre></td></tr></table></figure>

<p>The local density of states beautifully reveals the presence of edge states in the sample. You can see that each filled Landau level produces a maximum in the density of states, which goes all around the edges of the sample. In this case, our simulation had two filled Landau levels in the bulk.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;In the plot above, which edge state moves faster, the one closer to the edge or the one further away ?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;They go at the same velocity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The one more towards the bulk, because it is not slowed by the confining potential.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The one closer to the edge, because the local electric field there is stronger.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;One cannot tell, because it depends on microscopic details.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The drift velocity is given by the ratio of the local electric field and the magnetic field. &quot;</span></span><br><span class="line">    <span class="string">&quot;The slope of the confinement potential increases sharply at the edge, hence the local electric field &quot;</span></span><br><span class="line">    <span class="string">&quot;is stronger there.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="The-harmless-anomaly-of-the-chiral-edges"><a href="#The-harmless-anomaly-of-the-chiral-edges" class="headerlink" title="The harmless anomaly of the chiral edges"></a>The harmless anomaly of the chiral edges</h1><p>The chiral edge states can be described in such simple terms, that you might doubt the fact that they cannot exist without a bulk. After all, couldn’t we just build a theory of a single chiral edge state, neglecting the bulk of the quantum Hall system and the existence of the other edge? Can’t a truly one-dimensional system just show the same behavior of the chiral edge state of the quantum Hall effect?</p>
<p>Let’s consider the equation $E=\hbar v (k-k_F)$ which describes these chiral states. We can imagine that a constant electric field $\mathcal{E}$ can be applied along the edge, pallel to the momentum $k$. (In the Hall cylinder, this can be done by threading a time-dependent flux through the cylinder, as you have seen in the previous part of the lecture).</p>
<p>The momentum $k$ changes according to the equation $\hbar \dot{k} = -e\mathcal{E}$. After a time $t$, the energy of a state with momentum $k$ has changed to $\hbar v (k - k_F - e\mathcal{E}t/\hbar)$. This increase corresponds to a time-dependent shift of the Fermi momentum, $k_F,\to,k_F + e\mathcal{E}t/\hbar$. Recall that $k_F = 2\pi N/L$ where $N$ is the number of electrons, so the rate of change of $k_F$ gives</p>
<p>$$\dot{N} = \mathcal{E}L/\Phi_0,$$</p>
<p>with $\Phi_0=h/e$ a flux quantum! Since the number of electrons is changing, <strong>charge is not conserved</strong>. In particular, after a time such that $\mathcal{E}L t = \Phi_0$, it seems that exactly one electron has popped out of nowhere at the edge.</p>
<p>At this point, you should understand what’s happening. This is just how the Laughlin pump manifests itself if you only look at one edge. The number of electrons at one edge can increase, because electrons are being depleted from the other edge (which is not included in our “theory”) and pumped through the bulk until they appear.</p>
<blockquote>
<p>This property of the edge is referred to as the <strong>chiral anomaly</strong>. The chiral anomaly tells us that we cannot have a consistent theory for a chiral edge state without a bulk, which at the same time conserves electric charge. Chiral edge states, or anything else that exhibits a chiral anomaly, are an example of the bulk edge correspondence, since they can only appear at the edge of a two dimensional system and never in isolation.</p>
</blockquote>
<p>We called the anomaly “harmless” since the non-conservation of charge at the edge has a very simple explanation when the rest of the system is included in the picture. If you ever encounter other “anomalous” theories, it might well be a sign that the system under consideration is only the edge of something else!</p>
<h1 id="Quantization-of-Hall-Conductance-from-edge-states"><a href="#Quantization-of-Hall-Conductance-from-edge-states" class="headerlink" title="Quantization of Hall Conductance from edge states"></a>Quantization of Hall Conductance from edge states</h1><p>To conclude our case about chiral edge states, we will now show that both signatures of the quantum Hall effect can be explained solely in terms of the edge states, as long as the interactions between electrons are neglected. In principle, this exercise can be done in any of the sample geometries that you have seen so far: the 6-terminal Hall bar, the Hall cylinder, and the Corbino geometry. We will choose the last one for the sake of convenience.</p>
<p>So let’s take again our Corbino disk immersed in an external magnetic field. With respect to last time, we now apply a small voltage difference $V$ between the edges, and there is no flux passing through in the middle of the Corbino disk.</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/QHEedgestates/corbino_voltage.svg" alt></p>
<p>In this new drawing, we have also added arrows to indicate that we now know that each edge of the Corbino supports one chiral  state. We cannot resist the temptation of showing you another beautiful plot of the local density of states, showing edge states in the Corbino geometry:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W = <span class="number">60</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, mu=<span class="number">0.9</span>, mu_lead=<span class="number">0.9</span>, B=<span class="number">0.15</span>, phi=<span class="number">0.0</span>)</span><br><span class="line">syst = qhe_corbino(<span class="number">2</span> * W, W).finalized()</span><br><span class="line">ldos = kwant.ldos(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">fig = plt.figure(figsize=[<span class="number">15</span>, <span class="number">15</span>])</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">kwant.plotter.<span class="built_in">map</span>(syst, ldos, num_lead_cells=<span class="number">20</span>, colorbar=<span class="literal">False</span>, ax=ax)</span><br></pre></td></tr></table></figure>

<p>Note how the local density of states for each edge state oscillates between maxima and minima. This is because the edge state wave functions are standing waves which go all around the Corbino disk.</p>
<p>But back to the point. We want to consider the case when the system is in equilibrium, and we ask what are the currents that flow in the system as a consequence of the small applied voltage $V$.</p>
<p>First, $V$ does not determine the presence of a current <em>between the edges</em>. Even though electrons can be injected in the edges, these are separated by the bulk of the system, where due to the position of the Fermi level there are no states available to carry a current. Furthermore, there is no time-dependent flux being threaded through the Corbino disk, so the Laughlin pump is not in motion. Since there is no charge transfer at all in the direction parallel to the applied voltage, we have that the longitudinal conductance $\sigma_L=0$.</p>
<p>However, what is the current $I_\circlearrowleft$ flowing <em>around</em> the ring? Because such a current would flow <em>orthogonally</em> with respect to the applied voltage, it is associated with the Hall conductance, $I_\circlearrowleft= \sigma_H V$.</p>
<p>Let’s first consider the case $V=0$. The Fermi level is then the same at both edges. There are as many electrons going around the ring clockwise on the outer edge, as there are going around counterclockwise on the inner edge. In this case there is no net current flowing around the ring.</p>
<p>A small voltage difference $V$ creates a small imbalance in the electron population between the edges. There will be, say, more electrons running counterclockwise on the inner edge than running clockwise on the outer edge. So we do expect a net current flowing around the ring.</p>
<p>Let’s compute the intensity of the current, it’s quite simple.</p>
<p>Every chiral edge state is a <em>transport channel</em> for the current. Now, the defining property of chiral edge states is that they only allow electrons to travel along the edge in one direction. Electrons have no chance to reverse their velocity, or in other words no chance to <em>backscatter</em>.  This means that chiral edge states are perfect transport channels to carry a current, so they have the highest conductance possible. Quantum mechanics limits the maximum conductance that a single transport channel can have to the value $G_0=e^2/h$, which is the conductance quantum you already met last week. With $n$ of these channels, we obtain precisely</p>
<p>$$I_\circlearrowleft = n ,\frac{e^2}{h} V,.$$</p>
<blockquote>
<p>Thus, the relevant electromagnetic responses, namely the longitudinal and Hall conductivities $\sigma_L=0$ and $\sigma_H=ne^2/h$, can both be derived directly by only considering the chiral edge states.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;At which energy did we set the Fermi level in the density of states plot for the Corbino disk?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;It is impossible to answer on the base of the plot alone, because it depends on the voltages applied to the leads.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Exactly at the same energy as the third Landau level.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Between the second and the third Landau levels.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Between the third and the fourth Landau levels.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;There are three edge states visible in the figure. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence there are three filled Landau levels in the bulk, &quot;</span></span><br><span class="line">    <span class="string">&quot;so the Fermi level lies somewhere above the third, but below the fourth Landau level.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Important-things-to-know-about-edge-states"><a href="#Important-things-to-know-about-edge-states" class="headerlink" title="Important things to know about edge states"></a>Important things to know about edge states</h1><p>The physical picture that we presented this week is very simple, and it is also somewhat simplified.</p>
<p>In the summary video of this week, Bert Halperin from Harvard University will discuss how disorder and interactions enter in the description of the quantum Hall effect, and where the electric current is really carried. In 1982, Bert was the <a href="http://sites.fas.harvard.edu/~phys191r/References/e3/halperin1982.pdf">first to understand</a> that the quantum Hall effect could be explained by the existence of chiral edge states, so we are very happy that you can learn the story directly from him.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;rQs12c-SieE&quot;</span>, src_location=<span class="string">&quot;3.3-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Chiral edge states&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w3_pump_QHE/Laughlinargument/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_corbino</span>(<span class="params">r_out=<span class="number">100</span>, r_in=<span class="number">65</span>, w_lead=<span class="number">10</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create corbino disk. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead, B, phi</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ring shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ring</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        rsq = x ** <span class="number">2</span> + y ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> r_in ** <span class="number">2</span> &lt; rsq &lt; r_out ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crosses_branchcut</span>(<span class="params">hop</span>):</span></span><br><span class="line">        x1, y1 = hop[<span class="number">0</span>].pos</span><br><span class="line">        x2, y2 = hop[<span class="number">1</span>].pos</span><br><span class="line">        <span class="keyword">return</span> y1 &lt; <span class="number">0</span> <span class="keyword">and</span> x1 &gt; <span class="number">0.5</span> <span class="keyword">and</span> x2 &lt; <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="comment"># Check for correctness!</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">branchcut_hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hopping(site1, site2, p) * np.exp(<span class="number">1j</span> * p.phi)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ring, (<span class="number">0</span>, r_in + <span class="number">1</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># adding special hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hops_across_cut</span>(<span class="params">syst</span>):</span></span><br><span class="line">        <span class="keyword">for</span> hop <span class="keyword">in</span> kwant.builder.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat, lat)(syst):</span><br><span class="line">            <span class="keyword">if</span> crosses_branchcut(hop):</span><br><span class="line">                <span class="keyword">yield</span> hop</span><br><span class="line"></span><br><span class="line">    syst[hops_across_cut] = branchcut_hopping</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt; y &lt; w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line">    lead[lat.neighbors()] = <span class="keyword">lambda</span> site1, site2, p: -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment">#### Attach the leads and return the system. ####</span></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line">    syst.attach_lead(lead, origin=lat(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total_charge</span>(<span class="params">value_array</span>):</span></span><br><span class="line">    determinants = [np.linalg.det(s) <span class="keyword">for</span> s <span class="keyword">in</span> value_array]</span><br><span class="line">    charge = np.cumsum(np.angle(determinants / np.roll(determinants, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> charge / (<span class="number">2</span> * np.pi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_ribbon</span>(<span class="params">W, periodic=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Creates ribbon system</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If we have periodic boundary conditions, the flux through a single </span></span><br><span class="line"><span class="string">    unit cell is quantized.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -W / <span class="number">2</span> &lt;= y &lt;= W / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (x1 - x2) * (y1 + y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_periodic</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(</span><br><span class="line">            -<span class="number">1j</span></span><br><span class="line">            * np.pi</span><br><span class="line">            / (W + <span class="number">1</span>)</span><br><span class="line">            * np.<span class="built_in">round</span>((W + <span class="number">1</span>) * p.B / (<span class="number">2</span> * np.pi))</span><br><span class="line">            * (x1 - x2)</span><br><span class="line">            * (y1 + y2)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym_syst = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym_syst)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line">        syst[lat.neighbors()] = hopping_periodic</span><br><span class="line">        syst[lat(<span class="number">0</span>, -W / <span class="number">2</span>), lat(<span class="number">0</span>, +W / <span class="number">2</span>)] = hopping_periodic</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst[lat.neighbors()] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Quantum hall bar codes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhe_hall_bar</span>(<span class="params">L=<span class="number">50</span>, W=<span class="number">10</span>, w_lead=<span class="number">10</span>, w_vert_lead=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Create a hall bar system. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Square lattice, one orbital per site.</span></span><br><span class="line"><span class="string">    Returns kwant system.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments required in onsite/hoppings: </span></span><br><span class="line"><span class="string">        t, mu, mu_lead</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    L = <span class="number">2</span> * (L // <span class="number">2</span>)</span><br><span class="line">    W = <span class="number">2</span> * (W // <span class="number">2</span>)</span><br><span class="line">    w_lead = <span class="number">2</span> * (w_lead // <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> w_vert_lead <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        w_vert_lead = w_lead</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        w_vert_lead = <span class="number">2</span> * (w_vert_lead // <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bar shape</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (x &gt;= -L / <span class="number">2</span> <span class="keyword">and</span> x &lt;= L / <span class="number">2</span>) <span class="keyword">and</span> (y &gt;= -W / <span class="number">2</span> <span class="keyword">and</span> y &lt;= W / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Onsite and hoppings</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * p.t - p.mu</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ax</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        x1, y1 = site1.pos</span><br><span class="line">        x2, y2 = site2.pos</span><br><span class="line">        <span class="keyword">return</span> -p.t * np.exp(-<span class="number">0.5j</span> * p.B * (x1 + x2) * (y1 - y2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_lead_hop_y</span>(<span class="params">x0</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hopping_Ay</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">            x1, y1 = site1.pos</span><br><span class="line">            x2, y2 = site2.pos</span><br><span class="line">            <span class="keyword">return</span> -p.t * np.exp(-<span class="number">1j</span> * p.B * x0 * (y1 - y2))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hopping_Ay</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_hop_vert</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Building system</span></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(bar, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[lat.neighbors()] = hopping_Ax</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attaching leads</span></span><br><span class="line">    sym_lead = kwant.TranslationalSymmetry((-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -w_lead / <span class="number">2</span> &lt;= y &lt;= w_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_onsite = <span class="keyword">lambda</span> site, p: <span class="number">4</span> * p.t - p.mu_lead</span><br><span class="line"></span><br><span class="line">    sym_lead_vertical = kwant.TranslationalSymmetry((<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    lead_vertical1 = kwant.Builder(sym_lead_vertical)</span><br><span class="line">    lead_vertical2 = kwant.Builder(sym_lead_vertical)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical1</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> -L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= -L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_shape_vertical2</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> +L / <span class="number">4</span> - w_vert_lead / <span class="number">2</span> &lt;= x &lt;= +L / <span class="number">4</span> + w_vert_lead / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    lead_vertical1[lat.shape(lead_shape_vertical1, (-L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical1[lat.neighbors()] = lead_hop_vert</span><br><span class="line">    lead_vertical2[lat.shape(lead_shape_vertical2, (L / <span class="number">4</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead_vertical2[lat.neighbors()] = lead_hop_vert</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1)</span><br><span class="line">    syst.attach_lead(lead_vertical2)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead_vertical1.<span class="built_in">reversed</span>())</span><br><span class="line">    syst.attach_lead(lead_vertical2.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    lead[lat.shape(lead_shape, (-<span class="number">1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(-L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead)</span><br><span class="line"></span><br><span class="line">    lead = kwant.Builder(sym_lead)</span><br><span class="line">    lead[lat.shape(lead_shape, (-<span class="number">1</span>, <span class="number">0</span>))] = lead_onsite</span><br><span class="line">    lead[lat.neighbors()] = make_lead_hop_y(L / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    syst.attach_lead(lead.<span class="built_in">reversed</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_sigmas</span>(<span class="params">G</span>):</span></span><br><span class="line">    <span class="comment"># reduce by one dimension G -&gt; G[temp, temp]</span></span><br><span class="line">    temp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    G = G[temp, :]</span><br><span class="line">    G = G[:, temp]</span><br><span class="line">    <span class="comment"># invert R = G^-1</span></span><br><span class="line">    <span class="comment"># find out whether it is a numpy object</span></span><br><span class="line">    r = np.linalg.inv(G)</span><br><span class="line">    <span class="comment"># Voltages follow: V = R I[temp]</span></span><br><span class="line">    V = r @ np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># Completely solved the six terminal system.</span></span><br><span class="line">    <span class="comment"># Consider the 2x2 conductance now: Use I = sigma U</span></span><br><span class="line">    E_x = V[<span class="number">1</span>] - V[<span class="number">0</span>]</span><br><span class="line">    E_y = V[<span class="number">1</span>] - V[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># formula above</span></span><br><span class="line">    sigma_xx = E_x / (E_x ** <span class="number">2</span> + E_y ** <span class="number">2</span>)</span><br><span class="line">    sigma_xy = E_y / (E_x ** <span class="number">2</span> + E_y ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> sigma_xx, sigma_xy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pumping</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    p.mu_lead = p.mu</span><br><span class="line">    phis = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">40</span>)</span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    rs = [kwant.smatrix(syst, energy=<span class="number">0.0</span>, params=<span class="built_in">dict</span>(p=p)).submatrix(<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">for</span> p.phi <span class="keyword">in</span> phis]</span><br><span class="line">    charges = -total_charge(rs)</span><br><span class="line">    style = &#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&quot;aspect&quot;</span>: <span class="string">&quot;square&quot;</span>&#125;</span><br><span class="line">    kdims = [<span class="string">&quot;$\phi/2\pi$&quot;</span>, <span class="string">&quot;$q_&#123;pump&#125;$&quot;</span>]</span><br><span class="line">    title = <span class="string">&quot;$\mu = &#123;:.2&#125;$, $\sigma_H = &#123;:&#125; \cdot e^2/h$&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        p.mu, <span class="built_in">int</span>(<span class="built_in">round</span>(charges[-<span class="number">1</span>]))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> holoviews.Path((phis / (<span class="number">2</span> * np.pi), charges), kdims=kdims, label=title).opts(</span><br><span class="line">        plot=style</span><br><span class="line">    )[:, <span class="number">0</span>:<span class="number">3.1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Ady Stern from the Weizmann Institute of Science will introduce the quantum Hall effect.</p>
<p>Ady thanks Dr. Dan Arav and Gil Novik from the School of Media Studies of the<br>College of Management - Academic Studies for their help in preparing the videos.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;QC3tQT7MD00&quot;</span>, src_location=<span class="string">&quot;3.2-intro&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="The-Hall-effect"><a href="#The-Hall-effect" class="headerlink" title="The Hall effect"></a>The Hall effect</h1><p>We now move on to the quantum Hall effect, the mother of all topological effects in condensed matter physics.</p>
<p>But let’s start from the classical <a href="http://en.wikipedia.org/wiki/Hall_effect">Hall effect</a>, the famous phenomenon by which a current flows perpendicular to an applied voltage, or vice versa a voltage develops perpendicular to a flowing current.</p>
<p>How does one get a Hall effect? The key is to break time-reversal symmetry. A flowing current breaks time-reversal symmetry, while an electric field doesn’t. Hence, any system with a Hall effect must somehow break time-reversal symmetry.</p>
<p>But wait a minute, you might catch me and ask, what about a normal electric current flowing parallel to an electric field? This is what happens in a metal on a regular basis, and a metal does not break time-reversal symmetry.</p>
<p>The key difference there is that such a longitudinal current breaks time-reversal through energy dissipation, which turns into heat that breaks time-reversal by the second law of thermodynamics. A Hall current is special in that it is <strong>dissipationless</strong>. We can drive a Hall current without wasting any energy because the current flows perpendicular to the voltage gradient.</p>
<blockquote>
<p>Thus to get a Hall effect we must somehow break time-reversal symmetry. We will examine the simplest way to achieve this, an external magnetic field.</p>
</blockquote>
<h2 id="How-to-measure-the-Hall-effect"><a href="#How-to-measure-the-Hall-effect" class="headerlink" title="How to measure the Hall effect"></a>How to measure the Hall effect</h2><p>Let’s consider a two dimensional gas of electrons immersed in a strong, perpendicular magnetic field. In particular, we take the following geometry, which is called a Hall bar and is routinely used in experiments:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/hall_bar.svg" alt></p>
<p>The electron gas is contacted by six electrodes, numbered in the figure. We can use this Hall bar geometry set-up to measure the transport characteristics of the gas, as follows.</p>
<p>The transport characteristics are tabulated using the 4 components $\sigma_{xx},\sigma_{yy},\sigma_{xy}$ and $\sigma_{yx}$ of the so-called conductivity tensor. Once we know the conductivity tensor, we can use it to calculate how the current density $\mathbf{j} = (j_x,j_y)$ flows in response to the electric field $\mathbf{E} = (E_x,E_y)$ in the metal, through the equation  </p>
<p>$$j_\alpha=\sum_\beta \sigma_{\alpha\beta}E_{\beta}.$$</p>
<p>By inverting this set of relations between current densities and electric field, we obtain the resistivities $\rho_{xx}, \rho_{xy}, \dots$, which are more often reported in experimental data. Also, in two-dimensional systems there is no real difference between conductance and conductivity (or resistance and resistivity) - they have the same physical units. So the terms are somehow interchangeable.</p>
<p>The way to use the Hall bar device is to drive a current $I$ along the $x$ direction, so that there is a current density $j_x=(I/W)$ where $W$ is the width of the sample. There is no current density in the perpendicular direction.</p>
<p>We can measure the electric field using the Hall bar geometry from the voltage drops between the probes with voltages $V_{1,2,3,4}$.<br>We can then measure the $x$-component of the electric field from the longitudinal voltage drop $V_L\sim (V_1-V_2)$ or  $(V_3-V_4)$ according to the averaged equation </p>
<p>$$E_x \equiv \frac{V_1+V_3-V_2-V_4}{2L}.$$</p>
<p>Similarly, we can measure the $y$-component of the electric field from the  Hall voltage $V_H=(V_1-V_3)$ or $(V_2-V_4)$. Specifically we can calculate the electric field as: </p>
<p>$$E_y \equiv \frac{V_1+V_2-V_4-V_3}{2W}.$$</p>
<p>The Hall bar can only measure the conductance completely for isotropic or rotationally invariant systems. If we rotate the system by 90 degrees we can transform $x\rightarrow y$ and $y\rightarrow -x$. So we expect $\sigma_{xx}=\sigma_{yy}=\sigma_L$, the longitudinal conductance. If we apply this same rotation transformation we conclude that $\sigma_{xy}=-\sigma_{yx}=\sigma_H$, the <em>Hall conductance</em>. </p>
<p>So with rotational invariance the 4 component conductance tensor has only 2 independent components i.e. the longitudinal and Hall conductance. We can calculate these using the two electric fields $E_{x,y}$ that we measure using the Hall bar.<br>To do this, we solve the set of equations $j_y=\sigma_L E_y - \sigma_H E_x=0$ and $j_x=\sigma_L E_x+\sigma_H E_y$ to obtain $\sigma_{L,H}$. We obtain the Hall conductance</p>
<p>$$\sigma_H=\frac{j_x E_y}{E_x^2+E_y^2}.$$</p>
<h1 id="The-classical-Hall-effect-is-a-linear-effect"><a href="#The-classical-Hall-effect-is-a-linear-effect" class="headerlink" title="The classical Hall effect is a linear effect"></a>The classical Hall effect is a linear effect</h1><p>Let’s now try to obtain an alternative expression for the Hall conductance $\sigma_H$ of our Hall bar. In general we expect the electric and magnetic fields present in our Hall bar to apply a force to the electrons, and increase their velocity. </p>
<p>Instead of solving the problem directly, let us make the ansatz that the electrons enter a state, which is obtained from the usual electron ground state by doing a Galilean transformation to a reference frame moving with velocity $\bf{v}$ with respect to the original reference frame.</p>
<p>Since the average velocity of the electrons is $\bf v$ in the original reference frame, the average force on the electrons is </p>
<p>$${\bf F}= e,(\mathbf{E}+\mathbf{v}\times \mathbf{B}).$$</p>
<p>If we want to be a steady state then $\bf F=0$, which means that ${\bf v}= (\mathbf{E}\times \mathbf{B})/B^2$. Since the electrons move with an average velocity $\bf v$, and if $n$ denotes the electron density, we can easily guess that the current density is ${\bf j}=n e {\bf v}=(n e/ B) ,(\mathbf{E}\times \mathbf{z})$.</p>
<blockquote>
<p>Comparing with the previous subsection, we can thus conclude that simply based on Galilean invariance, an electron gas in a magnetic field must have a Hall conductance that is given by </p>
</blockquote>
<p>$$\sigma_H=n e B^{-1}.$$</p>
<p>This relation, which says that $\sigma_H\propto n$, is extremely general in the sense that it does not depend on how the electrons interact with each other or anything else. It is referred to as the Streda relation. If we define the so-called “filling factor” as $\nu=n h/ e B$ the Hall conductance can be written as a multiple of the quantum of conductance as $\sigma_H=\nu \frac{e^2}{h}$.</p>
<p>As you already heard from Ady Stern in the intro video, people have measured the Hall conductance of this exact system to incredible precision. At relatively high density, the Hall conductance of this system behaves itself accordingly and scales linearly with gate voltage, which is tuned to control the density. At low filling factors, one would expect many non-idealities like disorder and interaction to break the Galilean invariance based argument and lead to a Hall conductance $\sigma_H$ that varies from sample to sample and depends on disorder. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;What is the longitudinal conductance for the ideal electron gas in a magnetic field?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Infinity since there are no impurities in the system.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Finite and inversely proportional to the magnetic field like the Hall conductance.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Finite and proportional to density but independent of magnetic field.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Zero since current is perpendicular to electric field.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = <span class="string">&quot;As we saw the velocity is related to the cross-product of the electric and magnetic field.&quot;</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="The-quantum-Hall-effect-experimental-data"><a href="#The-quantum-Hall-effect-experimental-data" class="headerlink" title="The quantum Hall effect: experimental data"></a>The quantum Hall effect: experimental data</h1><p>Instead, a completely unexpected result was measured for the first time by Klaus von Klitzing. Typical experimental data looks like this (taken from M.E. Suddards, A. Baumgartner, M. Henini and C. J. Mellor, <a href="http://iopscience.iop.org/1367-2630/14/8/083015">New J. Phys. 14 083015</a>):</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/QHE.png" alt></p>
<blockquote>
<p>As the average density is varied, the Hall conductance $\sigma_H$ appears to form plateaus at integer filling fractions $\nu=1,2,3,\dots$. These plateaus are incredibly sample independent and occur at the same value in many other materials. At the same time, the longitudinal conductivity appears to vanish except at the transition points between the plateaus. This is the integer “Quantum Hall effect”. </p>
</blockquote>
<p>This setup is easy to try to reproduce numerically, but there’s one complication:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syst = qhe_hall_bar(L=<span class="number">60</span>, W=<span class="number">100</span>, w_lead=<span class="number">90</span>, w_vert_lead=<span class="number">28</span>).finalized()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.3</span>, mu_lead=<span class="number">0.3</span>, B=<span class="literal">None</span>)</span><br><span class="line">Bs = np.linspace(<span class="number">0.02</span>, <span class="number">0.15</span>, <span class="number">200</span>)</span><br><span class="line">num_leads = <span class="built_in">len</span>(syst.leads)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">G</span>(<span class="params">syst, p</span>):</span></span><br><span class="line">    smatrix = kwant.smatrix(syst, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    G = [</span><br><span class="line">        [smatrix.transmission(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_leads)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_leads)</span><br><span class="line">    ]</span><br><span class="line">    G -= np.diag(np.<span class="built_in">sum</span>(G, axis=<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> calculate_sigmas(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sigmasxx, sigmasxy = np.array([G(syst, p) <span class="keyword">for</span> p.B <span class="keyword">in</span> Bs]).T</span><br><span class="line"></span><br><span class="line">kdims = [<span class="string">r&quot;$B^&#123;-1&#125; [a.u.]$&quot;</span>, <span class="string">&quot;$\sigma_&#123;xx&#125;, \sigma_&#123;xy&#125;\,[e^2/h]$&quot;</span>]</span><br><span class="line">plot_xx = holoviews.Path((<span class="number">1</span> / Bs, sigmasxx), label=<span class="string">r&quot;$\sigma_&#123;xx&#125;$&quot;</span>, kdims=kdims).opts(</span><br><span class="line">    style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line">plot_xy = holoviews.Path((<span class="number">1</span> / Bs, sigmasxy), label=<span class="string">r&quot;$\sigma_&#123;xy&#125;$&quot;</span>, kdims=kdims).opts(</span><br><span class="line">    style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(plot_xx * plot_xy).opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">0</span>, <span class="string">&quot;yticks&quot;</span>: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">8</span>))&#125;)</span><br></pre></td></tr></table></figure>

<p>Numerical systems are so good that the longitudinal conductivity always stays low even at the transition.</p>
<p>But other than that small problem everything works just the same.</p>
<h1 id="Quantized-Hall-conductance-from-pumping-Laughlin-argument"><a href="#Quantized-Hall-conductance-from-pumping-Laughlin-argument" class="headerlink" title="Quantized Hall conductance from pumping: Laughlin argument"></a>Quantized Hall conductance from pumping: Laughlin argument</h1><p>Why is the quantized Hall conductance $\sigma_H$ so robust and independent of system details? Clearly there must be a topological argument at play.</p>
<p>Soon after the experimental discovery, Laughlin came up with an elegant argument that mapped the Hall conductance problem to a topological pumping problem and in the process explained the robustness. Let us go through this argument.</p>
<h2 id="The-Corbino-geometry"><a href="#The-Corbino-geometry" class="headerlink" title="The Corbino geometry"></a>The Corbino geometry</h2><p>To start with, we imagine doing the Hall measurement in a system cut out as an annulus, which is referred to as the Corbino disk:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/corbino_flux.svg" alt></p>
<p>We will also try to do the experiment in reverse i.e. apply an electric field along the circumference of the disk and measure the current $I$ in the radial direction, as shown in the figure. The radial current is easy to measure - we just measure the amount of charge $\Delta Q$ transferred between the inner and outer edges of the Corbino geometry and obtain the radial current $I=\Delta Q/\Delta T$, where $\Delta T$ is the time over which this is done.</p>
<p>But how do we apply an electric field in the tangential direction?  The easiest way to do this is to apply a time-dependent magnetic field in the centre of the disc and use the Faraday effect. </p>
<p>We can calculate the electric field from the changing magnetic field using Faraday’s law as $\oint d{\bf{r}\cdot\bf{E}}=\partial_t \Phi$, where $\Phi$ is the magnetic flux resulting from the field in the center of the disk. Assuming that the electric field depends only on the radius $R$ we find that the resulting tangential electric field is given by</p>
<p>$$E(R,t)=\frac{1}{2\pi R},\partial_t \Phi.$$ </p>
<p>Given $I$, we can also calculate the other component of the measurement of the Hall conductance $\sigma_H$ i.e. the radial current density $j=I/(2\pi R)$ at the same radius $R$ as we calculated the electric field. </p>
<p>Now that we know both the circumferential electric field and also the radial current density, the Hall conductance can be measured easily in this geometry as </p>
<p>$$\sigma_H=\frac{j}{E(r,t)}=\frac{I}{\partial_t \Phi}.$$</p>
<p>You might worry that we were a bit simplistic and ignored the longitudinal conductance in this geometry. We could measure the longitudinal conductivity by applying a voltage difference between the inner and outer edges and measuring the resulting radial current $I$. For the remainder of this discussion, we assume that the longitudinal conductivity vanishes as is observed experimentally.</p>
<h2 id="Laughlin-pump"><a href="#Laughlin-pump" class="headerlink" title="Laughlin pump"></a>Laughlin pump</h2><p>We are now ready to present the pumping argument to explain why the low temperature Hall effect is quantized.</p>
<p>To do this, we change the magnetic field in the center of the Corbino disc so that the flux changes by $\Delta \Phi=\Phi_0=h/e$, i.e. a <strong>flux quantum</strong> over the time $\Delta T$. (Note that this flux quantum is only half of the superconducting flux quantum that we were using last week. That’s because now the current is being carried by electrons and not Cooper pairs. It is customary to use the same symbol $\Phi_0$ for both, since they often appear in different contexts). Assuming that we have a system with Hall conductance $\sigma_H$, we obtain the charge transferred as </p>
<p>$$\Delta Q=I \Delta T=\sigma_H, \Delta T, \partial_t\Phi =\sigma_H,\Delta\Phi=\sigma_H, \frac{h}{e}.$$</p>
<p>Writing $\sigma_H=\nu e^2/h$, we obtain $\Delta Q=\nu e$. Since the longitudinal conductance $\sigma_L=0$, we expect the system to be gapped in the bulk of the disc and we expect the entire charge transfer $\Delta Q$ to occur between the edges.</p>
<blockquote>
<p>Since the flux $\Phi$ in the center is a flux quantum $\Phi_0$, the wave functions of the electrons all return to being the same as at $\Phi=0$. Therefore only an integer number of charges $\Delta Q=n e$ can be pumped between the edges. This is Laughlin’s argument for why the Hall conductance must be quantized as</p>
</blockquote>
<p>$$\sigma_{xy}=n e^2/h.$$</p>
<p>What you notice at this point is that we basically have a pump similar to the last unit.</p>
<p>Here an integer number of charges is pumped from one edge to the other as the flux $\Phi$ is increased by $\Phi_0$. As one sees below, one can simulate electrons in a Corbino geometry and check that indeed an integer number of charges is pumped between the edges as the flux $\Phi$ is changed by $\Phi_0$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W = <span class="number">20</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, B=<span class="number">2</span> * np.pi / (W + <span class="number">1</span>), phi=<span class="literal">None</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = qhe_corbino(r_out=<span class="number">2</span> * W, r_in=<span class="number">20</span>, w_lead=<span class="number">10</span>)</span><br><span class="line">mus = np.linspace(<span class="number">0.4</span>, <span class="number">1.4</span>, <span class="number">11</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.mu: plot_pumping(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Experimentally the quantum Hall conductance jumps - what does this mean about the &quot;</span></span><br><span class="line">    <span class="string">&quot;robustness of the Laughlin pumping argument?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The Laughlin argument breaks down because it assumes specific values of the magnetic field.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Laughlin argument assumes there is no longitudinal conductivity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hall conductance is not a topological invariant since it changes.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The flux in the corbino geometry was changed by a value that was not a multiple of the flux quantum.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The key ingredient in the Laughlin argument was that there is no states at the fermi level in &quot;</span></span><br><span class="line">    <span class="string">&quot;the bulk which is equivalent to no longitudinal conductivity&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Landau-levels-a-microscopic-model-for-the-quantum-hall-effect"><a href="#Landau-levels-a-microscopic-model-for-the-quantum-hall-effect" class="headerlink" title="Landau levels: a microscopic model for the quantum hall effect"></a>Landau levels: a microscopic model for the quantum hall effect</h1><p>The general argument so far is great in that it applies to virtually any complicated electron system with interactions and in a real material, but we would probably feel better if we could calculate the Hall conductance directly for some simple system. So let us try to do this for the simplest case of electrons in a magnetic field.</p>
<p>For starters, let us forget about the Corbino disk and just ask what do quantum mechanical electrons do in a magnetic field. </p>
<h2 id="Landau-levels-on-the-back-of-an-envelope"><a href="#Landau-levels-on-the-back-of-an-envelope" class="headerlink" title="Landau levels on the back of an envelope"></a>Landau levels on the back of an envelope</h2><p>We know what classical electrons do in a perpendicular magnetic field: They go around in <em>cyclotron orbits</em>, because of the Lorentz force. The cyclotron radius in a magnetic field of strength $B$ for an electron with velocity $v$ is $r_c = mv/eB$. An electron performing a cyclotron orbit at velocity $v$ has angular momentum $L=mvr_c=eB r^2_c$. In quantum mechanics, however, only orbits with a quantized angular momentum $L=n\hbar$ will be allowed. From the equality $r^2_c = n\hbar/eB$ one obtains that only some discrete values are allowed for the radius, $r_n = \sqrt{n} l_B$, where $l_B = \sqrt{\hbar/eB}$ is called the magnetic length.</p>
<p>All cyclotron orbits, independent of the radius, circle at the same frequency $\omega_c=eB/m$. The energy of the electron in this quantized orbit is equal to $L\omega_c = n\hbar\omega_c$. So the energy spectrum really looks like that of a harmonic oscillator. All the energy levels are also shifted up from zero energy by the zero-point motion of the harmonic oscillator, $\hbar\omega_c/2$. We finally obtain that the allowed energy levels are</p>
<p>$$E_n = \hbar \omega_c ,\left(n+\tfrac{1}{2}\right),.$$</p>
<p>These quantized energy levels of electrons in a magnetic field are called <strong>Landau levels</strong>.</p>
<p>You can put many electrons in the same Landau level: one for every flux quantum of the magnetic flux passing through the system. Therefore Landau levels have a huge degeneracy, proportional to the area of the sample.</p>
<h2 id="Landau-levels-from-the-Hamiltonian"><a href="#Landau-levels-from-the-Hamiltonian" class="headerlink" title="Landau levels from the Hamiltonian"></a>Landau levels from the Hamiltonian</h2><p>Now that we know the answer in advance, we can solve the Schrödinger equation for electrons in a magnetic field without stress. It will still be important to understand the quantum Hall effect in a bit more detail. The Hamiltonian is</p>
<p>$$H=(\textbf{p}-e \textbf{ A})^2.$$ </p>
<p>The vector potential $\bf{A}$ depends on position, which makes this Hamiltonian complicated to solve in general. For a uniform magnetic field, we can make our life easier by choosing a Landau gauge </p>
<p>$$\textbf{A}(x,y)=\hat{\textbf{x}}B y ,$$ </p>
<p>where the vector potential does not depend on $x$. In this gauge, the entire Hamiltonian is translationally invariant along the $x$ direction, and therefore commutes with the corresponding momentum $p_x$. This allows us to choose $p_x=\hbar k$ as a good quantum number, and our two dimensional Hamiltonian reduces to a one dimensional one:</p>
<p>$$H(k)=p_y^2+(\hbar k-e B y)^2.$$</p>
<p>Apart from a shift of the $y$ coordinate by $y_0(k)=\hbar k/eB$, this is exactly the Hamiltonian of a simple harmonic oscillator! Its eigenvalues are the Landau levels, which are independent of $k$. The corresponding wave functions are those of the harmonic oscillator along the $y$ direction, and plane waves with momentum $k$ along the $x$ direction. In the $y$ direction, they are localized in space within a length $\sim l_B$.</p>
<p>This gives us another way to understand the quantized Hall conductance for ideal two dimensional electron gases.</p>
<p>Now, the electron energies are quantized in Landau levels, and if $n$ Landau levels are filled at a given chemical potential, the filling factor is $\nu=n$. The Streda formula then predicts the Hall conductance as $\sigma_H=\nu e^2/h=n e^2/h$. The longitudinal conductivity must vanish since the gapped system does not allow dissipation of energy in the bulk.</p>
<h1 id="Flux-pumping-of-electrons-in-a-Hall-cylinder"><a href="#Flux-pumping-of-electrons-in-a-Hall-cylinder" class="headerlink" title="Flux pumping of electrons in a Hall cylinder"></a>Flux pumping of electrons in a Hall cylinder</h1><p>We can now see explicitly how the Laughlin pumping argument works, starting from the microscopic description of electrons in terms of Landau levels. Starting from the formulas we derived, it is a little difficult to do so in the Corbino geometry, which has an angular symmetry rather than a translational symmetry. It is very easy if we consider the Laughlin pump for electrons in a cylinder:</p>
<p><img src="/2021/01/07/src/w3_pump_QHE/Laughlinargument/hall_cylinder.svg" alt></p>
<p>In fact the cylinder drawn above and the Corbino disk are completely equivalent - you can imagine deforming one into the other. The advantage of the cylinder is that we get to keep our $(x, y)$ coordinates. The Hall cylinder that we considered for Laughlin’s argument is in fact equivalent to a ribbon in the $(x, y)$ plane, with periodic boundary conditions $x\equiv x+L$ in the $x$ direction ($L$ is the circumference of the cylinder).<br>The periodic boundary conditions along the $x$ direction discretize the allowed values of $k$ as $k=2\pi n/L$.</p>
<p>For the Laughlin pumping argument, we need to introduce a flux through the cylinder. Using Stokes’ theorem, we know that the line integral of the vector potential around the cylinder must be equal to the flux passing through it, $\oint \textbf{dr}\cdot\textbf{A(r)}=\Phi$. So we can introduce a flux through the cylinder by choosing our vector potential $\bf{A}$ as </p>
<p>$$\textbf{A}(x,y)=(B y +\Phi/L),\hat{\textbf{x}},,$$ </p>
<p>very similar to the previous calculation. The resulting Hamiltonian for the states labeled by $n$ is  </p>
<p>$$H=p_y^2+\left(\frac{\hbar 2\pi n}{L}-e B y-\frac{e\Phi}{L}\right)^2,.$$</p>
<p>Comparing the above equation to the quantum harmonic oscillator, we see that the harmonic oscillator levels<br>must be centered at </p>
<p>$$y_0(n) = \left(n-\frac{\Phi}{\Phi_0}\right)\frac{h}{e B L},.$$</p>
<blockquote>
<p>We see from this that the Landau level wave-functions are centered around a discrete set of rings at $y_0(n)$ on the cylinder axis that are labelled by the integer $n$.  As $\Phi$ is increased we see that the centers $y_0$ move so that after one flux quantum $\Delta\Phi=\Phi_0=h/e$ all the electrons have moved down by one step along $y$, i.e. $n \rightarrow n-1$. If $n$ Landau levels are filled then a total charge of $\Delta Q=n e$ will be transferred between the edges, in exact accordance with the Laughlin argument.</p>
</blockquote>
<p>We can now look again at the Laughlin pump, monitoring at the same time the Landau levels. You can see that the total pumped charge jumps in integer steps each time a Landau level passes through the Fermi level.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">1.1</span>, <span class="number">1.1</span>],</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-np.pi, np.pi, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="keyword">lambda</span> p: <span class="string">&quot;Landau levels&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">W = <span class="number">20</span></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, B=<span class="number">2</span> * np.pi / (W + <span class="number">1</span>), phi=<span class="literal">None</span>, mu=<span class="literal">None</span>)</span><br><span class="line">syst = qhe_corbino(r_out=<span class="number">2</span> * W, r_in=<span class="number">20</span>, w_lead=<span class="number">10</span>)</span><br><span class="line">sys1 = qhe_ribbon(W, <span class="literal">True</span>)</span><br><span class="line">HLine = holoviews.HLine(<span class="number">0</span>).opts(style=&#123;<span class="string">&quot;linestyle&quot;</span>: <span class="string">&quot;--&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;)</span><br><span class="line">mus = np.linspace(<span class="number">0.4</span>, <span class="number">1.4</span>, <span class="number">11</span>)</span><br><span class="line">hm1 = holoviews.HoloMap(&#123;p.mu: plot_pumping(syst, p) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br><span class="line">hm2 = holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: spectrum(sys1, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>]</span><br><span class="line">)</span><br><span class="line">hm1 + hm2 * HLine</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider a cylinder of height $W$, circumference $L$, subject to a magnetic field $B$, &quot;</span></span><br><span class="line">    <span class="string">&quot;and with 2 Landau levels filled. &quot;</span></span><br><span class="line">    <span class="string">&quot;Approximately, how many electrons does it contain?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [<span class="string">&quot;$2.\,$&quot;</span>, <span class="string">&quot;$2 W/L\,.$&quot;</span>, <span class="string">&quot;$2 B WL / \Phi_0\, $.&quot;</span>, <span class="string">&quot;$ B L^2/\Phi_0\,$.&quot;</span>]</span><br><span class="line">explanation = <span class="string">&quot;Based on the form of the Hamiltonian, $y$ goes from $0$ to $W$ and therefore $n$ goes from 0 to $B W L/\Phi_0$.&quot;</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;2u8_2isyi7o&quot;</span>, src_location=<span class="string">&quot;3.2-summary&quot;</span>, res=<span class="string">&quot;360&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you learned? Ask them below</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Laughlin argument&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w2_majorana/w2_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulation-tweaking-the-nanowire"><a href="#Simulation-tweaking-the-nanowire" class="headerlink" title="Simulation: tweaking the nanowire"></a>Simulation: tweaking the nanowire</h1><p>We have two choices for your coding assignments of this week. Consider the task complete when you finish one of the two.</p>
<p>This is especially true since both of the assignments constitute a complete paper :)</p>
<p>As usual, start by grabbing the notebooks of this week (<code>w2_majorana</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<h2 id="Tilted-magnetic-field"><a href="#Tilted-magnetic-field" class="headerlink" title="Tilted magnetic field"></a>Tilted magnetic field</h2><p>Explore what happens when we change one the important knobs of the nanowire model, the external magnetic field. We studied what happens when $B$ is pointing along the $z$ direction. However, what happens when the magnetic field is tilted?</p>
<p>Generalize the Hamiltonian of the nanowire to the case of a magnetic field with three components $B_x, B_y, B_z$. How do the new terms look like?</p>
<p>Go into the <code>nanowire</code> notebook. Modify the <code>nanowire_chain</code> function to include the magnetic field pointing in general direction.<br>Plot the band structure for different field directions, and compare to the original case of having only $B_z$. What changes?</p>
<p>Compare your results with what you find over here:</p>
<ul>
<li>arXiv:1403.4464</li>
</ul>
<h2 id="From-4-pi-to-2-pi"><a href="#From-4-pi-to-2-pi" class="headerlink" title="From $4\pi$ to $2\pi$."></a>From $4\pi$ to $2\pi$.</h2><p>Now let’s switch to the signatures of Majoranas. The code for these is in the <code>signatures</code> notebook.</p>
<p>How does the $4\pi$-periodic Josephson effect disapper? We argued that we cannot just remove a single crossing. Also periodicity isn’t a continuous variable and cannot just change. So what is happening?</p>
<p>Study the spectrum of a superconducting ring as a function of magnetic field, as you make a transition between the trivial and the topological regimes.</p>
<p>What do you see? Compare your results with the paper below.</p>
<ul>
<li>arXiv:1210.3237</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Majorana nanowire&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><p>As we mentioned, there are really hundreds of papers that use the models and concepts that we used in the lecture.</p>
<p>Here is a small selection of the ones that you may find interesting.</p>
<h3 id="arXiv-1204-2792’"><a href="#arXiv-1204-2792’" class="headerlink" title="arXiv:1204.2792’,"></a>arXiv:1204.2792’,</h3><p><strong>Hint:</strong> Welcome to the real world.</p>
<h3 id="arXiv-1101-5795’"><a href="#arXiv-1101-5795’" class="headerlink" title="arXiv:1101.5795’,"></a>arXiv:1101.5795’,</h3><p><strong>Hint:</strong> Majorana conductance with many modes.</p>
<h3 id="arXiv-1006-4395’"><a href="#arXiv-1006-4395’" class="headerlink" title="arXiv:1006.4395’,"></a>arXiv:1006.4395’,</h3><p><strong>Hint:</strong> To play a nice melody, you just need a keyboard.<br>This paper first showed how Majoranas in wire networks can be moved around</p>
<h3 id="arXiv-1008-0629"><a href="#arXiv-1008-0629" class="headerlink" title="arXiv:1008.0629"></a>arXiv:1008.0629</h3><p><strong>Hint:</strong> Real nanowires are more complicated.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Majoranas&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w2_majorana/signatures/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line">dims = SimpleNamespace(</span><br><span class="line">    G=holoviews.Dimension(<span class="string">r&quot;$G/G_0$&quot;</span>),</span><br><span class="line">    V_bias=holoviews.Dimension(<span class="string">&quot;$V_&#123;bias&#125;$&quot;</span>),</span><br><span class="line">    phi=holoviews.Dimension(<span class="string">r&quot;$\Phi/\Phi_0$&quot;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_system_spectroscopy</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># We apply a magnetic field in all parts of the system</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_sc</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (<span class="number">2</span> * p.t - p.mu_sc) * pauli.s0sz + p.Ez * pauli.sxs0 + p.delta * pauli.s0sx</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_normal</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu_l) * pauli.s0sz + p.Ez * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite_barrier</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu_l + p.Vbarrier) * pauli.s0sz + p.Ez * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The hopping is the same in all subsystems. There is normal hopping and</span></span><br><span class="line">    <span class="comment"># spin orbit interaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.s0sz + <span class="number">1j</span> * p.alpha * pauli.sysz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.chain(norbs=<span class="number">4</span>)</span><br><span class="line">    syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The first subsystem just consists of the tunnel barrier (one site with a</span></span><br><span class="line">    <span class="comment"># potential)</span></span><br><span class="line">    syst[lat(<span class="number">0</span>)] = onsite_barrier</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The second subsystem is a normal lead</span></span><br><span class="line">    <span class="comment"># The translational symmetry makes it semi-infinite.</span></span><br><span class="line">    lead1 = kwant.Builder(</span><br><span class="line">        kwant.TranslationalSymmetry(*lat.prim_vecs), conservation_law=-pauli.s0sz</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># Define a unit cell (in this case the unit cell consists of a single site)</span></span><br><span class="line">    lead1[lat(<span class="number">0</span>)] = onsite_normal</span><br><span class="line">    <span class="comment"># Define the hopping between unitcells</span></span><br><span class="line">    lead1[lat(<span class="number">1</span>), lat(<span class="number">0</span>)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The third subsystem is a superconducting lead. A Majorana bound state</span></span><br><span class="line">    <span class="comment"># can arise at the edge of this system.</span></span><br><span class="line">    lead2 = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">    <span class="comment"># Again: Define a unit cell</span></span><br><span class="line">    lead2[lat(<span class="number">0</span>)] = onsite_sc</span><br><span class="line">    <span class="comment"># Again define hopping between unit cells</span></span><br><span class="line">    lead2[lat(<span class="number">1</span>), lat(<span class="number">0</span>)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a connection between the first subsystem (the tunnel barrier, system name: syst)</span></span><br><span class="line">    <span class="comment"># and the other two subsystems (the normal and the superconducting lead)</span></span><br><span class="line">    syst.attach_lead(lead1)</span><br><span class="line">    syst.attach_lead(lead2)</span><br><span class="line"></span><br><span class="line">    syst = syst.finalized()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_chain</span>(<span class="params">L=<span class="literal">None</span>, periodic=<span class="literal">False</span></span>):</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        L = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">onsite, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu) * pauli.szs0 + p.B * pauli.s0sz + p.delta * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        syst[lat(x)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 - <span class="number">0.5j</span> * p.alpha * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping_with_flux</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        phase = np.exp(<span class="number">1j</span> * p.flux / <span class="number">2</span>)</span><br><span class="line">        phase_factors = np.kron(np.diag([phase, phase.conj()]), pauli.s0)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.7</span> * phase_factors @ hop(site1, site1, p)</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line">        syst[lat(<span class="number">0</span>), lat(L - <span class="number">1</span>)] = hopping_with_flux</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tunnel_spectroscopy</span>(<span class="params">syst, p, Es</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Andreev_cond</span>(<span class="params">E</span>):</span></span><br><span class="line">        sm = kwant.smatrix(syst, energy=E, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">        <span class="comment"># (i, j) means we call for block j of lead i in the scattering matrix.</span></span><br><span class="line">        <span class="comment"># The normal lead is i = 0 here, where block j = 0 corresponds to electrons</span></span><br><span class="line">        <span class="comment"># and block j = 1 holes.</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            sm.submatrix((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>)).shape[<span class="number">0</span>]</span><br><span class="line">            - sm.transmission((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">            + sm.transmission((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    Gs = [Andreev_cond(E) <span class="keyword">for</span> E <span class="keyword">in</span> Es]</span><br><span class="line">    <span class="keyword">return</span> np.array(Gs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_spectroscopy</span>(<span class="params">Vbarrier</span>):</span></span><br><span class="line">    syst = make_system_spectroscopy()</span><br><span class="line">    Es = np.linspace(-<span class="number">0.15</span>, <span class="number">0.15</span>, <span class="number">101</span>)</span><br><span class="line">    p = SimpleNamespace(</span><br><span class="line">        t=<span class="number">1</span>, mu_l=<span class="number">0.5</span>, mu_sc=<span class="number">0</span>, alpha=<span class="number">0.15</span>, delta=<span class="number">0.1</span>, Vbarrier=Vbarrier</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Trivial, because the magnetic field is zero (third argument)</span></span><br><span class="line">    p.Ez = <span class="number">0</span></span><br><span class="line">    Gs_trivial = tunnel_spectroscopy(syst, p, Es)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Non-trivial</span></span><br><span class="line">    p.Ez = <span class="number">0.25</span></span><br><span class="line">    Gs_topological = tunnel_spectroscopy(syst, p, Es)</span><br><span class="line">    kdims = [dims.V_bias, dims.G]</span><br><span class="line">    plot = holoviews.Path((Es, Gs_trivial), kdims=kdims, label=<span class="string">&quot;trivial&quot;</span>).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    plot *= holoviews.Path((Es, Gs_topological), kdims=kdims, label=<span class="string">&quot;topological&quot;</span>).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    style_overlay = &#123;</span><br><span class="line">        <span class="string">&quot;xticks&quot;</span>: [-<span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.1</span>],</span><br><span class="line">        <span class="string">&quot;yticks&quot;</span>: [<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">1.5</span>, <span class="number">2.0</span>],</span><br><span class="line">        <span class="string">&quot;show_legend&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;legend_position&quot;</span>: <span class="string">&quot;top&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fig_size&quot;</span>: <span class="number">150</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    style_path = &#123;<span class="string">&quot;show_legend&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=&#123;<span class="string">&quot;Overlay&quot;</span>: style_overlay, <span class="string">&quot;Path&quot;</span>: style_path&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_spectrum</span>(<span class="params">trivial=<span class="literal">False</span></span>):</span></span><br><span class="line">    B = <span class="number">0.2</span> <span class="keyword">if</span> trivial <span class="keyword">else</span> <span class="number">1.0</span></span><br><span class="line">    p = SimpleNamespace(mu=<span class="number">0.4</span>, t=<span class="number">1.0</span>, alpha=<span class="number">0.2</span>, delta=<span class="number">0.1</span>, B=B)</span><br><span class="line">    syst = nanowire_chain(L=<span class="number">100</span>, periodic=<span class="literal">True</span>).finalized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">energy</span>(<span class="params">flux</span>):</span></span><br><span class="line">        p.flux = flux</span><br><span class="line">        H = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">        <span class="keyword">return</span> np.linalg.eigvalsh(H)</span><br><span class="line"></span><br><span class="line">    fluxes = np.linspace(<span class="number">0</span>, <span class="number">4</span> * np.pi, <span class="number">51</span>)</span><br><span class="line">    spectrum = np.array([energy(flux) <span class="keyword">for</span> flux <span class="keyword">in</span> fluxes])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the two subgap states.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trivial:</span><br><span class="line">        N = spectrum.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line">        non_trivial = np.where((fluxes &gt; np.pi) &amp; (fluxes &lt; <span class="number">3</span> * np.pi))</span><br><span class="line">        spectrum[non_trivial, N - <span class="number">1</span> : N + <span class="number">1</span>] = spectrum[</span><br><span class="line">            non_trivial, N : N - <span class="number">2</span> : -<span class="number">1</span></span><br><span class="line">        ].copy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fluxes, spectrum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_spectrum_nanowire</span>(<span class="params">fluxes, spectrum, ylim=[-<span class="number">0.2</span>, <span class="number">0.2</span>]</span>):</span></span><br><span class="line">    N = spectrum.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line">    kdims = [dims.phi, <span class="string">&quot;$E$&quot;</span>]</span><br><span class="line">    plot = holoviews.Path((fluxes, spectrum), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>, <span class="string">&quot;alpha&quot;</span>: <span class="number">0.4</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    plot *= holoviews.Path((fluxes, spectrum[:, N - <span class="number">1</span>]), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    plot *= holoviews.Path((fluxes, spectrum[:, N]), kdims=kdims).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;k&quot;</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (<span class="number">2</span> * np.pi, <span class="string">&quot;1&quot;</span>), (<span class="number">4</span> * np.pi, <span class="string">&quot;2&quot;</span>)]&#125;</span><br><span class="line">    <span class="keyword">return</span> plot.redim.<span class="built_in">range</span>(**&#123;<span class="string">&quot;$E$&quot;</span>: (-<span class="number">0.11</span>, <span class="number">0.11</span>)&#125;).opts(plot=ticks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_gse_sc_nanowire</span>(<span class="params">fluxes, spectrum</span>):</span></span><br><span class="line">    N = spectrum.shape[<span class="number">1</span>] // <span class="number">2</span></span><br><span class="line">    energy_gs = np.<span class="built_in">sum</span>(spectrum[:, :N], axis=<span class="number">1</span>)</span><br><span class="line">    energy_gs -= np.<span class="built_in">max</span>(energy_gs)</span><br><span class="line">    current = np.diff(energy_gs) * <span class="built_in">len</span>(energy_gs)</span><br><span class="line"></span><br><span class="line">    xdim = dims.phi</span><br><span class="line">    ydim = <span class="string">r&quot;$E_&#123;tot&#125;(\Phi)$&quot;</span></span><br><span class="line"></span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: [(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), (<span class="number">2</span> * np.pi, <span class="string">&quot;1&quot;</span>), (<span class="number">4</span> * np.pi, <span class="string">&quot;2&quot;</span>)]&#125;</span><br><span class="line">    plot = holoviews.Path((fluxes, energy_gs), kdims=[xdim, ydim], label=<span class="string">&quot;Energy&quot;</span>).opts(</span><br><span class="line">        plot=ticks</span><br><span class="line">    )</span><br><span class="line">    ydim = <span class="string">r&quot;$I(\Phi)$&quot;</span></span><br><span class="line">    plot += holoviews.Path(</span><br><span class="line">        ((fluxes[<span class="number">1</span>:] + fluxes[:-<span class="number">1</span>]) / <span class="number">2</span>, current), kdims=[xdim, ydim], label=<span class="string">&quot;Current&quot;</span></span><br><span class="line">    ).opts(plot=ticks)</span><br><span class="line">    <span class="keyword">return</span> plot</span><br></pre></td></tr></table></figure>

<h1 id="How-to-detect-Majoranas"><a href="#How-to-detect-Majoranas" class="headerlink" title="How to detect Majoranas"></a>How to detect Majoranas</h1><p>Our second guest lecturer for this week is Carlo Beenakker, from Leiden University.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;WAhNblNbadA&quot;</span>, src_location=<span class="string">&quot;2.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Andreev-reflection"><a href="#Andreev-reflection" class="headerlink" title="Andreev reflection"></a>Andreev reflection</h1><p>To understand how conductance through a Majorana works, we first have to learn how charge is transferred from a metallic lead to a superconductor. In general this transfer takes place via a mechanism known as Andreev reflection. Before we discuss the conductance signatures of a Majorana zero mode, it is useful to learn what Andreev reflection is.</p>
<p>Let’s consider the following very simple circuit with two electrodes:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/ns_interface.svg" alt></p>
<p>One electrode is a normal metal, the other a superconductor, and they are kept at a voltage difference $V$. At the interface between the normal metal and the superconductor (in short, NS interface) there is a barrier. We are particularly interested in the case when the voltage difference is very small compared to the energy gap in the superconductor, $eV &lt; \Delta$, where $e$ is the charge of the electron.</p>
<p>What happens when electrons arrive at the interface with superconductor? The superconductor has no states available up to an energy $\Delta$ around the Fermi level, and the voltage is not enough to provide for this energy difference. How can a current develop?</p>
<p>To understand this, let’s look more closely at an electron arriving at the interface with the superconductor. There are two possible processes that can take place, <em>normal reflection</em> and <em>Andreev reflection</em>. In normal reflection, the electron is simply reflected at the interface with the superconductor:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/normal_reflection.svg" alt></p>
<p>With normal reflection, there is no net charge transfer from the left electrode to the right electrode. Hence this process does not contribute any net current. Normal reflection obviously doesn’t even require a superconductor and would take place also if the right electrode was normal.</p>
<p>Andreev reflection, instead, is unique to the NS interface. In Andreev reflection, an electron is converted to a hole by the superconductor, and a Cooper pair is created in the superconductor.</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/andreev_reflection.svg" alt></p>
<p>You can see that a net charge of $2e$ is transferred from the left to the right electrode, and at low voltages Andreev reflection is the only process responsible for the electrical current.</p>
<p>Above the superconducting gap, $eV &gt; \Delta$ transmission of an incident electron into the superconductor also contributes to the current.</p>
<p>You can also think of Andreev <em>reflection</em> as a <em>transmission</em> problem. Because of the presence of the superconductor, both electrons and holes participate in the transfer of charge in the normal metal lead. Conceptually, you can imagine to separate the left lead into two leads, one only carrying electrons and one only carrying holes. These two leads are connected by the superconductor, which converts incoming electrons in the first lead into outgoing holes in the second lead, and viceversa:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/andreev_as_transmission.svg" alt></p>
<p>With this picture, you can understand that Andreev reflection is very similar to the problem of transmission through a double barrier.</p>
<p>Let’s call $r_{eh}$ the amplitude for Andreev reflection. Its absolute value squared, $\left|r_{eh}\right|^2$, is the probability that an incoming electron from the normal metal is Andreev reflected as a hole. Once we know $r_{eh}$, we can compute the conductance $G(V)$, which relates the current $I$ that develops as a response to a small voltage $V$, $G(V) = dI/dV$. The conductance is given by the following formula:</p>
<p>$$G(V)=2G_0|r_{eh}|^2.$$</p>
<p>We will not derive this equation, since it can be understood intuitively. The conductance is proportional to the probability $|r_{eh}|^2$ of Andreev reflection, since we know that at low voltages this is the only process that transfers electric charge from the left to the right electrode.</p>
<p>The factor of $2$ is due to each Andreev reflection transferring a charge of a Cooper pair, $2e$. Finally, $G_0=e^2/h$ is the <strong>conductance quantum</strong>, the fundamental proportionality constant which relates currents to voltages.</p>
<h1 id="Andreev-reflection-off-a-Majorana-zero-mode"><a href="#Andreev-reflection-off-a-Majorana-zero-mode" class="headerlink" title="Andreev reflection off a Majorana zero mode"></a>Andreev reflection off a Majorana zero mode</h1><p>Now that we understand a conventional NS interface, let’s see what happens if our superconductor is topological:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/ns_majorana_interface.svg" alt></p>
<p>You can imagine that the superconducting electrode is now a nanowire in the topological phase, like the one you have just studied. Because the superconductor is topological, there is a Majorana mode at the NS interface, whose wave function will “leak” a bit into the normal metal, through the barrier. Of course, there will be also a second Majorana mode, but we place it far enough from the NS interface, so that it does not have a role in the transport. Does the Majorana zero mode at the interface change the Andreev reflection properties?</p>
<p>Yes, and in a rather drastic way. Going back to the picture of Andreev reflection as a transmission process through a double barrier, the crucial difference is that the Majorana mode now appears as a bound state between the two barriers:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/resonant_transmission_through_majorana.svg" alt></p>
<p>In the double barrier problem in quantum mechanics, you can have <strong>resonant</strong> transmission in the presence of a bound state. This means that the probability $\left|r_{eh}\right|^2$ to pass through the barriers is dramatically enhanced if the energy of the incident electron matches the energy of the bound state. In our case, the energy of the incident electron is $V$, and the energy of the bound state, the Majorana mode, is zero. So the presence of the Majorana mode leads to a <strong>resonant peak</strong> in the conductance of the NS interface at $V=0$.</p>
<h1 id="Quantization-of-the-Majorana-resonance"><a href="#Quantization-of-the-Majorana-resonance" class="headerlink" title="Quantization of the Majorana resonance"></a>Quantization of the Majorana resonance</h1><p>Seeing the resonant peak is the most direct way we know to measure the presence of a Majorana zero mode.</p>
<p>However, the presence of a resonance associated with Majorana modes is not uniquely topological, because tunneling into any low energy bound state produces resonance.</p>
<p>Is there anything in particular which distinguishes the Majorana resonance from any other resonance?</p>
<p>Let’s just look at what happens if we compare conductance of an NS interface in the cases when S is trivial and non-trivial, and see how the conductance changes as we alter the tunnel barrier strength.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;V: plot_spectroscopy(V) <span class="keyword">for</span> V <span class="keyword">in</span> np.arange(<span class="number">1</span>, <span class="number">4.25</span>, <span class="number">0.25</span>)&#125;,</span><br><span class="line">    kdims=[<span class="string">r&quot;$V_&#123;barrier&#125;$&quot;</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>We see a very robust and persistent characteristic:<br>the peak height of the Majorana resonance is quantized to the value of $2G_0$, independent of the strength of the voltage barrier. From the formula above, this means that if a Majorana is present we have $\left|r_{eh}\right|^2=1$, that is we have <strong>perfect Andreev reflection</strong>.</p>
<p>To understand why it is robust, we need to go beyond drawing cartoon figures.</p>
<h2 id="Reflection-matrix-of-a-normal-metal-superconductor-interface"><a href="#Reflection-matrix-of-a-normal-metal-superconductor-interface" class="headerlink" title="Reflection matrix of a normal metal-superconductor interface"></a>Reflection matrix of a normal metal-superconductor interface</h2><p>Quantum-mechanically, we can describe transport through the NS interface as a scattering problem. An incoming wave function $\Psi_\textrm{in}$ propagates in the left electrode, until it is reflected back at the interface with the superconductor, turning into an outgoing wave function $\Psi_\textrm{out}$. Because of the presence of the superconductor, both the incoming and outgoing states can be electrons $\Psi_e$ or holes $\Psi_h$. At <strong>zero energy</strong>, they are related to each other by particle-hole symmetry:</p>
<p>$$\Psi_e(E) = \mathcal{P},\Psi_h(-E),$$</p>
<p>The reflection enforces a linear relation between incoming and ingoing waves:</p>
<p>$$\Psi_\textrm{out} = r(V) ,\Psi_\textrm{in},$$</p>
<p>$$r(V)=\left(\begin{array}{cc}r_{ee}&amp;r_{eh}\r_{he}&amp;r_{hh}\end{array}\right).$$</p>
<p>The matrix $r$ is known as the <strong>reflection matrix</strong>. Its complex elements are the amplitudes of normal and Andreev reflection of an incoming electron - $r_{ee}$ and $r_{eh}$ - and normal and Andreev reflection of an incoming hole - $r_{hh}$ and $r_{he}$. (For brevity we don’t write out explicitly that each of those depends on $V$.)</p>
<p>If there is more than one incoming electron state (in our case there are two due to spin), all 4 elements of $r$ become matrices themselves. They then describe scattering between all the possible incoming and outgoing states.</p>
<p>Because for $eV\ll \Delta$ there are no propagating waves in the superconductor, the reflection process which relates $\Psi_\textrm{out}$ and $\Psi_\textrm{in}$ is unitary, $r^\dagger r=1$. This implies that</p>
<p>$$\left|r_{ee}\right|^2+\left|r_{eh}\right|^2 = \left|r_{he}\right|^2+\left|r_{hh}\right|^2 = 1,.$$</p>
<p>This is the mathematical way of saying that an electron (or hole) arriving at the interface has no alternatives other than being normal-reflected or Andreev-reflected.</p>
<p>Can we add any other constraint to $r$, that might help to distinguish any characteristic of the Majorana mode? Just like we did last week, let’s try to study $r$ using symmetry and topology. Our circuit involves a superconductor, so we must have particle-hole symmetry in the problem.</p>
<p>In order to derive $r$ explicitly we could start directly from the Bogoliubov-de Gennes Hamiltonian of the NS system, and solve it for an energy $V$. This is a lot of work, which we won’t do, but knowing this fact we can understand the consequences of particle-hole symmetry for $r$.</p>
<p>First, particle-hole symmetry exchanges electrons and hole components of the wave function, so it involves a Pauli matrix $\tau_x$ acting on $\Psi_\textrm{in}$ or $\Psi_\textrm{out}$. Second, it is an anti-unitary symmetry, so it involves complex conjugation. Third, it changes the sign of the energy so it sends $V$ into $-V$. Hence we arrive at the following symmetry for the reflection matrix:</p>
<p>$$\tau_x r^*(-V) \tau_x = r(V),.$$</p>
<p>Together with unitarity, particle-hole symmetry imposes that the conductance is symmetric around zero voltage, $G(V)=G(-V)$. In the most interesting point, $V=0$ we have:</p>
<p>$$ \tau_x r^*_0 \tau_x = r_0 ,.$$</p>
<p>where we defined $r_0\equiv r(V=0)$. So much for the impact of symmetry on $r$. What about topology?</p>
<h1 id="Topological-invariant-of-the-reflection-matrix"><a href="#Topological-invariant-of-the-reflection-matrix" class="headerlink" title="Topological invariant of the reflection matrix"></a>Topological invariant of the reflection matrix</h1><p>The Majorana zero mode is the consequence of a topological phase in the topological superconductor, and its presence is dictated by the bulk-boundary correspondence. Can we find any consequence of this fact in $r_0$? It turns out that reflection matrices $r$ with particle-hole symmetry are also topological in their own way. Their topological invariant is </p>
<p>$$Q = \det,r_0,.$$</p>
<p>Again, we will not <em>derive</em> this equation, but rather convince ourselves this expression is correct.</p>
<p>First of all, the determinant of a unitary matrix such as $r_0$ is always a complex number with unit norm, so $\left|\det,r_0,\right|=1$. Second, because of particle-hole symmetry, the determinant is real: $\det r_0 = \det, (\tau_x r^<em>_0,\tau_x) = \det,r_0^*,=(\det,r_0)^</em>$. Hence, $\det,r_0,= \pm 1$. This is quite promising! Two possible discrete values, just like the Pfaffian invariant of the Kitaev chain.</p>
<p>Because it is just dictated by unitarity and particle-hole symmetry, the determinant of $r_0$ cannot change from $+1$ to $-1$ under a change of the properties of the NS interface. For instance, you can vary the height of the potential barrier at the interface, but this cannot affect the determinant of $r_0$.</p>
<p>The only way to make the determinant change sign is to close the bulk gap in the superconducting electrode. If the gap goes to zero, then it is not true that an incoming electron coming from the normal metal can only be normal-reflected or Andreev-reflected. It can also just enter the superconducting electrode as an electron. Hence the reflection matrix no longer contains all the possible processes taking place at the interface, and it won’t be unitary anymore. This allows the determinant to change sign. We conclude that $Q=\det,r$ is a good topological invariant.</p>
<p>Explicitly, we have that</p>
<p>$$Q=|r_{ee}|^2-|r_{eh}|^2\equiv\pm 1,.$$</p>
<p>We already saw that unitarity requires that $|r_{ee}|^2+|r_{eh}|^2=1$. There are only two possibilities for both conditions to be true: either $|r_{ee}|=1$ (<strong>perfect  normal reflection</strong>) or $|r_{eh}|=1$ (<strong>perfect Andreev reflection</strong>). The situation cannot change without a phase transition. Thus the quantized conductance of the Majorana mode is topologically robust in this case, and in fact survives past the tunneling limit. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Imagine we replace the superconducting electrode with an insulating material, &quot;</span></span><br><span class="line">    <span class="string">&quot;and imagine that at the interface with the normal metal there is a bound state. &quot;</span></span><br><span class="line">    <span class="string">&quot;How is the current through the interface different with respect &quot;</span></span><br><span class="line">    <span class="string">&quot;to that through an NS interface with a Majorana?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;It is not quantized but still non-zero.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is zero because there cannot be Andreev reflection without a superconductor.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It is not symmetric in voltage but it is still non-zero.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It has a resonance peak whose width is independent of the barrier strength.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;A current requires an exit path for the charge. &quot;</span></span><br><span class="line">    <span class="string">&quot;No current can flow through the insulator, since there are no excitations at the Fermi level in an insulator. &quot;</span></span><br><span class="line">    <span class="string">&quot;A superconductor is also gapped with respect to excitations, but is different than a normal insulator. &quot;</span></span><br><span class="line">    <span class="string">&quot;It has a condensate of Cooper pairs, so a current can develop thanks to Andreev reflection at the interface.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Flux-induced-fermion-parity-switch-in-topological-superconductors"><a href="#Flux-induced-fermion-parity-switch-in-topological-superconductors" class="headerlink" title="Flux-induced fermion parity switch in topological superconductors"></a>Flux-induced fermion parity switch in topological superconductors</h1><p>How do we probe the Pfaffian topological invariant of a topological superconductor directly? Last week, we introduced a thought-experiment where we probed the bulk-edge correspondence of Majorana modes by changing the sign of the hopping across a bond. The non-trivial value of the topological invariant results in a fermion parity switch as a result of the change in sign of the hopping $t$ across the junction i.e. </p>
<p>$$t\rightarrow -t.$$</p>
<p>It turns out that the sign change in the hopping across the junction might also be obtained by introducing a magnetic flux through the superconducting ring (similar to the <a href="http://en.wikipedia.org/wiki/Aharonov-Bohm_effect">Aharonov-Bohm effect</a>). The role of the special bond is now played by a Josephson junction, which is just an insulating barrier interrupting the ring, as in the following sketch:</p>
<p><img src="/2021/01/07/src/w2_majorana/signatures/josephson_majorana_ring.svg" alt></p>
<p>How does the magnetic flux enter the Hamiltonian? By following the usual argument for introducing magnetic fields into lattice Hamiltonians using <a href="http://topocondmat.org/w2_majorana/Peierls.html">Peierls substitution</a>, the flux $\Phi$ can be accounted for simply by changing the phase of the hopping across the junction in the ring:</p>
<p>$$t,\to,t,\exp (i\phi/2).$$</p>
<p>Here, $\phi = 2\pi\Phi/\Phi_0$ is usually called the <strong>superconducting phase difference</strong> across the junction, and $\Phi_0=2e/h$ is the <strong>superconducting flux quantum</strong>. Notice that when $\Phi=\Phi_0$ the hopping changes sign: $t ,\to, \exp (i\pi) t = -t$, exactly as we had last week!</p>
<blockquote>
<p>Thus, the introduction of a flux quantum $\Phi=\Phi_0$, changes the sign of the hopping $t\rightarrow t e^{i\phi}=-t$, which as discussed last week changes the fermion parity of the ground state for topological superconductors. This fermion parity switch is related to a pair of Majorana modes coupled at the junction (as in the figure above).</p>
</blockquote>
<p>To see how this happens explicitly, let’s look at the spectrum of a topological superconducting ring as a function of flux,  obtained using our nanowire model:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fluxes, spectrum = nanowire_spectrum()</span><br><span class="line">plot_spectrum_nanowire(fluxes, spectrum)</span><br></pre></td></tr></table></figure>

<p>Staring at the spectrum we see that, lo and behold, the fermion parity switch appears, around $\Phi=\Phi_0/2$. Can we measure this fermion parity switch in our superconducting ring?</p>
<h1 id="Detecting-the-fermion-parity-switch-using-the-Josephson-effect"><a href="#Detecting-the-fermion-parity-switch-using-the-Josephson-effect" class="headerlink" title="Detecting the fermion parity switch using the Josephson effect"></a>Detecting the fermion parity switch using the Josephson effect</h1><p>The change in fermion parity of the ground state can be detected using the so-called <a href="http://en.wikipedia.org/wiki/Josephson_effect">Josephson effect</a>. The Josephson current can be computed from the expectation value of the derivative of the energy operator with respect to flux,</p>
<p>$$I(\Phi)=\frac{1}{2}\frac{d E_\textrm{tot}(\Phi)}{d \Phi},$$</p>
<p>where $E_\textrm{tot}(\Phi)=\left\langle H_{BdG}(\Phi)\right\rangle$ is the total energy of the system corresponding to the BdG Hamiltonian $H_{BdG}(\Phi)$. </p>
<blockquote>
<p>The key idea to detecting the ground state fermion parity switch is to note that changing the flux $\Phi$ adiabatically cannot change the fermion parity of the system. If you start with the system in the ground state and advance the magnetic flux from $\Phi$ to $\Phi+\Phi_0$, you end up in an excited state, because in the meantime the fermion parity has changed. To go back to the initial ground state with the same fermion parity, you need to advance $\Phi$ by $2\Phi_0$.</p>
</blockquote>
<p>Note that this argument relies on the absence of a reservoir of electrons, such as a metallic lead. In this case, when the two levels cross at zero energy and the ground state fermion parity changes, there is no electron that can enter or leave the system. </p>
<p>The fermion parity switch, together with fermion parity conservation of the ring, result in the energy $E_\textrm{tot}(\Phi)$ and the corresponding current (that can be measured) showing a $2\Phi_0$ periodicity in $\Phi$ - that is, a $4\pi$ periodicity in $\phi$:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fluxes, spectrum = nanowire_spectrum()</span><br><span class="line">plot_gse_sc_nanowire(fluxes, spectrum)</span><br></pre></td></tr></table></figure>

<p>At this point you might wonder, what is so unique about the $2\Phi_0$ periodicity of the Josephson effect?</p>
<p>To answer this question, we need to review an alternative way of thinking about the Josephson effect in terms of just connecting a pair of superconductors by a junction without having to wrap the superconductor in a ring. In this case,  the hopping phase  $\phi$ (which we also referred to as the <em>superconducting phase</em>) that appeared in the tunneling term proportional to $t e^{i\phi/2}$ can be eliminated by shifting the fermion operators on one side of the junction by a phase i.e.  $c^\dagger\rightarrow c^\dagger e^{-i\phi/2}$. For superconducting systems, this transformation has the interesting effect of changing the superconducting phase on one side of the junction as </p>
<p>$$\Delta\rightarrow \Delta e^{i\phi}.$$ </p>
<p>Now you see why $\phi$ was referred to as <em>superconducting phase</em> in the first place. After this transformation (also called a gauge transformation) $\phi$ really becomes the complex phase of the superconducting term proportional to $\Delta$.</p>
<blockquote>
<p>But this also tells you one more thing - following the gauge transformation the Hamiltonian $H_{BdG}$ only depends on $\phi$ through the term $\Delta e^{i\phi}$, so one expects the energy to be $2\pi$ periodic in $\phi$. This leads to the conventional wisdom that the Josephson effect is $2\pi$-periodic (or equivalently $\Phi_0$-periodic in the case of a ring). </p>
</blockquote>
<p>As seen from the plots below, this is exactly what happens in the non-topological phase. In this case, when we look at the energy spectrum, no fermion parity switches appear:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fluxes, spectrum = nanowire_spectrum(trivial=<span class="literal">True</span>)</span><br><span class="line">plot_spectrum_nanowire(fluxes, spectrum, ylim=[-<span class="number">0.11</span>, <span class="number">0.11</span>])</span><br></pre></td></tr></table></figure>

<p>In turn, this means that energy and current are periodic with period $\Phi_0$:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fluxes, spectrum = nanowire_spectrum(trivial=<span class="literal">True</span>)</span><br><span class="line">plot_gse_sc_nanowire(fluxes, spectrum)</span><br></pre></td></tr></table></figure>

<p>At this point, you might be a little worried about how the topological superconductor managed to get around this <em>conventional wisdom</em>. The answer is subtle, and relies on the implicit assumption of the ground state fermion parity of the junction being fixed as one changes $\phi$. Topological superconductors violate this assumption and therefore can create the $4\pi$ periodic (or fractional) Josephson effect. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Suppose that in your topological nanowire junction, positive energy quasiparticles can escape &quot;</span></span><br><span class="line">    <span class="string">&quot;into a reservoir very quickly, making the junction always relax to the ground state. &quot;</span></span><br><span class="line">    <span class="string">&quot;How would this affect the periodicity of the Josephson effect?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;It would make the periodicity random because of the quasiparticles jumping around randomly.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;If the system can always relax to the ground state, the current would have a period of $\Phi_0$ (hence $2\pi)$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since the Josephson effect is topologically protected, these processes have no effect on the periodicity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The period becomes $\Phi_0/2$ because it is easier for the quasiparticles to jump out at this value of the flux.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;A particle tunneling out means that the fermion parity of the ground state changes. &quot;</span></span><br><span class="line">    <span class="string">&quot;Hence the lowest between the red and black energy levels is always occupied, and both energy and current &quot;</span></span><br><span class="line">    <span class="string">&quot;turn out to have a period $\Phi_0$.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;sSacO5RpW5A&quot;</span>, src_location=<span class="string">&quot;2.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Signatures of Majorana modes&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w2_majorana/nanowire/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size=<span class="number">110</span></span><br><span class="line"><span class="keyword">from</span> holoviews.core.options <span class="keyword">import</span> Cycle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_chain</span>():</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">onsite, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu) * pauli.szs0 + p.B * pauli.s0sz + p.delta * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    syst[lat(<span class="number">0</span>)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 - <span class="number">0.5j</span> * p.alpha * pauli.szsx</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spinful_kitaev_chain</span>():</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu) * pauli.szs0 + p.B * pauli.szsz</span><br><span class="line"></span><br><span class="line">    syst[lat(<span class="number">0</span>)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 - <span class="number">1j</span> * p.delta * pauli.sys0</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_gap</span>(<span class="params">syst, p, resolution=<span class="number">1e-4</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find gap in a system by doing a binary search in energy.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This tells us if there are modes at a certain energy.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(syst.modes(energy=<span class="number">0</span>, params=<span class="built_in">dict</span>(p=p))[<span class="number">0</span>].momenta):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    gap = step = <span class="built_in">min</span>(<span class="built_in">abs</span>(kwant.physics.Bands(syst, params=<span class="built_in">dict</span>(p=p))(k=<span class="number">0</span>))) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> step &gt; resolution:</span><br><span class="line">        step /= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(syst.modes(gap, params=<span class="built_in">dict</span>(p=p))[<span class="number">0</span>].momenta):</span><br><span class="line">            gap -= step</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gap += step</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spinorbit_band_gap</span>(<span class="params">syst, mu, t, delta, Bs</span>):</span></span><br><span class="line">    syst = syst.finalized()</span><br><span class="line">    alphas = [<span class="number">0.0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>]</span><br><span class="line">    p = SimpleNamespace(mu=mu, t=t, delta=delta)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gap</span>(<span class="params">syst, p, alpha, B</span>):</span></span><br><span class="line">        p.alpha = alpha</span><br><span class="line">        p.B = B</span><br><span class="line">        <span class="keyword">return</span> find_gap(syst, p)</span><br><span class="line"></span><br><span class="line">    gaps = [gap(syst, p, alpha, B) <span class="keyword">for</span> alpha <span class="keyword">in</span> alphas <span class="keyword">for</span> B <span class="keyword">in</span> Bs]</span><br><span class="line">    gaps = np.reshape(gaps, (<span class="built_in">len</span>(alphas), -<span class="number">1</span>))</span><br><span class="line">    dims = &#123;<span class="string">&quot;kdims&quot;</span>: [<span class="string">r&quot;$B$&quot;</span>], <span class="string">&quot;vdims&quot;</span>: [<span class="string">&quot;Band gap&quot;</span>]&#125;</span><br><span class="line">    B_crit = holoviews.VLine(np.sqrt(p.delta ** <span class="number">2</span> + p.mu ** <span class="number">2</span>))</span><br><span class="line">    plot = [</span><br><span class="line">        holoviews.Curve((Bs, gaps[i]), label=<span class="string">r&quot;$\alpha=&#123;&#125;$&quot;</span>.<span class="built_in">format</span>(alphas[i]), **dims)</span><br><span class="line">        * B_crit</span><br><span class="line">        <span class="keyword">for</span> i, alpha <span class="keyword">in</span> <span class="built_in">enumerate</span>(alphas)</span><br><span class="line">    ]</span><br><span class="line">    title = <span class="string">r&quot;$\Delta=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(p.delta, p.mu)</span><br><span class="line">    style = &#123;<span class="string">&quot;xticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>], <span class="string">&quot;yticks&quot;</span>: [<span class="number">0</span>, <span class="number">0.05</span>, <span class="number">0.1</span>], <span class="string">&quot;fig_size&quot;</span>: <span class="number">150</span>&#125;</span><br><span class="line">    plot = holoviews.Overlay(plot)</span><br><span class="line">    <span class="keyword">return</span> plot.opts(plot=style)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">title</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        title = <span class="string">r&quot;$\alpha=&#123;:.2&#125;$, $\mu=&#123;:.2&#125;$, $B=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$&quot;</span></span><br><span class="line">        title = title.<span class="built_in">format</span>(p.alpha, p.mu, p.B, p.delta)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        title = <span class="string">r&quot;$\mu=&#123;:.2&#125;$, $B=&#123;:.2&#125;$, $\Delta=&#123;:.2&#125;$&quot;</span></span><br><span class="line">        title = title.<span class="built_in">format</span>(p.mu, p.B, p.delta)</span><br><span class="line">    <span class="keyword">return</span> title</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">style = &#123;</span><br><span class="line">    <span class="string">&quot;k_x&quot;</span>: np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">101</span>),</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: <span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: <span class="string">r&quot;$E/t$&quot;</span>,</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;xlims&quot;</span>: [-<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">&quot;ylims&quot;</span>: [-<span class="number">1.5</span>, <span class="number">1.5</span>],</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: title,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="From-Kitaev-model-to-an-experiment"><a href="#From-Kitaev-model-to-an-experiment" class="headerlink" title="From Kitaev model to an experiment"></a>From Kitaev model to an experiment</h1><p>We have a special guest to begin this week’s lecture, Yuval Oreg from the Weizmann Institute in Rehovot.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;GQLfs4i22ms&quot;</span>, src_location=<span class="string">&quot;2.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Small-parameters"><a href="#Small-parameters" class="headerlink" title="Small parameters"></a>Small parameters</h1><p>We are now all set to make Majoranas in a real system. Or at least to invent a way to make Majoranas in a real system.</p>
<p>The way we approach this problem is by considering the Kitaev chain a ‘skeleton’, and ‘dressing’ it with real physics phenomena until it becomes real. </p>
<blockquote>
<p>Interestingly, this is not at all how the condensed matter community came to this model.<br>Instead, the path to it was from complex to simple. The whole story started from what we’ll consider in the very end of the course, fractional particles.</p>
</blockquote>
<blockquote>
<p>Then it was simplified to topological superconductors (that still do not exist in nature, as far as we know).<br>Majoranas were then predicted to exist (week 7) in a combination of a 3D topological insulator (week 6), which was then simplified to a two-dimensional topological insulator (week 5), and only after a few more simplification steps, the nanowire model was developed.</p>
</blockquote>
<p>So once again, here is our ‘skeleton’, the Kitaev model Hamiltonian written in momentum space:</p>
<p>$$H_{Kitaev} = (-2 t \cos k -\mu) \tau_z + 2 \Delta \tau_y \sin k.$$</p>
<p>The model seems OK for a start, because it has some superconducting pairing $\Delta$ and some normal dispersion given by terms proportional to $\mu$ and $t$.</p>
<p>Before we proceed further, let’s understand the relation between these parameters.</p>
<p>First of all, we want to make a controllable system, so that we can tweak its parameters. That means that we need a <strong>semiconductor</strong>. In semiconductors the electron density is very low, so that the chemical potential is near the bottom of the band. This makes it easier to define $\mu$ with respect to the bottom of the band:</p>
<p>$$\mu \rightarrow \mu - 2t.$$</p>
<p>Now the transition between trivial and non-trivial states happens when $\mu = 0$.</p>
<p>Of course semiconductors are never additionally superconducting. Luckily this is easy for us to resolve. We just paste a superconductor and semiconductor together into a hybrid structure, and let the superconductor induce superconductivity in the semiconductor. Making such a hybrid is extremely challenging from the material science point of view, but it’s definitely not our problem for now.</p>
<p>The next thing we should consider is that $\mu$ will always stay small compared to the bandwidth, so $\mu \ll 2t$. The same holds for superconducting pairing: $\Delta \ll t$. This is because superconductivity is a very weak effect compared to the kinetic energy of electrons. These two inequalities combined mean that we can expand the $\cos k$ term and only work with the continuum limit of the Kitaev model:</p>
<p>$$H = (k^2/2m - \mu) \tau_z + 2 \Delta \tau_y k.$$</p>
<p>The effective electron mass $m$ is just the coefficient of the expansion. Let’s take a look at the band structure in this regime, both in the topological regime and in the trivial regime:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syst = spinful_kitaev_chain()</span><br><span class="line">p1 = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.1</span>, mu=-<span class="number">0.3</span>, B=<span class="number">0.0</span>, alpha=<span class="number">0.0</span>)</span><br><span class="line">p2 = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.1</span>, mu=<span class="number">0.3</span>, B=<span class="number">0.0</span>, alpha=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(syst, p1, **style).relabel(<span class="string">&quot;Trivial bandstructure&quot;</span>)</span><br><span class="line">    + spectrum(syst, p2, **style).relabel(<span class="string">&quot;Topological bandstructure&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="The-need-for-spin"><a href="#The-need-for-spin" class="headerlink" title="The need for spin"></a>The need for spin</h1><p>Still, there is one obvious thing missing from the model, namely electron spin. This model works with some hypothetical spinless fermions, that do not really exist. So to make the model physical, we need to remember that every single particle has spin, and the Hamiltonian has some action in spin space, described by the Pauli matrices $\sigma$.</p>
<p>The simplest thing which we can do is to just add the spin as an extra degeneracy, that is to multiply every term in the Hamiltonian by $\sigma_0$. Obviously this doesn’t change the spectrum, and a zero energy solution stays a zero energy solution.</p>
<p>Just kidding, this would be very bad! The problem about adding spin is that the whole point of a Kitaev chain is to create <em>unpaired</em> Majorana modes. If we add an extra spin degeneracy to these Majoranas, the edge of our chain will host two Majoranas, or in other words one regular fermion fine-tuned to zero energy.</p>
<p>What’s the correct way of introducing spin then? We still need to add it. Let’s add spin such that the Kitaev chain corresponding to one spin species is topologically trivial, and the Kitaev chain corresponding to the other spin species non-trivial. We know that the chemical potential $\mu$ controls whether a Kitaev chain is topological or trivial, so if say spin up has $\mu &gt; 0$ and spin down $\mu &lt; 0$, we’re back in business.</p>
<p>We achieve this by adding Zeeman coupling of the spin to an external magnetic field:</p>
<p>$$H = (k^2/2m - \mu - B \sigma_z) \tau_z + 2 \Delta \tau_y k.$$</p>
<p>Whenever the Zeeman energy $|B|$ is larger than $\mu$ we have one Majorana fermion at the end of the chain.</p>
<p>Let’s look at what happens with the dispersion as we increase the magnetic field from zero to a value larger than $\mu$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syst = spinful_kitaev_chain()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">0.1</span>, mu=<span class="number">0.3</span>, B=<span class="literal">None</span>)</span><br><span class="line">Bs = np.linspace(<span class="number">0</span>, <span class="number">0.4</span>, <span class="number">10</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.B: spectrum(syst, p, **style) <span class="keyword">for</span> p.B <span class="keyword">in</span> Bs&#125;, kdims=[<span class="string">r&quot;$B$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>We now see that we resolved the first problem:</p>
<blockquote>
<p>A high enough <strong>Zeeman splitting</strong> allows to separate the different spins.<br>Then we can make one spin species trivial, while the other one is topological and hosts Majoranas.</p>
</blockquote>
<h1 id="Realistic-superconducting-pairing"><a href="#Realistic-superconducting-pairing" class="headerlink" title="Realistic superconducting pairing"></a>Realistic superconducting pairing</h1><p>The next part for us to worry about is the superconductor.</p>
<p>Something that you probably saw in the Kitaev chain Hamiltonian is that the superconducting pairing $\Delta$ has a peculiar form. It pairs electrons from <em>neighboring</em> sites, and not those from the same site. In momentum space this means that the superconducting pairing is proportional to $\Delta k$.</p>
<p>Of course, in a Kitaev chain the superconducting pairing cannot couple two electrons from the same site since there is just one particle per site!</p>
<p>Real world superconductors are different. Most of them, and specifically all the common superconductors like $Al$, $Nb$, $Pb$, $Sn$ have $s$-wave pairing. This means that the pairing has no momentum dependence, and is local in real space. The Kitaev chain pairing is proportional to the first power of momentum and so it is a $p$-wave pairing.</p>
<p><a href="https://en.wikipedia.org/wiki/High-temperature_superconductivity">High temperature superconductors</a> like cuprates or pnictides do have a momentum-dependent pairing, but it’s yet another type ($d$-wave, or a more exotic $s\pm$-wave).</p>
<p>So if we want to invent a way to make Majoranas, we will need to use $s$-wave pairing. And then, as you should remember from the previous week, due to the fermionic statistics the pairing function should be antisymmetric. In a Kitaev chain the antisymmetry is due to the real space structure of the pairing, but in an $s$-wave superconductor, the antisymmetry of the pairing should arise due to its spin structure.</p>
<p>This leaves only one option. All the $s$-wave superconductors are spin-singlet:</p>
<p>$$H_{pair} = \Delta(c_\uparrow c_\downarrow - c_\downarrow c_\uparrow) + \text{h.c.}$$</p>
<p>This means that now we need to modify the pairing, but before that we’ll need to do one other important thing.</p>
<h3 id="Important-and-useful-basis-change"><a href="#Important-and-useful-basis-change" class="headerlink" title="Important and useful basis change."></a>Important and useful basis change.</h3><p>When you see Bogoliubov-de-Gennes Hamiltonians in the literature, you will find them written in two different bases.<br>One variant is the one which we introduced last week:</p>
<p>$$<br>H_\textrm{BdG} = \begin{pmatrix} H &amp; \Delta \ -\Delta^* &amp; -H^* \end{pmatrix}.<br>$$</p>
<p>It has the particle-hole symmetry $H_\textrm{BdG} = - \tau_x H^*_\textrm{BdG} \tau_x$. In this basis, the $s$-wave pairing is proportional to $\sigma_y$.</p>
<p>However for systems with complicated spin and orbital structure, there is a different basis which makes the bookkeeping much easier.</p>
<p>If we have a time-reversal symmetry operator $\mathcal{T} = U \mathcal{K}$, we can apply the unitary transformation $U$ to the holes, so that in the new basis we get the Bogoliubov-de-Gennes Hamiltonian</p>
<p>$$<br>H_\textrm{BdG} = \begin{pmatrix} H &amp; \Delta’ \ \Delta’^\dagger &amp; -\mathcal{T} H \mathcal{T}^{-1}\end{pmatrix},<br>$$</p>
<p>with $\Delta’ = \Delta U^\dagger$.</p>
<p>Why is this basis useful?</p>
<ul>
<li>First of all, because in this new basis the $s$-wave pairing is a unit matrix regardless of the system we consider.</li>
<li>Second, because it’s easy to get the Hamiltonian of holes. We take the Hamiltonian for electrons, and change the signs of all terms that respect time-reversal symmetry, but not for those that break it, such as the term proportional to the magnetic field $B$. So if the electrons have a Hamiltonian $H(B)$, the Hamiltonian of the holes just becomes $-H(-B)$.</li>
</ul>
<p>There is one disadvantage. The particle-hole symmetry now becomes more complicated. For our system with only one orbital and spin it is $\mathcal{P} = \sigma_y \tau_y \mathcal{K}$. But, let us tell you, the advantages are worth it.</p>
<h1 id="s-wave-superconductor-with-magnetic-field"><a href="#s-wave-superconductor-with-magnetic-field" class="headerlink" title="s-wave superconductor with magnetic field"></a>s-wave superconductor with magnetic field</h1><p>Let’s look at how our chain looks once we change the superconducting coupling to be $s$-wave. The Zeeman field (or anything of magnetic origin) changes sign under time-reversal symmetry. </p>
<p>This means that the Zeeman field has the same form for electrons and for holes in the new basis, and the full Hamiltonian is now:</p>
<p>$$<br>H_\textrm{BdG} = (k^2/2m - \mu)\tau_z + B \sigma_z + \Delta \tau_x.<br>$$</p>
<p>This Hamiltonian is easy to diagonalize since every term only has either a $\tau$ matrix or a $\sigma$ matrix. At $k=0$ it has 4 levels with energies $E = \pm B \pm \sqrt{\mu^2 + \Delta^2}$.</p>
<p>We can use this expression to track the crossings. We also know that when $B=0$ the system is trivial due to spin degeneracy.<br>Together this means that we expect the system to be non-trivial (and will have a negative Pfaffian invariant) when</p>
<p>$$ B^2 &gt; \Delta^2 + \mu^2.$$</p>
<p>Are we now done? Not quite.</p>
<h3 id="Problem-with-singlets"><a href="#Problem-with-singlets" class="headerlink" title="Problem with singlets"></a>Problem with singlets</h3><p>A singlet superconductor has an important property: Since electrons are created in singlets, the total spin of every excitation is conserved. Zeeman field conserves the spin in $z$-direction, so together every single state of our system has to have a definite spin, <em>including the Majoranas</em>.</p>
<p>And that is a big problem. Majoranas are their own particle-hole partners, and that means that they cannot have any spin (energy, charge, or any other observable property at all).</p>
<p>So does this now mean that we “broke” the bulk-edge correspondence? Let’s look at the band structure (tweak the Zeeman energy):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syst = nanowire_chain()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.0</span>, delta=<span class="number">0.1</span>, alpha=<span class="number">0.0</span>, B=<span class="literal">None</span>)</span><br><span class="line">Bs = np.linspace(<span class="number">0</span>, <span class="number">0.4</span>, <span class="number">10</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.B: spectrum(syst, p, **style) <span class="keyword">for</span> p.B <span class="keyword">in</span> Bs&#125;, kdims=[<span class="string">r&quot;$B$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>Of course we didn’t break bulk-edge correspondence. Majoranas in our system would have to have a spin, which isn’t possible. That in turn means that they cannot appear, and that means that the system cannot be gapped.</p>
<p>We can also approach this differently. From all the spin Pauli matrices, only $\sigma_z$ appears in the Hamiltonian, so there’s a conservation law. The two bands that cross at zero energy in the band structure above belong to opposite spin bands, and so cannot be coupled.</p>
<p>Now we need to solve this final problem before we are done.</p>
<h1 id="How-to-open-the-gap"><a href="#How-to-open-the-gap" class="headerlink" title="How to open the gap?"></a>How to open the gap?</h1><p>The final stretch is straightforward.</p>
<p>We know that there is no gap because of conservation of one of the spin projections, so we need to break the spin conservation.</p>
<p>If we don’t want to create an inhomogeneous magnetic field, we have to use a different term that couples to spin. That term is spin-orbit interaction. In it’s <a href="http://en.wikipedia.org/wiki/Rashba_effect">simplest form</a> this interaction appears in our wire as</p>
<p>$$H_{SO} = \alpha \sigma_y k,$$</p>
<p>so it is like a Zeeman field pointing in $y$-direction with a strength proportional to the particle momentum. Note that this term is invariant under time reversal symmetry (both $\sigma_y$ and $k$ change sign). So now we have our final Hamiltonian:</p>
<p>$$<br>H_\textrm{wire} = (k^2/2m + \alpha \sigma_y k - \mu)\tau_z + B \sigma_z + \Delta \tau_x.<br>$$</p>
<p>At $k = 0$, spin-orbit coupling vanishes, so it has no effect on the system being topologically trivial or non-trivial.</p>
<p>Let’s now check that it does what we want, namely open the gap at a finite momentum:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syst = nanowire_chain()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="number">0.1</span>, delta=<span class="number">0.1</span>, B=<span class="number">0.2</span>, alpha=<span class="literal">None</span>)</span><br><span class="line">alphas = np.linspace(<span class="number">0</span>, <span class="number">0.4</span>, <span class="number">10</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.alpha: spectrum(syst, p, **style) <span class="keyword">for</span> p.alpha <span class="keyword">in</span> alphas&#125;, kdims=[<span class="string">r&quot;$\alpha$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Yep, it does :)</p>
<p>An important remark: You might now think that since spin-orbit interaction depends on spin, it makes the magnetic field unnecessary. This is not true: Since spin-orbit interaction preserves time-reversal symmetry, in the absence of a magnetic field the energy spectrum of the model would have a <em>Kramers degeneracy</em>, as you learned last week. To get one unpaired Majorana mode per edge and not two, we need to break Kramers degeneracy and therefore break time-reversal symmetry. So the combination of both Zeeman field and spin-orbit coupling is needed.</p>
<h1 id="Putting-everything-together"><a href="#Putting-everything-together" class="headerlink" title="Putting everything together"></a>Putting everything together</h1><p>Let’s now rest for a moment and reflect on what we have done.</p>
<p>We started from a toy model, which has a very special feature. Then one by one we fixed the parts of the model that we found unrealistic and ended up with a new system. It still has a relatively simple Hamiltonian, but already gives hope of being realizable in a lab.</p>
<p>Now try to guess: how many papers were written studying this exact model? The exact number is hard to obtain, but the count is in the hundreds!</p>
<p>Despite the model being very simple and the fact that it can be written in one line, it has four independent parameters already in our simplest formulation. Let’s enumerate the parameters once again:</p>
<ul>
<li>The chemical potential $\mu$, which sets the overall electron density in the wire.</li>
<li>The induced superconducting gap $\Delta$, which is required to make particle-hole symmetry play a role.</li>
<li>The spin-orbit coupling $\alpha$, which breaks spin conservation.</li>
<li>The Zeeman field $B$, which breaks Kramers degeneracy.</li>
</ul>
<p>We need to control every single parameter out of these 4 to create Majoranas (and there are even more). This is why the task of creating Majoranas is extremely challenging.</p>
<p>As a final point in our story, let’s see how the four parameters work together in determining how large the gap in our system is.</p>
<p>Obviously, this is the key parameter that we care about when creating Majoranas.<br>The smaller the gap, the worse the protection of Majoranas, and the more we need to worry about the effects of finite temperature.</p>
<p>Let’s calculate the gap as a function of all of the relevant parameters.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%opts Curve (color=Cycle(values=[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>]))</span><br><span class="line">%%opts Overlay [show_legend=<span class="literal">True</span> legend_position=<span class="string">&#x27;top&#x27;</span>]</span><br><span class="line"></span><br><span class="line">syst = nanowire_chain()</span><br><span class="line">Bs = np.linspace(<span class="number">0</span>, <span class="number">0.3</span>, <span class="number">71</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">0.05</span>, <span class="number">0.15</span>, <span class="number">5</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;mu: spinorbit_band_gap(syst, mu, <span class="number">1.0</span>, <span class="number">0.1</span>, Bs) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Here the vertical line denotes the critical value of the Zeeman field at which the wire becomes topological.</p>
<p>Let’s summarize our observations:</p>
<ul>
<li>So we see that the closer $\mu$ is to 0, the lower $B$ is required to reach the topological regime.</li>
<li>After reaching the topologically nontrivial regime, the gap slowly grows as we go away from the transition region, and after reaching its peak value, it starts dropping.</li>
<li>Finally, we see that the higher the spin-orbit coupling, the larger the optimal gap in the topological regime.</li>
</ul>
<p>We finish our investigation of this model for now with a final simple picture of the band structure of our system.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syst = nanowire_chain()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, B=<span class="number">0.07</span>, delta=<span class="number">0.025</span>, alpha=<span class="number">0.8</span>, mu=<span class="literal">None</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">0.18</span>, <span class="number">0.22</span>, <span class="number">10</span>)</span><br><span class="line">holoviews.HoloMap(&#123;p.mu: spectrum(syst, p, **style) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>When $\mu$ is very negative we see two split electron bands at positive energy corresponding to two spin orientations.</p>
<p>The lower of these two bands has a characteristic double minimum due to spin-orbit coupling.</p>
<p>As we increase $\mu$, the bands move down in energy, until they couple with the hole bands at $E=0$. This only happens due to the combination of superconductivity and spin-orbit coupling.</p>
<p>At $k=0$ the spin-orbit coupling is ineffective, so the electron and hole bands pass through each other, changing the system first from trivial to topological and then back.</p>
<p>The non-monotonous behavior of the gap versus $B$ that we saw earlier is a consequence of this complicated band structure: There are different values of momenta where the dispersion has local minima. When we are close to the phase transition, $k=0$ defines the gap, while for large $B$, it is the gap at finite momentum that becomes smallest.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;What happens if we align the magnetic field $B$ along the $y$-direction instead of the $z$-direction?&quot;</span></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Then we do not need spin-orbit coupling anymore in order to get Majoranas.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Then the spin projection along the $y$ direction is conserved, so we can&#x27;t get Majoranas.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It&#x27;s impossible, because a magnetic field can only be applied along $z$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Then the spin-orbit term is automatically modified to point along the $z$ direction, so nothing really changes.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;If both the magnetic field and the spin orbit coupling point in the $y$ direction, &quot;</span></span><br><span class="line">    + <span class="string">&quot;then the Hamiltonian commutes with $\sigma_y$, and spin projection along $y$ is a good quantum number. &quot;</span></span><br><span class="line">    + <span class="string">&quot;So we are back to the problem that a gap at finite momentum does not open, &quot;</span></span><br><span class="line">    + <span class="string">&quot;and we do not get a topological phase supporting Majoranas.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Outlook"><a href="#Outlook" class="headerlink" title="Outlook"></a>Outlook</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;MsFyJBAMFLI&quot;</span>, src_location=<span class="string">&quot;2.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Majoranas in nanowires&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w2_majorana/braiding/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Braiding-of-Majoranas"><a href="#Braiding-of-Majoranas" class="headerlink" title="Braiding of Majoranas"></a>Braiding of Majoranas</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;Ndf2Z84g1R0&quot;</span>, src_location=<span class="string">&quot;2.3-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Majorana-zero-modes-in-nanowire-networks"><a href="#Majorana-zero-modes-in-nanowire-networks" class="headerlink" title="Majorana zero modes in nanowire networks"></a>Majorana zero modes in nanowire networks</h1><p>As you just heard in the video, the goal of this lecture is to compute the quantum statistics of Majorana zero modes. In order to do this, we will have in mind a nanowire network where Majorana modes can be exchanged in space, like this one:</p>
<p><img src="/2021/01/07/src/w2_majorana/braiding/nanowire_network.svg" alt></p>
<p>In the drawing, you can see a nanowire with many T-shaped junctions in between several Majorana zero modes (which is why we call it a network). We will not worry about the microscopic description of the nanowire network, which will differ in irrelevant ways from similar structures in alternative platforms for Majoranas (we’ll learn about those later, in week 7). Just to fix the ideas, you can imagine that the system can be effectively described by the Kitaev chain toy-model, and that the Majoranas are at the positions of domain walls where the gap changes sign, as you saw in the first week of the course.</p>
<p>The only thing that distinguishes the Majorana zero modes is their position in the network. They have no other “flavour” that would allow us to characterize them. They are identical to each other, just like all electrons are identical to each other. If we exchanged two Majoranas in space, the system after the exchange would look exactly the same as it looked before the exchange.</p>
<blockquote>
<p>It is very interesting to ask what is the behaviour of the quantum state $\left|\Psi\right\rangle$ of a system of identical particles under the exchange of two of the particles. You already know that for bosons and fermions $\left|\Psi\right\rangle,\to,\pm\left|\Psi\right\rangle$. To see what happens in the case of Majoranas, we first have to learn how to write down the quantum state $\left|\Psi\right\rangle$ corresponding to a set of Majoranas like the one sketched above.</p>
</blockquote>
<h2 id="The-Hilbert-space-of-a-set-of-Majoranas"><a href="#The-Hilbert-space-of-a-set-of-Majoranas" class="headerlink" title="The Hilbert space of a set of Majoranas"></a>The Hilbert space of a set of Majoranas</h2><p>From now on, it is important to keep in mind that by considering only the states corresponding to the Majorana zero modes, we are neglecting the existence of the states that live in the bulk. As mentioned in the video, we assume that the energy spectrum looks like this:</p>
<p><img src="/2021/01/07/src/w2_majorana/braiding/gs_manifold.svg" alt></p>
<p>Based on your knowledge of the Kitaev chain, this assumption should sound reasonable to you. Because you have several Majoranas, there will be several states all at zero energy, forming a “ground state manifold”.</p>
<p>Let’s now explore more in detail the ground state manifold defined by this degenerate sets of states.</p>
<p>In the drawing you see six Majoranas, that is three pairs, but let’s consider here the more general case of $N$ pairs. It might appear that since the $\gamma_n$s don’t appear in the Hamiltonian, there is a degenerate quantum state for each of the $2N$ values of $n$. However, just as Majorana modes appear in pairs, they can be assigned quantum states only in pairs.</p>
<blockquote>
<p>To assign quantum states to Majoranas, we can pair the Majoranas and form fermionic modes,<br>$$<br>c^\dagger_n = \tfrac{1}{2}(\gamma_{2n-1}+i\gamma_{2n}),,\<br>c_n =\tfrac{1}{2}(\gamma_{2n-1}-i\gamma_{2n}),,<br>$$<br>for $n=1,\dots, N$. Using this notation, we have chosen to pair neighboring Majoranas into a fermionic mode. We have now a set of $N$ fermionic modes with corresponding creation and annihilation operators. Every mode can be empty or it can be occupied by a fermion, giving us two possible degenerate quantum states $\left|0\right\rangle$ and $\left|1\right\rangle$ for each pair of Majoranas.</p>
</blockquote>
<p>Going back to our sketch, we can represent the situation as follows:</p>
<p><img src="/2021/01/07/src/w2_majorana/braiding/majoranas_pairing.svg" alt></p>
<p>The coloring of the Majorana modes now makes explicit our choice of how to pair them into fermionic modes. In total, the system above has 8 possible states, corresponding to all the possible combinations of the occupation numbers of the 3 fermionic modes. Generalizing, we will have $2^N$ possible quantum states for $N$ pairs of Majoranas. We can represent each such state with a ket</p>
<p>$$\left| s_1, s_2, \dots, s_N\right\rangle,,$$</p>
<p>where $s_n$ is equal to $0$ if the $n$-th fermionic mode is not occupied, and equal to $1$ if it is occupied. These states are a <em>complete basis</em> for the Hilbert space of the set of Majorana modes. Note that these basis states are all eigenstates of the operators $P_n \equiv 1-2c^\dagger_n c_n \equiv i\gamma_{2n-1}\gamma_{2n}$. For instance, we have that</p>
<p>$$ P_1 \left| 0, \dots \right\rangle\ = (1-2c^\dagger_1 c_1)\left|0, \dots \right\rangle= + \left|0, \dots \right\rangle,, $$<br>$$ P_1 \left| 1, \dots \right\rangle\ = (1-2c^\dagger_1 c_1)\left|1, \dots \right\rangle= - \left|1, \dots \right\rangle,, $$</p>
<p>and so on. The operator $P_n$ is the <em>fermion parity operator</em> for the pair of Majoranas $\gamma_{2n-1}$ and $\gamma_{2n}$. At this point it is useful to remind you that different Majorana operators all anticommute with each other. This means that the product of a pair of Majorana operators commutes with the product of a different pair, for instance:</p>
<p>$$(\gamma_1\gamma_2)(\gamma_3\gamma_4) = (\gamma_3\gamma_4)(\gamma_1\gamma_2),.$$</p>
<p>However, if the two pairs share a Majorana, then they do not commute anymore, for instance:</p>
<p>$$(\gamma_1\gamma_2)(\gamma_2\gamma_3) = - (\gamma_2\gamma_3)(\gamma_1\gamma_2),.$$<br>Of course, the product above can also be simplified: since $\gamma_2^2=1$, you have that $(\gamma_1\gamma_2)(\gamma_2\gamma_3)=\gamma_1\gamma_3$.<br> All $P_n$’s commute with each other, because they all involve a different pair of Majoranas. </p>
<blockquote>
<p>Thus the  Hilbert space of states $|\Psi\rangle$ of a set of $N$ pairs of Majorana modes is spanned by the simultaneous eigenstates $|s_1,s_2,\dots,s_N\rangle$ of the commuting fermion parity operators $P_n$ and is written as $$\left|\Psi\right\rangle= \sum_{s_n=0,1} \alpha_{s_1s_2\dots s_N},\left| s_1, s_2, \dots, s_N\right\rangle, $$<br> with complex coefficients $\alpha_{s_1s_2\dots s_N}$. </p>
</blockquote>
<p> At this point an important consideration is in order. You will remember learning during the first week that, while a superconducting Hamiltonian may not conserve the total number of electrons due to the creation and annihilation of Cooper pairs, the parity of the number of electrons is always conserved.<br>We can obtain the <em>total fermion parity</em> by multiplying all the operators $P_n$,</p>
<p>$$ P_\textrm{tot}=P_1\cdot P_2\cdot, \dots, \cdot P_N = i^N,\gamma_1\gamma_2\dots\gamma_{2N},.$$</p>
<p>The operator $P_\textrm{tot}$ has eigenvalues $s_1 s_2\dots s_N=\pm 1$, depending on whether the total number of occupied fermionic modes is even or odd. Applied to our case, this means that it is only meaningful to consider states $\left|\Psi\right\rangle$ which are <em>eigenstates</em> of the operator $P_\textrm{tot}$, that is</p>
<p>$$P_\textrm{tot}\left|\Psi\right\rangle=\pm\left|\Psi\right\rangle,.$$</p>
<p>In particular, linear combinations of states with different total parity are forbidden. You can see this condition as a constraint on the allowed values of the coefficients $\alpha_{s_1s_2\dots s_N}$.</p>
<p>This consideration only applies to closed systems. It does not apply if we are considering a system which is in contact with a reservoir of electrons, such as a metallic lead, in which case electrons may tunnel in and out of the lead, changing the total parity of the system. Equivalently, it does not apply if we are considering only a part of the total system. You could for instance imagine that, in our sketch, there are more Majorana zero modes in the part of the network which is not drawn explicitly (represented by the dots which “continue” the nanowire). In such a case it is perfectly possible that the <em>total</em> network is in, say, a state of even parity, but that the subsystem under consideration is in a superposition of even and odd parity states.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider an isolated system with N=7 pairs of Majoranas, and an even total fermion parity. &quot;</span></span><br><span class="line">    <span class="string">&quot;What is the ground state degeneracy of the system?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Trick question - it is not possible to get N=7 pairs of Majorana modes with even parity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2^7.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2^6.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;14&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The system has an energy gap, so it cannot be degenerate.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;7 pairs of Majoranas means a Hilbert space with dimension 2^7, &quot;</span></span><br><span class="line">    <span class="string">&quot;out of which half have even total parity and half have odd total parity. &quot;</span></span><br><span class="line">    <span class="string">&quot;So the degeneracy at fixed even parity is 2^6.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Non-Abelian-statistics-of-Majoranas"><a href="#Non-Abelian-statistics-of-Majoranas" class="headerlink" title="Non-Abelian statistics of Majoranas"></a>Non-Abelian statistics of Majoranas</h1><p>Let’s now imagine that experimentalists are not only able to build such a network, but also to move the position of the domain walls and swap the positions of two Majoranas, for instance by performing the following trajectory:</p>
<p><img src="/2021/01/07/src/w2_majorana/braiding/nanowire_network_exchange.svg" alt></p>
<p>Let’s suppose that the trajectory takes a time $T$. During the trajectory, the system is described by a time-dependent Hamiltonian $H(t)$, $0\leq t \leq T$. This Hamiltonian contains all the details of the system, such as the positions of the domain walls where the Majoranas are located. Because the final configuration of the system is identical to the initial one, for instance all the domain walls are in the same positions as in the beginning, we have that $H(0)=H(T)$. In other words, we are considering a <em>closed trajectory</em> which brings the Hamiltonian back into itself. To ensure that the wave-function for the system does not leave the ground state manifold of states $|\Psi\rangle$, we need to change the Hamiltonian $H(t)$ slowly enough to obey the <a href="http://en.wikipedia.org/wiki/Adiabatic_theorem">adiabatic theorem</a>. </p>
<p>So let’s imagine that we are in the adiabatic limit and that we exchange two Majoranas $\gamma_n$ and $\gamma_m$. As usual in quantum mechanics, the initial and final quantum states are connected by a unitary operator $U$ ($U^{-1}=U^\dagger$),</p>
<p>$$\left|\Psi\right\rangle ,\to, U \left|\Psi\right\rangle,.$$</p>
<p>Because the quantum state $\left|\Psi\right\rangle$ never leaves the ground state manifold, which has $2^N$ states, the operator $U$ can be written a $2^N\times 2^N$ unitary matrix.</p>
<p>We can derive the exact form of $U$ without a direct calculation, which would require knowing $H(t)$, but only based on the following, general considerations. First, the adiabatic exchange of two Majoranas does not change the parity of the number of electrons in the system, so $U$ commutes with the total fermion parity, $[U, P_\textrm{tot}]=0$. Second, it is reasonable to assume that $U$ only depends on the Majoranas involved in the exchange, or in other words that it is a function of $\gamma_n$ and $\gamma_m$, and of no other operator. And because it has to preserve fermion parity, it can only depend on their product, that is on the parity operator $-i\gamma_n\gamma_m$, which is Hermitian. Finally, the exponential of $i$ times a Hermitian operator is a unitary operator. So, in general $U$ must take the form</p>
<p>$$U\equiv\exp(\beta \gamma_n \gamma_m) = \cos(\beta) + \gamma_n\gamma_m \sin(\beta),,$$</p>
<p><em>up to an overall phase</em>. Here, $\beta$ is a real coefficient to be determined, and in the last equality we have used the fact that $(\gamma_n\gamma_m)^2=-1$. To determine $\beta$, it is convenient to go to the <a href="http://en.wikipedia.org/wiki/Heisenberg_picture">Heisenberg picture</a> and look at the evolution of the Majorana operators in time. We have that</p>
<p>$$<br>\gamma_n,\to,  U,\gamma_n,U^\dagger,,\<br>\gamma_m,\to,  U,\gamma_m,U^\dagger,.<br>$$</p>
<p>Inserting our guess for $U$ we obtain:</p>
<p>$$<br>\gamma_n,\to,   \cos (2\beta),\gamma_n  - \sin(2\beta),\gamma_m,,\<br>\gamma_m,\to,   \cos (2\beta),\gamma_m  + \sin(2\beta),\gamma_n,.<br>$$</p>
<p>Now we have to remember that at time $T$ we have completed a closed trajectory, so that the Majorana $\gamma_n$ is now in the place initially occupied by $\gamma_m$, and vice versa. This condition leads to the choice $\beta = \pm \pi/4$. It is not strange that we find that both signs are possible - this distinguishes the clockwise and the counterclockwise exchange of the Majoranas. </p>
<blockquote>
<p>Thus, we can write the unitary operator that exchanges the Majorana modes $\gamma_n$ and $\gamma_m$ in an explicit (and somewhat non-trivial looking!) form as:<br>$$U = \exp \left(\pm\frac{\pi}{4}\gamma_n \gamma_m\right) = \tfrac{1}{\sqrt{2}}\left(1\pm\gamma_n\gamma_m\right)$$</p>
</blockquote>
<p>To fix our ideas and study the consequences of $U$ more closely, it is convenient to just focus on four Majoranas $\gamma_1,\gamma_2,\gamma_3$ and $\gamma_4$. For this discussion we will assume that counter-clockwise exchanges pick the $+$ sign in $U$. Their ground state manifold has four states, which in the notation introduced before we write down as</p>
<p>$$\left|00\right\rangle, \left|11\right\rangle, \left|01\right\rangle, \left|10\right\rangle,,$$</p>
<p>where the first digit is the occupation number of the fermionic mode $c^\dagger_1=\tfrac{1}{2}(\gamma_1+i\gamma_2)$ and the second digit the occupation number of $c^\dagger_2=\tfrac{1}{2}(\gamma_3+i\gamma_4)$. The most generic possible wave function is a superposition</p>
<p>$$\left|\Psi\right\rangle = s_{00}\left|00\right\rangle + s_{11} \left|11\right\rangle + s_{01} \left|01\right\rangle + s_{10} \left|10\right\rangle,,$$</p>
<p>which we can also represent as a vector with four entries, $\left|\Psi\right\rangle = (s_{00}, s_{11}, s_{01}, s_{10})^T$. The operator $U$ at this point can be written as a $4\times 4$ matrix. In order to do so, you just have to compute the action of a product of Majoranas on the basis states. This a simple but tedious operation, which we skip here. It results in the following matrices for the operators $U_{12}, U_{23}$ and $U_{34}$ exchanging neighboring Majoranas:</p>
<p>$$<br>U_{12} = \exp\left(\frac{\pi}{4}\gamma_1 \gamma_2\right) \equiv\begin{pmatrix}<br>e^{-i\pi/4} &amp; 0 &amp; 0 &amp; 0 \0 &amp; e^{i\pi/4} &amp; 0 &amp;0 \0 &amp; 0&amp; e^{-i\pi/4} &amp;0 \ 0&amp;0&amp; 0&amp; e^{i\pi/4}<br>\end{pmatrix},,<br>$$</p>
<p>$$<br>U_{23} = \exp\left(\frac{\pi}{4}\gamma_2 \gamma_3\right) \equiv\frac{1}{\sqrt{2}}\begin{pmatrix}<br>1 &amp; -i &amp; 0 &amp; 0\ -i &amp; 1 &amp; 0&amp; 0\ 0&amp; 0&amp; 1 &amp; -i\ 0&amp; 0&amp; -i &amp; 1<br>\end{pmatrix},,<br>$$</p>
<p>$$<br>U_{34} = \exp\left(\frac{\pi}{4}\gamma_3 \gamma_4\right) \equiv\begin{pmatrix}<br>e^{-i\pi/4} &amp; 0 &amp; 0 &amp; 0\ 0&amp; e^{i\pi/4} &amp; 0&amp; 0\ 0&amp; 0&amp; e^{i\pi/4} &amp; 0\ 0&amp; 0&amp; 0&amp; e^{-i\pi/4}<br>\end{pmatrix},.<br>$$</p>
<p>These matrices indeed act in a very non-trivial way on the wave function. For instance, if we start from the state $\left|00\right\rangle$ and we exchange $\gamma_2$ and $\gamma_3$, we obtain</p>
<p>$$\left|00\right\rangle,\to,U_{23}\left|00\right\rangle=\tfrac{1}{\sqrt{2}}\left(\left|00\right\rangle-i\left|11\right\rangle\right),,$$</p>
<p>which is a superposition of states! Hence we have seen explicitly that the effect of the exchange two Majoranas on the wavefunction amounts to much more than just an overall phase, as it happens for bosons and fermions.</p>
<p>Let’s now try a sequence of two exchanges. In this case, we have to multiply the corresponding $U$s, ordering them from right to the left according to the order of the exchanges. Given that the matrices above are not diagonal, it is not surprising that the order in the product matters a lot. For instance you can check that</p>
<p>$$U_{23}U_{12}\neq U_{12}U_{23},$$</p>
<blockquote>
<p>We have just shown that exchanging two Majorana modes leads to a non trivial rotation in the ground state manifold, and that changing the order of the exchanges changes the final result. These properties make Majorana modes <strong>non-Abelian anyons</strong>. The exchange of two non-Abelian anyons is usually called <strong>braiding</strong>, a name which is suggestive of the fact that, when thinking of the trajectories of the different particles, a sequence of exchanges looks like a braid made out of different strands.</p>
</blockquote>
<p>Finally, you might object to the fact that the network of nanowires drawn in the figures only allows to exchange neighbouring Majoranas, even though our derivation of $U=\exp(\pi\gamma_n\gamma_m/4)$ seems to hold for any pair of Majoranas. This geometric constraint is not a big problem: by carefully composing many exchanges between neighbours, we can exchange any pair of Majoranas. As an example, you have that $U_{13}\equiv\exp\left(\pi\gamma_1 \gamma_3/4\right) = U_{12}^\dagger,U^\dagger_{23},U_{12}$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider a system with only one pair of Majorana modes, thus with just two degenerate states with different fermion parity. &quot;</span></span><br><span class="line">    <span class="string">&quot;What happens when we exchange the pair of Majorana modes, starting from a given fermion parity eigenstate?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The fermion parity of the state flips.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Nothing happens.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The system wave-function picks up a phase that depends on the fermion parity.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You end up in a superposition of the two states.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The total fermion parity cannot change, &quot;</span></span><br><span class="line">    <span class="string">&quot;but the two states can pick up a different phase. &quot;</span></span><br><span class="line">    <span class="string">&quot;This is indeed what happens since the operator $U$ describing the exchange depends on fermion parity.&quot;</span></span><br><span class="line">)</span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Majoranas-and-quantum-computation-basic-ideas"><a href="#Majoranas-and-quantum-computation-basic-ideas" class="headerlink" title="Majoranas and quantum computation: basic ideas"></a>Majoranas and quantum computation: basic ideas</h1><p>The non-Abelian statistics of Majorana modes is a very special property. Furthermore, it has some practical interest, since it could be used to realize a robust <strong>quantum computer</strong>. (If you are not yet interested in quantum computation, you can skip this part, even though we suggest that you get interested in it! Quantum computation is a huge topic of research, but <a href="http://arxiv.org/abs/quant-ph/9708022">this</a> is a good place to start learning.)</p>
<p>Let’s discuss very briefly how this can be done.</p>
<p>First, we can think of our network of nanowires with $2N$ Majoranas as a small computer. The $2^N$ states of the ground state manifold can encode a string of $N$ bits, so it’s like having a small <em>register</em>. As always in quantum computation, and unlike in a classical computer, the register can be in a superposition of different states. So far, nothing really special about Majoranas.</p>
<p>How do we execute an <em>algorithm</em> on our register? Simply by exchanging the Majorana modes! Because of the non-Abelian statistics, different sequences of exchanges will yield different algorithms. Of course, to execute an interesting algorithm we may need a lot of Majorana modes and a very very long sequence of exchanges. However, it all begins with the small building blocks, the matrices that you have just studied in detail.</p>
<p>You might say that this is just another way to obtain a given unitary operator acting on the wave function. The beautiful thing, though, is that both the state of the register and the algorithms are <em>topologically protected</em>. Let’s explain what we mean by that.</p>
<p>The state of the register is encoded in the fermion parity degrees of freedom, which are shared <em>non-locally</em> by the Majoranas. This means that no local perturbation can change the state of the register and cause <em>decoherence</em> of the quantum state. The environment cannot access the information stored in the Majoranas, as long as they are kept far away from each other. The only exception is a change in fermion parity due to the tunnelling of a stray quasiparticle into the system (this is the problem of quasiparticle poisoning, the same that can hinder the detection of the $4\pi$-periodic Josephson effect of Majorana modes, as you heard from Carlo Beenakker). But except from this, the Majoranas are a great <em>quantum memory</em>.</p>
<p>On the other hand, every step of the algorithm will be extremely accurate because it is given by an exchange of two Majoranas, which corresponds to <em>exactly</em> $\exp(\pi\gamma_n\gamma_m/4)$. When you are in the adiabatic limit, this operator does not depend on any of the details on how the exchange between Majoranas is performed. It does not depend on <em>how</em> you move the Majoranas, or on the particular trajectory that $\gamma_n$ and $\gamma_m$ followed, or on the timing of the trajectory. So the final result is extremely reliable.</p>
<p>These are the basic ideas of <strong>topological quantum computation</strong>. It is incredible that we can find condensed matter systems, such as networks of Majoranas, which are naturally endowed with these characteristics. </p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;V3e9r4S8GHs&quot;</span>, src_location=<span class="string">&quot;2.3-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Non-Abelian statistics of Majorana modes&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w2_majorana/Peierls/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This first cell will be removed by the converter.</span></span><br></pre></td></tr></table></figure>

<h1 id="Tight-binding-models-in-a-magnetic-field-Peierls-substitution"><a href="#Tight-binding-models-in-a-magnetic-field-Peierls-substitution" class="headerlink" title="Tight-binding models in a magnetic field: Peierls substitution"></a>Tight-binding models in a magnetic field: Peierls substitution</h1><p>To understand how the vector potential enters a tight-binding model by the so-called Peierls substitution, let us remind ourselves that the gauge-invariance of the Schrodinger equation requires us to transform the wave-function amplitude or equivalently the creation operator of an electron at a site as $$c_j^\dagger \rightarrow c_j^\dagger e^{-i\frac{e}{\hbar c}\Lambda(\bf r_j)},$$<br>where $\Lambda(\bf r)$ generates the gauge transformation of the vector potential $\bf A(\bf r)\rightarrow \bf A(\bf r)+\bf\nabla A(\bf r)$. If there is no magnetic field then the vector potential can locally be set to $\bf A=0$ by an appropriate gauge choice of $\bf \Lambda$. The hopping term in the absence of a vector potential is written as $H_t=t_{jl}c_j^\dagger c_l+h.c$, which must gauge transform to  $$H_t=t_{jl} e^{-i\frac{e}{\hbar c}(\Lambda(\bf r_j)-\Lambda(\bf r_l))}c_j^\dagger c_l+h.c=t_{jl} e^{-i\frac{e}{\hbar c}(\int_{\bf r_l}^{\bf r_j} d\bf r’\cdot\bf A(\bf r’)}c_j^\dagger c_l+h.c.$$ While this expression is derived for zero magnetic field, by choosing the integration path to be the shortest distance over nearest neighbor bond, this expression is used to include magnetic fields in lattice models. This is referred to as the Peierls substitution for lattices.</p>
<p>If we put our topological nanowire in a ring (as with the Aharonov-Bohm effect) with a junction (as in the figure) and concentrate the magnetic field in the center of the ring, the vector potential $\bf A$ is constrained  by the magnetic flux $\Phi$ as $$\oint d\bf {r’\cdot\bf A(\bf r’)}=\int d^2\bf {r’\bf \nabla\times \bf A(\bf r’)}=\Phi.$$<br>Choosing a gauge for the vector potential so that it vanishes everywhere except in the junction the hopping phase $\theta$ for the junction i.e. $H_t=t_{N,1}e^{i\theta}c_N^\dagger c_1+h.c.$ is written as $$\theta=\int_{\bf r_l}^{\bf r_j} d\bf r’\cdot\bf A(\bf r’)=\pi \Phi/\Phi_0,$$ where $\Phi_0=hc/2e$ is the superconducting flux quantum. </p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w1_topointro/w1_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations-what-about-other-symmetries"><a href="#Simulations-what-about-other-symmetries" class="headerlink" title="Simulations: what about other symmetries"></a>Simulations: what about other symmetries</h1><p>So you’ve made it through the content of the first week. Congratulations!</p>
<p>Now let’s get our hands dirty.</p>
<p>Let’s begin by grabbing the notebooks of this week and the extra code we use to run these notebooks over <a href="http://tiny.cc/topocm_smc">here</a>. (Click the [i] button to the left of the folder that you want to copy.)</p>
<p>You need to copy the <code>code</code> folder and the <code>w1_topointro</code> folder. Let’s look into what’s inside.</p>
<h4 id="First-task-combination-of-particle-hole-and-time-reversal-symmetries"><a href="#First-task-combination-of-particle-hole-and-time-reversal-symmetries" class="headerlink" title="First task: combination of particle-hole and time-reversal symmetries"></a>First task: combination of particle-hole and time-reversal symmetries</h4><p>Look at the notebook about topology of zero-dimensional systems, and see how we generate Hamiltonians with a spinful time-reversal symmetry</p>
<p>$$<br>H = \sigma_y H^* \sigma_y.<br>$$</p>
<p>Now try to add this time reversal symmetry to a Hamiltonian which also has particle-hole symmetry. It is easiest to do in the basis where particle-hole symmetry has the form $H = -H^*$.<br>What do you think will happen? What will the extra symmetry do to the topological invariant?<br>Test your guess by plotting the spectrum and calculating the Pfaffian invariant.</p>
<h4 id="Second-task-Su-Schrieffer-Heeger-SSH-model"><a href="#Second-task-Su-Schrieffer-Heeger-SSH-model" class="headerlink" title="Second task: Su-Schrieffer-Heeger (SSH) model"></a>Second task: Su-Schrieffer-Heeger (SSH) model</h4><p>Similar to the Kitaev chain, the SSH model is simple a one-dimensional model where you can see all the essential aspects of topological systems. Unlike the Kitaev chain it does correspond to a physical system: electrons in a polyacetylene chain.</p>
<p>Here’s such a chain:</p>
<p><img src="/2021/01/07/src/w1_topointro/w1_assignments/polyacetylene.png" alt></p>
<p>Due to the dimerization of the chain the unit cell has two atoms and the hoppings have alternating strengths $t_1$ and $t_2$, so that the Hamiltonian is<br>$$H = \sum_{n=1}^N t_1 \left|2n-1\right\rangle\left\langle 2n\right|+t_2 \left|2n\right\rangle \left\langle 2n+1\right| + \textrm{h.c}$$</p>
<p>We can choose to start a unit cell from an even-numbered site, so $t_1$ becomes intra-cell hopping and $t_2$ inter-cell hopping.</p>
<p>Now get the notebook with the Kitaev chain and transform a Kitaev chain into an SSH chain.</p>
<p>Now repeat the calculations we’ve done with Majoranas using SSH chain. Keep $t_1 = 1$ and vary $t_2$.<br>You should see something very similar to what you saw with the Kitaev chain.</p>
<p>As you can guess, this is because the chain is topological.<br>Think for a moment: what kind of symmetry protects the states at the edges of the chain.<br><em>(Hint: you did encounter this symmetry in our course.)</em></p>
<p>The particle-hole symmetry, is a consequence of a mathematical transformation, and cannot be broken.<br>The symmetry protecting the SSH chain, however, can be broken.<br>Test your guess about the protecting symmetry by adding to your chain a term which breaks this symmetry and checking what it does to the spectrum of a finite chain and to its dispersion (especially as chain goes through a phase transition).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Toy models simulations&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><p>For the first week we have these papers:</p>
<h3 id="arXiv-1103-0780"><a href="#arXiv-1103-0780" class="headerlink" title="arXiv:1103.0780"></a>arXiv:1103.0780</h3><p><strong>Hint:</strong> Topological classification is not always applied to Hamiltonians.<br>Figure out what is the topological quantity in open systems.<br>See this idea also applied in arXiv:1405.6896.</p>
<h3 id="arXiv-1305-2924"><a href="#arXiv-1305-2924" class="headerlink" title="arXiv:1305.2924"></a>arXiv:1305.2924</h3><p><strong>Hint:</strong> This is a study of statistical properties of topological transitions.</p>
<h3 id="arXiv-1111-6600"><a href="#arXiv-1111-6600" class="headerlink" title="arXiv:1111.6600"></a>arXiv:1111.6600</h3><p><strong>Hint:</strong> A toy model may still be useful in practice.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Toy models&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w1_topointro/1D/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line">%output size=<span class="number">150</span></span><br><span class="line">dims = SimpleNamespace(</span><br><span class="line">    E_t=<span class="string">r&quot;$E/t$&quot;</span>,</span><br><span class="line">    mu_t=<span class="string">r&quot;$\mu/t$&quot;</span>,</span><br><span class="line">    lambda_=<span class="string">r&quot;$\lambda$&quot;</span>,</span><br><span class="line">    x=<span class="string">r&quot;$x$&quot;</span>,</span><br><span class="line">    k=<span class="string">r&quot;$k$&quot;</span>,</span><br><span class="line">    amplitude=<span class="string">r&quot;$|u|^2 + |v|^2$&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">holoviews.core.dimension.title = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kitaev_chain</span>(<span class="params">L=<span class="literal">None</span>, periodic=<span class="literal">False</span></span>):</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((-<span class="number">1</span>,)))</span><br><span class="line">        L = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transformation to antisymmetric basis</span></span><br><span class="line">    U = np.array([[<span class="number">1.0</span>, <span class="number">1.0</span>], [<span class="number">1.0j</span>, -<span class="number">1.0j</span>]]) / np.sqrt(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">onsite, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.mu * U @ pauli.sz @ U.T.conj()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        syst[lat(x)] = onsite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> U @ (-p.t * pauli.sz - <span class="number">1j</span> * p.delta * pauli.sy) @ U.T.conj()</span><br><span class="line"></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> periodic:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">last_hop</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">            <span class="keyword">return</span> hop(site1, site2, p) * (<span class="number">1</span> - <span class="number">2</span> * p.lambda_)</span><br><span class="line"></span><br><span class="line">        syst[lat(<span class="number">0</span>), lat(L - <span class="number">1</span>)] = last_hop</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bandstructure</span>(<span class="params">mu, delta=<span class="number">1</span>, t=<span class="number">1</span>, Dirac_cone=<span class="string">&quot;Hide&quot;</span>, show_pf=<span class="literal">False</span></span>):</span></span><br><span class="line">    syst = kitaev_chain(<span class="literal">None</span>)</span><br><span class="line">    p = SimpleNamespace(t=t, delta=delta, mu=mu)</span><br><span class="line">    plot = holoviews.Overlay([spectrum(syst, p, ydim=<span class="string">&quot;$E/T$&quot;</span>, xdim=<span class="string">&quot;$k$&quot;</span>)][-<span class="number">4</span>:<span class="number">4</span>])</span><br><span class="line">    h_1 = h_k(syst, p, <span class="number">0</span>)</span><br><span class="line">    h_2 = h_k(syst, p, np.pi)</span><br><span class="line">    pfaffians = [find_pfaffian(h_1), find_pfaffian(h_2)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> show_pf:</span><br><span class="line">        signs = [(<span class="string">&quot;&gt;&quot;</span> <span class="keyword">if</span> pf &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;&lt;&quot;</span>) <span class="keyword">for</span> pf <span class="keyword">in</span> pfaffians]</span><br><span class="line">        title = (</span><br><span class="line">            <span class="string">&quot;$\mu = &#123;mu&#125; t$, Pf$(iH_&#123;&#123;k=0&#125;&#125;) &#123;sign1&#125; 0$, Pf$(iH_&#123;&#123;k=\pi&#125;&#125;) &#123;sign2&#125; 0$&quot;</span></span><br><span class="line">        )</span><br><span class="line">        title = title.<span class="built_in">format</span>(mu=mu, sign1=signs[<span class="number">0</span>], sign2=signs[<span class="number">1</span>])</span><br><span class="line">        plot *= holoviews.VLine(<span class="number">0</span>) * holoviews.VLine(-np.pi)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> pfaffians[<span class="number">0</span>] * pfaffians[<span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            title = <span class="string">&quot;$\mu = &#123;mu&#125; t$, topological &quot;</span>.<span class="built_in">format</span>(mu=mu)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            title = <span class="string">&quot;$\mu = &#123;mu&#125; t$, trivial &quot;</span>.<span class="built_in">format</span>(mu=mu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> Dirac_cone == <span class="string">&quot;Show&quot;</span>:</span><br><span class="line">        ks = np.linspace(-np.pi, np.pi)</span><br><span class="line">        ec = np.sqrt((mu + <span class="number">2</span> * t) ** <span class="number">2</span> + <span class="number">4.0</span> * (delta * ks) ** <span class="number">2</span>)</span><br><span class="line">        plot *= holoviews.Path((ks, ec), kdims=[dims.k, dims.E_t]).opts(</span><br><span class="line">            style=&#123;<span class="string">&quot;linestyle&quot;</span>: <span class="string">&quot;--&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">        )</span><br><span class="line">        plot *= holoviews.Path((ks, -ec), kdims=[dims.k, dims.E_t]).opts(</span><br><span class="line">            style=&#123;<span class="string">&quot;linestyle&quot;</span>: <span class="string">&quot;--&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> plot.relabel(title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_pfaffian</span>(<span class="params">H</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.sign(np.real(pf.pfaffian(<span class="number">1j</span> * H)))</span><br></pre></td></tr></table></figure>

<h1 id="Kitaev-chain-and-bulk-edge-correspondence"><a href="#Kitaev-chain-and-bulk-edge-correspondence" class="headerlink" title="Kitaev chain and bulk-edge correspondence"></a>Kitaev chain and bulk-edge correspondence</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;U84MzZm9Gbo&quot;</span>, src_location=<span class="string">&quot;1.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Unpaired-Majorana-modes-in-one-dimensional-systems"><a href="#Unpaired-Majorana-modes-in-one-dimensional-systems" class="headerlink" title="Unpaired Majorana modes in one-dimensional systems"></a>Unpaired Majorana modes in one-dimensional systems</h1><h2 id="Fermion-operators-and-Majorana-operators"><a href="#Fermion-operators-and-Majorana-operators" class="headerlink" title="Fermion operators and Majorana operators"></a>Fermion operators and Majorana operators</h2><p>Let’s start from the creation and annihilation operators $c^\dagger$ and $c$ of a fermionic mode. These operators satisfy the anticommutation relation $c^\dagger c + cc^\dagger = 1$ and, furthermore, square to zero, $c^2=0$ and $(c^\dagger)^2=0$. They connect two states $\left|0\right\rangle$ and $\left|1\right\rangle$ which correspond to the ‘vacuum’ state with no particle and the ‘excited’ state with one particle, according to the following rules $c \left|0\right\rangle = 0$, $c^\dagger\left|0\right\rangle=\left|1\right\rangle$ and $c^\dagger \left|1\right\rangle = 0$.</p>
<p>When you have a pair of $c$ and $c^\dagger$ operators, you can write them down in the following way</p>
<p>$$ c^\dagger = \tfrac{1}{2}(\gamma_1+i\gamma_2),;; c = \tfrac{1}{2}(\gamma_1-i\gamma_2).$$</p>
<p>The operators $\gamma_1$ and $\gamma_2$ are known as Majorana operators. By inverting the transformation above, you can see that $\gamma_1=\gamma_1^\dagger$ and $\gamma_2=\gamma_2^\dagger$. Because of this property, we cannot think of a single Majorana mode as being ‘empty’ or ‘filled’, as we can do for a normal fermionic mode. This makes Majorana modes special.</p>
<p>You can also check that to maintain all the properties of $c$ and $c^\dagger$, the operators $\gamma_1$ and $\gamma_2$ must satisfy the following relations:</p>
<p>$$\gamma_1\gamma_2 + \gamma_2\gamma_1 = 0;,;\gamma_1^2=1;,;\gamma_2^2=1;.$$</p>
<p>You can see that Majorana modes are similar to normal fermions in the sense that they have operators which all anticommute with each other. Using Majorana modes instead of normal fermionic modes is very similar to writing down two real numbers in place of a complex number. Indeed, every fermion operator can always be expressed in terms of a pair of Majorana operators. This also means that Majorana modes always come in even numbers.</p>
<p>The two Majorana operators $\gamma_1, \gamma_2$ still act on the same states $\left|0\right\rangle$ and $\left|1\right\rangle$.<br>If these two states have an energy difference $\epsilon$, this corresponds to a Hamiltonian $H=\epsilon c^\dagger c$.<br>We can also express this Hamiltonian in terms of Majoranas as $H=\tfrac{1}{2},\epsilon,(1 - i\gamma_1\gamma_2)$.</p>
<p>But is it possible to have a single isolated Majorana mode, one that is not close to its partner?<br>The naive answer is ‘no’: condensed matter systems are made out of electrons, and these always correspond to pairs of Majoranas.<br>However, it turns out that by engineering the Hamiltonian in a special way it actually is possible to separate two Majoranas.</p>
<h2 id="Unpaired-Majorana-modes-in-a-model-of-dominoes"><a href="#Unpaired-Majorana-modes-in-a-model-of-dominoes" class="headerlink" title="Unpaired Majorana modes in a model of dominoes"></a>Unpaired Majorana modes in a model of dominoes</h2><p>Let’s see how creating isolated Majoranas can be done. Let us consider a chain of $N$ sites, where each site can host a fermion with creation operator $c^\dagger_n$. Equivalently, each site hosts two Majorana modes $\gamma_{2n-1}$ and $\gamma_{2n}$. This situation is illustrated below for $N=4$, where each site is represented by a domino tile.</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/majorana_dominoes.svg" alt></p>
<p>What happens if we pair the Majoranas? This means that the energy cost for each fermion to be occupied is $\mu$, and the Hamiltonian becomes</p>
<p>$$H=(i/2),\mu, \sum_{n=1}^{N} \gamma_{2n-1}\gamma_{2n}.$$</p>
<p>This is how the pairing looks:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/trivial_dominoes.svg" alt></p>
<p>All the excitations in this system have an energy $\pm|\mu|/2$, and the chain has a gapped bulk and no zero energy edge states.</p>
<p>Of course this didn’t help us to achieve our aim, so let’s pair the Majoranas differently.<br>We want only one Majorana to remain at an edge, so let’s pair up the Majoranas from <em>adjacent</em> sites, leaving the first one and the last one without a neighboring partner:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/topological_dominoes.svg" alt></p>
<p>To every pair formed in this way, we assign an energy difference $2t$ between the empty and filled state, hence arriving at the Hamiltonian</p>
<p>$$H=it \sum_{n=1}^{N-1} \gamma_{2n}\gamma_{2n+1}.$$</p>
<p>You can see that the two end Majorana modes $\gamma_1$ and $\gamma_{2N}$ do not appear in $H$ at all.<br>Hence our chain has two zero-energy states, localized at its ends.<br>All the states which are not at the ends of the chain have an energy of $\pm |t|$, independently on the length of the chain. Hence, we have a one-dimensional system with a gapped bulk and zero energy states at the edges.</p>
<h2 id="The-Kitaev-chain-model"><a href="#The-Kitaev-chain-model" class="headerlink" title="The Kitaev chain model"></a>The Kitaev chain model</h2><p>Let us now try to write the Hamiltonian $H$, which we have so far written in terms of Majoranas, in terms of regular fermions by substituting $\gamma_{2n-1}=(c_n^\dagger+c_n)$ and $\gamma_{2n}=-i(c_n^\dagger-c_n)$. We find that both pairings sketched above are extreme limits of one tight-binding Hamiltonian for a one-dimensional superconducting wire:</p>
<p>$$H=-\mu\sum_n c_n^\dagger c_n-t\sum_n (c_{n+1}^\dagger c_n+\textrm{h.c.}) + \Delta\sum_n (c_n c_{n+1}+\textrm{h.c.}),.$$</p>
<p>It has three real parameters: the onsite energy $\mu$, the hopping $t$ between different sites, and the superconducting pairing $\Delta$. Note that the $\Delta$ terms create or annihilate pairs of particles at neighboring sites.</p>
<p>Starting from this Hamiltonian, the unpaired Majorana regime is the special point $\Delta=t$ and $\mu=0$, while the completely trivial regime of isolated fermions is $\Delta=t=0$ and $\mu\neq 0$.</p>
<p>As we learned just before, it is useful to write down the above superconducting Hamiltonian in the Bogoliubov-de Gennes formalism $H = \tfrac{1}{2} C^\dagger H_\textrm{BdG} C$, with $C$ a column vector containing all creation and annihilation operators, $C=(c_1, \dots, c_N, c_1^\dagger, \dots, c^\dagger_N)^T$. The $2N\times 2N$ matrix $H_\textrm{BdG}$ can be written in a compact way by using Pauli matrices $\tau$ in particle and hole space, and denoting with $\left|n\right\rangle$ a column basis vector $(0,\dots,1,0,\dots)^T$ corresponding to the $n$-th site of the chain. In this way, we have for instance that $C^\dagger,\tau_z,\left|n\right\rangle\left\langle n\right|,C = 2c_n^\dagger c_n-1$. The Bogoliubov-de Gennes Hamiltonian is then given by</p>
<p>$$H_{BdG}=-\sum_n \mu \tau_z\left|n\right\rangle\left\langle n\right|-\sum_n \left[(t\tau_z+i\Delta\tau_y),\left|n\right\rangle\left\langle n+1 \right| + \textrm{h.c.}\right].$$</p>
<p>The BdG Hamiltonian acts on a set of basis states $\left|n\right\rangle\left|\tau\right\rangle$, with $\tau=\pm 1$ corresponding to electron and hole states respectively. It has particle-hole symmetry, $\mathcal{P}H_\textrm{BdG}\mathcal{P}^{-1}=-H_\textrm{BdG}$ with $\mathcal{P}=\tau_x\mathcal{K}$.</p>
<h2 id="Topological-protection-of-edge-Majorana-modes"><a href="#Topological-protection-of-edge-Majorana-modes" class="headerlink" title="Topological protection of edge Majorana modes"></a>Topological protection of edge Majorana modes</h2><p>The fact that the Kitaev model can have unpaired Majorana zero modes is certainly interesting. At this point you might however object:</p>
<p>“Unpaired Majoranas appear because you chose one particular, and perhaps even unreachable, set of parameters! Clearly by setting $\mu=0$ you have cut the first and last Majorana mode from the rest of the chain. I bet that if you change the value of $\mu$ only slightly from zero, the zero modes will be coupled to the rest of the chain and quickly disappear. So these Majorana modes may just be an artefact appearing in this highly tuned model!”</p>
<p>Well, let’s test if this objection is true. Let’s start from the situation with unpaired Majorana modes ($\Delta=t, \mu=0$) and then increase $\mu$. Then let’s plot the energy spectrum of a chain with $N=25$ sites as a function of $\mu$, and also keep track how do the two lowest energy states of our system look like, when we change $\mu$ <strong>(move the slider)</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_wf</span>(<span class="params">syst, wf1, wf2, lstyle=<span class="string">&quot;-&quot;</span>, lcolor=<span class="string">&quot;b&quot;</span></span>):</span></span><br><span class="line">    xs = np.array([i.pos[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> syst.sites])</span><br><span class="line">    indx = np.argsort(xs)</span><br><span class="line">    wf_sq = (</span><br><span class="line">        np.linalg.norm(wf1.reshape(-<span class="number">1</span>, <span class="number">2</span>), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line">        + np.linalg.norm(wf2.reshape(-<span class="number">1</span>, <span class="number">2</span>), axis=<span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line">    )</span><br><span class="line">    plot = holoviews.Path((xs[indx], wf_sq[indx]), kdims=[dims.x, dims.amplitude])</span><br><span class="line">    <span class="keyword">return</span> plot.opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;linestyle&quot;</span>: lstyle, <span class="string">&quot;color&quot;</span>: lcolor&#125;,</span><br><span class="line">        plot=&#123;<span class="string">&quot;yticks&quot;</span>: <span class="number">0</span>, <span class="string">&quot;xticks&quot;</span>: <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(xs), <span class="number">10</span>))&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_pwave</span>(<span class="params">L, t, delta, mu</span>):</span></span><br><span class="line">    <span class="comment"># At mu=0 the first exited state is not well defined due to the massive degeneracy.</span></span><br><span class="line">    <span class="comment"># That is why we add a small offset to mu.</span></span><br><span class="line">    syst = kitaev_chain(L).finalized()</span><br><span class="line">    p = SimpleNamespace(t=t, delta=delta, mu=mu + <span class="number">1e-4</span>)</span><br><span class="line">    ham = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    ev, evec = np.linalg.eigh(ham)</span><br><span class="line">    <span class="keyword">return</span> plot_wf(syst, evec[:, L], evec[:, L - <span class="number">1</span>]) * plot_wf(</span><br><span class="line">        syst, evec[:, L + <span class="number">1</span>], evec[:, L - <span class="number">2</span>], lstyle=<span class="string">&quot;--&quot;</span>, lcolor=<span class="string">&quot;r&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syst = kitaev_chain(L=<span class="number">25</span>)</span><br><span class="line">mus = np.arange(<span class="number">0</span>, <span class="number">4</span>, <span class="number">0.2</span>)</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, delta=<span class="number">1</span>, mu=mus)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(</span><br><span class="line">        syst,</span><br><span class="line">        p,</span><br><span class="line">        xticks=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        yticks=<span class="built_in">range</span>(-<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">        xdim=dims.mu_t,</span><br><span class="line">        ydim=dims.E_t,</span><br><span class="line">        ylims=(-<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">    )</span><br><span class="line">    * holoviews.HoloMap(&#123;mu: holoviews.VLine(mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[dims.mu_t])</span><br><span class="line">    + holoviews.HoloMap(</span><br><span class="line">        &#123;mu: plot_pwave(<span class="number">25</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, mu) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[dims.mu_t]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The left panel shows the spectrum, where we see two states at zero energy that split. On the right panel the blue line is the wave function of the state corresponding to the pair of Majorana modes, while the red dashed line is the wave function of the first excited state.</p>
<p>As you can see, the zero energy eigenvalues corresponding to the two unpaired Majorana zero modes persist for a long time, and they only split in energy when $\mu \simeq 2t$. Another thing that we observe is that the wave function of the Majoranas stays zero in the middle of our wire.</p>
<p>As we increase $\mu$ (try it), the wave function of the Majoranas becomes less localized near the edges of the wire, but the coupling between two ends only appears later.</p>
<p>You would observe a similar behavior if you varied $\mu$ in the negative direction starting from $\mu=0$. The Majoranas persist until $\mu\simeq-2t$, where the bulk gap closes.</p>
<p>In fact, the Majoranas only split when the higher-energy states in the bulk, originally separated by an energy gap of $2 t$, come very close to zero energy. So our investigation shows that the Majorana modes are protected <strong>as long as the bulk energy gap is finite</strong>.</p>
<p>How can we understand this? Recall that we are dealing with a particle-hole symmetric Hamiltonian. Hence, the spectrum has to be symmetric around zero energy. When $\mu=0$, we have two zero energy levels, corresponding to the Majorana modes which are localized far away from each other and separated by a gapped medium. Trying to move these levels from zero energy individually is impossible, as it would violate particle-hole symmetry:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/level_deformation_fig.svg" alt></p>
<p>The only possibility to move the energy levels from zero is to couple the two unpaired Majorana modes to each other. However, because of the spatial separation between Majoranas and of the presence of an energy gap, this coupling is impossible. The only way to split the Majorana modes in energy is to first close the bulk energy gap, and that is exactly what happens at large values of $\mu$ (to be precise, it happens at $\mu=2t$).</p>
<p>So we have just learned the following:</p>
<blockquote>
<p>Isolated zero end-modes at each end in the Kitaev chain are protected by <strong>symmetry</strong> between positive and negative energy, and by the <strong>absence of zero-energy excitations in the bulk of the wire</strong>, but not by fine-tuning of the chain parameters.</p>
</blockquote>
<p>As you see, our conclusion sounds a lot like what we learned about topology just before. We have come to these conclusions by studying a Kitaev chain on an open geometry with boundaries, and by focusing on the presence or absence of edge states localized at the boundaries of the chain. In the rest of the unit we will see that the presence or absence of edge states can be deduced by studying the bulk alone. In order to do this, we will now study an infinite Kitaev chain without boundaries.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;But wait! What happens if we remove the last Majorana site of a Kitaev chain&quot;</span></span><br><span class="line">    <span class="string">&quot; in the topological phase?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;We get a chain with a single Majorana mode.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;We cannot remove a single Majorana site because electrons (pairs of Majoranas) &quot;</span></span><br><span class="line">    <span class="string">&quot;are the only physical degrees of freedom.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Hamiltonian becomes topologically trivial.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Removing a single Majorana is not allowed by particle-hole symmetry&quot;</span>,</span><br><span class="line">]</span><br><span class="line">explanation = <span class="string">&quot;Indeed, as we explained, removing a single Majorana is like removing a single pole of a magnet. So not possible.&quot;</span></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Topological-phases-from-the-bulk-spectrum"><a href="#Topological-phases-from-the-bulk-spectrum" class="headerlink" title="Topological phases from the bulk spectrum"></a>Topological phases from the bulk spectrum</h1><h2 id="Going-to-momentum-space"><a href="#Going-to-momentum-space" class="headerlink" title="Going to momentum space"></a>Going to momentum space</h2><p>The Majoranas are edge excitations that arise from the bulk-edge correspondence. You might wonder if there is a way to deduce the existence of Majorana modes by looking at the bulk? To answer this, eliminate the boundaries from the study of the Kitaev chain. You can imagine that the last site of the chain is reconnected to the first, so that the chain is closed in a ring (a “Kitaev ring”). In the absence of boundaries, the Bogoliubov-de Gennes Hamiltonian has a translational symmetry $\left|n\right\rangle,\to,\left|n+1\right\rangle$, since all parameters $t, \Delta$ and $\mu$ do not depend on the chain site $n$. In the presence of translational symmetries, it is always convenient to use <a href="http://en.wikipedia.org/wiki/Bloch_wave#Preliminaries:_Crystal_symmetries.2C_lattice.2C_and_reciprocal_lattice">Bloch’s theorem</a> and write down the Hamiltonian in momentum space rather than in real space. In our case, a state with momentum $k$ is given by</p>
<p>$$ \left|k\right\rangle =(N)^{-1/2} \sum_{n=1}^{N} e^{-ikn} \left|n\right\rangle.$$</p>
<p>We apply periodic boundary conditions, that is $\left\langle k | n=0 \right\rangle=\left\langle k | n=N \right\rangle$. The momentum $k$ is then a conserved quantum number with allowed values $2\pi p /N$ where $p=0, 1, 2, \dots, N-1$. Values of $k$ which differ by $2\pi$ are equivalent. One can also imagine that for very large $N$, $k$ is a continuous periodic variable with values in the interval $[-\pi,\pi]$, the <strong>Brillouin zone</strong>. Because $k$ is a good quantum number, the Bogoliubov-de Gennes Hamiltonian in momentum space can be reduced to a $2\times 2$ matrix:</p>
<p>$$ H(k) \equiv \left\langle k\right| H_\textrm{BdG} \left| k \right\rangle = (-2t\cos{k}-\mu),\tau_z + 2\Delta \sin{k},,\tau_y.$$</p>
<p>The full Bogoliubov-de Gennes Hamiltonian is obtained by summing all these $2\times 2$ blocks:</p>
<p>$$ H_\textrm{BdG} = \sum_k H(k) \left| k \right\rangle\left\langle k \right|.$$</p>
<p>In the limit of an infinite chain the sum becomes an integral over the Brillouin zone.</p>
<h2 id="Particle-hole-symmetry-in-momentum-space"><a href="#Particle-hole-symmetry-in-momentum-space" class="headerlink" title="Particle-hole symmetry in momentum space"></a>Particle-hole symmetry in momentum space</h2><p>Going to momentum space does not affect the particle-hole symmetry of the Bogoliubov-de Gennes Hamiltonian. However, one must always be careful in dealing with anti-unitary operators when making a basis transformation. The reason is that the action of the complex conjugation operator might depend on the basis. In our case, we have</p>
<p>$$\mathcal{P}\left|k\right\rangle!\left|\tau\right\rangle =  \left(\sum_n,e^{-ikn}\right)^<em>,\left|n\right\rangle,\tau_x\left|\tau\right\rangle^</em>=\left|-k\right\rangle,\tau_x\left|\tau\right\rangle^*.$$</p>
<p>Note that the particle-hole symmetry operator changes $k$ to $-k$. Therefore, the action of $\mathcal{P}$ on the Bogoliubov-de Gennes Hamiltonian written in momentum space is the following:</p>
<p>$$\mathcal{P}H_\textrm{BdG}\mathcal{P}^{-1} = \sum_k \tau_xH^<em>(k)\tau_x \left| -k \right\rangle\left\langle -k \right|=\sum_k \tau_xH^</em>(-k)\tau_x \left| k \right\rangle\left\langle k \right|,.$$</p>
<p>In the last equality, we have used the fact that the allowed values of $k$ always come in $(-k, k)$ pairs, plus the two symmetric points $k=0$ and $k=\pi$. Therefore, particle-hole symmetry $\mathcal{P}H_\textrm{BdG}\mathcal{P}^{-1}= -H_\textrm{BdG}$ implies that</p>
<p>$$H(k)=-\tau_xH^*(-k)\tau_x.$$</p>
<p>You can verify that it is indeed the case:</p>
<p>$$\tau_x H^*(-k) \tau_x = (2t\cos{k}+\mu),\tau_z - 2\Delta \sin{k},,\tau_y.$$</p>
<p>Given a solution with energy $E$ and momentum $k$, particle-hole symmetry dictates in general the presence of a solution with energy $-E$ and momentum $-k$.</p>
<h2 id="Band-structure"><a href="#Band-structure" class="headerlink" title="Band structure"></a>Band structure</h2><p>At this point, we only need to diagonalize this $2\times 2$ matrix to obtain the <em>band structure</em> of the Kitaev chain model, that is the energy levels $E(k)$. This can be done very easily, and results in two energy bands, one with positive energy and one with negative energy:</p>
<p>$$ E(k) = \pm\sqrt{(2t\cos{k}+\mu)^2 + 4\Delta^2\sin^2{k}}. $$</p>
<p>Let’s see what this band structure looks like (<strong>once again move the slider</strong> to change $\mu$):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mus = np.arange(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">plots = &#123;</span><br><span class="line">    (mu, Dirac_cone): bandstructure(mu, Dirac_cone=Dirac_cone)</span><br><span class="line">    <span class="keyword">for</span> mu <span class="keyword">in</span> mus</span><br><span class="line">    <span class="keyword">for</span> Dirac_cone <span class="keyword">in</span> [<span class="string">&quot;Show&quot;</span>, <span class="string">&quot;Hide&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(plots, kdims=[dims.mu_t, <span class="string">&quot;Dirac cone&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>You can see that the energy spectrum is gapped at all $k$ for $\mu=0$. This is natural: Since our chain does not have boundaries anymore, the energy spectrum does not contain the zero energy Majorana modes which we found in the previous subsection at $\mu=0$. However, you can see very clearly the bulk gap closing which occurs at the points $\mu=2t$ and $\mu=-2t$. Indeed, for these values of $\mu$ the two bands at negative and positive energy touch at $E=0$, for $k=\pi$ and $k=0$ respectively.</p>
<p>At first sight, the band structure looks quite similar on both sides of the bulk gap closings. Just from the above plot, it is not clear that the bulk gap closings separate two distinct phases of the model. Nevertheless, we will see that it is possible to rigorously come to this conclusion by studying the properties of $H(k)$ in more detail. But in the meantime, we will start by understanding better what happens close to the transition, by writing down a simple effective model from which we will be able to deduce a lot of information.</p>
<h2 id="Study-of-the-bulk-transition-with-an-effective-Dirac-model"><a href="#Study-of-the-bulk-transition-with-an-effective-Dirac-model" class="headerlink" title="Study of the bulk transition with an effective Dirac model"></a>Study of the bulk transition with an effective Dirac model</h2><p>Let’s look at the gapless points more in detail. We focus on the gap closing at $\mu=-2t$, which happens at $k=0$. Close to this point where the two bands touch, we can make a linear expansion of the Hamiltonian $H(k)$,</p>
<p>$$H(k) \simeq m \tau_z + 2\Delta,k,\tau_y,,$$</p>
<p>with $m=-\mu-2t$. We can see that $H(k)$ becomes a <strong>Dirac Hamiltonian</strong> - note that condensed matter physicists use this term quite loosely to refer to any Hamiltonian which is linear in the momentum operator. You can easily check that this Hamiltonian gives an energy spectrum $E(k) = \pm\sqrt{m^2 + 4\Delta^2k^2}$, and by returning to the plot above you can indeed verify that this is a very good approximation of the exact band structure around $\mu=-2t$.</p>
<p>The ‘’mass’’ $m$ appearing in this Dirac Hamiltonian is a very important parameter to describe what is happening. Its magnitude is equal to the energy gap $\left|\mu+2t\right|$ in the band structure close to the gap closing. Its sign reminds us of the two original phases which we encountered in the previous part of the lecture:</p>
<ul>
<li>$m&lt;0$ for $\mu&gt;-2t$, which corresponds to the <strong>topological</strong> phase, the one with Majorana modes in the open chain.</li>
<li>$m&gt;0$ for $\mu&lt;-2t$, which corresponds to the <strong>trivial</strong> phase, the one without Majorana modes in the open chain.</li>
</ul>
<p>Previously, we had identified the point $\mu=-2t$ as a phase transition between two phases with or without zero energy edge modes. By looking at the bulk Hamiltonian, the same point $\mu=-2t$ appears as a point where the bulk gap closes and <em>changes sign</em>.</p>
<p>When $m=0$, the Hamiltonian has two eigenstates with energy $E=\pm 2\Delta k$. These states are the eigenstates of $\tau_y$, hence they are equal weight superpositions of electron and holes. They are in fact Majorana modes, that are left-moving on the branch $E = -2\Delta k$ and right-moving on $E = 2\Delta k$. Now they are free to propagate in the chain since there is no bulk gap anymore. In our simple model, the speed of these modes is given by $v=2\Delta$.</p>
<h2 id="Majorana-modes-appearing-at-a-domain-wall-between-different-phases"><a href="#Majorana-modes-appearing-at-a-domain-wall-between-different-phases" class="headerlink" title="Majorana modes appearing at a domain wall between different phases"></a>Majorana modes appearing at a domain wall between different phases</h2><p>Let us consider the following question: What happens if the mass parameter $m(x)$ varies continuously <em>in space</em>, and changes sign at a certain point?</p>
<p>To answer the question, let’s write down the Dirac Hamiltonian above in real space. Then we have</p>
<p>$$H = -v,\tau_y,i\partial_x + m(x), \tau_z.$$</p>
<p>As anticipated, the mass is now a function of position, $m(x)$, with the property that $m(x)\to \pm m$ for $x\to\pm\infty$ and $m(x=0)=0$. The point $x=0$ is a <em>domain wall</em>, the border between two regions of space with opposite sign of the mass.</p>
<p>We already know that when $m=0$, the Hamiltonian above has a zero energy Majorana mode as a solution. Let us look at it in more detail. We need to solve the equation $H\Psi=0$, which can be rewritten as</p>
<p>$$\partial_x\Psi(x) = (1/v),m(x),\tau_x,\Psi(x).$$</p>
<p>Only a single Pauli matrix $\tau_x$ appears in this equation, which is therefore quite easy to solve. The solutions have the form</p>
<p>$$\Psi(x) = \exp,\left(\tau_x\int_0^x \frac{m(x’)}{v}, dx’\right) \Psi(0).$$</p>
<p>Two linearly independent solutions are given by the eigenstates of $\tau_x$:</p>
<p>$$\Psi(x) = \exp,\left(\pm\int_0^x \frac{m(x’)}{v}, dx’\right) \begin{pmatrix} 1 \ \pm 1 \end{pmatrix},.$$</p>
<p>Only one of the two is normalizable, thanks to the fact that $m(x)$ changes sign at $x=0$. In this way we obtain a wave function localized at $x=0$, with two exponential tails on the sides. This solution is our Majorana mode which, in this case, is a bound state localized at the domain wall. Note that no zero-energy solution would exist if $m(x)$ did not change sign. In this case $\Psi(x)$ would not be normalizable at either side of the domain wall.</p>
<p>Physically, we are considering a situation where our system is in the topological phase for $x&lt;0$ and in the trivial phase for $x&gt;0$. Therefore we have just demonstrated that at the interface between these two regions <em>there must be</em> a zero energy mode.</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/domain_wall_zero_mode.svg" alt></p>
<p>To clarify the situation, we can represent the same domain wall with our domino tiles. When you join together two chains of dominoes paired up in a different way, one single unpaired Majorana <em>must be</em> left in the middle:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/domain_wall_with_dominoes.svg" alt></p>
<h1 id="Bulk-topological-invariant-and-the-bulk-edge-correspondence"><a href="#Bulk-topological-invariant-and-the-bulk-edge-correspondence" class="headerlink" title="Bulk topological invariant and the bulk-edge correspondence"></a>Bulk topological invariant and the bulk-edge correspondence</h1><h2 id="Bulk-topological-invariant"><a href="#Bulk-topological-invariant" class="headerlink" title="Bulk topological invariant"></a>Bulk topological invariant</h2><p>Now that we understand the topological transition in more detail, let’s go back to the bulk Hamiltonian $H(k)$ of the Kitaev ring and try to generalize our Dirac-equation based criterion for Majorana modes. In our effective Dirac model it was easy to identify a quantity, the mass parameter $m$, whose sign determined whether the system could support unpaired Majorana modes at its ends. Let’s now try to turn this effective description into a <strong>bulk topological invariant</strong> which can be computed directly from $H(k)$. We will not attempt to give a rigorous derivation of the bulk invariant - a task which is often difficult even for advanced researchers in the field - but rather to arrive at it in a heuristic manner.</p>
<p>We can start with some important clues. On the one hand, we are studying a Bogoliubov-de Gennes Hamiltonian, and we have already learned that quantum dots with particle-hole symmetry are characterized by a topological invariant, the sign of the Pfaffian, which changes sign at every gap closing. On the other hand, we have just seen that the gap closing in the Kitaev chain model is accompanied by a change of sign of $m$. This suggests to try to link the quantity $m$ to a Pfaffian. How to do so?</p>
<p>In fact, you can think of the full $H_\textrm{BdG}$ as a very large matrix with particle-hole symmetry. It can be put in antisymmetric form and we can compute its Pfaffian. This Pfaffian may change only when an eigenvalue of $H(k)$ passes through zero. Because of particle-hole symmetry, for every eigenvalue $E(k)$ we have one at $-E(-k)$. So if $E(k)$ passes through zero, also its partner does. Furthermore, the spectrum has to be periodic in the Brillouin zone, which means that gap closings at finite momentum always come in pairs, and cannot change the Pfaffian. There are only two points which make exception: $k=0$ and $k=\pi$, which are mapped onto themselves by particle-hole symmetry. In fact, for these points we have:</p>
<p>$$ \tau_x H^<em>(0)\tau_x=-H(0),$$<br>$$ \tau_x H^</em>(\pi)\tau_x=-H(\pi).$$</p>
<p>So $H(0)$ and $H(\pi)$ can always be put individually in antisymmetric form, and we can always compute their Pfaffian. Also, note that these are precisely the points in momentum space where the gap closes: at $k=0$ for $\mu=-2t$ and at $k=\pi$ for $\mu=2t$. All things considered, we have a strong reason to focus exclusively on $H(0)$ and $H(\pi)$. Following the procedure that we learned in the last chapter, we can therefore put $H(0)$ and $H(\pi)$ in antisymmetric form,</p>
<p>$$\tilde{H}(0) = \frac{1}{2}<br>\begin{pmatrix} 1 &amp; 1 \ i &amp; -i \end{pmatrix}<br>\begin{pmatrix} -2t-\mu &amp; 0 \ 0 &amp; 2t+\mu \end{pmatrix}<br>\begin{pmatrix} 1 &amp; -i \ 1 &amp; i \end{pmatrix} = -i<br>\begin{pmatrix} 0 &amp; -2t-\mu \ 2t+\mu &amp; 0\end{pmatrix},$$<br>$$\tilde{H}(\pi) = \frac{1}{2}<br>\begin{pmatrix} 1 &amp; 1 \ i &amp; -i \end{pmatrix}<br>\begin{pmatrix} 2t-\mu &amp; 0 \ 0 &amp; -2t+\mu \end{pmatrix}<br>\begin{pmatrix} 1 &amp; -i \ 1 &amp; i \end{pmatrix} = -i<br>\begin{pmatrix} 0 &amp; 2t-\mu \ -2t+\mu &amp; 0\end{pmatrix}.$$</p>
<p>We now easily obtain that</p>
<p>$$\textrm{Pf}[iH(0)]=-2t-\mu,$$<br>$$\textrm{Pf}[iH(\pi)]=2t-\mu.$$</p>
<p>You see that the Pfaffian of $H(0)$ changes sign at $\mu=-2t$, and the Pfaffian of $H(\pi)$ does so at $\mu=2t$, in perfect agreement with the position of the gap closing in the band structure:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mus = np.arange(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">0.25</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;mu: bandstructure(mu, show_pf=<span class="literal">True</span>) <span class="keyword">for</span> mu <span class="keyword">in</span> mus&#125;, kdims=[dims.mu_t]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Individually, the two Pfaffians account for one of the two bulk gap closings which can occur in the model. To obtain a single bulk invariant $Q$ we can simply multiply the two! Hence we arrive at the following expression:</p>
<p>$$Q = \textrm{sign}\left(, \textrm{Pf}[iH(0)],\textrm{Pf}[iH(\pi)],\right).$$</p>
<p>A value $Q=-1$ means that the bulk is in a topological phase, such that if the wire was cut at a point, two unpaired Majorana modes would appear at the ends of it. On the other hand, a value $Q=+1$ means that the bulk is in the trivial phase. Again, you might think that this expression for $Q$, that we have just cooked up, is only valid for the particular model that we are considering. However, you would be wrong:</p>
<blockquote>
<p>The topological invariant $Q$ cannot change under continuous deformations of the Hamiltonian unless the gap closes.</p>
</blockquote>
<h2 id="Connecting-the-bulk-invariant-and-the-edge-modes"><a href="#Connecting-the-bulk-invariant-and-the-edge-modes" class="headerlink" title="Connecting the bulk invariant and the edge modes"></a>Connecting the bulk invariant and the edge modes</h2><p>At the moment, the bulk topological invariant $Q$ defined above might look just like an abstract mathematical object. We know that $Q=-1$ corresponds to the topological phase, but can we give a more concrete physical meaning to this value? This is the goal of this last part of the lecture.</p>
<p>We have already connected the Pfaffian of a Bogoliubov-de Gennes Hamiltonian to a physical quantity: The ground state fermion parity of the system. Our one-dimensional invariant involves the product of two Pfaffians, $\textrm{Pf}[iH(0)]$ and $\textrm{Pf}[iH(\pi)]$. By taking their product we are somehow <em>comparing</em> the fermion parity of the two states of the chain with $k=0$ and $k=\pi$, and we have that $Q=-1$ if and only if the two parities are different.</p>
<p>This means that if we <em>continuously deform</em> $H(0)$ into $H(\pi)$ in some way without breaking the particle-hole symmetry, we must encounter a zero-energy level crossing in the energy spectrum, what we called a <em>fermion parity switch</em> in the last chapter.</p>
<p>In practice, this can be done in the following way. Let’s imagine that we change the boundary conditions of a Kitaev ring with $N$ sites from <em>periodic</em> to <em>antiperiodic</em> boundary conditions, that is from $\left\langle k | n=0 \right\rangle=\left\langle k | n=N \right\rangle$ to $\left\langle k | n=0 \right\rangle=-\left\langle k | n=N \right\rangle$. This means that the allowed values of momentum shift from $k=2\pi p/N$ to $k = 2\pi p/N + \pi /N$.</p>
<p>Let’s now ask what is the difference in ground state fermion parity of the two chains. The value $k=0$ is always present in the chain with periodic boundary conditions, while $k=\pi$ is in the first set if $N$ is even and in the second set if $N$ is odd. This means that in either case, the difference in the ground state fermion parities between the chains with periodic and antiperiodic boundary conditions is equal to $Q$!</p>
<p>To verify this statement, we will now <em>physically change the boundary condition in real space</em>. For simplicity, we will do so for a Kitaev ring with $\Delta=t$. You will remember that, in the Majorana basis, this corresponds to the limit where neighboring Majoranas from different sites are coupled by hopping of strength $t$.</p>
<p>To go from periodic to antiperiodic boundary condition, we can change the hopping on the last bond of the ring (the one connecting sites $n=N-1$ and $n=0$) from $t$ to $-t$. This can easily be done continuously and without breaking particle-hole symmetry, for instance by setting the last hopping to be equal to $t,(1-2\lambda)$ and varying $\lambda$ in the interval $[0,1]$, as shown in this picture:</p>
<p><img src="/2021/01/07/src/w1_topointro/1D/majorana_ring.svg" alt></p>
<p>You can check that the Bogoliubov-de Gennes Hamiltonian of this closed ring satisfies particle-hole symmetry at every value of $\lambda$. Let’s now look at the energy spectrum $E(\lambda)$ of the system as we vary $\mu$ from $0$ to $4t$, passing once again through the gap closing at $\mu=2t$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">syst = kitaev_chain(L=<span class="number">25</span>, periodic=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1</span>, delta=<span class="number">1</span>, lambda_=np.linspace(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">101</span>), mu=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">kwargs = &#123;</span><br><span class="line">    <span class="string">&quot;xticks&quot;</span>: np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="string">&quot;yticks&quot;</span>: np.linspace(-<span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="string">&quot;xdim&quot;</span>: dims.lambda_,</span><br><span class="line">    <span class="string">&quot;ydim&quot;</span>: dims.E_t,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mus = np.arange(<span class="number">0</span>, <span class="number">4</span>, <span class="number">0.1</span>)</span><br><span class="line">holoviews.HoloMap(</span><br><span class="line">    &#123;p.mu: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[dims.mu_t]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>You can see that for $\mu&lt;2t$, the energy spectrum shows a zero-energy level crossing at $\lambda=1/2$. The fermion parity of the system is therefore different at $\lambda=0$ and $\lambda=1$. When $\lambda=1/2$ the hopping on the last bond is equal to zero. We have introduced a “cut” to the system, such that our closed Kitaev ring is effectively transformed to an open Kitaev chain. Because we are in the topological phase, this open Kitaev chain has two zero-energy unpaired Majorana modes!</p>
<p>On the other hand, when $\mu&gt;2 t$ no zero-energy level crossing is present. The ground state fermion parity is the same at $\lambda=0$ and $\lambda=1$. In this case, when we cut the system at $\lambda=1/2$, we find no unpaired Majorana modes, consistent with our knowledge of the behavior of the open chain in the trivial phase.</p>
<p>We have therefore learned the essence of the bulk-boundary correspondence: A non-trivial value $Q=-1$ of the bulk invariant for the closed chain implies the existence of unpaired Majorana modes for the open chain. Also, we have been able to connect the value of the bulk invariant to a measurable quantity, in this case the ground state fermion parity of the closed chain.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;What will happen if we take a 100 site Kitaev chain in the topological phase &quot;</span></span><br><span class="line">    <span class="string">&quot;and change the potential mu to a very large negative value for the last 50 sites?&quot;</span></span><br><span class="line">)</span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The topological gap at the last 50 sites closes and reopens as $\mu$ changes from $0$ to $-\infty$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The Majoranas get destroyed by the drastic change of chemical potential $\mu_j$.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;One of the Majoranas moves from being the end of the system to the middle.&quot;</span>,</span><br><span class="line">]</span><br><span class="line">MoocCheckboxesAssessment(question, answers, correct_answers=[<span class="number">0</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<h1 id="Three-approaches-to-analysing-topological-systems"><a href="#Three-approaches-to-analysing-topological-systems" class="headerlink" title="Three approaches to analysing topological systems"></a>Three approaches to analysing topological systems</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;wiHPQlEha6g&quot;</span>, src_location=<span class="string">&quot;1.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Bulk-edge correspondence in the Kitaev chain&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w12_manybody/w12_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-0910-2763"><a href="#arXiv-0910-2763" class="headerlink" title="arXiv:0910.2763"></a>arXiv:0910.2763</h3><p><strong>Hint:</strong> Fractional quantum Hall effect in graphene</p>
<h3 id="arXiv-1204-5479"><a href="#arXiv-1204-5479" class="headerlink" title="arXiv:1204.5479"></a>arXiv:1204.5479</h3><p><strong>Hint:</strong> Fractional Majoranas in fractional quantum Hall edges</p>
<h3 id="arXiv-0803-0272"><a href="#arXiv-0803-0272" class="headerlink" title="arXiv:0803.0272"></a>arXiv:0803.0272</h3><p><strong>Hint:</strong> A scheme for quantum computation using the toric code</p>
<h3 id="arXiv-1502-01665"><a href="#arXiv-1502-01665" class="headerlink" title="arXiv:1502.01665"></a>arXiv:1502.01665</h3><p><strong>Hint:</strong> Making a fractional quantum Hall effect by coupling wires</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Many-body topology&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w12_manybody/topoorder/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>The topological order is introduced by Barbara Terhal from RWTH Aachen.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;rLdHCKxMumY&quot;</span>, src_location=<span class="string">&quot;12.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Simplest-model-for-topological-degeneracy-Toric-code"><a href="#Simplest-model-for-topological-degeneracy-Toric-code" class="headerlink" title="Simplest model for topological degeneracy: Toric code"></a>Simplest model for topological degeneracy: Toric code</h1><p>We have worked hard to create topological models so far. The FQH system, which is the most topological in some sense, was also more obscure in terms of microscopics. Here, we follow Alexei Kitaev and write down a simple Hamiltonian that is obviously topological, but also relatively easy to analyse.</p>
<p>Let’s consider a system of localized spin$-1/2$ electrons that live on the bonds of a square lattice. The particular Hamiltonian that Kitaev wrote down is:</p>
<p>$$H=-A_v\sum_{+}\prod_+ \sigma_z-B_p\sum_{\Box}\prod_{\Box} \sigma_x.$$</p>
<p>As you can see in the figure below, $\Box$ refers to the spins on the bonds that surround a plaquette and $+$ refers to the bonds that surround a vertex. The beauty of this Hamiltonian is that all the terms commute between themselves. The only terms that you might suspect not to commute are a plaquette term and a vertex term that share some bonds. But you can convince yourself easily (by  looking at the figure) that such terms always share an even number of spins. This means that the commutation picks up an even number of minus signs and so these terms commute as well.</p>
<p><img src="/2021/01/07/src/w12_manybody/topoorder/toric_layout.svg" alt></p>
<p>Since $H$ is a sum of commuting terms, we can calculate the ground state as the simultaneous ground state for all the terms.<br>Let us first look at the vertex terms proportional to $A$. If we draw a red line through bond connecting neighboring spins with $\sigma_z=-1$ on our lattice (as shown below), then we find that each vertex in the ground state configuration has an even number of red lines coming in. Thus, we can think of the red  lines forming loops that can never be open ended. This allows us to view the ground state of the toric code as a loop gas. </p>
<p><img src="/2021/01/07/src/w12_manybody/topoorder/loops.svg" alt></p>
<p>What if we focus on the large plaquette term limit i.e. $A_v\ll B_p$ instead? The toric code is fairly symmetric between the vertex and plaquette terms. Clearly, focusing on the $\sigma_z$ diagonal basis was a choice. If we draw loops (blue lines) through the dual lattice (whose vertices are in the middle of the original lattice) whenever $\sigma_x=-1$ on some link. This results in a loop gas picture (blue lines) on the dual lattice, which focusses on the $\sigma_x$ terms. </p>
<p>Returning to the $\sigma_z$ representation, it looks like every loop configuration is a ground state wave-function and so is a massively degenerate loop space $L$. But this conclusion doesn’t include the plaquette terms (i.e. the $B_p$ coefficient) yet. Since the plaquette terms commute with the vertex terms in the Hamiltonian, the plaquette terms take us between different loop configurations. Considering the plaquette Hamiltonian in the low energy space of closed loops we can show that the ground state wave-function must be the sum of all possible (i.e. ones that can be reached by applying the plaquette terms) loop configurations with equal weight. </p>
<p>The ground state looks pretty non-degenerate at this point but if we consider the system with periodic boundary conditions - namely on a torus, we immediately see that there are 4 topologically distinct loop configurations that are degenerate. Basically, the plaquette terms can only deform the loops smoothly and therefore cannot change the parity of the winding numbers of the loops. </p>
<p>It is however possible to continuously deform a closed loop into a pair of loops along some cycle of the torus. So only the parity of the loop winding across a cut cannot be changed. Thus, the toric code on a torus has 4 degenerate ground state wave-functions (all with the same energy), which are topologically distinct. The difference between these wave functions is the parity of the number of loops crossing a vertical or a horizontal cycle on the torus.</p>
<p>Does this have anything to do with the way we have defined topology in this course, using the bulk-edge correspondence? Unfortunately and confusingly, not. These interacting systems are topological in the sense of having a topological degeneracy between topologically distinct states that cannot be continuously deformed into one another. In a sense, this is a more amazing feature than the bulk edge correspondence itself - the degeneracy between these states cannot be lifted by any reasonable (local) perturbation. This is sort of similar to Majorana fermions, but even more robust. In fact, the toric code does not even have edge states, so there is really no bulk-edge correspondence to speak of.</p>
<p>The topological robustness makes the topologically degenerate states particularly attractive to store quantum information. The main challenge of quantum information is the quantum decoherence problem, where local fluctuations in the Hamiltonian destroy the phase coherence of the quantum system used to store information. The solution proposed by topological quantum computation is to use the topologically degenerate space of a toric code to store the information. In fact, this is in essence what is being attempted by experimentalists who work on superconducting qubits, under the framework of the surface code. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;How would the topological degeneracy of the ground state that comes from the loop configurations &quot;</span></span><br><span class="line">    <span class="string">&quot;change if we put it on a torus (donut) with two holes?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Since there is still an infinite number of loop configurations, the degeneracy would be infinite.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since there is one additional hole there are two more distinct cycles. &quot;</span></span><br><span class="line">    <span class="string">&quot;So  the number of ground states increases by a factor of 4.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It still remains 4 since the loops is topologically forbidden from going around the extra loops.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Since there is one additional hole the loops can go around this hole an even or an odd number of time, &quot;</span></span><br><span class="line">    <span class="string">&quot;so the degeneracy increases from 4 to 8.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The additional hole introduces the possibility of 2 values of parity on each extra cycle. This adds a &quot;</span></span><br><span class="line">    <span class="string">&quot;factor of $2 \\times 2=4$.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Particle-like-excitations"><a href="#Particle-like-excitations" class="headerlink" title="Particle-like excitations"></a>Particle-like excitations</h1><p>As we saw in the FQH systems, excitations with fractional charge and statistics was really the hall-mark of topologically degenerate states. Since the basic degree of freedom in the toric code are spin, we expect all excitations to be neutral. But there is a possibility that we get fractionalized statistics. The neat thing about the toric code Hamiltonian is that it allows us to not only compute the ground state for the toric code but also all the excited states. Again, this is not too surprising since all the terms in the Hamiltonian commute, so all eigenstates are simultaneous eigenstates of the vertex and plaquette terms. If we focus on the vertex terms first (let’s say by assuming that $B_p\ll A_v$), we can get excitations of the vertex Hamiltonian by breaking loops. We can think of the end points of the loops as excitations, since the plaquette terms proportional to $B_p$ make the plaquette terms fluctuate. These particles (that you see in the figure below) because of analogy with $Z_2$ gauge theory, are called the electric defects, which we label ‘e’. As shown below, analogous defects in $\sigma_x=-1$-loops on the dual lattice are referred to as magnetic defects, which we will label ‘m’. </p>
<p><img src="/2021/01/07/src/w12_manybody/topoorder/toric_exchanges.svg" alt></p>
<p>While the intuitive picture for the excitations as ends of broken loops is nice, to describe these exctiation in the more general case, where $A_v$ and $B_p$ are comparable, it is convenient to define the so-called Wilson path operators </p>
<p>$$W_e=\prod_{\mathcal{l}<em>e} \sigma_z,\quad, W_m=\prod</em>{\mathcal{l}_m}  \sigma_x.$$</p>
<p>By viewing the system in the $\sigma_z$-basis in the limit $B_p\rightarrow 0$, we see that the operator $W_e$ counts the parity of $\sigma_z=-1$ spins that lie on the loop $\mathcal{l}_e$. Therefore, in this limit $W_e$ measures the parity of ‘e’ excitations inside the loop $\mathcal{l}_e$. The  operator $W_e$ is a product of the vertex terms inside the loop $\mathcal{l}_e$ and hence commutes with $H$ for any strength  of the plaquette terms proportional to $B_p$. </p>
<blockquote>
<p>Therefore $W_e$ and $W_m$ are conserved ‘flux’ operators that measure the parity of the number of electric and magnetic defects inside the loops $\mathcal{l}_{e,m}$ respectively.</p>
</blockquote>
<p>Thus, the values $W_{e,m}=-1$ can also be used to define what it means to have a localized ‘e’ or ‘m’ excitation respectively. These defects describe the localized excitations of the toric code. In fact in this model, this excitation on the ground states are localized to exactly one lattice site and may be viewed as point-like particles in a vacuum.  </p>
<p>Just like in the quantum Hall effect, we can use the Wilson loops $W_{e,m}$ to characterize the degenerate ground states of the toric code on a torus. The value of the Wilson loop $W_e$ counts the parity of intersections of $\sigma_z=-1$ loops (red lines) crossing the Wilson loop. Therefore, the value of the Wilson loop $W_e$ along one of the cycles of the torus counts the parity of the $\sigma_z=-1$ loops crossing it. Since we can draw a pair of commuting Wilson loop $W_e$, one through each cycle of the torus, the degeneracy of the torus from $W_e=\pm 1$ is 4. This is exactly what we got from the loop picture. </p>
<h1 id="Semionic-statistics-of-excitations"><a href="#Semionic-statistics-of-excitations" class="headerlink" title="Semionic statistics of excitations"></a>Semionic statistics of excitations</h1><p>The loop gas picture makes the ‘e’ and ‘m’ excitations, which are ends of loops look quite topological. But are they topological in a sense similar to the charges in the FQH system? To see this, let us try to interchange an ‘e’ particle and an ‘m’ particle. For starters let us see how to move each of these particles. To do this we use the ‘path’ operators </p>
<p>$$\Gamma^{(e)}(a,b)=\prod_{a\rightarrow b}\sigma_x,\quad,\Gamma^{(m)}(a,b)=\prod_{a\rightarrow b}\sigma_z,$$</p>
<p>to move an excitation from point $a$ to $b$. This is because this operator will flip $W_{e,m}(a):-1\rightarrow +1$ at end $a$ and hence destroy the excitation and also flip $W_{e,m}(b):+1\rightarrow -1$ to create an excitation. </p>
<p>Now, if we try to take an ‘e’ particle around an ‘m’ particle, the path forms a loop $W_e$ around ‘m’. This adds a factor of  $W_e=-1$ to the wave-function, for the double exchange process between ‘e’ and ‘m’, which is topologically equivalent to taking one particle around the other. This strange exchange statistics, which is not quite the same as the exchange of identical particles that we are used to is referred to as “semionic” statistics.</p>
<p>Next, we try to exchange a pair of ‘e’ particles. We can do this by applying a pair of path operators $\Gamma^{(e)}$ to the particles<br>that form a loop. This pair of operators form loop operator $W_e$, which must be $W_e=+1$ unless there is an ‘m’ particle inside. Therefore the ‘e’ particles are bosons and so are the ‘m’ particles by a similar argument.</p>
<p>Finally, if we exchange an ‘e’-‘m’ pair with another ‘e’-‘m’ pair, we see, that the result is equivalent to a double exchange between an ‘e’ particle and an ‘m’ particle in addition some ‘e’ and ‘m’ exchanges. The double exchange produces a $-$ sign as we saw. However, unlike the case of exchanging ‘e’ and ‘m’ particles, the ‘e’-‘m’ pairs (also called dyons) are identical particles and therefore we can treat them analogous to exchanging quantum particles in nature. In this context, the $-$ sign should suggest to you that the dyon ‘e’-‘m’ are really fermions. This is rather strange because the microscopic constituents of our theory were spins whose exchange phases are always $1$ (i.e. bosons) and we end up with fermions, which are in some sense half of bosons.<br>Thus, the toric code, in a sense, gives us a microscopic model of “fractional statistics”.</p>
<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topological order&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w12_manybody/fqhe/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This topic is introduced by Sankar Das Sarma from the university of Maryland.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;4gSJSo3olfg&quot;</span>, src_location=<span class="string">&quot;12.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Interacting-systems"><a href="#Interacting-systems" class="headerlink" title="Interacting systems"></a>Interacting systems</h1><p>One obvious thing that we completely ignored throughout the course is the effects of interactions on topology. It is of course possible to generalize all the symmetry classes that we have studied to many-body Hamiltonians, but what happens to the classification of the topological phases?</p>
<p>The first statement we should make here is that our work so far wasn’t wasted: most of the usual topological insulators turn out to tolerate interactions as long as the interactions do not spontaneously break the symmetry, or close the bulk gap.<br>There are interesting cases where the classification collapses. For example, the 1D BDI chain with Majorana fermions on one of the two sublattice degrees of freedom allows a $\mathbb{Z}_8$ classification with interactions instead of $\mathbb{Z}$. The reason for this is that the 8-Majorana interaction term doesn’t break the symmetries anymore.</p>
<p>However this is relatively minor compared to the real can of worms that the interactions open: the amount of possibilities for the interacting phases is much larger. To begin with, we’ll discuss the oldest known example of a strongly interacting topological phase, the fractional quantum Hall effect. Note that it only covers a single dimension ($D=2$), and a single symmetry class (no symmetry at all). Yet, classifying all such states turns out to be a very hard task.</p>
<h1 id="Fractional-charge-and-statistics-in-the-fractional-quantized-Hall-effect"><a href="#Fractional-charge-and-statistics-in-the-fractional-quantized-Hall-effect" class="headerlink" title="Fractional charge and statistics in the fractional quantized Hall effect"></a>Fractional charge and statistics in the fractional quantized Hall effect</h1><p>If you followed what we learned about the integer quantum Hall effect, you’ll remember that we used the pumping argument to establish that the Hall conductance in an incompressible liquid is quantized in integers. You might now wonder if the experimental evidence for the fractional quantum Hall effect completely invalidates this argument in some way. The key step in the argument was to realize that the pumped charge that results from the insertion of one flux quantum $\Phi_0$ into a Corbino geometry is </p>
<p>$$<br>Q_{pump}=\sigma_{xy}\Phi_0\equiv \nu e,<br>$$</p>
<p>where $\nu=\sigma_{xy}/G_0$ is the Hall conductance in dimensionless units. For the non-interacting system that we studied in the quantum Hall effect, we assumed that only an integer number of electrons could be transferred between the edges - so $\nu$ had to be an integer. </p>
<p>The real reason that the charge transferred had to be an integer multiple of the electron charge was that the Hamiltonian for the electrons was identical between flux $\Phi=0$ and flux $\Phi=\Phi_0$. Since the system is incompressible, it is reasonable to assume that all excitations in the system are local. Usually we expect different excited states to differ by rearranging electrons. Within this framework, such excitations can differ by integer multiples of electronic charge.</p>
<p>The existence of fractional values of $\nu$ implies that the edge can have local excitations that differ by a fractional electron charge. In principle, the inner edge of the Corbino geometry can be shrunk to a point, and if we do this, we’re forced to conclude that the system can now host excitations that have fractional charge.</p>
<p>The fractional charged excitations are local particles just like the electrons themselves. So we can ask about the statistics under exchange of two such particles. On performing such an exchange, the total many-body wave function of the system returns to itself, but<br>the wave function can pick up a Berry phase. For fermions this phase is $\pi$ and for Bosons it is zero. Instead of computing the phase directly, let us consider doing a double exchange, which is topologically equivalent to taking a particle around another one and computing the phase for that. </p>
<p><img src="/2021/01/07/src/w12_manybody/fqhe/exchange.svg" alt></p>
<p>Let us first assume that one of the particles was created by a flux quantum. Since the flux quantum created this particle adiabatically by a pumping process, locality dictates that the particle going around the flux quantum + particle cannot know about the existence of the other particle. Thus the phase from going around a particle together with its flux quantum must vanish. On the other hand, the particle picks up a phase of $2\pi \nu$ from just going around the flux quantum. Thus double exchange of a pair of particles leads to a Berry phase of $-2\pi\nu$. This is another strange property of excitations in the FQH state! They must obey different statistics than both fermions and bosons, and are thus referred to as anyons. Therefore the exchange phase of anyons in the simple FQH states is given by </p>
<p>$$<br>\phi_{exch}=\pi\nu.<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;The Laughlin argument was used to prove that the Hall effect must be quantized in integers. What is the key assumption&quot;</span></span><br><span class="line">    <span class="string">&quot;that must be dropped in order to understand the fractional quantum Hall effect?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Allow electrons to have fractional statistics.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Allow quasiparticles with fractional charge.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Require that the system forms an incompressible fluid.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Allow electrons to have fractional charge.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Allow quasiparticles to have fractional statistics.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;The key assumption in the Laughlin argument for the integer case was that the charge that was added by pumping could&quot;</span></span><br><span class="line">    <span class="string">&quot;only be an integer multiple of an electronic charge.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Topological-degeneracy"><a href="#Topological-degeneracy" class="headerlink" title="Topological degeneracy"></a>Topological degeneracy</h1><p>Knowing that the system supports particles with nontrivial braiding statistics, we can derive its next important property, the topological degeneracy of the ground state.</p>
<p>To do this, we turn around the argument for computing the statistics of particles and consider the statistics of fluxes. A particle going around a flux acquires a phase of $2\pi\nu$. As noted in the last unit, the combination of a particle and flux does not have any non-trivial exchange statistics. So replacing the particle by another flux will lead to a phase of $-2\pi \nu$. Therefore the exchange phase of fluxes gives a phase of $\pi\nu$, just like the exchange of particles.</p>
<p>Let us now put the FQH system on a torus. A natural operation on the torus is to create a flux anti-flux pair, move them around a cycle of the torus and annihilate them at the end. This operation inserts a flux into one of the two nontrivial cycles of the torus. Let’s label this operation $T_{1,2}$ for each of the cycles of the torus:</p>
<p><img src="/2021/01/07/src/w12_manybody/fqhe/torus.svg" alt></p>
<p>The last physical step to deriving the degeneracy is to ask what is the commutator $T_1^{-1}T_2^{-1}T_1 T_2$. This operator describes first moving a vortex around the red contour, then moving the vortex around the blue contour, moving the vortex back around the red contour, and finally undoing the motion of the vortex along the blue contour.<br>No matter which path we choose for this operation, we will need to take one vortex all the way around the other one. According to the braiding rule we get:</p>
<p>$$<br>T_1^{-1}T_2^{-1}T_1 T_2 =e^{i2\pi \nu}.<br>$$</p>
<p>Now all we need to do is an exercise in elementary quantum mechanics. First of all, both $T_{1,2}$ commute with the Hamiltonian. Let’s take $|\Psi\rangle$ as a simultaneous ground state of the Hamiltonian and eigenstate of $T_1$. If in addition $e^{i\alpha}|\Psi\rangle=T_2|\Psi\rangle$, then $T_1$ and $T_2$ would commute. Since we know this isn’t the case, $T_2|\Psi\rangle$ must be a ground state of the Hamiltonian which is not the same as $|\Psi\rangle$.</p>
<blockquote>
<p>We conclude that fractional quantum Hall phases have ground state degeneracy on the torus.</p>
</blockquote>
<p>We have seen an example of ground state degeneracy in Majorana wires, where the degeneracy of the zero modes could not be lifted by any local perturbation. The difference between the Majorana case and fractional quantum Hall is that in the latter we don’t rely on the presence of defects, and the degeneracy is a property of the surface on which we put the fractional quantum Hall state.</p>
<h1 id="Creating-an-FQH-state"><a href="#Creating-an-FQH-state" class="headerlink" title="Creating an FQH state"></a>Creating an FQH state</h1><p>How can we describe a fractional quantum Hall state? Laughlin used a representation of the many-electron wave function in complex coordinates to guess a wave function of an incompressible state. We will instead follow the more intuitive “Composite Fermion” approach due to Jain to understand this state. </p>
<p>The starting point for the FQH state is of course the same as for the integer quantum Hall states, i.e. electrons in a magnetic field that occupy Landau levels. As we noticed in week 3, every state in a single Landau level is at exactly the same energy. The simplest family of FQH states are ones where the lowest Landau level states are only partially filled. Since there is no kinetic energy, the state is determined entirely by optimizing the Coulomb repulsion such that the electrons are as far away from each other as possible.</p>
<p>The composite fermion theory postulates that electrons manage to space themselves out by associating themselves with “vortex”-like excitations. As you hopefully recall, a vortex in a superconductor is a defect where the superconducting phase $\varphi$ winds by $2\pi$ when going around the vortex. An electron going around the vortex picks up a $\pi$-phase shift. On the other hand, an electron can go around a double vortex and pick up effectively no (i.e. $2\pi$) phase shift. However, the electron feels a phase gradient or a vector potential ${\bf A}={\bf\nabla}\varphi$ as it goes around the vortex. Such a vector potential is like a magnetic field and repels the electron. </p>
<p>Of course we have no superconductivity at hand, but we can mimic the vortex properties using a mathematical trick involving complex numbers. First let us introduce complex coordinates for the electrons $z=x+iy$. Then we notice that we can insert a double vortex at $z_0$ in a gas of electrons with wave function $\Psi(z_1,\dots)$ by the transformation</p>
<p>$$<br>\Psi(z_1,\dots)\rightarrow \prod(z_i-z_0)^2\Psi(z_1,\dots).<br>$$</p>
<blockquote>
<p>The basic trick of composite fermions in trying to keep electrons far apart is to say that each electron binds  an even number $(2m)$ vortices to form a composite fermion.</p>
</blockquote>
<p>This amounts to the transformation of the many-body wave function $\Psi_{CF}(z_1,z_2,\dots)=\prod_{i &lt; j}(z_i-z_j)^2\Psi(z_1,z_2,\dots)$, where $z_j$ are the electron wave-functions.</p>
<p>Pictorially the composite fermion transformation is represented as:</p>
<p><img src="/2021/01/07/src/w12_manybody/fqhe/composite.svg" width="800"></p>
<p>The next step in the composite fermion approach to the FQH state is to say that all the correlation effects of the Coulomb interaction are taken care of by the flux attachment. Beyond this, the composite fermions are weakly interacting particles. If we believe in this picture, then the only non-interacting incompressible states that we can get are integer quantum Hall states. This means that the FQH states are integer quantum Hall states of the composite fermions.</p>
<p>How does this explain a fractionally filled state? Well, the original electron is $2m$ flux quanta together with a composite fermion. If we smear out the flux created by the electron density $\nu$, we get a magnetic field of $2m\nu$ flux quanta per unit area. This is in addition to the one flux quantum per unit area of the external magnetic field. Therefore the composite fermions, which are at a density of $\nu$ per unit area, see a magnetic field of $2m\nu+1$ per unit area. We can make the composite fermions form an incompressible state with $p$-Landau levels filled if<br>$\nu=p(2m\nu+1),$ so that we describe a state of filling </p>
<p>$$<br>\nu=\frac{p}{2 m p-1}.<br>$$</p>
<p>Thus the composite fermion theory provides an explanation for how electrons can form incompressible states at a fractional sequence of filling fractions that is known as the “Jain sequence”. These states were all seen in experiments.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Composite fermions allow one to explain incompressible states at fractional filling of the Landau levels by &quot;</span></span><br><span class="line">    <span class="string">&quot;postulating that:&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The quantum Hall system forms an incompressible liquid.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The fractionally charged quasiparticles bind to fluxes to reduce the filling.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The electrons become fractionally charged.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The electrons bind to fluxes and reduce the effective magnetic field.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Composite fermions are electrons bound to fluxes. Electrons are the fundamental particles and they cannot change &quot;</span></span><br><span class="line">    <span class="string">&quot;their charge. The fractional charged quasiparticles are invoked by composite fermions not explained by the theory. &quot;</span></span><br><span class="line">    <span class="string">&quot; The incompressible liquid is true for either integer or fractional quantum Hall.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Classification-and-fractional-topological-insulators"><a href="#Classification-and-fractional-topological-insulators" class="headerlink" title="Classification and fractional topological insulators"></a>Classification and fractional topological insulators</h1><p>Before we approach the classification of topological insulators in the presence of symmetries, let us discuss the fractional quantum Hall effect. In fact, there is a whole bunch of fractional quantum Hall states, so there is clearly room for classification. However, at first glance it looks more challenging because we cannot really solve general two dimensional interacting Hamiltonians. The tool that is used to understand what phases might exist is braiding. Based on all the examples of two-dimensional topological states with no symmetry that we have so far, it is believed that distinct topological states are characterized by distinct particle-like anyonic excitations with distinct topological properties. It is certainly obvious that if two states have topologically distinct excitations in the bulk they cannot be adiabatically deformed into one another, since the braiding rules cannot change continuously.</p>
<p>So the basic rule of the game is to ask what are all possible braiding rules for excitations in two dimensions. One would think that it would simply be arbitrary. Turns out that the situation is not quite as bad - locality and unitarity put rather strong constraints on the possible braidings of particles. The answer is obtained through a branch of mathematics called modular tensor category theory, and the theory tells us that valid sets of fractional excitations must obey the so-called pentagon and hexagon equations. All this being said, not all solutions of these equations are known - so basically the set of possible phases is not quite known. And this is all very abstract - and not even all the abstractly known phases that have acceptable braiding rules are known to be realized in nature. In fact, so far most of the known phases seem to be composite fermion ones that are well understood.</p>
<h2 id="Symmetries"><a href="#Symmetries" class="headerlink" title="Symmetries"></a>Symmetries</h2><p>To approach the classification of interacting topological insulators with symmetries, we can start by playing the same game as Kane and Mele, and combine two fractional quantum Hall states (instead of integer ones) to make a fractional topological insulator. If we choose a pair of FQH states which are related by time-reversal and stack them together for spin-up and spin-down electrons, that technically leads to a time-reversal invariant state. The key question that needs to be asked is whether one can gap out the edge states by adding time-reversal invariant perturbations. If one can do that, then unlike the Kane-Mele quantum spin Hall state, the state is not a phase that is protected by just time-reversal symmetry. This question is not too mathematically involved, though still beyond this course and can be answered by the bosonization technique as was done by <a href="http://arxiv.org/abs/0906.2769">Stern and Levin</a>.</p>
<p>We can however explain the result. If one stacks the two FQH states one obtains a spin-Hall conductance $\sigma_{sh}$, which is equal to the Hall conductance of each layer. Let the smallest charge of an excitation of our phase be $e^<em>$, some fraction of electron charge. It turns out that the edge states are protected from gapping by time-reversal invariant perturbations if and only if $\sigma_{sh}/e^</em>$ is an odd integer. This gives some idea as to what kind of interacting analogues of quantum spin Hall states one may get. But again, as with the non-symmetric case, the general classification is still up in the air. More importantly, we don’t really have realistic candidates for such states yet.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;zrL-qxjKfGw&quot;</span>, src_location=<span class="string">&quot;12.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;FQHE&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w11_extensions2/w11_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulation-powers-combined"><a href="#Simulation-powers-combined" class="headerlink" title="Simulation: powers combined"></a>Simulation: powers combined</h1><p>As usual, start by grabbing the notebooks of this week (<code>w11_extensions2</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<p>Are you tired yet of all the different kinds of topology? If no, this assignment is for you :-)</p>
<p>By now you should have a feel for how to make new topological phases. Your task now is to combine the two systems you’ve learned about and to create a Floquet crystalline topological insulator. If you want even more challenge, create also a gapless Floquet topological material.</p>
<p>Take care however: if you take a topologically nontrivial system and just apply rapid driving, you’ll still get a topological one. This cheating way is prohibited: at any moment during the driving cycle the Hamiltonian of your system should remain gapped.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Floquet and crystalline&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1010-6126"><a href="#arXiv-1010-6126" class="headerlink" title="arXiv:1010.6126"></a>arXiv:1010.6126</h3><p><strong>Hint:</strong> Computes topological edge states from Floquet Hamiltonian.</p>
<h3 id="arXiv-1212-3324"><a href="#arXiv-1212-3324" class="headerlink" title="arXiv:1212.3324"></a>arXiv:1212.3324</h3><p><strong>Hint:</strong> Points out and explains why the floquet Hamiltonian in momentum space does not capture the presence of Floquet edge states.</p>
<h3 id="arXiv-1202-1003"><a href="#arXiv-1202-1003" class="headerlink" title="arXiv:1202.1003"></a>arXiv:1202.1003</h3><p><strong>Hint:</strong> Theoretical prediction of topological crystalline insulator.</p>
<h3 id="arXiv-1212-6191"><a href="#arXiv-1212-6191" class="headerlink" title="arXiv:1212.6191"></a>arXiv:1212.6191</h3><p><strong>Hint:</strong> Are topological crystalline surface states stable against disorder?</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Floquet and crystalline&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w11_extensions2/floquet/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg <span class="keyword">as</span> la</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">pi_ticks = [</span><br><span class="line">    (-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>),</span><br><span class="line">    (-np.pi / <span class="number">2</span>, <span class="string">r&quot;$-\pi/2$&quot;</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>),</span><br><span class="line">    (np.pi / <span class="number">2</span>, <span class="string">r&quot;$\pi/2$&quot;</span>),</span><br><span class="line">    (np.pi, <span class="string">r&quot;$\pi$&quot;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkerboard</span>(<span class="params">W=<span class="literal">None</span></span>):</span></span><br><span class="line">    lat = kwant.lattice.general([[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]], [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)])</span><br><span class="line">    a, b = lat.sublattices</span><br><span class="line">    <span class="keyword">if</span> W:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lead_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">            (x, y) = pos</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; W <span class="keyword">and</span> <span class="number">0</span> &lt;= x &lt; W</span><br><span class="line"></span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">        syst[a.shape(lead_shape, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">0</span></span><br><span class="line">        syst[b.shape(lead_shape, (<span class="number">1</span>, <span class="number">0</span>))] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">        syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">0</span></span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>), b, a)] = <span class="keyword">lambda</span> s1, s2, p: -p.t1</span><br><span class="line">    syst[kwant.HoppingKind((-<span class="number">1</span>, <span class="number">1</span>), b, a)] = <span class="keyword">lambda</span> s1, s2, p: -p.t2</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), a, b)] = <span class="keyword">lambda</span> s1, s2, p: -p.t3</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), a, b)] = <span class="keyword">lambda</span> s1, s2, p: -p.t4</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evolution_operator</span>(<span class="params">hamiltonians, T</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(hamiltonians)</span><br><span class="line">    exps = [la.expm(-<span class="number">1j</span> * h * T / n) <span class="keyword">for</span> h <span class="keyword">in</span> hamiltonians]</span><br><span class="line">    <span class="keyword">return</span> reduce(np.dot, exps)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_h_k</span>(<span class="params">lead, p</span>):</span></span><br><span class="line">    bands = kwant.physics.Bands(lead, params=<span class="built_in">dict</span>(p=p))</span><br><span class="line">    h, t = bands.ham, bands.hop</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> k: h + t * np.exp(-<span class="number">1j</span> * k) + t.T.conj() * np.exp(<span class="number">1j</span> * k)</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Today’s topic, Floquet topological insulators, is introduced by Mark Rudner from the Niels Bohr Institute at Copenhagen.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;1peVp_IZ7Ts&quot;</span>, src_location=<span class="string">&quot;11.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Periodically-driven-systems"><a href="#Periodically-driven-systems" class="headerlink" title="Periodically driven systems"></a>Periodically driven systems</h1><p>We will now learn about a new generalization of topology, namely how it applies to the quantum evolution of systems with a time-dependent Hamiltonian. As you may recall, we’ve already encountered time dependence, back when we considered quantum pumps. However, back then we assumed that the time evolution was very slow, such that the system stayed in the ground state at all times, i.e. it was adiabatic. Can we relax the adiabaticity constraint? Can we find an analog of topology in systems that are driven so fast that energy isn’t conserved?</p>
<p>For the same reasons as before, we’ll consider periodic driving</p>
<p>$$<br>H(t + T) = H(t).<br>$$</p>
<p>Once again, this is necessary because otherwise, any system can be continuously deformed into any other, and there is no way to define a gap.</p>
<p>Before we get to topology, let’s refresh our knowledge of time-dependent systems.</p>
<p>The Schrödinger equation is:</p>
<p>$$<br>i\frac{d \psi}{dt} = H(t) \psi.<br>$$</p>
<p>It is a linear equation, so we can write its solution as</p>
<p>$$<br>\psi(t_2) = U(t_2, t_1) \psi(t_1),<br>$$</p>
<p>where $U$ is a unitary <em>time evolution operator</em>. It solves the same Schrödinger equation as the wave function, and is equal to the identity matrix at the initial time. It is commonly written as</p>
<p>$$<br>U(t_2, t_1) = \mathcal{T} \exp,\left[-i\int_{t_1}^{t_2} H(t) dt\right],<br>$$</p>
<p>where $\mathcal{T}$ represents time-ordering (not time-reversal symmetry). The time-ordering is just a short-hand notation for the need to solve the full differential equation, and it is necessary if the Hamiltonians evaluated at different times in the integral do not commute.</p>
<p>The time evolution operator satisfies a very simple multiplication rule:</p>
<p>$$<br>U(t_3, t_1) = U(t_3, t_2) U(t_2, t_1),<br>$$</p>
<p>which just says that time evolution from $t_1$ to $t_3$ is a product of time evolutions from $t_1$ to $t_2$ and then from $t_2$ to $t_3$. Of course an immediate consequence of this is the equality $U(t_2, t_1)^\dagger = U(t_2, t_1)^{-1} = U(t_1, t_2)$.</p>
<h2 id="Floquet-theory"><a href="#Floquet-theory" class="headerlink" title="Floquet theory"></a>Floquet theory</h2><p>The central object for the study of driven systems is the evolution operator over one period of the driving,</p>
<p>$$<br>U(t + T, t) \equiv U,<br>$$</p>
<p>which is called the Floquet time evolution operator. It is important because it allows us to identify the wave functions that are the same if an integer number of drive periods passes. These are the stationary states of a driven system, and they are given by the eigenvalues of the Floquet operator:</p>
<p>$$<br>U \psi = e^{i \alpha} \psi.<br>$$</p>
<p>The stationary states are very similar to the eigenstates of a stationary Hamiltonian, except that they are only stationary if we look at fixed times $t + nT$. That’s why the Floquet time evolution operator is also called a stroboscopic time evolution operator.</p>
<p>We can very easily construct a Hermitian matrix from $U$, the <strong>Floquet Hamiltonian</strong>:</p>
<p>$$<br>H_\textrm{eff} = i T^{-1} ,\ln U.<br>$$</p>
<p>Its eigenvalues $\varepsilon = \alpha / T$ are called quasi-energies, and they always belong to the interval $-\pi &lt; \alpha \leq \pi$.</p>
<p>If the system is translationally invariant, we can study the effective band structure of $H_\textrm{eff}(\mathbf{k})$, find an energy in which the bulk Hamiltonian has no states, and study the topological properties of such a Hamiltonian: most of the things we already know still apply.</p>
<p>Of course, selecting a single quasi-energy as the Fermi level is arbitrary, since the equilibrium state of driven systems doesn’t correspond to a Fermi distribution of filling factors, but at least it seems close enough for us to try to apply topological ideas.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;But wait, we arbitrarily chose the starting point $t$ in time for calculating the &quot;</span></span><br><span class="line">    <span class="string">&quot;Floquet operator. What if we chose a different one?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The starting time is just an extra parameter of our system, and topology depends on it.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter, the wave function evolution within one period &quot;</span></span><br><span class="line">    <span class="string">&quot;can be neglected, since we are interested in many periods.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There&#x27;s only one correct starting point in time.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;It doesn&#x27;t matter since the quasienergies are independent of the starting point.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Choosing a different starting point applies a unitary transformation &quot;</span></span><br><span class="line">    <span class="string">&quot;to the Floquet evolution operator, and so it keeps the quasienergies the same.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Driven-Majorana-wire"><a href="#Driven-Majorana-wire" class="headerlink" title="Driven Majorana wire"></a>Driven Majorana wire</h1><p>Let us start by considering something we know very well, namely the superconducting Majorana nanowire model from week 2. This model has three important parameters which determine whether the wire is in the topological Majorana phase or not: the chemical potential $\mu$, the superconducting gap $\Delta$, and the magnetic field $B$. The topological phase with unpaired Majorana modes at zero energy is realized for $B &gt; \sqrt{\mu^2 + \Delta^2}$.</p>
<p>Now, imagine that we can periodically drive some of these parameters. For instance, consider the simple example when</p>
<p>$$<br>\mu = \left{<br>\begin{matrix}<br>\mu_1 \quad \text{for } 0 &lt; t &lt; T/2 \<br>\mu_2 \quad \text{for } T/2 &lt; t &lt; T<br>\end{matrix}\right.<br>$$</p>
<p>Then, the integral to find the time evolution operator is easy to evaluate, and we simply have</p>
<p>$$<br>U = \exp(i T H_2 / 2) \exp(i T H_1 / 2)<br>$$</p>
<p>with $H_1$ and $H_2$ the nanowire Hamiltonians with chemical potential $\mu_1$ and $\mu_2$. A peculiar property of driven systems is that as the period becomes large, the band structure ‘folds’: if the driving is very weak, and the original Hamiltonian has energy $E$, the Floquet Hamiltonian has a much smaller quasienergy $(E\bmod 2\pi /T)$. This means that even when $H_1$ and $H_2$ correspond to trivial systems, we can still obtain nontrivial topology if we make the period large enough, as you can see for yourself:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%opts Path &#123;+axiswise&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_chain</span>(<span class="params">L=<span class="literal">None</span></span>):</span></span><br><span class="line">    lat = kwant.lattice.chain()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * p.t - p.mu) * pauli.szs0 + p.B * pauli.s0sz + p.delta * pauli.sxs0</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopping</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 + <span class="number">0.5</span> * <span class="number">1j</span> * p.alpha * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> L:</span><br><span class="line">        syst = kwant.Builder()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        syst = kwant.Builder(kwant.TranslationalSymmetry((-<span class="number">1</span>,)))</span><br><span class="line">        L = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    syst[(lat(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(L))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>,), lat)] = hopping</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_finite_spectrum</span>(<span class="params">periods, hamiltonians</span>):</span></span><br><span class="line">    energies = []</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> periods:</span><br><span class="line">        U = evolution_operator(hamiltonians, T)</span><br><span class="line">        phases = np.angle(la.eigvals(U))</span><br><span class="line">        phases = np.sort(np.<span class="built_in">abs</span>(phases))</span><br><span class="line">        ev = np.sort([(-<span class="number">1</span>) ** n * val <span class="keyword">for</span> n, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(phases)])</span><br><span class="line">        energies.append(ev)</span><br><span class="line">    <span class="keyword">return</span> np.array(energies).real</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_bands</span>(<span class="params">momenta, hamiltonians_k, T</span>):</span></span><br><span class="line">    energies = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> momenta:</span><br><span class="line">        hamiltonians = [h_k(k) <span class="keyword">for</span> h_k <span class="keyword">in</span> hamiltonians_k]</span><br><span class="line">        U = evolution_operator(hamiltonians, T)</span><br><span class="line">        phases = np.angle(la.eigvals(U))</span><br><span class="line">        phases = np.sort(np.<span class="built_in">abs</span>(phases))</span><br><span class="line">        ev = np.sort([(-<span class="number">1</span>) ** n * val <span class="keyword">for</span> n, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(phases)])</span><br><span class="line">        energies.append(ev)</span><br><span class="line">    <span class="keyword">return</span> np.array(energies).real</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">J = <span class="number">2.0</span></span><br><span class="line">p1 = SimpleNamespace(t=J / <span class="number">2</span>, mu=-<span class="number">1</span> * J, B=J, delta=<span class="number">2</span> * J, alpha=J)</span><br><span class="line">p2 = SimpleNamespace(t=J / <span class="number">2</span>, mu=-<span class="number">3</span> * J, B=J, delta=<span class="number">2</span> * J, alpha=J)</span><br><span class="line"></span><br><span class="line">syst = nanowire_chain(L=<span class="number">20</span>).finalized()</span><br><span class="line">H1 = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p1))</span><br><span class="line">H2 = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p2))</span><br><span class="line"></span><br><span class="line">lead = kwant.wraparound.wraparound(nanowire_chain(L=<span class="literal">None</span>)).finalized()</span><br><span class="line">h1_k = <span class="keyword">lambda</span> kx: lead.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p1, k_x=kx))</span><br><span class="line">h2_k = <span class="keyword">lambda</span> kx: lead.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p2, k_x=kx))</span><br><span class="line"></span><br><span class="line">periods = np.linspace(<span class="number">0.2</span> / J, <span class="number">1.6</span> / J, <span class="number">100</span>)</span><br><span class="line">momenta = np.linspace(-np.pi, np.pi)</span><br><span class="line"></span><br><span class="line">energies = calculate_finite_spectrum(periods, [H1, H2])</span><br><span class="line">spectrum = np.array([calculate_bands(momenta, [h1_k, h2_k], T) <span class="keyword">for</span> T <span class="keyword">in</span> periods])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot</span>(<span class="params">n</span>):</span></span><br><span class="line">    T = J * periods[n]</span><br><span class="line"></span><br><span class="line">    plot_1 = holoviews.Path(</span><br><span class="line">        (J * periods, energies),</span><br><span class="line">        kdims=[<span class="string">r&quot;Driving period $(JT)$&quot;</span>, <span class="string">r&quot;Quasi-energy $(ET)$&quot;</span>],</span><br><span class="line">        label=<span class="string">&quot;Finite system&quot;</span>,</span><br><span class="line">    ).opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: <span class="number">5</span>, <span class="string">&quot;yticks&quot;</span>: pi_ticks&#125;)</span><br><span class="line"></span><br><span class="line">    VLine = holoviews.VLine(T).opts(style=&#123;<span class="string">&quot;color&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;linestyle&quot;</span>: <span class="string">&quot;--&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    plot_2 = holoviews.Path(</span><br><span class="line">        (momenta, spectrum[n]), kdims=[<span class="string">&quot;$k$&quot;</span>, <span class="string">&quot;$E_kT$&quot;</span>], label=<span class="string">&quot;Floquet bands&quot;</span></span><br><span class="line">    ).opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: pi_ticks, <span class="string">&quot;yticks&quot;</span>: pi_ticks, <span class="string">&quot;aspect&quot;</span>: <span class="string">&quot;equal&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> plot_1 * VLine + plot_2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(&#123;n: plot(n) <span class="keyword">for</span> n <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)&#125;, kdims=[<span class="string">&quot;n&quot;</span>]).collate()</span><br></pre></td></tr></table></figure>

<p>On the left you see the Floquet spectrum of a finite system as a function of the driving period measured in units of the hopping strength, and on the right you see the Floquet dispersion in momentum space.</p>
<p>We now witness a cool phenomenon: just like in the undriven case, the particle-hole symmetry maps $E \rightarrow -E$, but now this means that not only $E = 0$ is special, but also $E = \pi$!</p>
<p>In other words, this means that there are two relevant gaps in the effective Floquet BdG Hamiltonian $H_\textrm{eff}$. Now, by using the same argument as we used for the regular Majoranas, we learn that if we have an isolated Floquet state with a quasienergy $\epsilon=0$ or $\epsilon=\pi$, it cannot be removed unless the gap surrounding it closes.</p>
<p>In other words:</p>
<blockquote>
<p>A Floquet superconductor has two types of Majorana bound states: the usual ones with quasienergy $\epsilon=0$, and the $\pi$-Majoranas that are as far from zero energy as possible.</p>
</blockquote>
<p>So the calculation above reveals two interesting features of driven systems: the first is that the periodic driving can turn a trivial system into a non-trivial system with topologically protected Floquet states. The second is that topology is richer than in the non-driven system: for instance, here the richness comes from the fact that the topologically protected states may occur at two different points in the spectrum.</p>
<p>Now try to answer the following question: what’s the topological invariant of this system? How do we tell whether normal Majoranas are present, and whether $\pi$-Majoranas are present? (We’ll return to this question in the end of the lecture.)</p>
<h1 id="A-Floquet-Chern-insulator"><a href="#A-Floquet-Chern-insulator" class="headerlink" title="A Floquet Chern insulator"></a>A Floquet Chern insulator</h1><p>As a second example of a driven system that shows something that the undriven system doesn’t, let’s consider the following toy model.</p>
<p>We take a square lattice with time-dependent nearest neighbor hopping $t$. Next, let’s engineer a time-evolution of the hopping between sites such that during a period $T$ hoppings are turned on in an alternate fashion, as in the following figure:</p>
<p><img src="/2021/01/07/src/w11_extensions2/floquet/time_steps.svg" alt></p>
<p>Each step lasts one quarter of a period.</p>
<p>Now let’s tune the period such that the probability for an electron to hop along a hopping is one at the end of each quarter period [$t = (\pi / 2) / (T / 4)$]. Over the complete period the trajectories of electrons will look like this:</p>
<p><img src="/2021/01/07/src/w11_extensions2/floquet/floquet_bulk.svg" alt></p>
<p>Every electron makes a closed loop and ends up back at its origin. After every single period the system is back to its initial state. In other words, the Floquet operator is $U=1$, and $H_\textrm{eff}=0$.</p>
<p>Let’s have a look at the dispersion, and also see what happens as we tune the driving period:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output size=<span class="number">200</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_dispersion_2D</span>(<span class="params">T</span>):</span></span><br><span class="line">    syst = checkerboard()</span><br><span class="line">    B = np.array(syst.symmetry.periods).T</span><br><span class="line">    A = B @ np.linalg.inv(B.T @ B)</span><br><span class="line">    syst = kwant.wraparound.wraparound(syst).finalized()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hamiltonian_k</span>(<span class="params">par</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">k_x, k_y</span>):</span></span><br><span class="line">            k_x, k_y = np.linalg.lstsq(A, [k_x, k_y], rcond=<span class="literal">None</span>)[<span class="number">0</span>]</span><br><span class="line">            ham = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=par, k_x=k_x, k_y=k_y))</span><br><span class="line">            <span class="keyword">return</span> ham</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    hamiltonians_k = [</span><br><span class="line">        hamiltonian_k(SimpleNamespace(t1=<span class="number">1</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>)),</span><br><span class="line">        hamiltonian_k(SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">1</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>)),</span><br><span class="line">        hamiltonian_k(SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">1</span>, t4=<span class="number">0</span>)),</span><br><span class="line">        hamiltonian_k(SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">1</span>)),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_energies</span>(<span class="params">k_x, k_y</span>):</span></span><br><span class="line">        hamiltonians = [h_k(k_x, k_y) <span class="keyword">for</span> h_k <span class="keyword">in</span> hamiltonians_k]</span><br><span class="line">        U = evolution_operator(hamiltonians, T)</span><br><span class="line">        ev = np.sort(np.angle(la.eigvals(U)))</span><br><span class="line">        <span class="keyword">return</span> ev</span><br><span class="line"></span><br><span class="line">    K = np.linspace(-np.pi, np.pi, <span class="number">50</span>)</span><br><span class="line">    energies = np.array([[get_energies(k_x, k_y) <span class="keyword">for</span> k_x <span class="keyword">in</span> K] <span class="keyword">for</span> k_y <span class="keyword">in</span> K])</span><br><span class="line"></span><br><span class="line">    ticks = &#123;<span class="string">&quot;xticks&quot;</span>: pi_ticks[::<span class="number">2</span>], <span class="string">&quot;yticks&quot;</span>: pi_ticks[::<span class="number">2</span>], <span class="string">&quot;zticks&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">    kwargs = &#123;</span><br><span class="line">        <span class="string">&quot;extents&quot;</span>: (-np.pi, -np.pi, -<span class="number">4</span>, np.pi, np.pi, <span class="number">4</span>),</span><br><span class="line">        <span class="string">&quot;kdims&quot;</span>: [<span class="string">&quot;$k_x$&quot;</span>, <span class="string">&quot;$k_y$&quot;</span>],</span><br><span class="line">        <span class="string">&quot;vdims&quot;</span>: [<span class="string">&quot;$E$&quot;</span>],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    title = <span class="string">r&quot;$T = &#123;:.2&#125; \pi$&quot;</span>.<span class="built_in">format</span>(T / np.pi)</span><br><span class="line"></span><br><span class="line">    xs = np.linspace(-np.pi, np.pi, energies.shape[<span class="number">1</span>])</span><br><span class="line">    ys = np.linspace(-np.pi, np.pi, energies.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        holoviews.Surface((xs, ys, energies[:, :, <span class="number">0</span>]), **kwargs).opts(plot=ticks)</span><br><span class="line">        * holoviews.Surface((xs, ys, energies[:, :, <span class="number">1</span>]), **kwargs).opts(plot=ticks)</span><br><span class="line">    ).relabel(title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ts = np.linspace(<span class="number">1</span>, <span class="number">3</span>, <span class="number">11</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line">holoviews.HoloMap(&#123;T: plot_dispersion_2D(np.pi * T) <span class="keyword">for</span> T <span class="keyword">in</span> Ts&#125;, kdims=[<span class="string">&quot;$T$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>Now, there isn’t a Hamiltonian which is more topologically trivial than the zero Hamiltonian. We may be tempted to conclude that our system is trivial and, by bulk-boundary correspondence, has no edge states.</p>
<p>That’s something we can also very easily verify by computing the dispersion of a finite size ribbon:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output size=<span class="number">200</span></span><br><span class="line">%%opts Path &#123;+axiswise&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_bands</span>(<span class="params">momenta, hamiltonians_k, T</span>):</span></span><br><span class="line">    energies = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> momenta:</span><br><span class="line">        hamiltonians = [h_k(k) <span class="keyword">for</span> h_k <span class="keyword">in</span> hamiltonians_k]</span><br><span class="line">        U = evolution_operator(hamiltonians, T)</span><br><span class="line">        energies.append(np.sort(np.angle(la.eigvals(U))))</span><br><span class="line">    <span class="keyword">return</span> np.array(energies).real</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ribbon_lead = checkerboard(<span class="number">10</span>).finalized()</span><br><span class="line"></span><br><span class="line">hamiltonians_k = [</span><br><span class="line">    get_h_k(ribbon_lead, SimpleNamespace(t1=<span class="number">1</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>)),</span><br><span class="line">    get_h_k(ribbon_lead, SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">1</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>)),</span><br><span class="line">    get_h_k(ribbon_lead, SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">1</span>, t4=<span class="number">0</span>)),</span><br><span class="line">    get_h_k(ribbon_lead, SimpleNamespace(t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">1</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">periods = np.linspace(<span class="number">0</span>, <span class="number">4</span> * np.pi, <span class="number">11</span>)</span><br><span class="line">momenta = np.linspace(-np.pi, np.pi)</span><br><span class="line">spectrum = np.array([calculate_bands(momenta, hamiltonians_k, T) <span class="keyword">for</span> T <span class="keyword">in</span> periods])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot</span>(<span class="params">n</span>):</span></span><br><span class="line">    T = periods[n]</span><br><span class="line">    title = <span class="string">r&quot;spectrum: $T=&#123;:.2&#125; \pi$&quot;</span>.<span class="built_in">format</span>(T / np.pi)</span><br><span class="line">    <span class="keyword">return</span> holoviews.Path(</span><br><span class="line">        (momenta, spectrum[n]), label=title, kdims=[<span class="string">&quot;$k$&quot;</span>, <span class="string">&quot;$E_kT$&quot;</span>]</span><br><span class="line">    ).opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: pi_ticks, <span class="string">&quot;yticks&quot;</span>: pi_ticks, <span class="string">&quot;aspect&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(&#123;n: plot(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>)&#125;, kdims=[<span class="string">&quot;n&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>We see something very different from our expectations. All the bulk states are indeed at $E=0$, but there are two branches of dispersion that are clearly propagating. These can only belong to the edges, and since the two edges look identical, these two modes have to belong to the opposite edges. We seem to conclude that even though the bulk Hamiltonian is trivial, the edges carry chiral edge states, as if there was a finite Chern number.</p>
<p>When the driving period is tuned to ensure the absence of bulk dispersion, we can also understand why the edge states appear. If we select a state that starts on the edge, and follow it for one period, we find that there are modes that never leave the edge, since one of the hoppings in the vertical direction is absent.</p>
<p><img src="/2021/01/07/src/w11_extensions2/floquet/trajectories.svg" alt></p>
<p>So what is happening with bulk-edge correspondence?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">&quot;How can you change the chirality of the edge states in the figure above?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;By changing the driving period.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;By reversing the driving protocol sequence.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;By changing the sign of the nearest neighbor hopping.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;By making the electrons start from the black sublattice.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Reversing the driving protocol is the same as applying time-reversal symmetry, &quot;</span></span><br><span class="line">    <span class="string">&quot;so it will reverse the direction of the chiral edge modes&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Bulk-edge-correspondence-in-driven-systems"><a href="#Bulk-edge-correspondence-in-driven-systems" class="headerlink" title="Bulk-edge correspondence in driven systems"></a>Bulk-edge correspondence in driven systems</h1><p>The two examples we’ve studied reveal an imporant feature of topological Floquet insulators. It seems that knowing the bulk Floquet Hamiltonian is sufficient to calculate the topological invariant, by just applying the known expression to the Floquet Hamiltonian. However, that’s not enough.</p>
<p>In rough terms, the reason for this insufficiency is due to Floquet topological insulators missing a topologically trivial state which can be taken as a reference. With any regular 2D Hamiltonian, we know that if we take $E \rightarrow -\infty$, we will get a trivial system with the Chern number zero. In a Floquet system, the only thing that lowering the energy tells us is that the Chern number is periodic in quasienergy, like any other observable property.</p>
<p>What do we need to know to derive the full topological invariant from the bulk properties? The answer is that we need the complete evolution operator for all moments in time, or in other words the full dependence $H(t)$. The actual calculation of the topological invariant is technically involved, and falls beyond what we can cover in this course. Moreover, to the best of our knowledge, the full classification of Floquet topological insulators is not yet accomplished.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;DbyqIczcR9c&quot;</span>, src_location=<span class="string">&quot;11.1-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Floquet&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w11_extensions2/cti/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line">%output size=<span class="number">150</span></span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Crystalline topological insulators are introduced by Liang Fu from MIT.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;N9-tUYjXC1s&quot;</span>, src_location=<span class="string">&quot;11.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="The-role-of-crystalline-symmetries"><a href="#The-role-of-crystalline-symmetries" class="headerlink" title="The role of crystalline symmetries"></a>The role of crystalline symmetries</h1><p>In the very beginning of the course, we told you that conservation laws - unitary symmetries of the Hamiltonian - do not lead to striking consequences on topology. They allow to reduce the problem by making the Hamiltonian block-diagonal, but not much else (see also Shinsei Ryu’s introductory video to week eight).</p>
<p>At first sight, it may seem that crystalline symmetries: mirror or reflection symmetries, rotation symmetries, and so on - are no exception to the above consideration. They are unitary symmetries whose operators commute with the Hamiltonian. </p>
<p>Nevertheless, the role of crystalline symmetries can be quite subtle and it can have important consequences. The reason is that crystalline symmetries are non-local. They relate one point in a crystal to another point, possibly a very distant point. This means that in terms of the Bloch Hamiltonian of the crystal, these symmetries mix different values of momentum.</p>
<p>Consider for instance a 2D crystal with a reflection symmetry $\mathcal{R}: (x, y) \to (-x, y)$ around the $x=0$ axis. In momentum space, this symmetry will read $RH(k_x, k_y)R^\dagger = H(-k_x, k_y)$, with a certain unitary operator $R$.</p>
<p>Due to this type of constraint on the Brillouin zone, crystalline symmetries can have important consequences on the topological properties of Bloch Hamiltonians.</p>
<p>Note however, that sometimes the mere presence of a surface can break a crystalline symmetry of the bulk, so that one should be careful when applying the bulk-boundary correspondence to properties based on crystalline symmetries.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">r&quot;In which case can inversion symmetry protect gapless surface states?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Never.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;In the case of 2D TIs with inversion symmetry.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Only in three dimensions.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Only in combination with particle-hole or time-reversal symmetry. &quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = <span class="string">&quot;Any surface would break inversion symmetry of a crystal.&quot;</span></span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">0</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Reflection-symmetry"><a href="#Reflection-symmetry" class="headerlink" title="Reflection symmetry"></a>Reflection symmetry</h1><p>The second-simplest crystalline symmetry (after translation symmetry of course) occurring in many materials is reflection (or mirror) symmetry around one spatial coordinate. For instance, in a 3D crystal, reflection symmetry around the $z$ axis transforms the wave-wector as</p>
<p>$$<br>(k_x, k_y, k_z)\rightarrow (k_x, k_y, -k_z).<br>$$</p>
<p>Reflection symmetry also applies a 180 degree rotation about the $z$-axis to the electron spin, so $\psi_{\uparrow}\rightarrow -i \psi_{\uparrow}$ and $\psi_{\downarrow}\rightarrow i \psi_{\downarrow}$, so that the operator squares to $-1$ when acting on a spin.</p>
<p>Next, if we consider the application of reflection symmetry to either a two-dimensional material or a plane in a three dimensional material, then we can choose $k_z=0$ and the reflection symmetry just becomes a regular unitary symmetry i.e., the $C_2$ rotation.</p>
<p>In this case, the topological classification follows rather simply from our earlier discussion. $C_2$ is a unitary symmetry with eigenvalues $\pm i$. We can split our Hamiltonian into the corresponding two sector $H_{\pm}$ acting on the $C_2=\pm i$ sectors respectively. Each of the Hamiltonians $H_{\pm}$ are 2 dimensional Hamiltonians in class A (i.e. with no symmetry) and therefore we can associate a Chern number $N_{\pm}$ with each of them. </p>
<blockquote>
<p>If the Hamiltonian overall is trivial then the total Chern number $N_++N_-=0$ so we can classify the 2 dimensional mirror symmetric Hamiltonians by a <strong>mirror Chern number</strong> $N_M=N_+-N_-$.</p>
</blockquote>
<p>The mirror Chern number is a topological invariant in the sense that it cannot change without a closure of the bulk gap provided the reflection symmetry remains intact. Moreover, the reflection symmetry together with non-trivial values of the invariant will guarantee edge states.</p>
<p>Naturally, the same recipe allows to construct a reflection symmetric topological insulator starting from any other topological invariant, not just a Chern number. We will now try to do this.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;How would you attempt to make a model of a topological&quot;</span></span><br><span class="line">    <span class="string">&quot; insulator with surface states protected by reflection symmetry?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;By using the interface of a material with reflection symmetry, and that of one without it.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;By stacking many layers of a lower dimensional topological insulator, &quot;</span></span><br><span class="line">    <span class="string">&quot;and coupling them in a reflection-symmetric fashion.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Reflection symmetry alone cannot protect any gapless surface state.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;By making a narrow ribbon of the material where only the momentum orthogonal to the reflection axis can be non-zero.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;Such a stack would have a reflection symmetry around any of the layers, &quot;</span></span><br><span class="line">    <span class="string">&quot;which is not broken by the presence of a surface parallel to the stacking direction.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question, answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>Let’s think, what could be the simplest topological system protected by reflection symmetry.</p>
<p>We need $d=2$, since the only possible reflection symmetry is broken by the boundary in $d=1$, and we can once again consider coupled Majorana nanowires.</p>
<p>We can put two nanowires in a unit cell of the lattice and make their parameters different. In this way, the weak topological invariant is trivial (there is an even number of Majoranas per unit cell).</p>
<p>On the other hand, if the hopping between the nanowires is reflection invariant, there will be a reflection symmetry axis passing through each nanowire, like this:</p>
<p><img src="/2021/01/07/src/w11_extensions2/cti/reflection.svg" alt></p>
<p>If we do everything right (this does require some trial and error in searching for the hopping that actually can couple the two Majoranas from the edge), we get a painfully familiar dispersion:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nanowire_chains</span>(<span class="params">length=<span class="number">40</span>, n=<span class="number">2</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        (x, y) = site.pos</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            (<span class="number">2</span> * p.t - p.mu) * pauli.szs0</span><br><span class="line">            + p.delta * pauli.sxs0</span><br><span class="line">            + (y % <span class="number">2</span> == <span class="number">0</span>) * p.B * pauli.s0sz</span><br><span class="line">            + (y % <span class="number">2</span> == <span class="number">1</span>) * p.B * pauli.s0sy</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.szs0 + <span class="number">0.5</span> * <span class="number">1j</span> * p.alpha * pauli.szsx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        (x1, y1) = site1.pos</span><br><span class="line">        (x2, y2) = site2.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1j</span> * (-<span class="number">1</span>) ** ((x1 + x2 - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) * p.tx * pauli.sysx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y) = pos</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> &lt;= x &lt; n) <span class="keyword">and</span> (<span class="number">0</span> &lt;= y &lt; length)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line">    sym = kwant.TranslationalSymmetry((n, <span class="number">0</span>))</span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syst = nanowire_chains()</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, tx=<span class="number">0.2</span>, mu=<span class="number">0.0</span>, B=<span class="number">0.4</span>, delta=<span class="number">0.15</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">spectrum(</span><br><span class="line">    syst,</span><br><span class="line">    p,</span><br><span class="line">    k_x=np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">101</span>),</span><br><span class="line">    ylims=(-<span class="number">0.2</span>, <span class="number">0.2</span>),</span><br><span class="line">    xticks=<span class="number">3</span>,</span><br><span class="line">    yticks=<span class="number">3</span>,</span><br><span class="line">    title=<span class="string">&quot;Stacked Majorana wires&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>In a similar way, we can also construct a tight-binding model with a mirror Chern number. The only difference with the Majorana wires that we need to worry about is that Chern number is a $\mathbb{Z}$ invariant instead of $\mathbb{Z}_2$.</p>
<p>This means that the Chern number of the alternating layers has to have opposite signs, or otherwise the surface would just have surface states going in a single direction.</p>
<p>Once again, coupling the layers we get a familiar Dirac cone on the surface:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stacked_qwz</span>(<span class="params">w=<span class="number">50</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= z &lt; w</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0.5j</span> * p.delta * pauli.sx - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> p.gamma * pauli.sy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        (x, y, z) = site1.pos</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">0.5j</span> * p.delta * pauli.sy * (-<span class="number">1</span>) ** (y) - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> pauli.sz * (<span class="number">4</span> * p.t + p.mu)</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.eye(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line">yticks = [(<span class="number">0</span>, <span class="string">r&quot;$0$&quot;</span>), (np.pi / <span class="number">2</span>, <span class="string">r&quot;$\pi/2$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, delta=<span class="number">1</span>, gamma=<span class="number">0.5</span>, mu=-<span class="number">0.5</span>)</span><br><span class="line">syst = stacked_qwz(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">spectrum(</span><br><span class="line">    syst,</span><br><span class="line">    p,</span><br><span class="line">    num_bands=<span class="number">2</span>,</span><br><span class="line">    k_x=np.linspace(-np.pi, np.pi, <span class="number">51</span>),</span><br><span class="line">    k_y=np.linspace(<span class="number">0</span>, np.pi, <span class="number">51</span>),</span><br><span class="line">    xticks=xticks,</span><br><span class="line">    yticks=yticks,</span><br><span class="line">    title=<span class="string">&quot;Stacked Chern insulator&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Again, the dispersion of the edge states looks exactly like what we saw already because the edge state dispersion in any topological insulator is just given by the Dirac equation.</p>
<h1 id="Experimental-realization-of-a-3D-crystalline-topological-insulator"><a href="#Experimental-realization-of-a-3D-crystalline-topological-insulator" class="headerlink" title="Experimental realization of a 3D crystalline topological insulator"></a>Experimental realization of a 3D crystalline topological insulator</h1><p>As mentioned by Liang Fu, three dimensional crystalline topological insulators have been both predicted and also found in nature. The magical material, which is topological turns out to be SnTe, which is actually a “rock-salt” structure. We won’t bore you with the details of the rock-salt structure, which you can find for yourself on <a href="https://en.wikipedia.org/wiki/Cubic_crystal_system#Rock-salt_structure">Wikipedia</a>. </p>
<p>We will just start with the key ingredients for the crystalline topological insulator, namely the symmetries of the crystal. These include, spatial inversion $P$, time-reversal symmetry $\Theta$ and most importantly the three mirror planes in the cubic Brillouin zone. The three mirror planes $\Gamma L_1 L_2$, $\Gamma L_3 L_4$ and $\Gamma L_3 L_1$ in the Brillouin zone are reflection-symmetric directions that are created out of four time-reversal invariant momenta $\Gamma, L_1, L_2, L_3, L_4$. </p>
<p>While the reflection symmetry acts non-trivially on general wave-vectors $\bf k$, the symmetry preserves the mirror planes in the Brillouin zone. Following the idea of dimensional reduction that we used for three dimensional topological insulators (week 6) and also in subsequent weeks, we can define the topological invariant for the crystalline topological insulator in terms of the three mirror Chern numbers for the three mirror planes. For SnTe, all these mirror Chern numbers turn out to be $N_{M}(\Gamma L_i L_j)=-2$. This topological invariant leads to surface Dirac cones on certain surfaces as shown below.</p>
<p><img src="/2021/01/07/src/w11_extensions2/cti/SnTefig.png" alt></p>
<p>Figure copyright of the Zahid Hasan lab, Princeton, 2015, available under CC-BY-NC-SA 4.0 International license.</p>
<p>This surface spectrum is very easy to interpret.</p>
<p>The crystal surface you see here is perpendicular to two mirror planes projected on $\bar{\Gamma}\bar{X}$ axes. Since the mirror Chern number with respect to each of these planes is $-2$, there is a pair of Dirac cones near each $X$-point protected by a respective mirror symmetry.</p>
<p>The reflection symmetry pins the pairs of Dirac cones to the mirror planes, while time reversal symmetry requires their momenta to be opposite. The 90 degree rotation symmetry interchanges the pairs of cones.</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In short, crystalline topological insulators combine the variety of topological phases with the variety of the crystalline symmetry groups, leading to a multitude of new opportunities.</p>
<p>Questions about what you just learned? Ask them below!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Crystalline TI&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w10_extensions/w10_assignments/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br></pre></td></tr></table></figure>

<h1 id="Simulations"><a href="#Simulations" class="headerlink" title="Simulations"></a>Simulations</h1><p>As usual, start by grabbing the notebooks of this week (<code>w10_extensions</code>). They are once again over <a href="http://tiny.cc/topocm_smc">here</a>.</p>
<h2 id="Weyl-semimetal-with-time-reversal-symmetry"><a href="#Weyl-semimetal-with-time-reversal-symmetry" class="headerlink" title="Weyl semimetal with time-reversal symmetry."></a>Weyl semimetal with time-reversal symmetry.</h2><p>Time-reversal symmetry has a very similar effect on Weyl semimetals as it has on gapless superconductors: it keeps the value of the Chern number around the Weyl point the same, and leads to appearance of quadruplets of Weyl points.</p>
<p>Your task is to construct a Weyl semimetal with time reversal symmetry. As we discussed, 4 Weyl points are needed.</p>
<p>If you don’t know where to start, here’s a hint: you’re not the first one who wants to construct a Weyl semimetal with time reversal, search on arxiv.</p>
<h2 id="Graphene-edge-states"><a href="#Graphene-edge-states" class="headerlink" title="Graphene edge states."></a>Graphene edge states.</h2><p>Graphene, just like $d$-wave superconductors has edge states. They only exist when the Dirac points are not located at coinciding momenta parallel to the boundary.</p>
<p>Define a graphene ribbon supporting edge states. For that you’ll need to figure out which orientation to choose.</p>
<p>Then try to add a term to the boundary that breaks the sublattice symmetry and moves the edge states from zero energy. What happens?</p>
<p>What if you add the next-nearest neighbor hopping in the bulk. What do you see now?</p>
<p>Try to remove the edge states completely by tweaking the sublattice symmetry breaking term at the edge. Did you succeed? How?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Now share your results:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Labs&quot;</span>, <span class="string">&quot;Extensions&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Review-assignment"><a href="#Review-assignment" class="headerlink" title="Review assignment"></a>Review assignment</h1><h3 id="arXiv-1504-01350"><a href="#arXiv-1504-01350" class="headerlink" title="arXiv:1504.01350"></a>arXiv:1504.01350</h3><h3 id="arXiv-1503-06808"><a href="#arXiv-1503-06808" class="headerlink" title="arXiv:1503.06808"></a>arXiv:1503.06808</h3><p><strong>Hint:</strong> Different mechanical TI</p>
<h3 id="arXiv-1309-5846"><a href="#arXiv-1309-5846" class="headerlink" title="arXiv:1309.5846"></a>arXiv:1309.5846</h3><p><strong>Hint:</strong> Weyl + disorder</p>
<h3 id="arXiv-1410-1320"><a href="#arXiv-1410-1320" class="headerlink" title="arXiv:1410.1320"></a>arXiv:1410.1320</h3><p><strong>Hint:</strong> The best of both worlds</p>
<h3 id="arXiv-0909-5680"><a href="#arXiv-0909-5680" class="headerlink" title="arXiv:0909.5680"></a>arXiv:0909.5680</h3><p><strong>Hint:</strong> A general approach to gapless superconductors.</p>
<h3 id="Bonus-Find-your-own-paper-to-review"><a href="#Bonus-Find-your-own-paper-to-review" class="headerlink" title="Bonus: Find your own paper to review!"></a>Bonus: Find your own paper to review!</h3><p>Do you know of another paper that fits into the topics of this week, and you think is good?<br>Then you can get bonus points by reviewing that paper instead!</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocSelfAssessment()</span><br></pre></td></tr></table></figure>

<p><strong>Do you have questions about what you read? Would you like to suggest other papers? Tell us:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Reviews&quot;</span>, <span class="string">&quot;Extensions&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w10_extensions/mechanics/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">import</span> topomech</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Today’s lecture will be given by Vincenzo Vitelli, from Leiden University. You will learn about topologically protected mechanical structures, that mirror the properties of topological insulators and quantum Hall systems.</p>
<p>The main concepts and mathematical ideas will be presented in the context of real mechanical prototypes. Hopefully, this approach will stimulate you to cross the line that too often separates theory from applications.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;i-eNPei2zMg&quot;</span>, src_location=<span class="string">&quot;10.2-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>The materials of this lecture are kindly provided by the Topological Mechanics lab at Leiden University: Vincenzo Vitelli (PI), Bryan Chen, Anne Meeussen, Jayson Paulose, Benny van Zuiden, and Yujie Zhou. They are copyright of their creators, and are available under a<br><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons Attribution-ShareAlike 4.0<br>International License.</a><br><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><br><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a></p>
<h1 id="Kink-and-anti-kink"><a href="#Kink-and-anti-kink" class="headerlink" title="Kink and anti-kink"></a>Kink and anti-kink</h1><p>Let’s consider the chain you saw in the video:</p>
<p><img src="/2021/01/07/src/w10_extensions/mechanics/chain_scheme.png" alt></p>
<p>In the figure, the red dashed lines represent springs and the green arrows the vibrational eigenvectors. The rigid rotors are in black, while the blue dots are point masses of magnitude $m$.</p>
<p>Imagine the system with periodic boundary conditions, that is on a closed ring. As you can see from the figure, in the bulk there are an equal number of degrees of freedom (the rotors) as there are constraints (the springs). This can be seen as a ‘‘charge neutrality‘‘ condition:</p>
<p><img src="/2021/01/07/src/w10_extensions/mechanics/chaint.png" alt></p>
<p>If you cut the ring, you remove one constraint, and now there is a zero energy mode in the system. We will discuss later that the direction the rotors lean plays a role of a ‘‘mechanical’’ polarization.</p>
<p>The constraint counting does not tell you where the mode will be located, but if you write the dynamical matrix and find the zero eigenmode, you will learn that the zero mode (whose eigenvectors are represented in the figure as green arrows) is localized at the edge towards which the rotors are pointing. Note that we are tacitly assuming that the vibrational modes of this structure are gapped. Convince yourself that the gap closes if the angle of repose, labeled by $\bar{\theta}$, is equal to zero.</p>
<p>A study of the vibrational modes of this chain was presented in the original paper of Kane and Lubensky, which was mentioned in the introductory video:</p>
<ul>
<li>arXiv:1308.0554</li>
</ul>
<p>We shall now show that the zero mode localized at the edge is a time snaphot of a non-linear object, the kink that separates regions of left and right leaning rotors, a bit like a domain wall in an Ising model:</p>
<p><img src="/2021/01/07/src/w10_extensions/mechanics/kink.png" alt></p>
<p>To see that, it is easier to consider the constraint equation $l^2_{n,n+1}=\bar{l}^2$ that demands that the length of the springs $l_{n, n+1}$ between any two rotors labeled by $n$ and $n+1$ is not stretched. This is certainly the case for the rigid bar systems shown in the video which correspond to the limit of infinite spring constant. Such systems are called <a href="http://en.wikipedia.org/wiki/Linkage_%28mechanical%29">linkages</a>.  </p>
<p>In terms of the parameters defined in the first figure, the constraint equation $l^2_{n,n+1}=\bar{l}^2$ reads</p>
<p>$$<br>\require{action}<br>\require{color}<br>\toggle{<br>\cos(\theta _{n} + \theta _{n+1}) - \cos(2\bar{\theta}) + \frac{a}{r}(\sin\theta _{n} - \sin\theta _{n+1})=0<br>\textit{ (click for explanation)}.}{<br>l^2 = r^2 (\cos\theta_1 + \cos\theta_2)^2 + [r(\sin\theta_1 - \sin\theta_2) + a]^2 \textit{ (click more)}<br>}{<br>l^2 = 2 r^2 + a^2 + 2r^2 \cos\theta_1\cos\theta_2 - 2r^2\sin\theta_1\sin\theta_2 + 2ar(\sin\theta_1 - \sin\theta_2) \textit{, and so}<br>}{<br>(l^2 - 2r^2 - a^2)/2r = \color{red}{r\cos(\theta_1 + \theta_2) + a(\sin\theta_1 - \sin\theta_2) = r\cos(2\bar{\theta})}<br>}<br>\endtoggle<br>$$</p>
<p>To take the continuum limit of the above equation, we define a slowly-varying angular field $\theta (x)$ and subsequently define the field $u(x)=r\sin\theta (x)$, the $x$-component of the position of the mass. When $r/a$ is sufficiently small, we obtain</p>
<p>$$<br>\frac{a^2}{2}\frac{du}{dx} = u^2-\bar{u}^2,<br>$$</p>
<p>where $\bar u\equiv |r\sin\bar\theta|&gt;0$. Besides the uniform left- and right-leaning solutions<br>$u(x)=\pm \bar u$, this equation admits only one <em>zero-energy</em> solution (for $u&lt;\bar{u}$) given by the kink</p>
<p>$$<br>u(x) = \bar u\tanh\left(\frac{x-x_0}{w_0}\right),<br>$$</p>
<p>where $w_0=a^2/2\bar u$ is the width of the static domain wall that interpolates between left-leaning ($u&lt;0$ as $x\rightarrow-\infty$) and right-leaning ($u&gt;0$ as $x\rightarrow+\infty$) states.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">r&quot;What happens to the kink width $w_0$ when the gap closes?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [<span class="string">&quot;It goes to zero.&quot;</span>, <span class="string">&quot;It does not vary.&quot;</span>, <span class="string">&quot;It diverges.&quot;</span>]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">r&quot;We said that a gap equal to zero corresponds to $\bar&#123;\theta&#125;\to0$. &quot;</span></span><br><span class="line">    <span class="string">r&quot;This gives $w_0 = a^2/2\bar&#123;u&#125;d \propto 1 / |\sin \bar\theta \to \infty$.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="Non-linear-dynamics"><a href="#Non-linear-dynamics" class="headerlink" title="Non-linear dynamics"></a>Non-linear dynamics</h1><p>You can explicitly obtain a continuum Lagrangian for the chain which, in the limit $l(x)\approx\bar{l}$ and $\bar{\theta}\ll 1$, reads:</p>
<p>$$<br>\mathcal{L}=\int dx \left[\frac{1}{2}M\left(\frac{\partial<br>u}{\partial t}\right)^2 -<br>\frac{1}{2}K\frac{a^4}{4}\left(\frac{\partial u}{\partial<br>x}\right)^2 -\frac{1}{2}K(\bar u^2-u^2)^2 - \frac{1}{2} K \frac{a^2}{2}(\bar<br>u^2-u^2)\frac{\partial u}{\partial x}\right].<br>$$</p>
<p>The first term is a linearized kinetic energy, while the second and third terms are the ordinary <a href="http://en.wikipedia.org/wiki/Quartic_interaction">$\phi^4$ field theory</a> that you might have encountered for instance while studying the Ising model.</p>
<p>The final term linear in $\partial_x u$ is topological in the sense that it integrates to the boundary. It ensures that the static kink has zero energy, since the last three terms in the Lagrangian can be combined into a perfect square, that vanishes for the static kink solution (this is sometimes called a BPS state). The topological boundary term does not affect the equations of motions in the bulk, but it breaks the $\partial_x u \rightarrow -\partial_x u$ symmetry of the $\phi^4$ theory. That’s why the two edges are not equivalent in terms of initiating the kink motion.</p>
<p>The anti-kink solution (with left- and right-leaning states reversed in space) costs a finite stretching energy. Hence, the anti-kink is forbidden in the ground state represented by the linkage limit, where $k_e \rightarrow \infty$. The anti-kink would require an opposite choice of sign in front of the topological boundary term.</p>
<p>As discussed in the introductory video, however, something that behaves like an anti-kink can be obtained if we stick in the system a rigid bar much longer than the others:</p>
<p><img src="/2021/01/07/src/w10_extensions/mechanics/antikink.png" alt></p>
<p>Rather than analyzing mathematically the dynamics of the Lagrangian above, watch the two videos below that<br>show the motion in the linkage limit.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;BE4NDhfdpBQ&quot;</span>, src_location=<span class="string">&quot;10.2-topological-linkages-I&quot;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;mRjpzC4rJx0&quot;</span>, src_location=<span class="string">&quot;10.2-topological-linkages-II&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>If you are curious about the mathematical details and a systematic study of the dynamics in the springs-rotors system, you can check out the following paper:</p>
<ul>
<li>arXiv:1404.2263</li>
</ul>
<p>Note that with different geometrical parameters, the same chain above can realize the <a href="http://en.wikipedia.org/wiki/Sine-Gordon_equation">sine-Gordon Lagrangian</a>. As before, check out the following movie:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;w2k1Y0WON2E&quot;</span>, src_location=<span class="string">&quot;10.2-topological-linkages-III&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>The same reference above contains hints on how to build this structure with LEGO - plus of course all the mathematical details!</p>
<h1 id="Zero-modes-and-states-of-self-stress"><a href="#Zero-modes-and-states-of-self-stress" class="headerlink" title="Zero modes and states of self-stress"></a>Zero modes and states of self-stress</h1><p>At this point we could expand around the kink solution and find a zero mode localized at its center where the gap closes. Such a zero mode allows the kink to translate as shown in the linkage video.</p>
<p>For now we will simply remark that if one views the orientation along which the rotors lean as a mechanical polarization, then there will be an excess positive ‘‘charge’’ corresponding to a soft mode at the kink center and a negative one at the anti-kink (see the last two figures). Never mind if this electrostatic analogy is not yet clear; we will return to it and show that the antikink harbours a so-called ** state of self stress**, a dual state to the zero mode.  </p>
<p>Before doing that we need to review the Maxwell count which is a <strong>global</strong> relation that stipulates that the number of zero modes $n_\text{m}$, present in an arbitrary mechanical structure, is simply given by the difference between the number of degrees of freedom minus the number of <strong>independent</strong> constraints.</p>
<p>For simplicity, assume that the mechanical structure under examination can be viewed as a network composed of $N_\text{s}$ sites (for instance point masses) connected by $N_\text{b}$ central force bonds (for instance springs or rigid beams) in $d$ dimensions. In this case, the number of degrees of freedom is given by $d N_\text{s}$ and the <strong>total</strong> number of constraints is simply $N_\text{b}$. The states of self-stress are the <strong>redundant</strong> constraints present in the structure, whose number we denote by $n_{ss}$.</p>
<p>The Maxwell criterion then reads</p>
<p>$$<br>d N_\text{s} - N_\text{b} = n_{m} - n_{ss},.<br>$$</p>
<p>Let’s apply this equation to the following examples of mechanical structures:</p>
<p><img src="/2021/01/07/src/w10_extensions/mechanics/modecount.png" alt></p>
<p>Note that on the left panel there are 4 sites in 2 dimensions, hence 8 degrees of freedom. There are also 4 bonds which leaves 4 soft modes, as prescribed by the Maxwell criterion. You can easily verify that there are 2 trivial translational and 1 rotational zero modes plus 1 non-trivial zero mode, the one indicated by the arrows in the figure.</p>
<p>If you add two extra bonds along the diagonals, as in the right panel, the left hand side of the Maxwell count gives 2. Now, the 3 translations and rotations are still there, the non-trivial zero mode is no longer present but there is one redundant constraint or state of self stress. The difference between the 3 trivial zero modes and the state of self stress gives<br>indeed 2, again as expected from the Maxwell criterion. Here we will denote structures for which the left hand side of the Maxwell count is zero as <strong>isostatic</strong>.</p>
<p>(Note that this is an abuse of terminology.  Strictly speaking, isostatic<br>structures have $dN_{\text{s}}-n_{m,\text{triv}}=N_\text{b}$ and $n_{ss}=0$, where<br>$n_{m,\text{triv}}$ is the number of translations and rotations in $d$<br>dimensions.)</p>
<p>As a simple test of your knowledge, consider the following question whose answer will prove handy later.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">r&quot;What is the number of bonds $z_c$ emanating from each node in a $d$-dimensional isostatic structure &quot;</span></span><br><span class="line">    <span class="string">&quot;where all nodes have the same number of bonds (neglecting boundaries)?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [<span class="string">r&quot;$z_c=d$.&quot;</span>, <span class="string">r&quot;$z_c=2d$.&quot;</span>, <span class="string">r&quot;$z_c=d(d-1)$.&quot;</span>, <span class="string">r&quot;$z_c=d^2$.&quot;</span>]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">&quot;In an isostatic structure we have equal number of degrees of freedom and number of constraints. &quot;</span></span><br><span class="line">    <span class="string">&quot;This gives the equation $d N = z N /2$, because each bond is shared by two sites.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">1</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Why do we call redundant constraints with the name <em>states of self stress</em>?</p>
<p>Consider the example in the right panel of the figure. Note that if you apply a suitable distribution of stresses  in the bonds, the structure will remain in static equilibrium. In the example, you can apply a compression to the vertical and horizontal bars, which corresponds to an outgoing force on the masses, and a tension on the diagonal bars such that this outgoing force is canceled. The numbers next to the springs in the figure (positive for the compressions, negative for tensions) give the right ratios such that the forces cancel.</p>
<p>We see therefore that states of self stress are assignments of tensions or compressions to (some of) the bonds that do not result in net forces on the nodes. As such, they are <em>dual</em> to the zero energy mechanical modes, which are displacements of some of the sites that do not result in tensions or compressions of the bonds (that’s why they cost zero elastic energy).</p>
<p>This relation between states of self stress and zero modes can be made more precise by introducing the rigidity, or compatibility, matrix $R_{ij}$ that describes the small distortions of the mechanical structure captured by linear elastic theories. This $R$ matrix relates the bond extensions $e_i = R_{ij} u_j$ to the site displacements $u_j$.</p>
<p>The zero energy modes are members of the null space of $R_{ij}$, which in an isostatic system are also the (right) eigenvectors of $R_{ij}$ with eigenvalue 0. (Convince yourself that the rigidity matrix is square for an isostatic system.)</p>
<p>Conversely the states of self stress are the zero eigenvectors  of the transpose matrix $R^{T}$ that relates the forces on the nodes to the tensions in the bonds. The Maxwell count equation follows from the rank-nullity theorem and can be expressed as an index theorem. (We suggest the reader interested in a careful proof and statement of these results to consult <a href="http://arxiv.org/abs/1503.01324">this review</a>.)</p>
<p>Here we merely remark that if one smoothly deforms the network without cutting bonds or adding sites then the left hand side of the Maxwell count does not change. This means that after such a smooth deformation, the difference between the number of zero modes and states of self stress must remain invariant even if $n_m$ and $n_{ss}$ change individually. In this sense the isostatic condition can be viewed as a charge neutrality condition. As we shall see,  this electrostatic analogy is far reaching. We will now turn our attention to periodic mechanical structures that are isostatic, hence ‘‘charge neutral’’, but mechanically polarized so that edge modes can appear at the sample boundary like charges in an electrically polarized medium.</p>
<h1 id="Topological-band-theory"><a href="#Topological-band-theory" class="headerlink" title="Topological band theory"></a>Topological band theory</h1><p>The first step is to set up a topological band theory of vibrational modes by defining the Fourier-transformed rigidity matrix $R(\mathbf{k})$ whose determinant is complex: $\det R(\mathbf{k}) \equiv |\det R(\mathbf{k})|e^{i\phi(\mathbf{k})}$. Consider now for simplicity a two dimensional lattice whose phonons are gapped, away from $\mathbf{k}=\mathbf{0}$, like the twisted Kagome lattice shown at the end of the introductory video.</p>
<p>Two winding numbers,<br>$n_i={n_1,n_2}$, of $\phi(\mathbf{k})$ can be evaluated using</p>
<p>$$<br>n_i=- \frac{1}{2\pi}\oint_{C_i}d\mathbf{k}\cdot\nabla_\mathbf{k}<br>\phi(\mathbf{k})<br>$$</p>
<p>along the two cycles ${C_1,C_2}$ of the Brillouin zone corresponding to the reciprocal lattice directions orthogonal to the basis vectors ${\mathbf{a}_1,\mathbf{a}_2}$ of the lattice. The winding numbers are invariants of the gapped lattice; smooth<br>deformations do not change $n_i$ unless the lattice becomes untwisted and the phonon gap closes along a line in the Brillouin zone. We can now define the topological polarization</p>
<p>$$<br>\mathbf{P}_T   = \sum_i n_i \mathbf{a}_i.<br>$$</p>
<p>In the figure below, the topological polarization of the deformed Kagome lattice is $\mathbf{P}_T = \mathbf{a}_1$ in terms of the primitive vectors $\mathbf{a}_i$.</p>
<p><img src="/2021/01/07/src/w10_extensions/mechanics/kagome.png" alt></p>
<p>Kane and Lubensky proved that the number of topological zero modes (i.e. modes that arise without adding or removing bonds anywhere in the structure) minus the number of topological states of self stress, $\nu_\text{T}$, in any lattice subsystem bounded by $\cal C$ is given by</p>
<p>$$<br>\nu_\text{T} = \oint_{\cal C} \frac{d^{d-1}S}{V_\text{cell}} \mathbf{P}_T  \cdot\hat{n},<br>$$</p>
<p>where $\hat{n}$ is the inward-pointing normal to the boundary, and $V_\text{cell}$ is the $d$-dimensional volume of the unit cell.</p>
<p>Notice that this result applies to a <strong>patch</strong> of the material, unlike the original Maxwell count which is a <strong>global</strong> statement. It can be understood intuitively with the aid of the electrostatic analogy to polarized media. Just as Gauss’s law yields the net charge enclosed in a region from the flux of the <em>electric</em> polarization through its boundary, the net<br>value of $\nu_\text{T}$ in an arbitrary portion of an isostatic lattice is given by the flux of the <em>topological</em> polarization through its boundary.</p>
<h1 id="Dislocations-and-topological-zero-modes"><a href="#Dislocations-and-topological-zero-modes" class="headerlink" title="Dislocations and topological zero modes"></a>Dislocations and topological zero modes</h1><p>Watch now the following video that explains visually how to insert inside a twisted Kagome lattice a topological defect called a dislocation. You encountered dislocations and disclinations in a previous lecture by Taylor Hughes. (Alternatively, an excellent introduction to topological defects is given in chapter nine of the book by Chaikin and Lubensky, <em>Principles of Condensed Matter Physics</em>). The video will show you how to localize topological zero modes or states of self stress in the interior of a lattice with defects that act as internal boundary where the gap locally closes.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;Mrm7JH6LJJI&quot;</span>, src_location=<span class="string">&quot;10.2-dislocations&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>The key point in designing the lattice in the video  is that the dislocations must not change the local balance between degrees of freedom and constraints. The video shows such a dislocation, obtained by pairing a five-coordinated plaquette with a seven-coordinated plaquette.</p>
<p>More details can be found in this paper:</p>
<ul>
<li>arXiv:1406.3323</li>
</ul>
<p>Since no lattice point disclinations are used, every lattice point still has exactly four bonds emanating from it (remember the condition for isostaticity from the first control question!).</p>
<p>Each dislocation is characterized by a topological charge of its own called the Burgers vector, $\bf b$, that measures the deficit in <em>any</em> circuit surrounding it that would be closed in a perfect lattice. The dipole moment, $\bf d$, of the<br>five- and seven-fold coordinated plaquettes (highlighted in green and orange respectively)<br>is obtained upon rotating $\bf b$ by $\pi/2$. It points outward from the added strip of material that terminates at the dislocation, and its length is equal to the width of that strip. Therefore, $\bf d$ quantifies the orientation and size of the effective ‘‘edge’’ created by the dislocation. The dipole moments of the dislocation on the left in the video (${\bf d}_l = (2/\sqrt{3})({\bf a}_1- {\bf a}_2/2)$)  and on the right (${\bf d}_r =-{\bf d}_l$) are aligned with and against the<br>lattice polarization, respectively (see also the last figure).</p>
<p>If you evaluate the flux of the topological polarization, $\mathbf{P}_T$, through a contour encircling an isolated dislocation using the last equation of the previous unit, you obtain</p>
<p>$$<br>\nu_\text{T} =\frac{1}{V_\text{cell}}\mathbf{P}_T  \cdot  \mathbf{d},<br>$$</p>
<p>where $V_\text{cell} = |,\textbf{a}_1,\times,\textbf{a}_2,|$ is the unit cell area. The topologically protected modes arise from a delicate interplay between<br>a Berry phase associated with cycles in the Brillouin zone, embedded in ${\bf P}_T$, and the Berry phase of a topological<br>defect in real space, represented by its Burgers vector (or dipole $\mathbf{d}$).</p>
<p>A similar interplay dictates the existence of localized electronic modes at dislocations in conventional topological insulators. One obtains $\nu_\textrm{T}=+1,(-1)$ for the left (right) dislocation in the deformed Kagome lattice shown in the figure and in the video. The sign of $\nu_\text{T}$  distinguishes zero modes ($+$) or states of self stress ($-$), while its magnitude gives their numbers.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = (</span><br><span class="line">    <span class="string">&quot;Consider the square lattice shown in the following figure, where the primitive vectors $a_i$ &quot;</span></span><br><span class="line">    <span class="string">r&quot;are of equal length and have an angle $\pi/2$ between them, &quot;</span></span><br><span class="line">    <span class="string">r&quot;$P_T=a_1-a_2$, $d_L = a_1-a_2$, and $d_R=-d_L$. &quot;</span></span><br><span class="line">    <span class="string">r&quot;What is the topological mode count $\nu_T$ associated with the left and right dislocation respectively?&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answers = [<span class="string">r&quot;$(1,-1)$.&quot;</span>, <span class="string">r&quot;$(-1,1)$.&quot;</span>, <span class="string">r&quot;$(2,-2)$.&quot;</span>, <span class="string">r&quot;$(-2,2)$.&quot;</span>]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">r&quot;$P_T$ is parallel to $d_L$ and anti-parallel to $d_R$, and they all have length $\sqrt&#123;2&#125;$. &quot;</span></span><br><span class="line">    <span class="string">r&quot;The unit cell has unit area, so the formula  gives $\nu_T=(2, -2)$.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/07/src/w10_extensions/mechanics/square.png" alt></p>
<p>Notice that the zero modes in the Kagome lattice can also be localized at domain walls and the localization length diverges as the gap closes.</p>
<p>In the numerical simulation below, you can see explicitly that transforming the unit cell of the deformed Kagome lattice changes the localization properties and ultimately the location of the topological zero mode. In the simulation, we set up a perfectly isostatic lattice with periodic boundary conditions, and two domain walls separating a fixed unit cell on the outside with a unit cell that we modify in the inner region.</p>
<p>The unit cell chosen on the outside has topological polarization zero, while the topological polarization on the inside changes as you deform the unit cell by moving the slider. What you see plotted as you move the slider is the eigenvector associated with the lowest-energy eigenstate of the dynamical matrix, represented as a set of displacements on the lattice points (red arrows).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> holoviews.core.element <span class="keyword">import</span> Element2D</span><br><span class="line"><span class="keyword">from</span> holoviews.plotting.mpl <span class="keyword">import</span> ElementPlot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Figure</span>(<span class="params">Element2D</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FigurePlot</span>(<span class="params">ElementPlot</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_plot</span>(<span class="params">self, ranges=<span class="literal">None</span></span>):</span></span><br><span class="line">        element = self.hmap.last</span><br><span class="line">        self.handles[<span class="string">&quot;fig&quot;</span>] = element.data</span><br><span class="line">        <span class="keyword">return</span> self.handles[<span class="string">&quot;fig&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_axis</span>(<span class="params">self, fig, ax</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Override this method to avoid creating a useless figure.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_frame</span>(<span class="params">self, key, ranges=<span class="literal">None</span>, element=<span class="literal">None</span></span>):</span></span><br><span class="line">        element = self._get_frame(key)</span><br><span class="line">        self.handles[<span class="string">&quot;fig&quot;</span>] = element.data</span><br><span class="line">        <span class="keyword">return</span> self.handles[<span class="string">&quot;fig&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.Store.register(&#123;Figure: FigurePlot&#125;, <span class="string">&quot;matplotlib&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_figure</span>(<span class="params">x</span>):</span></span><br><span class="line">    x1 = (<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>)</span><br><span class="line">    x2 = (x, -x, -x)</span><br><span class="line">    mesh = topomech.dwallslab(x1, x2)</span><br><span class="line">    fig = topomech.showlocalizedmode(mesh)</span><br><span class="line">    plt.close(fig)</span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(&#123;i: Figure(get_figure(i)) <span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(-<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">21</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>(We thank Jayson Paulose for providing the simulation.)</p>
<p>You can see that the localized mode changes position from left to right between the beginning and the end of the deformation procedure. This is because our deformation has switched the polarization of the unit cell in the inner part of the system. In the middle of the transformation, there is a gap closing in the bulk, i.e. the zero mode extends through the bulk rather than being confined to either domain wall. You can explain this behavior using the analogy of polarization flux we have developed above.</p>
<p>These examples show how to insert topologically protected mechanical modes anywhere you want in the lattice. In the video and in the numerical simulation, the activation was performed ‘‘by hand’’. However, these soft motions can also be activated by adding motors that can cause some motions that perform a desired task, as is the case in robotic structures.</p>
<h1 id="States-of-self-stress-and-selective-buckling"><a href="#States-of-self-stress-and-selective-buckling" class="headerlink" title="States of self-stress and selective buckling"></a>States of self-stress and selective buckling</h1><p>You may get the impression that only the zero modes are potentially useful and the states of self stress are merely bookeeping devices that do nothing. This is far from truth, as will be illustrated in the next video.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;RbJTxKFqO7I&quot;</span>, src_location=<span class="string">&quot;10.2-buckling&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>As you can see, by controlling the position of states of self stress, you can pre-select the region of a material that will fail, for example by buckling. All you have to do is to activate the self stress by pushing on the structure in the same way as you had to activate the zero modes to set them in motion.</p>
<p>You can find out more details in this paper.</p>
<ul>
<li>arXiv:1502.03396</li>
</ul>
<p>In summary, states of self stress and zero modes represent <strong>propensities</strong> that a structure has to respond by mechanical failure (triggered by stress concentrations) or free motion respectively. In topological mechanics we control how these states of motion or stress are positioned in a material by lattice geometry and topology, rather than variations in local properties like elastic moduli or local coordination.</p>
<p>As a result these states are designed to be topologically robust under smooth deformations and yet tunable, e.g. you can choose where to position them by adding defects to the lattice and choose their localization properties by playing with the gap. The tunability in response to changes in lattice structure is a crucial feature that lets us exploit the properties of weak topological insulators in a mechanical context.</p>
<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;j0X0sVy_6Og&quot;</span>, src_location=<span class="string">&quot;10.2-summary&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topological Mechanics&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w10_extensions/gapless/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> hsv_to_rgb</span><br><span class="line"></span><br><span class="line">pi_ticks = [(-np.pi, <span class="string">r&quot;$-\pi$&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;$0$&quot;</span>), (np.pi, <span class="string">r&quot;$\pi$&quot;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d_wave</span>(<span class="params">w=<span class="literal">None</span>, direction=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Creates a d-wave system.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    -----------</span></span><br><span class="line"><span class="string">    w : int</span></span><br><span class="line"><span class="string">        Width of the system, if None the system is infinite</span></span><br><span class="line"><span class="string">    direction : str</span></span><br><span class="line"><span class="string">        Direction of translation symmetry, if None it&#x27;s an infinite</span></span><br><span class="line"><span class="string">        system in x and y.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz - p.delta * pauli.sx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz + p.delta * pauli.sx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">4</span> * p.t - p.mu) * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.square()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> w:</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">            (x, y) = pos</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        sym = kwant.TranslationalSymmetry(*lat.prim_vecs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> direction == <span class="string">&quot;topo&quot;</span>:</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">                (x, y) = pos</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> &lt;= y - x &lt; w</span><br><span class="line"></span><br><span class="line">            sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">elif</span> direction == <span class="string">&quot;triv&quot;</span>:</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">ribbon_shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">                (x, y) = pos</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> &lt;= y &lt; w</span><br><span class="line"></span><br><span class="line">            sym = kwant.TranslationalSymmetry((<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    syst = kwant.Builder(sym)</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(ribbon_shape, (<span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), lat)] = hopy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">graphene_infinite</span>():</span></span><br><span class="line">    lat = kwant.lattice.honeycomb()</span><br><span class="line">    a, b = lat.sublattices</span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry(*lat.prim_vecs))</span><br><span class="line">    syst[lat.shape(<span class="keyword">lambda</span> pos: <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))] = <span class="number">0</span></span><br><span class="line">    syst[kwant.builder.HoppingKind((<span class="number">0</span>, <span class="number">0</span>), a, b)] = <span class="keyword">lambda</span> site1, site2, p: p.t_1</span><br><span class="line">    syst[kwant.builder.HoppingKind((<span class="number">0</span>, <span class="number">1</span>), a, b)] = <span class="keyword">lambda</span> site1, site2, p: p.t_23</span><br><span class="line">    syst[kwant.builder.HoppingKind((-<span class="number">1</span>, <span class="number">1</span>), a, b)] = <span class="keyword">lambda</span> site1, site2, p: p.t_23</span><br><span class="line">    <span class="keyword">return</span> syst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_dets</span>(<span class="params">syst, p, ks, chiral=<span class="literal">False</span></span>):</span></span><br><span class="line">    B = np.array(syst.symmetry.periods).T</span><br><span class="line">    A = B @ np.linalg.inv(B.T @ B)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">momentum_to_lattice</span>(<span class="params">k</span>):</span></span><br><span class="line">        k, residuals = np.linalg.lstsq(A, k, rcond=-<span class="number">1</span>)[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(k)</span><br><span class="line"></span><br><span class="line">    syst = kwant.wraparound.wraparound(syst).finalized()</span><br><span class="line">    kys, kxs = np.meshgrid(ks, ks)</span><br><span class="line">    dets = np.zeros_like(kxs, dtype=<span class="built_in">complex</span>)</span><br><span class="line">    <span class="keyword">for</span> i, kx <span class="keyword">in</span> <span class="built_in">enumerate</span>(ks):</span><br><span class="line">        <span class="keyword">for</span> j, ky <span class="keyword">in</span> <span class="built_in">enumerate</span>(ks):</span><br><span class="line">            kx, ky = momentum_to_lattice([kx, ky])</span><br><span class="line">            ham = syst.hamiltonian_submatrix(params=<span class="built_in">dict</span>(p=p, k_x=kx, k_y=ky))</span><br><span class="line">            <span class="keyword">if</span> chiral:</span><br><span class="line">                <span class="comment"># Bring the chiral symmetric Hamiltonian in offdiagonal form</span></span><br><span class="line">                U = (pauli.s0 + <span class="number">1j</span> * pauli.sx) / np.sqrt(<span class="number">2</span>)</span><br><span class="line">                ham = U @ ham @ U.T.conjugate()</span><br><span class="line">            dets[i, j] = ham[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    H = np.angle(dets) / (<span class="number">2</span> * np.pi)</span><br><span class="line">    V = np.<span class="built_in">abs</span>(dets)</span><br><span class="line">    H = np.mod(H, <span class="number">1</span>)</span><br><span class="line">    V /= np.<span class="built_in">max</span>(V)</span><br><span class="line">    V = <span class="number">1</span> - V ** <span class="number">2</span></span><br><span class="line">    S = np.ones_like(H)</span><br><span class="line">    HSV = np.dstack((H, S, V))</span><br><span class="line">    RGB = hsv_to_rgb(HSV)</span><br><span class="line">    bounds = (ks.<span class="built_in">min</span>(), ks.<span class="built_in">min</span>(), ks.<span class="built_in">max</span>(), ks.<span class="built_in">max</span>())</span><br><span class="line">    pl = holoviews.RGB(RGB, bounds=bounds, label=<span class="string">r&quot;$\det(h)$&quot;</span>, kdims=[<span class="string">&quot;$k_x$&quot;</span>, <span class="string">&quot;$k_y$&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> pl.opts(plot=&#123;<span class="string">&quot;xticks&quot;</span>: pi_ticks, <span class="string">&quot;yticks&quot;</span>: pi_ticks&#125;).opts(</span><br><span class="line">        style=&#123;<span class="string">&quot;interpolation&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Weyl_slab</span>(<span class="params">w=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopx</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5j</span> * p.t * pauli.sx - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopy</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hopz</span>(<span class="params">site1, site2, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5j</span> * p.t * pauli.sy - p.t * pauli.sz</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onsite</span>(<span class="params">site, p</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span> * p.t * pauli.sz - p.mu * pauli.sz</span><br><span class="line"></span><br><span class="line">    lat = kwant.lattice.general(np.eye(<span class="number">3</span>))</span><br><span class="line">    syst = kwant.Builder(kwant.TranslationalSymmetry([<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">pos</span>):</span></span><br><span class="line">        (x, y, z) = pos</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt;= z &lt; w</span><br><span class="line"></span><br><span class="line">    syst[lat.shape(shape, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))] = onsite</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), lat)] = hopx</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), lat)] = hopy</span><br><span class="line">    syst[kwant.HoppingKind((<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), lat)] = hopz</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> syst</span><br></pre></td></tr></table></figure>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Ashvin Vishwanath from the University of California, Berkeley will introduce Weyl semimetals and other examples of gapless, yet topological, systems.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocVideo(<span class="string">&quot;MAWwa4r1qIc&quot;</span>, src_location=<span class="string">&quot;10.1-intro&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Topological-invariants-of-Fermi-surfaces"><a href="#Topological-invariants-of-Fermi-surfaces" class="headerlink" title="Topological invariants of Fermi surfaces"></a>Topological invariants of Fermi surfaces</h1><p>The idea that leads us to the topology of gapless systems is extremely simple. It is:</p>
<blockquote>
<p>If we consider momentum as an external conserved parameter, we can study topological closings of the gap in momentum space.</p>
</blockquote>
<p>Let’s consider the simplest type of topological invariant, one we learned about at the very beginning of this course. Remember the simplest topological invariant of a 0D Hamiltonian, the number of filled energy levels? What if we take two points in momentum space, $\mathbf{k}_1$ and $\mathbf{k}_2$, and consider a Hamiltonian such that the number of filled states changes by $n$ between these two points? We can conclude that there are at least $n$ Fermi surfaces that lie on every path between $\mathbf{k}_1$ and $\mathbf{k}_2$ in momentum space.</p>
<p>Now we just need to take this idea and apply it to more interesting systems and topological invariants!</p>
<p>What types of topological invariants are relevant? Aside from special circumstances, we cannot make use of time-reversal or particle-hole symmetries: in momentum space these only have an immediate effect in isolated $\mathbf{k}$-points, where every momentum component is either $0$ or $\pi$. So there are no paths in momentum space for which either of the symmetries is effective in each point.</p>
<p>So we are left with only two symmetry classes: A and AIII (no symmetry at all or sublattice/chiral symmetry), and with only two invariants: if there is a sublattice symmetry, a winding number can be defined, and without it there’s a Chern number.</p>
<h1 id="Graphene-and-protected-Dirac-cones"><a href="#Graphene-and-protected-Dirac-cones" class="headerlink" title="Graphene and protected Dirac cones"></a>Graphene and protected Dirac cones</h1><p>We’ve already analysed the 0D Chern number that stabilizes the usual Fermi surfaces. Let’s go one dimension higher, and study winding numbers in systems with sublattice symmetry around 1D loops. </p>
<p>For a winding number to be nonzero, we need to consider 1D loops in momentum space. As a reminder, with sublattice symmetry the Hamiltonian can always be brought to the form</p>
<p>$$<br>H = \begin{pmatrix}<br>0 &amp; h(\mathbf{k}) \<br>h^\dagger(\mathbf{k}) &amp; 0<br>\end{pmatrix}<br>$$</p>
<p>The topological invariant is a nonzero winding of $\det h(\mathbf{k})$ when $\mathbf{k}$ goes around some contour. Since $h(\mathbf{k})$ is continuous, this means that its determinant also has to vanish somewhere inside this contour.</p>
<p>To study a particular example where this appears, let’s return to graphene, which we studied as a simple limit of Haldane model. For graphene we have the Hamiltonian</p>
<p>$$h(k_x, k_y) = t_1 e^{i \mathbf{k} \cdot \mathbf{a_1}} + t_2 e^{i \mathbf{k} \cdot \mathbf{a_2}} + t_3 e^{i \mathbf{k} \cdot \mathbf{a_3}},$$</p>
<p>where $t_1, t_2, t_3$ are the three hoppings connecting a site in one of the two graphene sublattices, and $a_1, a_2, a_3$ are the lattice vectors connecting one unit cell to its neighbors.</p>
<p>To consider something specific, let’s take $t_2 = t_3 = t$ and vary $t_1$. This is what the band structure and $\det h$ look like:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output size=<span class="number">150</span> fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">p = SimpleNamespace(t_1=<span class="number">1.0</span>, t_23=<span class="number">1.0</span>)</span><br><span class="line">syst = graphene_infinite()</span><br><span class="line">ks = np.sqrt(<span class="number">3</span>) * np.linspace(-np.pi, np.pi, <span class="number">80</span>)</span><br><span class="line">kwargs = <span class="built_in">dict</span>(</span><br><span class="line">    title=<span class="keyword">lambda</span> p: <span class="string">r&quot;Graphene, $t_1 = &#123;:.2&#125; \times t$&quot;</span>.<span class="built_in">format</span>(p.t_1), zticks=<span class="number">3</span></span><br><span class="line">)</span><br><span class="line">ts = np.linspace(<span class="number">1</span>, <span class="number">2.4</span>, <span class="number">8</span>)</span><br><span class="line">(</span><br><span class="line">    holoviews.HoloMap(</span><br><span class="line">        &#123;p.t_1: spectrum(syst, p, k_x=ks, k_y=ks, **kwargs) <span class="keyword">for</span> p.t_1 <span class="keyword">in</span> ts&#125;,</span><br><span class="line">        kdims=[<span class="string">&quot;$t_1$&quot;</span>],</span><br><span class="line">    )</span><br><span class="line">    + holoviews.HoloMap(</span><br><span class="line">        &#123;p.t_1: plot_dets(syst, p, ks) <span class="keyword">for</span> p.t_1 <span class="keyword">in</span> ts&#125;, kdims=[<span class="string">&quot;$t_1$&quot;</span>]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The left panel shows the band structure, and you see that it has gapless points. The right panel shows $\det h$ by using hue as a phase and intensity as magnitude (so white is $\det h = 0$). There are two Dirac points (you see 6, but this is because we plot more than one Brillouin zone). </p>
<p>We also see that the winding numbers around these two Dirac points have opposite signs (because by going around them clockwise you encounter red, blue and green colors in opposite orders). This must always be the case since the winding number around the edges of the complete Brillouin zone must vanish - as you walk down every edge of the Brillouin zone twice in opposite directions, their contributions always cancel.</p>
<p>As $t_1$ increases, the two poles move towards each other, eventually annihilating and leaving a completely gapped dispersion relation. Let’s now try to obtain an effective model for the dispersion at each pole and at the phase transition point.</p>
<p>We know that $\det h$ has to vanish next to some point $\mathbf{k}_0$. We can expand the Hamiltonian to a linear order next to this point, which immediately leaves us with a Hamiltonian</p>
<p>$$<br>H(\mathbf{k}) =<br>\begin{pmatrix}<br>0 &amp; e^{i\alpha} (v_x \delta k_x + i v_y \delta k_y) \<br>e^{-i\alpha} (v_x \delta k_x - i v_y \delta k_y) &amp; 0<br>\end{pmatrix},<br>$$</p>
<p>where $\mathbf{\delta k}$ is of course the difference between $\mathbf{k}$ and the Dirac point momentum. Of course this is the 2D Dirac equation, which should be very familiar now.</p>
<p>At the phase transition where the two Dirac points annihilate, we can also quickly guess that the correct dispersion should be a quadratic function along the axis connecting the two Dirac points, and linear along the other axis (this is also what we see in the plot). We thus have</p>
<p>$$<br>H(\mathbf{k}) =<br>\begin{pmatrix}<br>0 &amp; e^{i\alpha} (\beta \delta k_1^2 + m + i v_2 \delta k_2) \<br>e^{-i\alpha} (\beta \delta k_1^2 + m - i v_2 \delta k_2) &amp; 0<br>\end{pmatrix},<br>$$</p>
<p>such that for $m&gt;0$ we have a fully gapped Hamiltonian, and for $m&lt;0$ there are two Dirac points.</p>
<h1 id="d-wave-superconductors-and-edge-states"><a href="#d-wave-superconductors-and-edge-states" class="headerlink" title="$d$-wave superconductors and edge states"></a>$d$-wave superconductors and edge states</h1><p>Gapless points with Dirac dispersion were known for quite some time before graphene. They exist in the cuprate family of high temperature superconductors, known to have a $d$-wave order parameter. These materials are layered, with weak couplings between the layers, so in the study of these complicated systems, one often starts with a simplified two-dimensional Hamiltonian.</p>
<p>This Hamiltonian just has the usual kinetic energy term of a single particle band and a superconducting pairing proportional to $k_x^2 - k_y^2$, namely</p>
<p>$$<br>H = \begin{pmatrix}<br>k^2/2m -\mu &amp; \Delta (k_x^2 - k_y^2) \<br>\Delta (k_x^2 - k_y^2) &amp; \mu-k^2/2m<br>\end{pmatrix}.<br>$$</p>
<p>There is no spin-orbit coupling here, so the Hamiltonian has a spinless time-reversal symmetry $H = H^<em>$. It also has a particle-hole symmetry $H= - \tau_y H^</em> \tau_y$. Their product, the chiral symmetry $H = -\tau_y H \tau_y$ allows the Hamiltonian to have gapless points where both the single-particle dispersion and the pairing vanish.</p>
<h2 id="Difference-between-sublattice-symmetries"><a href="#Difference-between-sublattice-symmetries" class="headerlink" title="Difference between sublattice symmetries"></a>Difference between sublattice symmetries</h2><p>Time-reversal symmetry ensures that the winding points come in pairs at opposite momenta, just like in graphene.<br>In graphene however, the chiral symmetry operator $\sigma_z$ commutes with the time-reversal symmetry operator. This means that applying time-reversal symmetry changes the direction of a loop in momentum space, but leaves the winding number invariant. In $d$-wave superconductors on the other hand, the chiral symmetry operator $\tau_y$ is odd under time-reversal (i.e. the operators anticommute), and the winding is invariant under it.</p>
<p>This means that a Dirac point at momentum $k$ and positive winding must come together with a Dirac point at $-k$ and also positive winding. Since the total winding over the Brillouin zone must be 0, this means that in superconducting systems the Dirac points come in quadruplets: two with positive winding and two with negative winding.</p>
<p>The $d$-wave superconductor Hamiltonian gives just that: there are 4 Dirac points at $|k_x| = |k_y| = k_F / \sqrt{2}$.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">r&quot;What happens if you make the 2D $d$-wave Hamiltonian 3D, by adding coupling between 2D layers?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;The Dirac points couple and gap out.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;In 3D you cannot have a $d$-wave pairing.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;There will remain isolated gapless points in the larger 3D Brillouin zone.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You get a closed 1D Dirac line of gap closings in the 3D Brillouin zone.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">r&quot;The real and imaginary parts of the solutions of $\det h(\mathbf&#123;k&#125;)=0$ form two surfaces &quot;</span></span><br><span class="line">    <span class="string">r&quot;in the Brillouin zone. The intersection of these two surfaces is a line.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">3</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Edge-states"><a href="#Edge-states" class="headerlink" title="Edge states"></a>Edge states</h2><p>Now let’s see how bulk-edge correspondence can be made to work for gapless systems. The idea here is to consider the projection of the wave vector parallel to a continuous sample boundary $k_\parallel$ as a parameter, and to apply the bulk-edge correspondence to the remaining lower-dimensional Hamiltonian.</p>
<p>Whenever the line corresponding to a constant $k_\parallel$ crosses a Dirac point, the winding number of the Hamiltonian $H(k_\parallel)$ changes by the winding of the Dirac point. This means that for certain values of momentum parallel to the boundary, a zero energy edge state will appear.</p>
<p>For a $d$-wave superconductor this will only happen for some crystalline orientations, as you can see for yourself:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%opts VLine (color=<span class="string">&#x27;k&#x27;</span>)  Curve (linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">p = SimpleNamespace(mu=<span class="number">2.0</span>, t=<span class="number">1.0</span>, delta=<span class="number">1.0</span>)</span><br><span class="line">k = np.arccos(<span class="number">1</span> - p.mu / p.t / <span class="number">4</span>)</span><br><span class="line">ks = np.linspace(-np.pi, np.pi, <span class="number">50</span>)</span><br><span class="line">sys0 = d_wave()</span><br><span class="line">sys1 = d_wave(<span class="number">50</span>, direction=<span class="string">&quot;topo&quot;</span>)</span><br><span class="line">sys2 = d_wave(<span class="number">50</span>, direction=<span class="string">&quot;triv&quot;</span>)</span><br><span class="line"></span><br><span class="line">det_plot = plot_dets(sys0, p, ks, chiral=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">det_plot1 = (</span><br><span class="line">    det_plot</span><br><span class="line">    * holoviews.Curve(([-np.pi, np.pi], [np.pi, -np.pi]))</span><br><span class="line">    * holoviews.Curve(([-np.pi, np.pi - <span class="number">2</span> * k], [np.pi - <span class="number">2</span> * k, -np.pi]))</span><br><span class="line">    * holoviews.Curve(([-np.pi + <span class="number">2</span> * k, np.pi], [np.pi, -np.pi + <span class="number">2</span> * k]))</span><br><span class="line">).relabel(<span class="string">&quot;$\det(h)$&quot;</span>)</span><br><span class="line"></span><br><span class="line">det_plot2 = det_plot * holoviews.VLine(k) * holoviews.VLine(-k)</span><br><span class="line"></span><br><span class="line">kwargs = <span class="built_in">dict</span>(k_x=ks, ylims=[-<span class="number">2</span>, <span class="number">2</span>], xticks=pi_ticks, yticks=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    spectrum(sys1, p, title=<span class="string">&quot;Ribbon with edge states&quot;</span>, **kwargs)</span><br><span class="line">    * holoviews.VLine(-<span class="number">2</span> * k)</span><br><span class="line">    * holoviews.VLine(<span class="number">2</span> * k)</span><br><span class="line">    + det_plot1</span><br><span class="line">    + spectrum(sys2, p, title=<span class="string">&quot;Ribbon without edge states&quot;</span>, **kwargs)</span><br><span class="line">    * holoviews.VLine(-k)</span><br><span class="line">    * holoviews.VLine(k)</span><br><span class="line">    + det_plot2</span><br><span class="line">).cols(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>On the right panels you once again see $\det h$, with added lines denoting different the values of $k_{\parallel}$ crossing the Dirac points. If the sample boundary is along the $(1, 0)$ axis, the Dirac points have coinciding $k_{\parallel}$, and their windings cancel, so that no single value of $k_{\parallel}$ carries an edge state.</p>
<p>On the other hand, the crystal boundary (1, 1), which lies at an angle $\pi/4$ with respect to the crystallographic axes, has a total winding of +2 at $k_{\parallel}=0$ and a winding of −1 for $k_{\parallel}=\pm k_F$. In this case, each $|k_{\parallel}|&lt;k_F$ carries a single edge state.</p>
<p>These edge states were known to exist long before the discovery of topological insulators, and it is fascinating to see how they perfectly fit to the theory of topological phenomena!</p>
<h1 id="Weyl-points"><a href="#Weyl-points" class="headerlink" title="Weyl points"></a>Weyl points</h1><p>So far we’ve seen two examples of Dirac points in two dimensions, the surface of a 3D topological insulator and graphene. You might wonder, why don’t we have such cones in three dimensions? These do indeed exist and are called Weyl points instead of Dirac points. The reason is historical - Dirac’s equation for the electron (which  is in 3D) involves states with four components, two for the electron and two for the hole. The direct generalization of graphene to $3D$ that we will discuss involves states with two electron component. Such electron states with linear dispersion were studied first by Weyl, and have strange properties as we will illustrate below.</p>
<p>Let us start by writing the low-energy Hamiltonian for the three dimensional generalization of graphene:</p>
<p>$$H({\bf k})=(\sigma_x k_x+\sigma_y k_y+\sigma_z k_z).$$</p>
<p>Here you might think of $\sigma_{x,y,z}$ as the spin of the electron (just as on the surface of a topological insulator).</p>
<p>Next we try the usual thing we would do with a two-dimensional Dirac cone - namely see what happens when we gap it out by applying a magnetic field $\bf\sigma\cdot B$. Adding such a term, we find that the Hamiltonian transforms as follows: </p>
<p>$$H({\bf k})\rightarrow H({\bf k})+{\bf\sigma\cdot B}={\bf\sigma\cdot (k+B)}.$$</p>
<p>The key observation here is that the addition of a magnetic field effectively shifts the wave-vector as </p>
<p>$${\bf k}\rightarrow \tilde{\bf k}={\bf k+ B}.$$</p>
<blockquote>
<p>So applying the most general perturbation we can think of does not gap out the Weyl point where the energy vanishes. Instead, the perturbation only shifts the Weyl point around in momentum space. This feels like some kind of topological protection.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%%output fig=<span class="string">&#x27;png&#x27;</span></span><br><span class="line">%%opts Surface [azimuth=<span class="number">45</span>]</span><br><span class="line"></span><br><span class="line">syst = Weyl_slab(w=<span class="number">10</span>)</span><br><span class="line">p = SimpleNamespace(t=<span class="number">1.0</span>, mu=<span class="literal">None</span>)</span><br><span class="line">mus = np.linspace(-<span class="number">0.4</span>, <span class="number">2</span>, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">kwargs = <span class="built_in">dict</span>(</span><br><span class="line">    k_x=np.linspace(-np.pi, <span class="number">0</span>),</span><br><span class="line">    k_y=np.linspace(-np.pi, np.pi),</span><br><span class="line">    title=<span class="keyword">lambda</span> p: <span class="string">&quot;Weyl semimetal, $\mu = &#123;:.2&#125;$&quot;</span>.<span class="built_in">format</span>(p.mu),</span><br><span class="line">    num_bands=<span class="number">4</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">holoviews.HoloMap(&#123;p.mu: spectrum(syst, p, **kwargs) <span class="keyword">for</span> p.mu <span class="keyword">in</span> mus&#125;, kdims=[<span class="string">r&quot;$\mu$&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>Is there a sense in which Weyl points are “topological”? They are clearly protected, but is there some topological reason for the protection? As in the rest of this section, the topology of gapless system becomes apparent by looking at the Hamiltonian in lower dimensional subspaces of momentum space. For the case of Weyl, the momentum space is three dimensional, so let us look at two dimensional subspaces of momentum space.</p>
<p>A natural subspace to choose is to fix $k_z=m$. The Weyl Hamiltonian then becomes that of a massive 2D Dirac cone</p>
<p>$$H_{2D,Dirac}(k_x,k_y;m)\equiv H(k_x,k_y,k_z=m)=(\sigma_x k_x+\sigma_y k_y+m\sigma_z).$$</p>
<p>As we talked about in week 4 with Chern insulators, the massive Dirac model has a Chern number, which changes by $1$ if $m$ changes sign. </p>
<blockquote>
<p>So we can think of the Weyl Hamiltonian in the momentum planes at fixed $k_z$ as Chern insulators with Chern numbers $n_{Ch}=0$ (i.e. trivial) if $k_z &lt; 0$ and $n_{Ch}=1$ (topological) if $k_z &gt; 0$.  The Hamiltonian at $k_z=0$ is at the phase transition point of the Chern insulator, which supports a gapless Dirac point.</p>
</blockquote>
<p>Systems with Weyl points are known as Weyl semimetals. Just like other topological phases, Weyl semimetals have an interesting surface spectrum. We can understand this easily by viewing the Weyl point as a stack of Chern insulators in momentum space. For any surface in a plane that contains the $z$-axis, we can treat $k_z$ as a conserved quantity. At this $k_z=m$, the Hamiltonian is just that of a Chern insulator with an appropriate Chern number. For the range of $k_z$ where the Chern number $n_{Ch}(k_z)=1$, the surface spectrum supports chiral edge states with an energy approximated at low energy by </p>
<p>$$E(k_x,k_z)\approx v(k_z)k_x.$$</p>
<p>We can consider the edge states over a range of $k_z$ together to visualize the “surface states”. </p>
<blockquote>
<p>The unique property of the surface states is that if we set $k_x=0$ then the energy vanishes on a line in the surface spectrum. This line actually terminates at $k_z=0$, where the Chern number changes. Such lines, which are referred to as “Fermi arcs,” are the unique bounday properties (hence the bulk-boundary correspondence) of Weyl semimetals.</p>
</blockquote>
<p>At large enough $k_z$, the two dimensional Hamiltonian $H_{2D,Dirac}(k_x,k_y;k_z)$ becomes trivial i.e. $n_{Ch}(|k_z|\rightarrow \infty)=0$. This means that if the Chern number is $n_{Ch}=1$ in a range of $k_z$, then $n_{Ch}(k_z)$ must change twice resulting in two Weyl points. So Weyl points come in pairs. These points map onto the ends of the Fermi arcs on the surface. </p>
<p><img src="/2021/01/07/src/w10_extensions/gapless/weyl.svg" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">question = <span class="string">r&quot;What protects the surface state of Weyl semi-metals from scattering inside the bulk Weyl point?&quot;</span></span><br><span class="line"></span><br><span class="line">answers = [</span><br><span class="line">    <span class="string">&quot;Chiral symmetry.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The energy gap in the bulk.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Absence of scattering.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The non-zero Chern number of the bulk.&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">explanation = (</span><br><span class="line">    <span class="string">r&quot;The bulk has gapless states due to the Weyl point. &quot;</span></span><br><span class="line">    <span class="string">&quot;Therefore, only momentum conservation protects surface states from going into the bulk.&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MoocMultipleChoiceAssessment(</span><br><span class="line">    question=question, answers=answers, correct_answer=<span class="number">2</span>, explanation=explanation</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>Questions about what you just learned? Ask them below!</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Questions&quot;</span>, <span class="string">&quot;Topology in gapless systems&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/w0_background/intro/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This cell is present in all the notebooks.</span></span><br><span class="line"><span class="comment"># It makes the necessary packages available and adjusts various settings.</span></span><br><span class="line"><span class="comment"># You should execute this cell at the start.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;../../code&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> init_mooc_nb <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">init_notebook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> HTML</span><br></pre></td></tr></table></figure>

<h1 id="A-welcome-word"><a href="#A-welcome-word" class="headerlink" title="A welcome word"></a>A welcome word</h1><p>First of all, greetings from the TOPOCMx team! We are very happy that you chose to follow our course.</p>
<p>Through TOPOCMx we want to provide an introduction to the new topics on topology in condensed matter.<br>We want it to be simple, and we want it to be useful for people with very different background and motivation.</p>
<p>We want the course to be useful to you if you are a <strong>master student</strong>, and you want to get an understanding of what topology is all about.</p>
<p>Or you could be a <strong>PhD student or a postdoc</strong> doing experiments, and you want to get a better theoretical understanding of what you should expect in your investigations.</p>
<p>You could even be a <strong>theorist working in topology</strong> and be extremely familiar with topological invariants and vector bundles, but you would like to get a better understanding of how the mathematical ideas apply in physical systems.</p>
<p>Finally, we also want this course to be equally useful if you are, say, a <strong>professor working in condensed matter</strong> and you want to apply the ideas introduced by topology in your domain, so that you just need a quick overview of what research activity is there.</p>
<p>But even despite your different backgrounds, we want our course to feel like this:</p>
<img src="/2021/01/07/src/w0_background/intro/magnetic_discussion_bruno_touschek.png" alt="Discussion" style="width: 70%;">

<p>rather than this:</p>
<img src="/2021/01/07/src/w0_background/intro/bored_audience_bruno_touschek.png" alt="Bored audience" style="width: 70%;">

<p><em>(Images by Bruno Touschek, © 1981 <a href="http://cds.cern.ch/record/135949">CERN</a> CC-BY-3.0)</em></p>
<h3 id="What-you-get"><a href="#What-you-get" class="headerlink" title="What you get"></a>What you get</h3><p>Let us explain what you can expect from the course, and what is special about it.<br>The first thing which you need to understand is that the course is hard.<br>We don’t mean advanced and involved math (we took care to skip all the parts that don’t help understanding).<br>Instead, since topology has impact on many different physical phenomena, the course will touch a lot of different concepts in condensed matter physics.</p>
<p>First of all, we will provide you with a description of the most <strong>important facts and discoveries in topology</strong> in the most simple and concise manner that we can find.</p>
<p>This will still be hard to some of you, since the required background in condensed matter physics is still broad.<br>If you see that it is the case, you will need to search for advice in the course <strong>discussions</strong>, so you’ll also use the course as an expert community.</p>
<p>If you are experienced already, you may find the lectures straightforward.<br>However, even though active research on topological insulators began less than ten years ago,<br>the field is already incredibly broad.</p>
<p>This is why we want our course to also fulfill a role of a <strong>journal club</strong>:<br>every week we’ll ask you to read one of several suggested papers, observe how the concepts that you learn<br>appear in a new context, and summarize it for the other participants.<br>That way you will learn to analyze research papers and get an <strong>overview of the field</strong>.</p>
<p>Most of the numerical simulations that are used in our research are actually amazingly easy if you know how to do them.<br>While teaching how to do computer simulations is not our main aim, we provide already set up simulations for the systems we describe in the lectures.</p>
<p>Using these <strong>computer simulations</strong> you can see for yourself how various models behave, discover new parameter regimes that we don’t cover in the lectures, or even extend the simulations and see how adding new terms to the models changes the results.</p>
<h3 id="How-you-can-help-us"><a href="#How-you-can-help-us" class="headerlink" title="How you can help us"></a>How you can help us</h3><p>MOOCs like this one are not a usual way for providing graduate-level materials, and even less so materials that are a topic of active research.</p>
<p>We believe that it is a very useful and promising way of knowledge dissemination, that has advantages over a book, a university course, or a review.</p>
<p>This is why it is extremely important for us to know what is your background and your motivation to take the course.<br>We want you to share what you found difficult, what you found easy, and where you think the course can be improved.</p>
<p>Moreover, we publish the <strong>source code</strong> for every single bit of this course in this <a href="https://github.com/topocm/topocm_content">Github repository</a>.<br>So whenever you see a typo, or you would like to suggest an improvement, you can open a new issue, (or even make a pull request if you know how to use Github).</p>
<h1 id="Software-you-will-need"><a href="#Software-you-will-need" class="headerlink" title="Software you will need"></a>Software you will need</h1><p>If you don’t want to be bothered trying out the numerical simulations, you are all set if you have an EdX account and you are signed up for the course.</p>
<p>However we strongly recommend to not skip the numerical simulations part. Following it will help you to develop intuition about how the topological systems behave. The numerical simulations can also serve as an extremely useful tool helping both in experiments and theory.</p>
<p>To get going with the simulations, you will need to get the computational software.<br>Specifically you need:</p>
<ul>
<li>Python 3.5 or 3.6</li>
<li>Python scientific stack (SciPy, NumPy, Matplotlib, Jupyter notebook)</li>
<li>Holoviews 1.7, a Python library for plotting data.</li>
<li><a href="http://kwant-project.org">Kwant</a> 1.3, a package for quantum transport simulations.</li>
</ul>
<p>The installation should be straightforward.<br>Installation of most of the requirements is described <a href="http://kwant-project.org/install">here</a>.</p>
<p>If you are using Windows, you are all set after following the above instructions.</p>
<p>The easiest way to install <code>kwant</code> when you are using Linux or OS X is with <code>conda</code> which comes with Miniconda, a Python distribution.</p>
<ol>
<li><p>Open a terminal and download <a href="http://conda.pydata.org/miniconda.html>">Miniconda</a><br>(or <a href="https://www.continuum.io/downloads">Anaconda</a>) by running:</p>
<pre><code>wget https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh</code></pre></li>
<li><p>Install Miniconda with:</p>
<pre><code>bash Miniconda3-latest-MacOSX-x86_64.sh</code></pre><p>and follow its instructions. Make sure that <code>conda</code> is in your PATH, which you<br>can do by adding <code>export PATH=&quot;$HOME/miniconda3/bin:$PATH&quot;</code> to your <code>.bashrc</code><br>or <code>.bash_profile</code>.</p>
</li>
<li><p>Add the <a href="https://conda-forge.github.io/">conda-forge</a> channel and install<br>Kwant and its dependencies with:</p>
<pre><code>conda config --add channels conda-forge
conda install kwant holoviews notebook feedparser</code></pre></li>
</ol>
<h3 id="Jupyter-notebooks"><a href="#Jupyter-notebooks" class="headerlink" title="Jupyter notebooks"></a>Jupyter notebooks</h3><p>A separate mention of the software we use goes to Jupyter notebooks.</p>
<p>Every document that you see in our course (including the one that you are reading right now) was prepared as a Jupyter notebook.</p>
<p>These notebooks are extremely handy, they allow:</p>
<ul>
<li>To use an interactive computing environment where you can see what your simulation does right as you are creating it.</li>
<li>To combine nicely formatted text (with Latex equations and images) together with code in any language and the output of that code.</li>
<li>To easily share that same code: here, take a look at the source of <a href="http://nbviewer.ipython.org/github/topocm/topocm_content/blob/master/w0_background/intro.ipynb">the notebook</a> that you are currently reading.</li>
<li>To convert it to a presentation, blog post, or an EdX course.</li>
</ul>
<p>The combination of the above nice properties with many more and with Jupyter being free software lead to the notebooks being <a href="http://www.nature.com/news/interactive-notebooks-sharing-the-code-1.16261">highlighted</a> in Nature.</p>
<p>For a short presentation of Jupyter notebooks just use <code>Help -&gt; User Interface Tour</code> inside the notebook.</p>
<h3 id="Sharing-notebooks"><a href="#Sharing-notebooks" class="headerlink" title="Sharing notebooks"></a>Sharing notebooks</h3><p>Showing the results of your work is very easy.</p>
<p>If you are using Sage Cloud, you can just click the “share the notebook” button when you have it opened, and copy the URL.</p>
<p>Otherwise you can make the notebook visible online (for example by putting it in your Dropbox public folder or something similar), copy link, and paste it into <a href="http://nbviewer.ipython.org">http://nbviewer.ipython.org</a>.</p>
<h3 id="Kwant-Python-and-Python-scientific-software"><a href="#Kwant-Python-and-Python-scientific-software" class="headerlink" title="Kwant, Python, and Python scientific software"></a>Kwant, Python, and Python scientific software</h3><p>For most of the simulations of condensed matter systems we are going to use the Kwant package. You can learn Kwant in more detail by following the <a href="http://kwant-project.org/doc/1.0/tutorial/">tutorial</a>, however we aim that for most of the exercises you will be able to learn by doing. The starting point of the exercises are the notebooks used in the lectures, and you should be able to solve them by only modifying the contents not too much.</p>
<p>The same applies to Python and the Python scientific stack (NumPy, SciPy, Matplotlib): these are easy to use, especially when you have code examples. If you are new to programming and wish to get acquainted with Python,<br><a href="http://www.learnpython.org/">here</a> are <a href="http://www.python-course.eu/">several</a> <a href="https://www.codecademy.com/learn/python">example courses</a> that start from the basics and slowly go into advanced topics. There are of course several MOOCs as well, but you will likely not need as much programming skill.</p>
<p><strong>Do you have questions about installation? Use this discussion:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MoocDiscussion(<span class="string">&quot;Software&quot;</span>, <span class="string">&quot;Help with installation&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Literature"><a href="#Literature" class="headerlink" title="Literature"></a>Literature</h1><p>We are mostly going to focus on the overall structure of the field and study the most basic and general phenomena. We will also skip detailed derivations or some details.</p>
<p>For a more formal and complete source of information on topological insulators and superconductors we recommend you to look into the reviews below. (Of course we think they will be much easier to follor after you finish the course).</p>
<h2 id="Topological-insulator-reviews"><a href="#Topological-insulator-reviews" class="headerlink" title="Topological insulator reviews"></a>Topological insulator reviews</h2><ul>
<li>arXiv:0801.0901</li>
<li>arXiv:1002.3895</li>
<li>arXiv:1008.2026</li>
</ul>
<h2 id="Majorana-fermion-reviews"><a href="#Majorana-fermion-reviews" class="headerlink" title="Majorana fermion reviews"></a>Majorana fermion reviews</h2><ul>
<li>arXiv:1112.1950</li>
<li>arXiv:1202.1293</li>
<li>arXiv:1206.1736</li>
<li>arXiv:1407.2131</li>
</ul>
<h2 id="Advanced-topics-Fractional-particles-and-topological-quantum-computation"><a href="#Advanced-topics-Fractional-particles-and-topological-quantum-computation" class="headerlink" title="Advanced topics: Fractional particles and topological quantum computation"></a>Advanced topics: Fractional particles and topological quantum computation</h2><ul>
<li>arXiv:0707.1889</li>
<li>arXiv:0711.4697</li>
<li>arXiv:1404.0897</li>
</ul>
<h2 id="Extra-topics"><a href="#Extra-topics" class="headerlink" title="Extra topics"></a>Extra topics</h2><ul>
<li>arXiv:1211.5623</li>
<li>arXiv:1501.00531</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/src/syllabus.md/</url>
    <content><![CDATA[# Syllabus


## Course structure

* Each section consists of several relatively self-contained topics, each introduced and summarized by an expert.
* If you have questions about the material, ask them using the discussion right after the final video of each topic.
* The assignments are a combination of numerical simulations, where you evaluate your success on your own (but do share your results), and a review of a paper out of a selection of papers. The reviews are then cross-evaluated by other participants.
* In order to keep everyone on the same page, we set a one week deadline for the assignments (plus an extra week for cross-evaluation of the paper reviews). The questions in the course materials have no deadline.

## Current course team

**Anton Akhmerov** is an assistant professor in Kavli Institute of Nanoscience of Delft University of Technology and QuTech.

**Jay Sau** is an assistant professor in the area of theoretical Condensed matter physics at the University of Maryland, College Park, USA.

**Bernard van Heck** is a postdoc at Yale University.

**Bas Nijholt, Irfan Muhammad, Tómas Örn Rosdahl** are PhD students working in Kavli Institute for Nanoscience at TU Delft supervised by Anton Akhmerov.

## Other course developers

The initial verison of the course was created by:
* Anton Akhmerov
* Jay Sau
* Bernard van Heck
* Sebastian Rubbert
* Rafał Skolasiński

## Acknowledgements

When working on the course, we greatly benefitted from support of

* [Delft University of Technology](http://tudelft.nl) and its Extension School
* [QuTech](http://qutech.nl)
* [Casimir Research School](http://casimir.researchschool.nl) and the [NanoFront](http://casimir.researchschool.nl/nanofront) program
* [University of Maryland](http://umd.edu) and its Physics Department
* [Joint Quantum Institute](http://jqi.umd.edu)

We thank [M. Wimmer](http://michaelwimmer.org/) and [C. Groth](http://inac.cea.fr/Pisp/christoph.groth/) for letting us use their code in some of the course materials.

For the support with implementing the technical aspects of the course we thank

* The [Jupyter project](https://jupyter.org) and its developer team, especially Min Ragan-Kelley.
* [SageMathCloud](https://cloud.sagemath.org) and its creator W. Stein.
* The [Holoviews](https://holoviews.org) team: Jean-Luc Stevens and Philipp Rudiger.

Finally, we thank all the external speakers for contributing the videos for the course.

## License

Unless otherwise specified the **Course Materials** of TU
Delft TOPOCMx are Copyright [Delft University of Technology](http://www.tudelft.nl/en/) and are licensed under
a [Creative Commons Attribution-ShareAlike 4.0
International License](http://creativecommons.org/licenses/by-sa/4.0/)
[![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)

The **source code** can also be used under conditions of the 3-clause BSD licence:

 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

**Videos contributed by external experts** are copyright of their creators, and are also available under Creative Commons Attribution 3.0 Unported License.
]]></content>
  </entry>
  <entry>
    <title>pytorch 学习</title>
    <url>/2020/05/02/pytorch_learning/</url>
    <content><![CDATA[<h3 id="pytorch-学习"><a href="#pytorch-学习" class="headerlink" title="pytorch 学习"></a>pytorch 学习</h3><h4 id="1-pytorch的优点"><a href="#1-pytorch的优点" class="headerlink" title="1. pytorch的优点"></a>1. pytorch的优点</h4><pre><code>自动微分
集成常用函数
拥有数据处理函数
多精度训练</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">torch.manual_seed(<span class="number">466</span>)</span><br><span class="line">np.random.seed(<span class="number">466</span>)</span><br></pre></td></tr></table></figure>

<h4 id="numpy-ndarray-与-pytorch-Tensors-之间的联系"><a href="#numpy-ndarray-与-pytorch-Tensors-之间的联系" class="headerlink" title="numpy ndarray 与 pytorch Tensors 之间的联系"></a>numpy ndarray 与 pytorch Tensors 之间的联系</h4>   <span id="more"></span>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_numpy = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">x_torch = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x_numpy,  x_torch&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x_numpy,x_torch)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<pre><code>x_numpy,  x_torch
[1 2 3] tensor([1, 2, 3])</code></pre><p>​    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;numpy 与 torch 之间的转化&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(torch.from_numpy(x_numpy),x_torch.numpy())</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<pre><code>numpy 与 torch 之间的转化
tensor([1, 2, 3], dtype=torch.int32) [1 2 3]</code></pre><p>​    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运算操作</span></span><br><span class="line">y_numpy = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">y_torch = torch.tensor([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x+y&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(x_numpy+y_numpy,x_torch+y_torch)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<pre><code>x+y
[3 5 7] tensor([3, 5, 7])</code></pre><p>​    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mean along the 0th dimension&quot;</span>)</span><br><span class="line">x_numpy = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4.</span>]])</span><br><span class="line">x_torch = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4.</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.mean(x_numpy, axis=<span class="number">0</span>), torch.mean(x_torch, dim=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<pre><code>mean along the 0th dimension
[2. 3.] tensor([2., 3.])</code></pre><h4 id="Tensor-view-用于reshape-tensor"><a href="#Tensor-view-用于reshape-tensor" class="headerlink" title="Tensor.view 用于reshape tensor"></a>Tensor.view 用于reshape tensor</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N,C,W,H = <span class="number">10</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span></span><br><span class="line">X = torch.randn(N,C,W,H)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X.shape)</span><br><span class="line"><span class="built_in">print</span>(X.view(N,C,<span class="number">5</span>*<span class="number">5</span>).shape)</span><br><span class="line"><span class="built_in">print</span>(X.view(-<span class="number">1</span>,C,<span class="number">5</span>*<span class="number">5</span>).shape)</span><br></pre></td></tr></table></figure>

<pre><code>torch.Size([10, 3, 5, 5])
torch.Size([10, 3, 25])
torch.Size([10, 3, 25])</code></pre><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>What’s special about PyTorch’s tensor object is that it implicitly creates a computation graph in the background. A computation graph is a a way of writing a mathematical expression as a graph. There is an algorithm to compute the gradients of all the variables of a computation graph in time on the same order it is to compute the function itself.</p>
<p>Consider the expression  𝑒=(𝑎+𝑏)∗(𝑏+1)  with values  𝑎=2,𝑏=1 . We can draw the evaluated computation graph as</p>
<p>In PyTorch, we can write this as<br><img src="/2020/05/02/pytorch_learning/tree-eval.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor(<span class="number">2.0</span>,requires_grad=<span class="literal">True</span>) <span class="comment"># requires_grad 自动微分参数</span></span><br><span class="line">b = torch.tensor(<span class="number">1.0</span>,requires_grad=<span class="literal">False</span>) <span class="comment"># 输入False不自动计算计算图</span></span><br><span class="line">c = a+b</span><br><span class="line">d = b+<span class="number">1</span></span><br><span class="line">e = c*d</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c&#x27;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;d&#x27;</span>,d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e&#x27;</span>,e)</span><br></pre></td></tr></table></figure>

<pre><code>c tensor(3., grad_fn=&lt;AddBackward0&gt;)
d tensor(2.)
e tensor(6., grad_fn=&lt;MulBackward0&gt;)</code></pre><h3 id="PyTorch-的自动微分框架"><a href="#PyTorch-的自动微分框架" class="headerlink" title="PyTorch 的自动微分框架"></a>PyTorch 的自动微分框架</h3><p>Now that we have seen that PyTorch keeps the graph around for us, let’s use it to compute some gradients for us.</p>
<p>Consider the function  $ 𝑓(𝑥)=(𝑥−2)^2 $.</p>
<p>Q: Compute $\frac{d}{dx} f(x)$ and then compute $f’(1)$.</p>
<p>We make a <code>backward()</code> call on the leaf variable (<code>y</code>) in the computation, computing all the gradients of <code>y</code> at once.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (x-<span class="number">2</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fp</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*(x-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">x = torch.tensor([<span class="number">1.0</span>],requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">y = f(x)</span><br><span class="line">y.backward()  <span class="comment">#backward()用于计算表达式中的所有梯度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;PyTorch 解为：&#x27;</span>,x.grad)</span><br><span class="line">z = f(x) * f(x**<span class="number">2</span>)</span><br><span class="line">z.backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;微分解析解为：&#x27;</span>,fp(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;PyTorch 解为：&#x27;</span>,x.grad)</span><br></pre></td></tr></table></figure>

<pre><code>PyTorch 解为： tensor([-2.])
微分解析解为： tensor([-2.], grad_fn=&lt;MulBackward0&gt;)
PyTorch 解为： tensor([-8.])</code></pre><p>It can also find gradients of functions.</p>
<p>Let $w = [w_1, w_2]^T$</p>
<p>Consider $g(w) = 2w_1w_2 + w_2\cos(w_1)$</p>
<p>Q: Compute $\nabla_w g(w)$ and verify $\nabla_w g([\pi,1]) = [2, \pi - 1]^T$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">w</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*w[<span class="number">0</span>]*w[<span class="number">1</span>] + w[<span class="number">1</span>]*torch.cos(w[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_g</span>(<span class="params">w</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.tensor([<span class="number">2</span>*w[<span class="number">1</span>]-w[<span class="number">1</span>]*torch.sin(w[<span class="number">0</span>]),<span class="number">2</span>*w[<span class="number">0</span>]+torch.cos(w[<span class="number">0</span>])])</span><br><span class="line"></span><br><span class="line">w = torch.tensor([np.pi,<span class="number">1</span>],requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">z = g(w)</span><br><span class="line">z.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;解析解：&#x27;</span>, grad_g(w))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Torch解：&#x27;</span>, w.grad)</span><br></pre></td></tr></table></figure>

<pre><code>解析解： tensor([2.0000, 5.2832])
Torch解： tensor([2.0000, 5.2832])</code></pre><h3 id="使用梯度"><a href="#使用梯度" class="headerlink" title="使用梯度"></a>使用梯度</h3><p>Now that we have gradients, we can use our favorite optimization algorithm: gradient descent!</p>
<p>Let $f$ the same function we defined above.<br>$ f = (x-2)^2 $</p>
<p>Q: What is the value of $x$ that minimizes $f$?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">5.0</span>],requires_grad=<span class="literal">True</span>)</span><br><span class="line">step_size = <span class="number">0.4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iter,\tx,\tf(x),\tf\&#x27;(x),\tf\&#x27;(x) pytorch&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    y = f(x)</span><br><span class="line">    y.backward()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;,\t&#123;:.3f&#125;,\t&#123;:.3f&#125;,\t&#123;:.3f&#125;,\t&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(i, x.item(), f(x).item(), fp(x).item(), x.grad.item()))</span><br><span class="line">    </span><br><span class="line">    x.data = x.data - step_size * x.grad</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#需要把grad值归零，不归零的话 y 的值会累积</span></span><br><span class="line">    x.grad.detach_() <span class="comment"># 为了提高效率</span></span><br><span class="line">    x.grad.zero_()</span><br></pre></td></tr></table></figure>

<pre><code>iter,    x,    f(x),    f&apos;(x),    f&apos;(x) pytorch
0,    5.000,    9.000,    6.000,    6.000
1,    2.600,    0.360,    1.200,    1.200
2,    2.120,    0.014,    0.240,    0.240
3,    2.024,    0.001,    0.048,    0.048
4,    2.005,    0.000,    0.010,    0.010
5,    2.001,    0.000,    0.002,    0.002
6,    2.000,    0.000,    0.000,    0.000
7,    2.000,    0.000,    0.000,    0.000
8,    2.000,    0.000,    0.000,    0.000
9,    2.000,    0.000,    0.000,    0.000</code></pre><h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><p>使用torch进行线性回归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造了一个线性带有噪音的data set</span></span><br><span class="line">d = <span class="number">2</span></span><br><span class="line">n = <span class="number">50</span></span><br><span class="line">X = torch.randn(n,d)</span><br><span class="line">true_w = torch.tensor([[-<span class="number">1.0</span>],[<span class="number">2.0</span>]])</span><br><span class="line">y = X @ true_w + torch.randn(n,<span class="number">1</span>)*<span class="number">0.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X shape&#x27;</span>,X.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y shape&#x27;</span>, y.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w shape&#x27;</span>, true_w.shape)</span><br></pre></td></tr></table></figure>

<pre><code>X shape torch.Size([50, 2])
y shape torch.Size([50, 1])
w shape torch.Size([2, 1])</code></pre><h3 id="Note-dimensions"><a href="#Note-dimensions" class="headerlink" title="Note: dimensions"></a>Note: dimensions</h3><p>PyTorch does a lot of operations on batches of data. The convention is to have your data be of size $(N, d)$ where $N$ is the size of the batch of data.</p>
<h3 id="Sanity-check"><a href="#Sanity-check" class="headerlink" title="Sanity check"></a>Sanity check</h3><p>To verify PyTorch is computing the gradients correctly, let’s recall the gradient for the RSS objective:</p>
<p>$$\nabla_w \mathcal{L}_{RSS}(w; X) = \nabla_w\frac{1}{n} ||y - Xw||_2^2 = -\frac{2}{n}X^T(y-Xw)$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span>(<span class="params">X,w</span>):</span></span><br><span class="line">    <span class="keyword">return</span> X @ w</span><br><span class="line"></span><br><span class="line"><span class="comment"># norm 求的是矩阵范数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rss</span>(<span class="params">y,y_hat</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.norm(y-y_hat)**<span class="number">2</span>/n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度解析解 @ 表示矩阵乘法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_rss</span>(<span class="params">X,y,W</span>):</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">2</span>*X.t()@(y-X @ w)/n</span><br><span class="line"></span><br><span class="line">w = torch.tensor([[<span class="number">1.0</span>],[<span class="number">0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">y_hat = model(X,w)</span><br><span class="line"></span><br><span class="line">loss = rss(y,y_hat)</span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Analytical gradient&#x27;</span>, grad_rss(X, y, w).detach().view(<span class="number">2</span>).numpy())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;PyTorch\&#x27;s gradient&#x27;</span>, w.grad.view(<span class="number">2</span>).numpy())</span><br></pre></td></tr></table></figure>

<pre><code>Analytical gradient [ 4.474982 -3.335253]
PyTorch&apos;s gradient [ 4.4749813 -3.3352537]</code></pre><p>Now that we’ve seen PyTorch is doing the right think, let’s use the gradients!</p>
<h2 id="Linear-regression-using-GD-with-automatically-computed-derivatives"><a href="#Linear-regression-using-GD-with-automatically-computed-derivatives" class="headerlink" title="Linear regression using GD with automatically computed derivatives"></a>Linear regression using GD with automatically computed derivatives</h2><p>We will now use the gradients to run the gradient descent algorithm.</p>
<p>Note: This example is an illustration to connect ideas we have seen before to PyTorch’s way of doing things. We will see how to do this in the “PyTorchic” way in the next example.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">step_size = <span class="number">0.4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iter,\t loss,\t w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    y_hat = model(X,w)</span><br><span class="line">    loss = rss(y,y_hat)</span><br><span class="line">    </span><br><span class="line">    loss.backward()</span><br><span class="line">    w.data = w.data - step_size * w.grad</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;,\t&#123;:.2f&#125;,\t&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i, loss.item(), w.view(<span class="number">2</span>).detach().numpy()))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># We need to zero the grad variable since the backward()</span></span><br><span class="line">    <span class="comment"># call accumulates the gradients in .grad instead of overwriting.</span></span><br><span class="line">    <span class="comment"># The detach_() is for efficiency. You do not need to worry too much about it.</span></span><br><span class="line">    w.grad.detach()</span><br><span class="line">    w.grad.zero_()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\ntrue w\t\t&#x27;</span>, true_w.view(<span class="number">2</span>).numpy())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;estimated w\t&#x27;</span>, w.view(<span class="number">2</span>).detach().numpy())</span><br></pre></td></tr></table></figure>

<pre><code>iter,     loss,     w
0,    7.80,    [-2.5799851  2.668203 ]
1,    3.22,    [-1.1622744  2.2072678]
2,    0.08,    [-0.997594   2.0795758]
3,    0.02,    [-0.98061234  2.0375962 ]
4,    0.01,    [-0.97969574  2.022719  ]
5,    0.01,    [-0.9800115  2.0172987]
6,    0.01,    [-0.98020816  2.0153053 ]
7,    0.01,    [-0.98029053  2.0145698 ]
8,    0.01,    [-0.98032224  2.014298  ]
9,    0.01,    [-0.9803341  2.0141976]
10,    0.01,    [-0.98033845  2.0141604 ]
11,    0.01,    [-0.98034006  2.0141468 ]
12,    0.01,    [-0.98034066  2.0141418 ]
13,    0.01,    [-0.9803409  2.01414  ]
14,    0.01,    [-0.98034096  2.0141392 ]
15,    0.01,    [-0.980341  2.014139]
16,    0.01,    [-0.980341  2.014139]
17,    0.01,    [-0.980341  2.014139]
18,    0.01,    [-0.980341  2.014139]
19,    0.01,    [-0.980341  2.014139]

true w         [-1.  2.]
estimated w     [-0.980341  2.014139]</code></pre><h3 id="Neural-Network-Basics-in-PyTorch"><a href="#Neural-Network-Basics-in-PyTorch" class="headerlink" title="Neural Network Basics in PyTorch"></a>Neural Network Basics in PyTorch</h3><p>fitting a simple neural network to the data </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line">X = torch.rand(n,d)</span><br><span class="line">y = <span class="number">4</span>* torch.sin(np.pi*X)*torch.cos(<span class="number">6</span>*np.pi*X**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(X.numpy(),y.numpy())</span><br><span class="line">plt.title(<span class="string">&#x27;plot of $f(x)$&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;$y$&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/05/02/pytorch_learning/output_25_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">step_size = <span class="number">0.05</span></span><br><span class="line">iter_times = <span class="number">12000</span></span><br><span class="line">n_hidden_1 = <span class="number">32</span></span><br><span class="line">n_hidden_2 = <span class="number">32</span></span><br><span class="line">d_out = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">neural_network = nn.Sequential(</span><br><span class="line">                                nn.Linear(d,n_hidden_1),</span><br><span class="line">                                nn.Tanh(),</span><br><span class="line">                                nn.Linear(n_hidden_1,n_hidden_2),</span><br><span class="line">                                nn.Tanh(),</span><br><span class="line">                                nn.Linear(n_hidden_2,d_out))</span><br><span class="line"></span><br><span class="line">loss_func = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">optim = torch.optim.SGD(neural_network.parameters(),lr=step_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iter, \t loss&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iter_times):</span><br><span class="line">    y_hat = neural_network(X)</span><br><span class="line">    loss = loss_func(y_hat,y)</span><br><span class="line">    optim.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optim.step()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">1000</span> ==<span class="number">0</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;,\t&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(i, loss.item()))</span><br></pre></td></tr></table></figure>

<pre><code>iter,      loss
0,    4.36
1000,    2.60
2000,    1.08
3000,    0.62
4000,    0.23
5000,    0.12
6000,    0.06
7000,    0.05
8000,    0.03
9000,    0.02
10000,    0.00
11000,    0.01</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_grid = torch.from_numpy(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>)).<span class="built_in">float</span>().view(-<span class="number">1</span>,d)</span><br><span class="line">y_hat = neural_network(X_grid)</span><br><span class="line">plt.scatter(X.numpy(), y.numpy())</span><br><span class="line">plt.plot(X_grid.detach().numpy(), y_hat.detach().numpy(), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;plot of $f(x)$ and $\hat&#123;f&#125;(x)$&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;$x$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;$y$&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/2020/05/02/pytorch_learning/output_27_0.png" alt="png"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title>20200411-日志</title>
    <url>/2020/04/11/20200411/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8d663e90880abff53eadf9d4d90ba25cefef50b18f73669d16f1aa6a5bbb9a67">af79fdb8a06ca51fd568169b60f35077e6598c67979dea63066ee56bfda465fac5e491534346592c51c0253e07a81968857653952e87756ecf9cc7a97165be16f3a047f6ca9f229b86d4dd54838c5b630da59596b4edb5b19c3273beca9da4b08a128d65f7394b1a86a2998f43d31d1a0296fcd29435242204adc19d300f20904f9f5e58c5a1b7056a209c574d631ea92a2d3392e119de66536bc7acf7af05bbc69c4e685173ec8e8e1b8066f40fb1af08e99237380c0459f026416e67a3a03d19b4fa3428d12fb622dcbd9322506326f3fec346aff0d4fa6b159da28a48ec0467ba4e7ea8f9ec5aa8078a93f5e5c7fd46667f7d4cc330de70af5d46acf1b817fe4df2f9be0c2c415774a89f916f46415ebc224748f157a7d3cfc4deb3baf375f3595933d4497df423e32579dddffd2237b093a987586b44333370076e4efff35d234673f98b1ec02c09de4b5fc12a51effa7db678c6c934cea0ad97bede309df95c40f961a2749603fb1a43ff4fe9cebc0aa225d906ba1148a85cf72371ad33d3cb22c77e5add313a34248130e04fca5795c1e2ac2df5ec6123bd8028d31680cd91aa624e17616d48e89f9136d48752ec14edd6c70f05c0a8cf28b68a5f0dadf810cd6711bfc63bfda6f21c376ad6360e9c2f5876fe0cc0b5c0d1dfecddfe45f1d07b777c62e0795ac7d3f0fc4a8abf246bbb410f1be0e83327db5a57929e2c58d644436869b3e8f69283eed4bdb22a771244c1077e6724232efb552810cb5098cf1700cf7002aea522394d5179d285a86a5cbbdf4fa655b0da949ffbefa8481650958aa7b76e6eb64337fcd3f5128862351ebc33db1425e51be87a78f4d4aa853fbc52dfbe12287c5d0243bfd3ac1cdcd79dd3548f4236fe7aabf127d0bcd75321b05a8774289c4f267431b346062d7220d5fac6e3c84643f9977b478454c2031a6f60e750626edb6ffc702982da7c4102fbc69b5c9bed3c917cd1fcd9d46c14e485af18b28d98c46f29e76a426bc4851ad59b20bfd2b9058115e39995dae6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">加密，请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>logs</category>
      </categories>
      <tags>
        <tag>logs</tag>
      </tags>
  </entry>
  <entry>
    <title>日志——2020年4月10日</title>
    <url>/2020/04/10/%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="636877c684d47082627a3fc386714696a7422f6872dd8084da41ac40564793fb">af79fdb8a06ca51fd568169b60f35077e6598c67979dea63066ee56bfda465fa0dc42c204a0c58c04048d5705e568138d0ff906baedc4819ce04e5c27978b8f219922aedcd8c6970faad140a0b25e347a12e976dac0b3aee3dd684b2378eeec8e1ae54268ef1eea894bdb3e454f35dfe408a3c36552007f82d97160f2a1a3d7ee3074e7497b6bb400357a6e3015abdf4829ba8a274bfa9aa06f590b24e79e8acee991d348707e15b5ffb3b1bf33e2a331281649d5c0d0914c23702a8c3b210ca450fec5c010ef9f6a6b9b854377268b99d8d449eab979d187431e04e6c11771bdd2151035d3405e8e1fb45f9561be5d40efb16e1ef3f8957fce67fe04d514c02b8e27c477bc4e8a4259b4e1b6cbc8261a24c10cc6571a54004bbc00f16abb0cbf4ed4fd335b118504325b8f583b308e2f3a1b400db3164cd3fd53f87cbe56019d39ee779895fe3deb6ad9ad9ac26e5b7d48c9c13a78720963806c624a1212e4a9501a3463e7ee8956269a12e0cc96e215a6b51453c21157d030559e44785c8793f32f36573d1991c02d8472cd0d7d6b53ef211bdfce8ee691a4cee272bbe78b5796187ac2eb57c8fbd8a6b9a9bb9a4f6b0516ca0968ee8ef021ac4ad30e0f43bf3f47e69fe84390fd3f12fef7bfa9e0a0e923eeb8c0058727d90227713c76c8a08764bb63935a99697c17e36cbb0445e9fb8151cf3afd2a16e3887dfde3971cb610bc6f66bfd62d48c5883ffdaee126dbd7c7566e6a42110c1e62990ffa938ad3039ea3e606bf177f934d8fed9220e8e56859ab79841cc75d2e5edba17a43e300a0dfa4a36994cfcb6fa8a52260f1779bd49b4975ec08ae85fb8c664147e32f4cc80bdca102dbebdc7c6a89496010d2998868df04fd8f6243008dab421a537d485df2e2e4cba60d9302e7a9f645fc591d0b437075bb35408c5945f86ff3a7d8a82d3fb61618386db95d43d602ea56522a44275cf60bc3db9e825589f3edcde6f721965e88d555fc3dd0cf28e0a88acbace3787191e75f284246cab5ed543eadb6114d1f814c827e2d2fd80efe40f2dc8fb90cf11e095b87673b25a4f99faa73bf86e7932a6e2b274eb9dbdc13108d474266b21fa2e2ab50d5b5850cff17a48abad779dd281e768c085afc92e54222b19971bff2e2c00106184f9096ed20deb7c3da513cfe2dacbc20eaf5c0ecc8ee41cdbd5f027bae79001c660f69520dad4cd359bdd90f4a8362e7ccc49725dfa1c42f79fa25d24612832faeec97d86e103366f39650050c2a18357726b8c10a6537697eaeabca0d5d74814bf484b848c02e403ee0c82731e92f85e563522ebe4255efaccddf6591aabf3b10ccd67f48d581d610070330d23f865d9bdf084b6949089d093fbb2653b26c7ee30d6678b651eff21090a2a4102af42e94f64ba97ec24d4a58645483ba5f6d54446c0a1ba83b2243f2d15a39f1eb1a75cf48dc216c94511f3615bb187afc98fbccf6ce104eec7f155151b73956d27e74899ba9963cdbe0aa5ce49a194741a0efdd3ce9c933f0b4b88f83104d98e1bcb857a59aca68b5d105160e59cf16ccc7dd38cf2e6a1904b45bb139928076f20ca90d6cf7aee49cb336ab4dcd006596b965e9355711a9a1e7e227b5cd5fb4cd855fee0bd239a4b46fa2511f987b7ddbdd17f2e09a95b6e1b88f51a2850959683a475e4d10a527f53af122c075f1033e8bbd5adf4c30fa8c0b75b1da6408fbd85c7cf36213738d7aec4a45f103ea565d8d813292bdd19cf87f0e409a724e629d9dcb1491ef820c71cb8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>logs</category>
      </categories>
      <tags>
        <tag>logs</tag>
        <tag>flag</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown中的LaTeX格式</title>
    <url>/2020/04/07/a/</url>
    <content><![CDATA[<h3 id="Markdown中的LaTeX格式"><a href="#Markdown中的LaTeX格式" class="headerlink" title="Markdown中的LaTeX格式"></a>Markdown中的LaTeX格式</h3><p>大部分情况下，我对于latex的数学公式都是内嵌于Markdown文本编辑器中的，分为两种形式</p>
<ol>
<li>行内公式排版：</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>c = \sqrt&#123;a^&#123;<span class="number">2</span>&#125;+b_&#123;<span class="number">0</span>&#125;^&#123;<span class="number">2</span>&#125;+e^&#123;x&#125;&#125; $</span><br></pre></td></tr></table></figure>

<p>$ c = \sqrt{a^{2}+b_{0}^{2}+e^{x}} $</p>
<ol>
<li>块公式排版： <span id="more"></span></li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span> c = \sqrt&#123;a^&#123;<span class="number">2</span>&#125;+b_&#123;<span class="number">0</span>&#125;^&#123;<span class="number">2</span>&#125; +e^&#123;x&#125;&#125; <span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p>$$ c = \sqrt{a^{2}+b_{0}^{2} +e^{x}} $$</p>
<h3 id="LaTex的数学公式基本规则"><a href="#LaTex的数学公式基本规则" class="headerlink" title="LaTex的数学公式基本规则"></a>LaTex的数学公式基本规则</h3><ol>
<li>转义</li>
</ol>
<blockquote>
<p>以下几个字符: # $ % &amp; ~ _ ^ \ { }有特殊意义，需要表示这些字符时，需要转义，即在每个字符前加上\（转义字符的具体含义下面会解释）</p>
<p><img src="/2020/04/07/a/9368615-bcfa93bf4f7c82e8.webp" alt="img"></p>
<p>image.png</p>
<p>不知为何简书不支持~的表示，需要时写作\sim</p>
</blockquote>
<blockquote>
<p>\boxed命令给公式加一个方框。\fbox具有类似功能<br> \mathbf将字体加粗<br> \boldsymbol将字体斜体且加粗</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$E</span> = mc^<span class="number">2</span> <span class="variable">$</span></span><br><span class="line"><span class="variable"></span><span class="variable">$ </span>\boxed&#123;E=mc^<span class="number">2</span>&#125; <span class="variable">$</span></span><br><span class="line"><span class="variable"></span><span class="variable">$\</span>fbox&#123;E=mc^<span class="number">2</span>&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span><span class="variable">$\</span>mathbf&#123;E = mc^<span class="number">2</span>&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span><span class="variable">$\</span>boldsymbol&#123;E = mc^<span class="number">2</span>&#125;$</span><br></pre></td></tr></table></figure>

<p>$E = mc^2 $<br>$ \boxed{E=mc^2} $<br>$\fbox{E=mc^2}$<br>$\mathbf{E = mc^2}$<br>$\boldsymbol{E = mc^2}$</p>
<ol>
<li>希腊字母与特殊字符</li>
</ol>
<p><img src="/2020/04/07/a/9368615-49868ef8c5950cf3.webp" alt="img"></p>
<p>image.png</p>
<p><img src="/2020/04/07/a/9368615-3d2020da2a5cfd58.webp" alt="img"></p>
<p>image.png</p>
<p><img src="/2020/04/07/a/9368615-7fcbdefb396ba056.webp" alt="img"></p>
<p>image.png</p>
<ol>
<li>上下标及常用符号</li>
</ol>
<blockquote>
<p>用^来表示上标<br> 用_来表示下标<br> 根号用\sqrt表示</p>
</blockquote>
<p>注意：这些有特殊含义的表示中（不限于这三种内容），如果超过一个字符或符号，需要用{}括起来。</p>
<p>对角标的使用中，如果角标位置看起来不明显时，可以强制改变角标大小或层次，如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$y_N</span>, y_&#123;_N&#125;,$</span><br></pre></td></tr></table></figure>

<p>显示为：<br> <img src="https://math.jianshu.com/math?formula=y_N%2C%20y_%7B_N%7D%2C" alt="y_N, y_{_N},"></p>
<p>第一种输出为正常输出，但输出效果不明显；第二种是将一级角标改为二级角标，字体也自动变为二级角标字体</p>
<p>当需要在左右两边都有上下标，可以用 \sideset 命令</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span> \sideset&#123;^<span class="number">1_2</span>&#125;&#123;^<span class="number">3_4</span>&#125;\bigotimes <span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p>$$ \sideset{^1_2}{^3_4}\bigotimes $$</p>
<p>\sqrt[开方次数，默认为2]{开方公式}， 例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$$ x_&#123;k&#125;^<span class="number">2</span>\quad \sqrt&#123;x&#125;\quad \sqrt[<span class="number">3</span>]&#123;x+y&#125; $$</span><br></pre></td></tr></table></figure>

<p>$$ x_{k}^2\quad \sqrt{x}\quad \sqrt[3]{x+y} $$</p>
<blockquote>
<p>公式中插入文本\text{}或\mbox{}，建议使用前者，它对于latex内置的\mbox{}的优势在于它可以根据当前位置自动调整文本样式（尤其是大小），而\mbox采用统一的正文样式。这一点在你的文本被用作上下标的时候非常重要。</p>
</blockquote>
<blockquote>
<p>公式中插入空格，间隔效果如下表：</p>
</blockquote>
<p><img src="/2020/04/07/a/9368615-2051eb8ef8627902.webp" alt="img"></p>
<p>image.png</p>
<blockquote>
<p>若需要显示更大或更小的字符，在符号前插入 \large 或 \small 命令</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$A</span>\large  A  \small A$</span><br></pre></td></tr></table></figure>

<p>$A\large  A  \small A$</p>
<blockquote>
<p>省略号\dots, \cdots,\vdots \ddots表示，\cdot常表示点乘，\vots是竖直方向的，\ddots是斜线方向的</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span> x_1, x_2, \dots, x_n\quad <span class="number">1</span>,<span class="number">2</span>,\cdots,n\quad \vdots\quad \ddots <span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p>$$ x_1, x_2, \dots, x_n\quad 1,2,\cdots,n\quad \vdots\quad \ddots $$</p>
<blockquote>
<p>关系符如下表所示</p>
</blockquote>
<p><img src="/2020/04/07/a/9368615-0fa226838bae9ea4.webp" alt="img"></p>
<p>image.png</p>
<blockquote>
<p>其他常用符号</p>
</blockquote>
<p><img src="/2020/04/07/a/9368615-2ac87b614fed0f3f.webp" alt="img"></p>
<p>image.png</p>
<ol>
<li>分数与组合数</li>
</ol>
<blockquote>
<p>分数用\frac{分子}{分母}表示，\cfrac用于连分数表示(这样相较于\frac不会产生字体自动缩小的问题)</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$x</span> = a _ <span class="number">0</span> + \cfrac &#123;<span class="number">1</span>&#125; &#123;a _ <span class="number">1</span></span><br><span class="line">          + \cfrac &#123;<span class="number">1</span>&#125; &#123;a _ <span class="number">2</span></span><br><span class="line">          + \cfrac &#123;<span class="number">1</span>&#125; &#123;a _ <span class="number">3</span> + \cfrac &#123;<span class="number">1</span>&#125; &#123;a _ <span class="number">4</span>&#125; &#125; &#125; &#125; </span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>$x = a _ 0 + \cfrac {1} {a _ 1<br>          + \cfrac {1} {a _ 2<br>                    + \cfrac {1} {a _ 3 + \cfrac {1} {a _ 4} } } }<br>$</p>
<p>字号工具环境设置：<br> \dfrac命令把字号设置为独立公式中的大小；<br> \tfrac则把字号设置为行间公式中的大小。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\frac&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125; \dfrac&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125; <span class="variable">$ </span></span><br></pre></td></tr></table></figure>

<p>$ \frac{1}{2} \dfrac{1}{2} $ </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span> \frac&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125; \tfrac&#123;<span class="number">1</span>&#125;&#123;<span class="number">2</span>&#125; <span class="variable">$$</span> </span><br></pre></td></tr></table></figure>

<p>$$ \frac{1}{2} \tfrac{1}{2} $$</p>
<blockquote>
<p>组合数用法与分数类似，在命令前加d和t也能达到分数字号设置同样的功能</p>
</blockquote>
<p>\binom{233}{x^2} </p>
<p>$$\binom{233}{x^2}$$</p>
<ol>
<li>运算符</li>
</ol>
<blockquote>
<p>基本加减乘除等于 +-*/= 可以直接输入<br> 特殊运算则用以下特殊命令\pm; \times; \div; \cdot; \cap; \cup; \geq; \leq; \neq; \approx; \equiv<br>$$\pm; \times; \div; \cdot; \cap; \cup; \geq; \leq; \neq; \approx; \equiv$$<br> 在此之上，如果想要使用堆积符号有以下三种形式</p>
</blockquote>
<ul>
<li>\stackrel{上位符号}{基位符号} 基位符号大，上位符号小</li>
<li>{上位公式\atop 下位公式} 上下符号一样大</li>
<li>{上位公式\choose 下位公式} 上下符号一样大；上下符号被包括在圆弧内</li>
</ul>
<p>$$\stackrel{上位符号}{基位符号} 基位符号大，上位符号小{上位公式\atop 下位公式} 上下符号一样大{上位公式\choose 下位公式} 上下符号一样大；上下符号被包括在圆弧内$$</p>
<blockquote>
<p>和、积、极限、积分等运算符用\sum, \prod, \lim, \int,这些公式在行内公式被压缩，以适应行高，可以通过\limits和\nolimits命令其是否压缩。<br>$$  和、积、极限、积分等运算符用\sum, \prod, \lim, \int,这些公式在行内公式被压缩，以适应行高，可以通过 和命令其是否压缩。$$</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\sum_&#123;i=<span class="number">1</span>&#125;^n i <span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">$ </span>\prod_&#123;i=<span class="number">1</span>&#125;^n i<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">$\</span>lim_&#123;x\to0&#125;x^<span class="number">2</span> <span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">$\</span>int_&#123;a&#125;^&#123;b&#125;x^<span class="number">2</span> dx <span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">$\</span>sum\nolimits_&#123;i=<span class="number">1</span>&#125;^n i \quad\prod\nolimits_&#123;i=<span class="number">1</span>&#125;^n i</span><br><span class="line">\quad</span><br><span class="line">\lim\nolimits_&#123;x\to0&#125;x^<span class="number">2</span> \quad\int\limits_&#123;a&#125;^&#123;b&#125;x^<span class="number">2</span> dx </span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>$ \sum_{i=1}^n i $</p>
<p>$ \prod_{i=1}^n i$</p>
<p>$\lim_{x\to0}x^2 $</p>
<p>$\int_{a}^{b}x^2 dx $</p>
<p>$\sum\nolimits_{i=1}^n i \quad\prod\nolimits_{i=1}^n i<br>\quad<br>\lim\nolimits_{x\to0}x^2 \quad\int\limits_{a}^{b}x^2 dx<br>$</p>
<ol>
<li>积分及箭头</li>
</ol>
<blockquote>
<p>积分符号使用如下形式：\int、\iint、\iiint、\iiiint、\idotsint</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$$ \<span class="keyword">int</span> \<span class="keyword">int</span> \quad \<span class="keyword">int</span> \<span class="keyword">int</span> \<span class="keyword">int</span> \quad </span><br><span class="line"> \<span class="keyword">int</span> \<span class="keyword">int</span> \<span class="keyword">int</span> \<span class="keyword">int</span> \quad \<span class="keyword">int</span> \dots（表示...） \<span class="keyword">int</span> $$</span><br><span class="line"></span><br><span class="line">$$ \iint \quad \iiint \quad \iiiint \quad \idotsint $$</span><br></pre></td></tr></table></figure>

<p>$$ \int \int \quad \int \int \int \quad<br> \int \int \int \int \quad \int \dots（表示…） \int $$</p>
<p>$$ \iint \quad \iiint \quad \iiiint \quad \idotsint $$</p>
<blockquote>
<p>箭头的种类过于繁多，这里不就一一列举了，但是箭头符号的名字很有规律，一般命名规则为方向+箭头种类：</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\leftarrow 或 \gets</td>
<td align="center"><img src="https://math.jianshu.com/math?formula=%5Cgets" alt="\gets"></td>
</tr>
<tr>
<td align="center">\rightarrow 或 \to</td>
<td align="center"><img src="https://math.jianshu.com/math?formula=%5C%2C%5Cto" alt="\,\to"></td>
</tr>
<tr>
<td align="center">\uparrow</td>
<td align="center"><img src="https://math.jianshu.com/math?formula=%5Cuparrow" alt="\uparrow"></td>
</tr>
<tr>
<td align="center">\downarrow</td>
<td align="center"><img src="https://math.jianshu.com/math?formula=%5Cdownarrow" alt="\downarrow"></td>
</tr>
</tbody></table>
<blockquote>
<blockquote>
<p>四个基本方向上下左右不多说，斜着的箭头的方向部分为\ne \se \nw \sw，为东北、东南、西北、西南简写<br> 示例：\nearrow <img src="https://math.jianshu.com/math?formula=%5Cnearrow" alt="\nearrow"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>还有左右、上下两个方向的箭头：<br> \leftrightarrow   <img src="https://math.jianshu.com/math?formula=%5Cleftrightarrow" alt="\leftrightarrow"><br> \updownarrow  <img src="https://math.jianshu.com/math?formula=%5Cupdownarrow" alt="\updownarrow"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>上面的箭头只有一根线，可以通过大写第一个字母变成双线：<br> \Leftrightarrow  <img src="https://math.jianshu.com/math?formula=%5CLeftrightarrow" alt="\Leftrightarrow"><br> \Uparrow  <img src="https://math.jianshu.com/math?formula=%5CUparrow" alt="\Uparrow"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在前面加上long可以把箭头变长，仅适用于左右箭头，注意双线箭头大写字母的位置：<br> \longleftarrow  <img src="https://math.jianshu.com/math?formula=%5Clongleftarrow" alt="\longleftarrow"><br> \longleftrightarrow  <img src="https://math.jianshu.com/math?formula=%5Clongleftrightarrow" alt="\longleftrightarrow"><br> \Longleftrightarrow 或 \iff <img src="https://math.jianshu.com/math?formula=%5Ciff" alt="\iff"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>还有只有一边的箭头，名字为harpoon+up/down，表示那一边的位置，这种箭头似乎不支持上面的buff buffbuff，但拥有左右双向箭头：<br> \leftharpoonup  <img src="https://math.jianshu.com/math?formula=%5Cleftharpoonup" alt="\leftharpoonup"><br> \rightleftharpoons  <img src="https://math.jianshu.com/math?formula=%5Crightleftharpoons" alt="\rightleftharpoons"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>意图在箭头上下位置添加说明时，有以下两种方式</p>
</blockquote>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.\xleftarrow和\xrightarrow可根据内容自动调整（上下都可以添加内容）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.\overset&#123;&#125;&#123;\rightarrow&#125;则是长度固定的箭头，适合单个字符，内容在上</span><br><span class="line">  \overrightarrow&#123;&#125;则是长度变化的箭头，适合多个字符，箭头在上</span><br><span class="line">注意<span class="number">2</span>中的都只适用于只在箭头上或下添加内容，改变位置将over改为under</span><br><span class="line"></span><br><span class="line"><span class="variable">$\</span>xleftarrow[x+y+z]&#123;x+y+z+<span class="number">1</span>&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">$\</span>xrightarrow[x+y+z+<span class="number">1</span>]&#123;x+y+z&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">$\</span>overset&#123;x+y+z&#125;&#123;\rightarrow&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"> <span class="variable">$\</span>underrightarrow&#123;x+y+z&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"><span class="variable">$\</span>underset&#123;x+y+z&#125;&#123;\leftarrow&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span></span><br><span class="line"> <span class="variable">$\</span>overleftarrow&#123;x+y+z&#125;$</span><br></pre></td></tr></table></figure>

<p>$\xleftarrow[x+y+z]{x+y+z+1}$</p>
<p>$\xrightarrow[x+y+z+1]{x+y+z}$</p>
<p>$\overset{x+y+z}{\rightarrow}$</p>
<p> $\underrightarrow{x+y+z}$</p>
<p>$\underset{x+y+z}{\leftarrow}$</p>
<p> $\overleftarrow{x+y+z}$</p>
<ol>
<li>注音和标注</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">字母上方横线\overline&#123;&#125;, \bar&#123;&#125;</span><br><span class="line"><span class="variable">$ </span>\bar&#123;x&#125; <span class="variable">$ </span>单个字符 </span><br><span class="line"><span class="variable">$\</span>overline&#123;xyz&#125;<span class="variable">$ </span>多个字符</span><br></pre></td></tr></table></figure>

<p>$ \bar{x} $ 单个字符<br>$\overline{xyz}$ 多个字符</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">字母下方横线\underline&#123;&#125;</span><br><span class="line"><span class="variable">$\</span>underline&#123;xyz&#125;$</span><br></pre></td></tr></table></figure>

<p>$\underline{xyz}$</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号</span><br><span class="line"><span class="variable">$\</span>overbrace&#123;a\dots a&#125;^&#123;n个&#125;<span class="variable">$ </span></span><br><span class="line"><span class="variable">$\</span>underbrace&#123;a\dots a&#125;_&#123;n个&#125;<span class="variable">$ </span></span><br></pre></td></tr></table></figure>

<p>$\overbrace{a\dots a}^{n个}$<br>$\underbrace{a\dots a}_{n个}$</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">向量表示有两种，单个字母用\vec&#123;x&#125;，多个字母用\overrightarrow 和\overleftarrow</span><br><span class="line"><span class="variable">$ </span>\vec&#123;x&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span><span class="variable">$\</span>overrightarrow&#123;AB&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span><span class="variable">$\</span>overleftarrow&#123;ABC&#125;$</span><br></pre></td></tr></table></figure>

<p>$ \vec{x}$<br>$\overrightarrow{AB}$<br>$\overleftarrow{ABC}$</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">字母上方波浪线\tilde&#123;&#125;, \widetilde&#123;&#125;</span><br><span class="line"><span class="variable">$ </span>\tilde&#123;x&#125;<span class="variable">$</span></span><br><span class="line"><span class="variable"></span><span class="variable">$ </span>\widetilde&#123;xyz&#125;$</span><br></pre></td></tr></table></figure>

<p>$ \tilde{x}$<br>$ \widetilde{xyz}$</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\dot&#123;x&#125;$</span><br></pre></td></tr></table></figure>

<p>$ \dot{x}$</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\hat&#123;x&#125;<span class="variable">$ </span></span><br><span class="line"><span class="variable">$ </span>\widehat&#123;xyz&#125;<span class="variable">$ </span></span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Chat%7Bx%7D" alt="\hat{x}"><br> <img src="https://math.jianshu.com/math?formula=%5Cwidehat%7Bxyz%7D" alt="\widehat{xyz}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\acute&#123;x&#125;$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cacute%7Bx%7D" alt="\acute{x}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\grave&#123;x&#125; $</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cgrave%7Bx%7D" alt="\grave{x}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\mathring&#123;x&#125;$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cmathring%7Bx%7D" alt="\mathring{x}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\ddot&#123;x&#125;$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cddot%7Bx%7D" alt="\ddot{x}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\check&#123;x&#125; $</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Ccheck%7Bx%7D" alt="\check{x}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\breve&#123;x&#125;$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbreve%7Bx%7D" alt="\breve{x}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\dddot&#123;x&#125; $</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cdddot%7Bx%7D" alt="\dddot{x}"></p>
<ol>
<li>编号</li>
</ol>
<blockquote>
<p>插入编号：<br> 使用\tag指令指定公式的具体编号，并使用\label指令埋下锚点。如y=x^2 \tag{1.5a}</p>
</blockquote>
<p><img src="https://math.jianshu.com/math?formula=y%3Dx%5E2%20%5Ctag%7B1.5a%7D" alt="y=x^2 \tag{1.5a}"></p>
<blockquote>
<p>引用编号：<br> 在markdown中不支持编号的锚点设置 \label与\ref 的使用</p>
</blockquote>
<ol>
<li>括号及嵌套</li>
</ol>
<p>常用括号有以下几种</p>
<p><img src="/2020/04/07/a/9368615-9db47069b8031901.webp" alt="img"></p>
<p>image.png</p>
<blockquote>
<p>括号的大小调整</p>
</blockquote>
<p>对括号的大小，手动模式可以用\big, \Big, \bigg, \Bigg等一系列命令(从小到大，默认是最小)放在上述括号前面调整大小。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span>Bigg( \bigg( \Big( \big((x) \big) \Big) \bigg) \Bigg)<span class="variable">$</span></span><br><span class="line"><span class="variable"></span><span class="variable">$\</span>Bigg\&#123; \bigg\&#123; \Big\&#123; \big\&#123;\&#123;x\&#125; \big\&#125; \Big\&#125; \bigg\&#125; \Bigg\&#125;$</span><br></pre></td></tr></table></figure>


<p>自动模式下要用 \left 和 \right 命令后面跟上所需分隔符，用来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} 等分隔符</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span> f(x,y,z) = 3y^2z \left( <span class="number">3</span>+\frac&#123;7x+<span class="number">5</span>&#125;&#123;<span class="number">1</span>+y^<span class="number">2</span>&#125; \right) <span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=f(x%2Cy%2Cz)%20%3D%203y%5E2z%20%5Cleft(%203%2B%5Cfrac%7B7x%2B5%7D%7B1%2By%5E2%7D%20%5Cright)" alt="f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">f\left(</span><br><span class="line">   \left[ </span><br><span class="line">     \frac&#123;</span><br><span class="line">       <span class="number">1</span><span class="operator">+</span>\left\&#123;x,y\right\&#125;</span><br><span class="line">     &#125;&#123;</span><br><span class="line">       \left(</span><br><span class="line">          \frac&#123;x&#125;&#123;y&#125;<span class="operator">+</span>\frac&#123;y&#125;&#123;x&#125;</span><br><span class="line">       \right)</span><br><span class="line">       \left(u<span class="operator">+</span><span class="number">1</span>\right)</span><br><span class="line">     &#125;<span class="operator">+</span>a</span><br><span class="line">   \right]<span class="operator">^</span>&#123;<span class="number">3</span><span class="operator">/</span><span class="number">2</span>&#125;</span><br><span class="line">\right)</span><br><span class="line">\tag&#123;<span class="number">1.2</span>&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>f\left(<br>   \left[<br>     \frac{<br>       1+\left{x,y\right}<br>     }{<br>       \left(<br>          \frac{x}{y}+\frac{y}{x}<br>       \right)<br>       \left(u+1\right)<br>     }+a<br>   \right]^{3/2}<br>\right)<br>\tag{1.2}<br>$$</p>
<p> 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \left. 或 \right. 来放一个”影子”括号：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;aligned&#125;</span><br><span class="line">a=&amp;\left(<span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+  \cdots \right. \\</span><br><span class="line">&amp; \cdots+ \left. \infty-<span class="number">2</span>+\infty-<span class="number">1</span>+\infty\right)</span><br><span class="line">\<span class="keyword">end</span>&#123;aligned&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Baligned%7D%20a%3D%26%5Cleft(1%2B2%2B3%2B%20%5Ccdots%20%5Cright.%20%5C%5C%20%26%20%5Ccdots%2B%20%5Cleft.%20%5Cinfty-2%2B%5Cinfty-1%2B%5Cinfty%5Cright)%20%5Cend%7Baligned%7D" alt="\begin{aligned} a=&amp;\left(1+2+3+ \cdots \right. \\ &amp; \cdots+ \left. \infty-2+\infty-1+\infty\right) \end{aligned}"></p>
<p>而如果分隔符不在左右而在中间，为了能够格式对齐，要用\middle加分隔符表示</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="variable">$P</span><span class="operator">=</span>\left(<span class="type">A</span><span class="operator">=</span><span class="number">2</span>\middle<span class="operator">|</span>\frac&#123;<span class="type">A</span><span class="operator">^</span><span class="number">2</span>&#125;&#123;<span class="type">B</span>&#125;<span class="operator">&gt;</span><span class="number">4</span>\right)$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=P%3D%5Cleft(A%3D2%5Cmiddle%7C%5Cfrac%7BA%5E2%7D%7BB%7D%3E4%5Cright)" alt="P=\left(A=2\middle|\frac{A^2}{B}&gt;4\right)"></p>
<ol>
<li>颜色设置</li>
</ol>
<p><img src="/2020/04/07/a/9368615-2fbc10b9e7ecae71.webp" alt="img"></p>
<p>image.png</p>
<ol>
<li>原文照排</li>
</ol>
<blockquote>
<p>LATEX 提供了 \verb 命令(一般用于在正文中插入较短的命令)来实现</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span>verb<span class="params">|x^2|</span>\quad x^<span class="number">2</span>$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cverb%7Cx%5E2%7C%5Cquad%20x%5E2" alt="\verb|x^2|\quad x^2"></p>
<ol>
<li>删除线</li>
</ol>
<blockquote>
<p>在公式内使用 \require{cancel} 来允许 片段删除线 的显示。<br> 声明片段删除线后，使用 \cancel{字符}、\bcancel{字符}、\xcancel{字符} 和 \cancelto{字符} 来实现各种片段删除线效果。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">\<span class="keyword">require</span>&#123;cancel&#125;\<span class="keyword">begin</span>&#123;array&#125;&#123;rl&#125;</span><br><span class="line">\verb<span class="params">|y+\cancel&#123;x&#125;|</span> &amp; y+\cancel&#123;x&#125;\\</span><br><span class="line">\verb<span class="params">|\cancel&#123;y+x&#125;|</span> &amp; \cancel&#123;y+x&#125;\\</span><br><span class="line">\verb<span class="params">|y+\bcancel&#123;x&#125;|</span> &amp; y+\bcancel&#123;x&#125;\\</span><br><span class="line">\verb<span class="params">|y+\xcancel&#123;x&#125;|</span> &amp; y+\xcancel&#123;x&#125;\\</span><br><span class="line">\verb<span class="params">|y+\cancelto&#123;0&#125;&#123;x&#125;|</span> &amp; y+\cancelto&#123;<span class="number">0</span>&#125;&#123;x&#125;\\</span><br><span class="line">\verb+\frac&#123;<span class="number">1</span>\cancel9&#125;&#123;\cancel95&#125; = \frac15+&amp; \frac&#123;<span class="number">1</span>\cancel9&#125;&#123;\cancel95&#125; = \frac15 \\</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Crequire%7Bcancel%7D%5Cbegin%7Barray%7D%7Brl%7D%20%5Cverb%7Cy%2B%5Ccancel%7Bx%7D%7C%20%26%20y%2B%5Ccancel%7Bx%7D%5C%5C%20%5Cverb%7C%5Ccancel%7By%2Bx%7D%7C%20%26%20%5Ccancel%7By%2Bx%7D%5C%5C%20%5Cverb%7Cy%2B%5Cbcancel%7Bx%7D%7C%20%26%20y%2B%5Cbcancel%7Bx%7D%5C%5C%20%5Cverb%7Cy%2B%5Cxcancel%7Bx%7D%7C%20%26%20y%2B%5Cxcancel%7Bx%7D%5C%5C%20%5Cverb%7Cy%2B%5Ccancelto%7B0%7D%7Bx%7D%7C%20%26%20y%2B%5Ccancelto%7B0%7D%7Bx%7D%5C%5C%20%5Cverb%2B%5Cfrac%7B1%5Ccancel9%7D%7B%5Ccancel95%7D%20%3D%20%5Cfrac15%2B%26%20%5Cfrac%7B1%5Ccancel9%7D%7B%5Ccancel95%7D%20%3D%20%5Cfrac15%20%5C%5C%20%5Cend%7Barray%7D" alt="\require{cancel}\begin{array}{rl} \verb|y+\cancel{x}| &amp; y+\cancel{x}\\ \verb|\cancel{y+x}| &amp; \cancel{y+x}\\ \verb|y+\bcancel{x}| &amp; y+\bcancel{x}\\ \verb|y+\xcancel{x}| &amp; y+\xcancel{x}\\ \verb|y+\cancelto{0}{x}| &amp; y+\cancelto{0}{x}\\ \verb+\frac{1\cancel9}{\cancel95} = \frac15+&amp; \frac{1\cancel9}{\cancel95} = \frac15 \\ \end{array}"></p>
<h3 id="数学公式高级规则"><a href="#数学公式高级规则" class="headerlink" title="数学公式高级规则"></a>数学公式高级规则</h3><ol>
<li>公式环境与对齐<br> 在下文的公式环境中，形如 equation<em>中， 带</em>号的不将公式标号排出来, 而不带*的自动给每行式子编排标号<br> latex的公式环境有很多种，这里只列举我常用的，更多请查阅latex官方说明</li>
</ol>
<blockquote>
<p>单行公式环境 equation<br> \begin{equation}<br> …<br> \end{equation}<br> 是最一般的公式环境，表示一个公式，默认情况下之表示一个单行的公式，但是它的功能可以通过内嵌各种其他环境进行扩展，不可以使用\与&amp;功能。它可以内嵌的一些关于对齐的环境将在后面介绍。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span><span class="keyword">begin</span>&#123;equation&#125;</span><br><span class="line">f(x)=3x^&#123;<span class="number">2</span>&#125;+<span class="number">6</span>(x-<span class="number">2</span>)-<span class="number">1</span></span><br><span class="line">\<span class="keyword">end</span>&#123;equation&#125;$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%20f(x)%3D3x%5E%7B2%7D%2B6(x-2)-1%20%5Cend%7Bequation%7D" alt="\begin{equation} f(x)=3x^{2}+6(x-2)-1 \end{equation}"></p>
<blockquote>
<p>align（多个公式）<br> 这是最基本的对齐环境，其他多公式环境都不同程度地依赖它。它采用“&amp;”分割各个对齐单元，使用“\”换行。它的每行是一个公式，都会独立编号。在排版过程中，它将&amp;分出来的列又分成组，组间特定方式排版，具体方式在flalign环境中讨论。<br> 通常情况下在公式中可以通过\tag设置标号，\label设置引用名称，但好像简书的markdown不支持\label，所以编号的意义就无所谓了。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span><span class="keyword">begin</span>&#123;align&#125;</span><br><span class="line"> f(x) &amp;= (x+a)(x+b) \\</span><br><span class="line"> &amp;= x^<span class="number">2</span> + (a+b)x + ab \tag&#123;<span class="number">1.1</span>&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;align&#125;$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Balign%7D%20f(x)%20%26%3D%20(x%2Ba)(x%2Bb)%20%5C%5C%20%26%3D%20x%5E2%20%2B%20(a%2Bb)x%20%2B%20ab%20%5Ctag%7B1.1%7D%20%5Cend%7Balign%7D" alt="\begin{align} f(x) &amp;= (x+a)(x+b) \\ &amp;= x^2 + (a+b)x + ab \tag{1.1} \end{align}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span><span class="keyword">begin</span>&#123;align&#125;</span><br><span class="line">A_&#123;<span class="number">1</span>&#125;&amp;=B_&#123;<span class="number">1</span>&#125;B_&#123;<span class="number">2</span>&#125; &amp; A_&#123;<span class="number">3</span>&#125; &amp; = B_&#123;<span class="number">1</span>&#125;\\</span><br><span class="line">A_&#123;<span class="number">2</span>&#125;&amp;=B_&#123;<span class="number">3</span>&#125;&amp; A_&#123;<span class="number">3</span>&#125;A_&#123;<span class="number">4</span>&#125; &amp; = B_&#123;<span class="number">4</span>&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;align&#125;$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Balign%7D%20A_%7B1%7D%26%3DB_%7B1%7DB_%7B2%7D%20%26%20A_%7B3%7D%20%26%20%3D%20B_%7B1%7D%5C%5C%20A_%7B2%7D%26%3DB_%7B3%7D%26%20A_%7B3%7DA_%7B4%7D%20%26%20%3D%20B_%7B4%7D%20%5Cend%7Balign%7D" alt="\begin{align} A_{1}&amp;=B_{1}B_{2} &amp; A_{3} &amp; = B_{1}\\ A_{2}&amp;=B_{3}&amp; A_{3}A_{4} &amp; = B_{4} \end{align}"></p>
<blockquote>
<p>公式组环境flalign与align的功能基本相同，唯一区别是列对之间的距离为弹性宽度，以使公式组两端对齐。然而简书不支持。。。</p>
</blockquote>
<blockquote>
<p>gather环境<br> 它是最简单的多行公式环境，自己不提供任何对齐。其中的各行公式按照全局方式分别对齐。<br> 在设置了全局左对齐之后，因为不存在内部各个公式之间对排版的干扰，这种环境非常适合写数学推导或者证明。而默认情况下，是居中对齐。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">\begin&#123;gather*&#125;</span><br><span class="line">E(X)=\<span class="keyword">lambda</span>    \qquad  D(X)=\<span class="keyword">lambda</span>    \\</span><br><span class="line">E(\bar&#123;X&#125;)=\<span class="keyword">lambda</span>  \\</span><br><span class="line">D(\bar&#123;X&#125;)=\frac&#123;\<span class="keyword">lambda</span>&#125;&#123;n&#125;    \\</span><br><span class="line">E(S^<span class="number">2</span>)=\frac&#123;n-<span class="number">1</span>&#125;&#123;n&#125;\<span class="keyword">lambda</span> \\</span><br><span class="line">\end&#123;gather*&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bgather%7D%20%5Cbecause%20E(X)%3D%5Clambda%20%5Cqquad%20D(X)%3D%5Clambda%20%5C%5C%20%5Ctherefore%20E(%5Cbar%7BX%7D)%3D%5Clambda%20%5C%5C%20D(%5Cbar%7BX%7D)%3D%5Cfrac%7B%5Clambda%7D%7Bn%7D%20%5C%5C%20E(S%5E2)%3D%5Cfrac%7Bn-1%7D%7Bn%7D%5Clambda%20%5C%5C%20%5Cend%7Bgather%7D" alt="\begin{gather} \because E(X)=\lambda \qquad D(X)=\lambda \\ \therefore E(\bar{X})=\lambda \\ D(\bar{X})=\frac{\lambda}{n} \\ E(S^2)=\frac{n-1}{n}\lambda \\ \end{gather}"></p>
<blockquote>
<p>与上文中公式组类似的，长公式也有两种multline和split两种环境，分别对应不对齐与对齐。</p>
</blockquote>
<p>multline不支持“&amp;”分列。其首行左对齐，末行右对齐，其余各行分别按照全局方式对齐。<br> split也用于排版多行公式，但它与多行公式环境multline的区别主要是以下三点：</p>
<ul>
<li>用&amp;作为分列符，但至多两列；左列右对齐，右列左对齐，形成一个列对，可使多行公式关于某个符号垂直对齐。因此用它排版的多行公式更为整齐美观。如果不用分列符&amp;,所有公式行为一列，且全都与首行公式的右端对齐。</li>
<li>必须置于除multline环境之外的其它公式环境中。</li>
<li>自身并不生成公式序号，而是由外在公式环境提供，序号垂直居中。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span>\<span class="keyword">begin</span>&#123;multline&#125;</span><br><span class="line">x=a+b+c+&#123;&#125; \\</span><br><span class="line">d+e+f+g</span><br><span class="line">\<span class="keyword">end</span>&#123;multline&#125;<span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmultline%7D%20x%3Da%2Bb%2Bc%2B%7B%7D%20%5C%5C%20d%2Be%2Bf%2Bg%20%5Cend%7Bmultline%7D" alt="\begin{multline} x=a+b+c+{} \\ d+e+f+g \end{multline}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span>\<span class="keyword">begin</span>&#123;split&#125;</span><br><span class="line">x=&amp;a+b+c+&#123;&#125; \\</span><br><span class="line">&amp;d+e+f+g</span><br><span class="line">\<span class="keyword">end</span>&#123;split&#125;<span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bsplit%7D%20x%3D%26a%2Bb%2Bc%2B%7B%7D%20%5C%5C%20%26d%2Be%2Bf%2Bg%20%5Cend%7Bsplit%7D" alt="\begin{split} x=&amp;a+b+c+{} \\ &amp;d+e+f+g \end{split}"></p>
<blockquote>
<p>/gathered，/aligned。以上几种方程组环境，无论每个公式多小，都会占满一行。而/gathered，/aligned环境，则只占据公式的实际宽度，整体作为一个特大的符号与其他符号一同处理。<br> 这个结构还可以添加位置参数，以决定与其他符号的竖直对齐方式(b,t)。而且这种环境不再具有自动编号功能。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span><span class="keyword">begin</span>&#123;equation&#125;</span><br><span class="line"> \left.\<span class="keyword">begin</span>&#123;aligned&#125;</span><br><span class="line">        B<span class="string">&#x27;&amp;=-\partial \times E,\\</span></span><br><span class="line"><span class="string">        E&#x27;</span>&amp;=\partial \times B - <span class="number">4</span>\pi j,</span><br><span class="line">       \<span class="keyword">end</span>&#123;aligned&#125;</span><br><span class="line"> \right\&#125;</span><br><span class="line"> \qquad \text&#123;Maxwell<span class="string">&#x27;s equations&#125;</span></span><br><span class="line"><span class="string">\end&#123;equation&#125;</span></span><br><span class="line"><span class="string">$</span></span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%20%5Cleft.%5Cbegin%7Baligned%7D%20B'%26%3D-%5Cpartial%20%5Ctimes%20E%2C%5C%5C%20E'%26%3D%5Cpartial%20%5Ctimes%20B%20-%204%5Cpi%20j%2C%20%5Cend%7Baligned%7D%20%5Cright%5C%7D%20%5Cqquad%20%5Ctext%7BMaxwell's%20equations%7D%20%5Cend%7Bequation%7D" alt="\begin{equation} \left.\begin{aligned} B&#39;&amp;=-\partial \times E,\\ E&#39;&amp;=\partial \times B - 4\pi j, \end{aligned} \right\} \qquad \text{Maxwell&#39;s equations} \end{equation}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span><span class="keyword">begin</span>&#123;equation&#125;</span><br><span class="line">\left.</span><br><span class="line">\<span class="keyword">begin</span>&#123;aligned&#125;</span><br><span class="line">x+y &amp;&gt; <span class="number">5</span> \\</span><br><span class="line">y-y &amp;&gt; <span class="number">11</span></span><br><span class="line">\<span class="keyword">end</span>&#123;aligned&#125;</span><br><span class="line">\ \right\&#125;\Rightarrow x^<span class="number">2</span> - y^<span class="number">2</span> &gt; <span class="number">55</span></span><br><span class="line">\<span class="keyword">end</span>&#123;equation&#125;$</span><br></pre></td></tr></table></figure>

<p>$\begin{equation}<br>\left.<br>\begin{aligned}<br>x+y &amp;&gt; 5 \<br>y-y &amp;&gt; 11<br>\end{aligned}<br>\ \right}\Rightarrow x^2 - y^2 &gt; 55<br>\end{equation}$</p>
<blockquote>
<p>cases环境常用于分段函数，上面的环境虽然支持分段函数形式的表达，但比较繁琐</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">L(Y,f(X))=</span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line"><span class="number">1</span>,\quad &amp;Y\neq f(X)\\</span><br><span class="line"><span class="number">0</span>,\quad &amp;Y=f(X)</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>L(Y,f(X))=<br>\begin{cases}<br>1,\quad &amp;Y\neq f(X)\<br>0,\quad &amp;Y=f(X)<br>\end{cases}<br>$$</p>
<blockquote>
<p>阵列环境 array可以帮助我们输入一个数组或表格<br> 通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。数组和表格均以 begin{array} 开头，并在其后定义列数及每一列的文本对齐属性，字母c l r 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 | ，若要插入水平分割线，在下一行输入前插入 \hline 。与矩阵相似，每行元素间均须要插入 &amp; ，每行元素以 \ 结尾，最后以 end{array} 结束数组。下面是几个示例：</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span><span class="keyword">begin</span>&#123;array&#125;&#123;c<span class="params">|l|</span>c<span class="params">|r&#125;</span></span><br><span class="line"><span class="params">n &amp; \text&#123;左对齐&#125; &amp; \text&#123;居中对齐&#125; &amp; \text&#123;右对齐&#125; \\</span></span><br><span class="line"><span class="params">\hline</span></span><br><span class="line"><span class="params">1 &amp; 0.24 &amp; 1 &amp; 125 \\</span></span><br><span class="line"><span class="params">\hline</span></span><br><span class="line"><span class="params">2 &amp; -1 &amp; 189 &amp; -8 \\</span></span><br><span class="line"><span class="params">\hline</span></span><br><span class="line"><span class="params">3 &amp; -20 &amp; 2000 &amp; 1+10i</span></span><br><span class="line"><span class="params">\<span class="keyword">end</span>&#123;array&#125;$</span></span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Cl%7Cc%7Cr%7D%20n%20%26%20%5Ctext%7B%E5%B7%A6%E5%AF%B9%E9%BD%90%7D%20%26%20%5Ctext%7B%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%7D%20%26%20%5Ctext%7B%E5%8F%B3%E5%AF%B9%E9%BD%90%7D%20%5C%5C%20%5Chline%201%20%26%200.24%20%26%201%20%26%20125%20%5C%5C%20%5Chline%202%20%26%20-1%20%26%20189%20%26%20-8%20%5C%5C%20%5Chline%203%20%26%20-20%20%26%202000%20%26%201%2B10i%20%5Cend%7Barray%7D" alt="\begin{array}{c|l|c|r} n &amp; \text{左对齐} &amp; \text{居中对齐} &amp; \text{右对齐} \\ \hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\ \hline 2 &amp; -1 &amp; 189 &amp; -8 \\ \hline 3 &amp; -20 &amp; 2000 &amp; 1+10i \end{array}"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span>left(\<span class="keyword">begin</span>&#123;array&#125;&#123;ccc<span class="params">|c&#125;</span></span><br><span class="line"><span class="params"> a11 &amp; a12 &amp; a13  &amp; b1 \\</span></span><br><span class="line"><span class="params">a21 &amp; a22  &amp; a23 &amp; b2  \\ </span></span><br><span class="line"><span class="params">a31 &amp; a32  &amp; a33 &amp; b3  \\</span></span><br><span class="line"><span class="params"> \<span class="keyword">end</span>&#123;array&#125;\right)$</span></span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cleft(%5Cbegin%7Barray%7D%7Bccc%7Cc%7D%20a11%20%26%20a12%20%26%20a13%20%26%20b1%20%5C%5C%20a21%20%26%20a22%20%26%20a23%20%26%20b2%20%5C%5C%20a31%20%26%20a32%20%26%20a33%20%26%20b3%20%5C%5C%20%5Cend%7Barray%7D%5Cright)" alt="\left(\begin{array}{ccc|c} a11 &amp; a12 &amp; a13 &amp; b1 \\ a21 &amp; a22 &amp; a23 &amp; b2 \\ a31 &amp; a32 &amp; a33 &amp; b3 \\ \end{array}\right)"></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\left\&#123; </span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1 \\ </span><br><span class="line">a_2x+b_2y+c_2z=d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z=d_3</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br><span class="line">\right. </span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\left{<br>\begin{array}{c}<br>a_1x+b_1y+c_1z=d_1 \<br>a_2x+b_2y+c_2z=d_2 \<br>a_3x+b_3y+c_3z=d_3<br>\end{array}<br>\right.<br>$$</p>
<ol>
<li>矩阵</li>
</ol>
<ul>
<li>第一种方式：使用matrix、pmatrix、bmatrix、Bmatrix、vmatrix或者Vmatrix，smallmatrix<br> 一个最基本的矩阵</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>\<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> \\</span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> </span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125; <span class="variable">$ </span>  </span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%200%20%26%201%20%5C%5C%201%20%26%200%20%5Cend%7Bmatrix%7D" alt="\begin{matrix} 0 &amp; 1 \\ 1 &amp; 0 \end{matrix}"></p>
<p>可以看到矩阵中用 &amp; 分隔列，用 \ 分隔行，在矩阵开始和结束部分\begin和\end+矩阵类型<br> 下面给出这几种矩阵类型的图示</p>
<table>
<thead>
<tr>
<th>矩阵类型</th>
<th>矩阵图示</th>
</tr>
</thead>
<tbody><tr>
<td>matrix</td>
<td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7Bmatrix%7D" alt="\begin{matrix}0 &amp; 1 \\1 &amp; 0 \end{matrix}"></td>
</tr>
<tr>
<td>pmatrix</td>
<td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7Bpmatrix%7D" alt="\begin{pmatrix}0 &amp; 1 \\1 &amp; 0 \end{pmatrix}"></td>
</tr>
<tr>
<td>bmatrix</td>
<td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7Bbmatrix%7D" alt="\begin{bmatrix}0 &amp; 1 \\1 &amp; 0 \end{bmatrix}"></td>
</tr>
<tr>
<td>Bmatrix</td>
<td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7BBmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7BBmatrix%7D" alt="\begin{Bmatrix}0 &amp; 1 \\1 &amp; 0 \end{Bmatrix}"></td>
</tr>
<tr>
<td>vmatrix</td>
<td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7Bvmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7Bvmatrix%7D" alt="\begin{vmatrix}0 &amp; 1 \\1 &amp; 0 \end{vmatrix}"></td>
</tr>
<tr>
<td>Vmatrix</td>
<td><img src="https://math.jianshu.com/math?formula=%5Cbegin%7BVmatrix%7D0%20%26%201%20%5C%5C1%20%26%200%20%5Cend%7BVmatrix%7D" alt="\begin{Vmatrix}0 &amp; 1 \\1 &amp; 0 \end{Vmatrix}"></td>
</tr>
<tr>
<td>smallmatrix</td>
<td><img src="https://math.jianshu.com/math?formula=(%5Cbegin%7Bsmallmatrix%7D%200%20%26%201%20%5C%5C%201%20%26%200%20%5Cend%7Bsmallmatrix%7D)" alt="(\begin{smallmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{smallmatrix})"></td>
</tr>
</tbody></table>
<p>在此之上，如果我们需要对矩阵起始和结束部分的括号进行变化，可以使用诸如</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span>left\&#123;\<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line"> x_1&amp; x_2\\ </span><br><span class="line"> y_1&amp; y_2</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;\right.<span class="variable">$ </span>   (此处.作为占位符表示不需要分隔符)</span><br><span class="line"><span class="variable">$\</span>left.\<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line">x_1 &amp; x_2\\ </span><br><span class="line"> y_1&amp; y_2</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;\right\&#125;<span class="variable">$ </span> </span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%20x_1%26%20x_2%5C%5C%20y_1%26%20y_2%20%5Cend%7Bmatrix%7D%5Cright." alt="\left\{\begin{matrix} x_1&amp; x_2\\ y_1&amp; y_2 \end{matrix}\right."><br> <img src="https://math.jianshu.com/math?formula=%5Cleft.%5Cbegin%7Bmatrix%7D%20x_1%20%26%20x_2%5C%5C%20y_1%26%20y_2%20%5Cend%7Bmatrix%7D%5Cright%5C%7D" alt="\left.\begin{matrix} x_1 &amp; x_2\\ y_1&amp; y_2 \end{matrix}\right\}"></p>
<p>第二种方式就是使用array环境，在左右端加上所需括号即可</p>
<blockquote>
<p>输入带省略符号的矩阵</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">        \<span class="keyword">begin</span>&#123;pmatrix&#125;</span><br><span class="line">        <span class="number">1</span> &amp; a_1 &amp; a_1^<span class="number">2</span> &amp; \cdots &amp; a_1^n \\</span><br><span class="line">        <span class="number">1</span> &amp; a_2 &amp; a_2^<span class="number">2</span> &amp; \cdots &amp; a_2^n \\</span><br><span class="line">        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\</span><br><span class="line">        <span class="number">1</span> &amp; a_m &amp; a_m^<span class="number">2</span> &amp; \cdots &amp; a_m^n \\</span><br><span class="line">        \<span class="keyword">end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\begin{pmatrix}<br>        1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \<br>        1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \<br>        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>        1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \<br>        \end{pmatrix}<br>$$</p>
<ol>
<li>交换图表</li>
</ol>
<blockquote>
<p>使用一行  \require{AMScd}  语句来允许交换图表的显示。<br> 声明交换图表后，语法与矩阵相似，在开头使用 begin{CD}，在结尾使用 end{CD}，在中间插入图表元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \ 。</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span><span class="keyword">require</span>&#123;AMScd&#125;</span><br><span class="line">\<span class="keyword">begin</span>&#123;CD&#125;</span><br><span class="line">    A @&gt;a&gt;&gt; B\\</span><br><span class="line">    <span class="variable">@V</span> b V V\<span class="comment"># <span class="doctag">@VV</span> c V\\</span></span><br><span class="line">    C @&gt;&gt;d&gt; D</span><br><span class="line">\<span class="keyword">end</span>&#123;CD&#125;$</span><br></pre></td></tr></table></figure>

<p><img src="https://math.jianshu.com/math?formula=%5Crequire%7BAMScd%7D%20%5Cbegin%7BCD%7D%20A%20%40%3Ea%3E%3E%20B%5C%5C%20%40V%20b%20V%20V%5C%23%20%40VV%20c%20V%5C%5C%20C%20%40%3E%3Ed%3E%20D%20%5Cend%7BCD%7D" alt="\require{AMScd} \begin{CD} A @&gt;a&gt;&gt; B\\ @V b V V\# @VV c V\\ C @&gt;&gt;d&gt; D \end{CD}"><br> 其中，@&gt;&gt;&gt; 代表右箭头、@&lt;&lt;&lt; 代表左箭头、@VVV 代表下箭头、@AAA 代表上箭头、@= 代表水平双实线、@| 代表竖直双实线、@.代表没有箭头。<br> 在 @&gt;&gt;&gt; 的 &gt;&gt;&gt; 之间任意插入文字即代表该箭头的注释文字。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$\</span><span class="keyword">begin</span>&#123;CD&#125;</span><br><span class="line">    A @&gt;&gt;&gt; B @&gt;&#123;\text&#123;very long label&#125;&#125;&gt;&gt; C \\</span><br><span class="line">    @. <span class="variable">@AAA</span> @<span class="params">| \\</span></span><br><span class="line"><span class="params">    D @= E @&lt;&lt;&lt; F</span></span><br><span class="line"><span class="params">\<span class="keyword">end</span>&#123;CD&#125;$</span></span><br></pre></td></tr></table></figure>

<p>$\begin{CD}<br>    A @&gt;&gt;&gt; B @&gt;{\text{very long label}}&gt;&gt; C \<br>    @. @AAA @| \<br>    D @= E @&lt;&lt;&lt; F<br>\end{CD}$</p>
<p>以上内容大致上应该能把绝大多数数学公式优美的书写下来了，更多内容还需要自行查阅官方说明~~</p>
<p>作者：古剑诛仙<br>链接：<a href="https://www.jianshu.com/p/22117d964baf">https://www.jianshu.com/p/22117d964baf</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>公式</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 学习</title>
    <url>/2020/04/06/start/</url>
    <content><![CDATA[<h1 id="Markdown-语法学习"><a href="#Markdown-语法学习" class="headerlink" title="Markdown 语法学习"></a><strong>Markdown</strong> 语法学习</h1><h2 id="1-分级标题"><a href="#1-分级标题" class="headerlink" title="1. 分级标题"></a>1. 分级标题</h2><hr>
<pre><code># 一级标题</code></pre><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题  "></a>六级标题  <!-- 最多六级标题 --></h6><blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题  &lt;!--最多6级标题--&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<span id="more"></span>
<h2 id="2-任务列表"><a href="#2-任务列表" class="headerlink" title="2. 任务列表"></a>2. 任务列表</h2><ul>
<li><input disabled type="checkbox"> 任务一 未作任务 <code>- + 空格 + []</code> </li>
<li><input checked disabled type="checkbox"> 任务二 已做任务 <code>- + 空格 + [x]</code></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 任务一 未做任务 <span class="code">`- + 空格 + [ ]`</span></span><br><span class="line"><span class="bullet">-</span> [x] 任务二 已做任务 <span class="code">`- + 空格 + [x]`</span></span><br></pre></td></tr></table></figure>

<h2 id="3-画图-HEXO-不支持！！！"><a href="#3-画图-HEXO-不支持！！！" class="headerlink" title="3.画图(HEXO 不支持！！！)"></a>3.画图(HEXO 不支持！！！)</h2><div id="flowchart-0" class="flow-chart"></div>


<pre class="mermaid">gantt
section Section
Completed :done,    des1, 2014-01-06,2014-01-08
Active        :active,  des2, 2014-01-07, 3d
Parallel 1   :         des3, after des1, 1d
Parallel 2   :         des4, after des1, 1d
Parallel 3   :         des5, after des3, 1d
Parallel 4   :         des6, after des4, 1d</pre>





<pre class="mermaid">graph TD
A[Hard] -->|Text| B(Round)
B --> C{Decision}
C -->|One| D[Result 1]
C -->|Two| E[Result 2]</pre>



<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: begin
en=>end: end
op=>operation: process
cond=>condition: Yes or No?

st->op->cond
cond(yes)->en
cond(no)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>first_upload</title>
    <url>/2020/04/02/demo/</url>
    <content><![CDATA[<p>$$sqrt{a}$$ </p>
<p> some   <strong>s</strong>  jiuzai </p>
<p>$$<br>J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例}<br>$$</p>
<hr>
<p>something</p>
<hr>
<p><img src="/2020/04/02/demo/a.jpg" alt="hh"></p>
]]></content>
      <categories>
        <category>demo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>demo</tag>
      </tags>
  </entry>
</search>
